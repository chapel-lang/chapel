Dynamically Loading Chapel Code
===============================

Status
  Draft

Author
  Michael Ferguson


Abstract
--------

This CHIP discusses possible strategies for supporting the dynamic
loading of Chapel code in a running Chapel program. The main challenge in
this area is generic programming, but some other challenges are also
discussed.

Rationale
---------

It is desirable to be able to create and load Chapel code at run-time.
However,  s of Chapel 1.15, there are several issues preventing this from
working in a straightforward manner.

This CHIP discusses how to enable dynamic loading of Chapel code. The
reason to discuss dynamic loading is that it is challenging to design for
while at the same time being a superset of the required functionality for
separate compilation. Additionally, it is related to some strategies
run-time code generation - in particular compiling some code and then
dynamically loading it can present a more interactive environment. In
fact some interpreters work this way.

Such functionality is interesting and pushes the envelope a little bit.
We might imagine:

 * loading code in to a running Chapel program on multiple locales.
 * a development environment offering a continuum between compiled and
   optimized code and "interpreted" code.
 * faster compiles that benefit from dynamically loading

This document focuses mainly on the challenges of dynamically loading
generic code. It additionally discusses some whole-program tables that
are currently generated by the Chapel compiler.

Challenges
----------

In this section, we identify the issues that prevent straightforward
separate compilation and dynamic loading of Chapel code at run-time.

Generic Functions
+++++++++++++++++

Today, the Chapel compiler handles generic functions and types by
specializing the code for whatever types they are used with. For example,
a function accepting a single generic argument will be "stamped out" for
each possible type of argument that it can be called with. (This
strategy is known as template specialization in C++ or monomorphization
in Rust).

As with C++, this strategy presents problems for complete separate
compilation, since generally speaking the instantiation cannot happen at
the time a library is compiled - but rather must happen when compiling
code that uses the library.

Iterators
+++++++++

Iterators need to be inlined in order to achieve good performance.  But
inlining an iterator uses both the body of the iterator and the body of
the loop. For this reason, iterators share many of the properties of
generic code.

Ftable, Class IDs and Virtual Method Table
++++++++++++++++++++++++++++++++++++++++++

Currently, the Chapel compiler generates several tables that contain
whole-program information. These include:

 * ftable, which allows integer function IDs to be used in the invocation
   of remote procedures / active messages / on statements
 * class ID table which supports dynamic casting
 * virtual method table which enables virtual dispatch

Strategies for Loading/Separately Compiling Generic Code
--------------------------------------------------------

This section discusses how it might be possible to dynamically load
generic code.

What Do Other Languages Do?
+++++++++++++++++++++++++++

Recall that Chapel and C++ use a strategy of specializing generic
functions at compile time in order to "stamp out" instantiations
appropriate for particular types. This strategy presents a challenge
for creating separate shared libraries. How do other languages that
include generics solve this problem?

C++
***

In C++, one of two things needs to happen in order to use a generic
function supplied by a library:

 1) the generic function must be implemented in a header available to the
    user of the library, or
 2) the compile-time parameters (usually types) needed to specialize the
    generic function match those for a specialization of the generic
    function supplied by the library. That is, the specialization is
    pre-compiled in to the library.

It is difficult to call either of these strategies "separate
compilation". (1) is really just putting of compiling the generic code
until it is used. (2) is separate compilation but has limited
flexibility. In particular, the generic code might need to be
re-instantiated with a type not available in the library. 

Java
****

The Java generics system offers a different approach. Instead of
specializing each generic function, code is generated to represent the
function in its generic form. This strategy is also known as type
erasure. It effectively amounts to putting off until run-time some of the
determinations of which functions to invoke for which calls. This shares
some similarities with virtual methods.  (in Chapel terms, it does some
function resolution at run-time).

The type erasure strategy used in Java has issues as well:

 * it is slower than the specialization approach
 * the type arguments must always be classes (not primitive types like
   int)

Rust
****

Rust uses a strategy that is guaranteed to specialize all generics at
compile time. To enable separate compilation and static linking, Rust
stores some form of AST in library files, so that new instantiations of
generic functions can be created when the library is used [1]_.

.. [1] http://faq.sealedabstract.com/rust/

Swift
*****

Swift generics are carefully designed, as a language feature, to not
require them to be handled at compile-time at all. In fact, the document
"Generics in Swift" [2]_ says :

   Generic code should be compiled such that it can be executed with
   any data type without requiring a separate "instantiation" step

.. [2] https://github.com/apple/swift/blob/master/docs/Generics.rst

Impact on Compile Time
**********************

In order to understand the compile-time performance implications of some
of these questions, I created a programs in Swift, Chapel, and C++ that
create hundreds of tuple types. I measured the time to compile these
programs. The programs are listed in the appendix.

============ ============ ============ ============
n tuples     Swift        Chapel       C++
============ ============ ============ ============
100          0.15s 80KB    23s 8MB     7.8s 3MB
200          0.15s 80KB    45s 6MB     17s 8MB
400          0.16s 80KB    97s 11MB    40s 19MB
2000         0.17s 90KB
25000        0.17s 91KB
50000        0.19s 106KB
============ ============ ============ ============


What Approaches could Chapel take?
++++++++++++++++++++++++++++++++++

There are several possible approaches that could enable the dynamic loading of
Chapel code:

1. Perform function resolution at run-time. If resolution occurs at
   run-time, generic instantiation is not required before a program can
   be run. Of course, instantiation remains an important optimization
   technique.

   There are two variants of this strategy:

     a. Resolution could be performed at run-time by a more traditional
        interpreter

     b. The generated code could include calls that perform resolution

   While b. is philosophically interesting, it amounts to embedding much
   of the interpreter in the generated code. It is not clear what
   advantage that would offer but it would restrict the flexibility of
   the interpreter/dynamic compiler.

   The main advantage of these strategies is that they do not require
   language changes. Additionally, there is likely to be significant
   overlap between this solution and the development of other features to
   enable more interactive Chapel development.

2. As with Swift or Java generics, the generics the language supports
   could be constrained to a particular set of functionality that can be
   implemented with things like method tables. In some ways this is a
   restricted form of 1b. above. In the context of Chapel, the drawback
   of this approach is that it would require language changes that might
   seem to reduce the capabilities to create generic code in Chapel.

   In particular, constrained generics typically require interfaces be
   built to express the constraint on types available to pass to a
   generic function; and each generic function needs to indicate which
   interfaces must be satisfied by the arguments. While this additional
   detail is great for library code, it might be a burden to rapid
   prototyping.

3. As with C++, Chapel could support separate compilation non-generic
   code or of particular instantiations of generics.

   As noted above, this strategy has limited flexibility because the
   generic code might need to be re-instantiated with a type not
   available in the library. 

Handling Ftable, Class IDs and Virtual Method Table
---------------------------------------------------

There are two basic approaches to these tables

1. Each of these tables could be constructed in a pointer-driven manner
   that enables the class hierarchy information to be built at run-time.
   Adding a new class or function does not require changes to tables that
   store the other functions. This is the approach in C++.

   The problem with this approach in the context of Chapel is that
   generally speaking these pointers are not the same across locales.
   That is in fact the reason that the compiler currently uses integer
   class IDs (rather than pointers to virtual method table sections,
   say). Similarly, it is the reason that the compiler currently uses
   integers to identify functions to execute on a remote locale. Using
   pointers for that purpose is challenging in the context of address
   space layout randomization. In particular, a given function can have a
   different address on a different locale, even if loaded from the same
   source program.

2. The tables could be re-generated at code loading time. It is important
   though that the strategy does not require traversing all of the
   allocated program memory. In particular, whatever mechanism class
   instances use to store their runtime type - currently a class ID field
   - should be stable when new code is loaded.

   However there is not a problem with reallocating and extending the
   virtual method table or ftable as long as any already loaded/compiled
   code can continue to use the same indexes/IDs/offsets that it did
   before.

   For the class IDs that support sub-class checks, the Schubert
   numbering strategy can still be used if a new table is created to
   go from class ID (that are numbered based on load order) to a
   depth-first traversal of the class hierarchy.

Appendix: Test Programs
-----------------------

.. code-block:: swift

  func f<T>( _ arg:T ) {
    let mirror = Mirror(reflecting:arg)
    let count = mirror.children.count
    print("count", count)
    for child in mirror.children {
      print("label", child.label ?? "_", "value", child.value)
    }
    print(arg)
  }

  func g<T>( _ i: Int, _ arg: T) {
    let t1 = (i, arg)
    f(t1)
    let t2 = (i, i, arg, arg)
    f(t2)
    let t3 = (i, i, i, arg, arg, arg)
    f(t3)
    let t4 = (i, i, i, i, arg, arg, arg, arg)
    f(t4)
    let t5 = (i, i, i, i, i, arg, arg, arg, arg, arg)
    f(t5)
    let t6 = (i, i, i, i, i, i, arg, arg, arg, arg, arg, arg)
    f(t6)
    let t7 = (i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg)
    f(t7)
    let t8 = (i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg, arg)
    f(t8)
    let t9 = (i, i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg, arg, arg)
    f(t9)
    let t10 = (i, i, i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg, arg, arg, arg)
    f(t10)
  }

  func h<T>( _ i: Int, _ arg: T) {
    let t1 = (arg,i)
    g(i, t1)
    let t2 = (arg, arg, i, i)
    g(i, t2)
    let t3 = (arg, arg, arg, i, i, i)
    g(i, t3)
    let t4 = (arg, arg, arg, arg, i, i, i, i)
    g(i, t4)
    let t5 = (arg, arg, arg, arg, arg, i, i, i, i, i)
    g(i, t5)
    let t6 = (arg, arg, arg, arg, arg, arg, i, i, i, i, i, i)
    g(i, t6)
    let t7 = (arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i)
    g(i, t7)
    let t8 = (arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i, i)
    g(i, t8)
    let t9 = (arg, arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i, i, i)
    g(i, t9)
    let t10 = (arg, arg, arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i, i, i, i)
    g(i, t10)
  }


  h( 1, (0.0,1) )
  h( 2, (0.0,1,2) )
  h( 3, (0.0,1,2,3) )
  h( 4, (0.0,1,2,3,4) )
  h( 5, (0.0,1,2,3,4,5) )
  h( 6, (0.0,1,2,3,4,5,6) )
  h( 7, (0.0,1,2,3,4,5,6,7) )
  h( 8, (0.0,1,2,3,4,5,6,7,8) )
  h( 9, (0.0,1,2,3,4,5,6,7,8,9) )
  h(10, (0.0,1,2,3,4,5,6,7,8,9,10) )
  h(11, (0.0,1,2,3,4,5,6,7,8,9,10,11) )
  h(12, (0.0,1,2,3,4,5,6,7,8,9,10,11,12) )
  h(13, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13) )
  h(14, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14) )
  h(15, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) )
  h(16, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) )
  h(17, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17) )
  h(18, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18) )
  h(19, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19) )
  h(20, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20) )
  h(21, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21) )
  h(22, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22) )
  h(23, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23) )
  h(24, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24) )
  h(25, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25) )

  h(26, (0.0,1.0) )
  h(27, (0.0,1.0,2) )
  h(28, (0.0,1.0,2,3) )
  h(29, (0.0,1.0,2,3,4) )
  h(30, (0.0,1.0,2,3,4,5) )
  h(31, (0.0,1.0,2,3,4,5,6) )
  h(32, (0.0,1.0,2,3,4,5,6,7) )
  h(33, (0.0,1.0,2,3,4,5,6,7,8) )
  h(34, (0.0,1.0,2,3,4,5,6,7,8,9) )
  h(35, (0.0,1.0,2,3,4,5,6,7,8,9,10) )
  h(36, (0.0,1.0,2,3,4,5,6,7,8,9,10,11) )
  h(37, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12) )
  h(38, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13) )
  h(39, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14) )
  h(40, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15) )
  h(41, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) )
  h(42, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17) )
  h(43, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18) )
  h(44, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19) )
  h(45, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20) )
  h(46, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21) )
  h(47, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22) )
  h(48, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23) )
  h(49, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24) )
  h(50, (0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25) )

  print("done")


.. code-block:: c++

  #include <iostream>
  #include <tuple>

  template<typename T>
  void f( T arg ) {
    int count = std::tuple_size<T>::value;
    std::cout << "count " << count << "\n";
    std::cout << std::get<0>(arg) << "\n";
  }

  template<typename T>
  void g( int i, T arg) {
    auto t1 = std::make_tuple(i, arg);
    f(t1);
    auto t2 = std::make_tuple(i, i, arg, arg);
    f(t2);
    auto t3 = std::make_tuple(i, i, i, arg, arg, arg);
    f(t3);
    auto t4 = std::make_tuple(i, i, i, i, arg, arg, arg, arg);
    f(t4);
    auto t5 = std::make_tuple(i, i, i, i, i, arg, arg, arg, arg, arg);
    f(t5);
    auto t6 = std::make_tuple(i, i, i, i, i, i, arg, arg, arg, arg, arg, arg);
    f(t6);
    auto t7 = std::make_tuple(i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg);
    f(t7);
    auto t8 = std::make_tuple(i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg,
        arg, arg, arg);
    f(t8);
    auto t9 = std::make_tuple(i, i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg,
        arg, arg, arg, arg);
    f(t9);
    auto t10 = std::make_tuple(i, i, i, i, i, i, i, i, i, i, arg, arg, arg, arg,
        arg, arg, arg, arg, arg, arg);
    f(t10);
  }

  template<typename T>
  void h( int i, T arg) {
    auto t1 = std::make_tuple(arg,i);
    g(i, t1);
    auto t2 = std::make_tuple(arg, arg, i, i);
    g(i, t2);
    auto t3 = std::make_tuple(arg, arg, arg, i, i, i);
    g(i, t3);
    auto t4 = std::make_tuple(arg, arg, arg, arg, i, i, i, i);
    g(i, t4);
    auto t5 = std::make_tuple(arg, arg, arg, arg, arg, i, i, i, i, i);
    g(i, t5);
    auto t6 = std::make_tuple(arg, arg, arg, arg, arg, arg, i, i, i, i, i, i);
    g(i, t6);
    auto t7 = std::make_tuple(arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i,
        i);
    g(i, t7);
    auto t8 = std::make_tuple(arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i,
        i, i, i, i);
    g(i, t8);
    auto t9 = std::make_tuple(arg, arg, arg, arg, arg, arg, arg, arg, arg, i, i,
        i, i, i, i, i, i, i);
    g(i, t9);
    auto t10 = std::make_tuple(arg, arg, arg, arg, arg, arg, arg, arg, arg, arg,
        i, i, i, i, i, i, i, i, i, i);
    g(i, t10);
  }


  int main() {

  h( 1, std::make_tuple(0.0,1) );
  h( 2, std::make_tuple(0.0,1,2) );
  h( 3, std::make_tuple(0.0,1,2,3) );
  h( 4, std::make_tuple(0.0,1,2,3,4) );
  /* not much point in going beyond 4*100 at the moment
  h( 5, std::make_tuple(0.0,1,2,3,4,5) );
  h( 6, std::make_tuple(0.0,1,2,3,4,5,6) );
  h( 7, std::make_tuple(0.0,1,2,3,4,5,6,7) );
  h( 8, std::make_tuple(0.0,1,2,3,4,5,6,7,8) );
  h( 9, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9) );
  h(10, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10) );
  h(11, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11) );
  h(12, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12) );
  h(13, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13) );
  h(14, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14) );
  h(15, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) );
  h(16, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) );
  h(17, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17) );
  h(18, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18) );
  h(19, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19) );
  h(20, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20) );
  h(21, std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)
  );
  h(22,
  std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22) );
  h(23,
  std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
  );
  h(24,
  std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24)
  );
  h(25,
  std::make_tuple(0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25)
  );
  ;
  h(26, std::make_tuple(0.0,1.0) );
  h(27, std::make_tuple(0.0,1.0,2) );
  h(28, std::make_tuple(0.0,1.0,2,3) );
  h(29, std::make_tuple(0.0,1.0,2,3,4) );
  h(30, std::make_tuple(0.0,1.0,2,3,4,5) );
  h(31, std::make_tuple(0.0,1.0,2,3,4,5,6) );
  h(32, std::make_tuple(0.0,1.0,2,3,4,5,6,7) );
  h(33, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8) );
  h(34, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9) );
  h(35, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10) );
  h(36, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11) );
  h(37, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12) );
  h(38, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13) );
  h(39, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14) );
  h(40, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15) );
  h(41, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) );
  h(42, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17) );
  h(43, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18) );
  h(44, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19) );
  h(45, std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)
  );
  h(46,
  std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21) );
  h(47,
  std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)
  );
  h(48,
  std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
  );
  h(49,
  std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24)
  );
  h(50,
  std::make_tuple(0.0,1.0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25)
  );
  */

  std::cout << "done\n";
  return 0;
  }


.. code-block:: chapel

  proc f( arg ) {
    writeln("count ", arg.size);
    for i in 1..arg.size {
      writeln("label .", i, " value ", arg);
    }
    writeln(arg);
  }

  proc g( i:int, arg ) {
    const t1 = (i, arg);
    f(t1);
    const t2 = (i, i, arg, arg);
    f(t2);
    const t3 = (i, i, i, arg, arg, arg);
    f(t3);
    const t4 = (i, i, i, i, arg, arg, arg, arg);
    f(t4);
    const t5 = (i, i, i, i, i, arg, arg, arg, arg, arg);
    f(t5);
    const t6 = (i, i, i, i, i, i, arg, arg, arg, arg, arg, arg);
    f(t6);
    const t7 = (i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg);
    f(t7);
    const t8 = (i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg, arg);
    f(t8);
    const t9 = (i, i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg, arg,
        arg);
    f(t9);
    const t10 = (i, i, i, i, i, i, i, i, i, i, arg, arg, arg, arg, arg, arg, arg,
        arg, arg, arg);
    f(t10);
  }

  proc h( i:int, arg ) {
    const t1 = (arg,i);
    g(i, t1);
    const t2 = (arg, arg, i, i);
    g(i, t2);
    const t3 = (arg, arg, arg, i, i, i);
    g(i, t3);
    const t4 = (arg, arg, arg, arg, i, i, i, i);
    g(i, t4);
    const t5 = (arg, arg, arg, arg, arg, i, i, i, i, i);
    g(i, t5);
    const t6 = (arg, arg, arg, arg, arg, arg, i, i, i, i, i, i);
    g(i, t6);
    const t7 = (arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i);
    g(i, t7);
    const t8 = (arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i, i);
    g(i, t8);
    const t9 = (arg, arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i, i, i,
        i);
    g(i, t9);
    const t10 = (arg, arg, arg, arg, arg, arg, arg, arg, arg, arg, i, i, i, i, i, i,
        i, i, i, i);
    g(i, t10);
  }

  h( 1, (0.0,1) );
  h( 2, (0.0,1,2) );
  h( 3, (0.0,1,2,3) );
  h( 4, (0.0,1,2,3,4) );
  /* not much point in going beyond 4*100 at the moment
  h( 5, (0.0,1,2,3,4,5) );
  h( 6, (0.0,1,2,3,4,5,6) );
  h( 7, (0.0,1,2,3,4,5,6,7) );
  h( 8, (0.0,1,2,3,4,5,6,7,8) );
  h( 9, (0.0,1,2,3,4,5,6,7,8,9) );
  h(10, (0.0,1,2,3,4,5,6,7,8,9,10) );
  h(11, (0.0,1,2,3,4,5,6,7,8,9,10,11) );
  h(12, (0.0,1,2,3,4,5,6,7,8,9,10,11,12) );
  h(13, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13) );
  h(14, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14) );
  h(15, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) );
  h(16, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) );
  h(17, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17) );
  h(18, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18) );
  h(19, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19) );
  h(20, (0.0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20) );
  */
  writeln("done");

