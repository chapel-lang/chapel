Chapel Package Manager
======================

Status
  Draft

Authors
  Kyle Brady,
  Ben Albrecht,
  Preston Sahabu


Abstract
--------

This CHIP proposes a package manager for Chapel and provides some
directions for future improvements. This CHIP primarily covers the design of
the initial Chapel package manager, but also includes some design and ideas for
future work.

Credit is due to Sam Boyer of the Glide package manager for Go. His article
on Medium_ provided an excellent guide and template for our own package manager.

Rationale
---------

Chapel's current approach of bundling any extra modules in the standard library
isn't sustainable if we wish to have a healthy ecosystem of libraries. There
are several problems with the current strategy:

* Modules are in our repository, so:

  * Developers must sign a CLA
  * Code must be under a compatible license
  * The core team needs to review each module

* Modules are gated for release alongside the compiler

Description
-----------

There are a several components of this package manager here I will propose what
two of them will look like initially:

* ``mason`` - a command line tool for building Chapel programs
* ``Mason.toml`` - module metadata mason uses to build your application

Mason
+++++

The idea of ``mason`` is based heavily off of Rust's cargo_. It is meant to
provide a consistent way for libraries and applications to be built. This is
done through the use of a manifest, ``mason.toml``. The manifest describes your
package, its dependencies, and how it is built. The long term answer for most
questions is to look at what cargo is doing. They have a very well
designed package manager, and reinventing the wheel should generally be avoided
when dealing with package manager design.

The authors of this proposal support the idea of writing ``mason`` in
Chapel. It would be good to have a piece of production code that is written in
Chapel that users and developers depend on and use regularly. The largest
concern that has been brought up with this idea is the lack of proper error
handling in Chapel. However, this should improve over time in parallel to the
development of ``mason``.


Mason Pipeline
--------------

The package manager pipeline has 4 key states, where each state acts as the
input to the next state:

* **Project Code**: ``src/``
* **Manifest File**: ``Mason.toml``

  * Markup-style file containing package metadata.

* **Lock File**: ``Mason.lock``

  * File containing list of dependencies generated from ``Mason.toml``.
  * Contains the necessary information to guarantee a consistent build on
    all supported platforms.

* **Dependency Code**: ``~/.mason/src/``

  * Dependencies that are downloaded into a local directory.

A package repository will consist of the following directory hierarchy:

::

  MyPackage/
    Mason.toml
    src/
      main.chpl

Upon invoking ``mason build``, the dependencies will be parsed into a directed
acyclic graph, resolved, and serialized into ``Mason.lock``. They will then be
downloaded into ``~/.mason/src/`` mirroring Cargo's ``~/.cargo/src/`` common pool
of dependencies. Finally, if the package is an application, the binary will
build into ``target/``. The final directory hierarchy will look like this:

::

  ~/.mason/src/
    (contains dependencies of MyPackage)


  MyPackage/
    Mason.toml
    Mason.lock
    src/
      main.chpl
    target/
      ( MyPackage )


Project Code
++++++++++++

This is the Chapel source code written by the package author.

For example, ``main.chpl``:

.. code-block:: chapel

   proc main() {
       writeln("Hello, world!");
   }

Project Code -> Manifest File
+++++++++++++++++++++++++++++

``mason`` will provide command line support for adding and removing dependencies
to the manifest in the form of ``mason add [package] [version]`` and
``mason rm [package]`` when within the project directory.

The manifest may also be edited manually.

``mason`` will not automatically generate any of the manifest from the project code. 


Manifest File
+++++++++++++

The ``Mason.toml`` manifest file will closely follow the design of
`Cargo's manifest file <http://doc.crates.io/manifest.html>`_,
``Cargo.toml``. Some fields will vary, if they are too Rust-specific or could
benefit from being more Chapel-specific.

For example, ``Mason.toml``:

.. code-block:: ini

   [package]
   name = "hello_world"
   version = "0.1.0"
   authors = ["Bradford Chamberlain <brad@chamberlain.com>"]

   [dependencies]
   Curl = "1.0.0"

**Registry**

Eventually, we will want a service similar to Cargo's crates.io_ to serve as our
registry. Due to the amount of effort behind such a task, it has been decided
that this can come at a later stage.

The initial mason registry would be a GitHub repository containing a list of
versioned manifest files from packages, not too unlike that of the OS X
Homebrew package manager registry.

The registry would follow a hierarchy as follows:

::

  https://github.com/chapel-lang/mason-registry

  registry/
    Curl/
        1.0.0.toml
        2.0.0.toml
    RecordParser/
        1.0.0.toml
        1.1.0.toml
        1.2.0.toml
    VisualDebug/
        2.2.0.toml
        2.2.1.toml

Each versioned manifest file would be identical to the manifest file in the
top-level directory of the package repository, with one additional field that
is not required in the repository manifest, a URL pointing to the repository
and revision in which the version is located.

Continuing the example from before, the 'registry' ``Mason.toml`` would include
the additional ``source`` field:


.. code-block:: ini

   [package]
   name = "hello_world"
   version = "0.1.0"
   authors = ["Brad Chamberlain <brad@chamberlain.com>"]
   source = { git = "https://github.com/bradcray/hello_world", tag = "0.1.0" }

   [dependencies]
   Curl = "1.0.0"


There are some recognized downsides of using a GitHub repository as a registry:

* It is not be feasible to cache packages centrally, compromising the
  reliability of the entire package ecosystem.

  * The packages themselves are distributed despite there being a central
    registry of manifests.
  * We *cannot* guarantee that a given package version will always remain
    unchanged or even always exist.

    * Although some form of nightly/weekly testing could help mitigate this
      issue.

* It is not easy to allow users to submit packages without human intervention
  (gatekeeper accepting pull requests).

* GitHub's native interface would severely inhibit discoverability of packages.

  * This can circumvented by building a separate website for exploring the
    package ecosystem.

    * Julia does a great job at this in their Ecosystem-Pulse_.

For these reasons, we would like to eventually pursue a truly central registry
with cached packaged and a first-class interface.

**Package Integrity**

There will be two primary measures taken to ensure that submitted packages are
valid and not of poor quality:

* Continuous Integration (CI) tools such as Travis CI could run a suite of
  basic functionality tests to ensure a submitted package is properly
  setup. Tests might include:

  * Downloading the package.
  * Building the package.
  * Running any tests that the package provides.

* A set of core and trusted non-core Chapel community developers will serve
  as gatekeepers who will allow packages into the repository by merging
  pull requests that pass all tests.

  * Other non-automated review procedures can be done by the gatekeepers,
    but it would be ideal to keep this effort minimal if required at all.

  * This is similar to Homebrew's approach to package submission.


Manifest File -> Lock File
++++++++++++++++++++++++++

This will be a fully automated step in which mason does the following:

* Parses the manifest file
* Builds a dependency directed acyclic graph (DAG)
* Performs any incompatible version resolution strategy
* Serializes the DAG and outputs it into ``Mason.lock``

If the user has manually edited their manifest file, they may update the
lock file using ``mason update`` from within the project directory. Otherwise,
the lock file is updated automatically when using ``mason add`` or ``mason rm``.
(see: Syncing Commands)

The user should never edit a ``Mason.lock`` file manually.


Lock File
+++++++++

The ``Mason.lock`` lock file will follow the design of ``Cargo.lock``. An
example of a ``Mason.lock`` generated from the previous ``Mason.toml`` example:

.. code-block:: ini

    [root]
    name = "hello_world"
    version = "0.1.0"
    dependencies = [ "curl 1.0.0 (git+https://github.com/tzakian/curl.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)",]

    [[package]]
    name = "curl"
    "version = "1.0.0"
    source= git+https://github.com/tzakian/curl.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9"


Lock File -> Dependency Code
++++++++++++++++++++++++++++

The dependency code will be downloaded into a common pool of packages, under
the user's home directory by default:

::

  ~/.mason/src/
    (dependencies)


Syncing Commands
++++++++++++++++

When any of ``add``, ``rm``, or ``update`` are invoked, ``mason`` will make sure that
the manifest file, lock file, and dependency code are kept in sync with each other.
Effectively, this means that when ``update`` is run, dependencies will be downloaded,
and when ``add`` or ``rm`` are run, ``update`` will be run.

To avoid unnecessary updates, a hash of the manifest will be kept in the lock file.
We will not hash the lock file because the dependencies across all projects are kept
in a single namespaced directory -- we can simply check if all the dependency
directories are present. 


Build System
------------

When invoked, ``mason build`` will do the following:

* Navigate to the root of the project.

* Run ``update`` to make sure any manual manifest edits are reflected in the
  dependency code.

* Build ``main.chpl`` in the ``/src`` directory.
 
  - ``main.chpl`` will be the designated main by the ``--main-module`` flag.

  - Binary dependencies are included by specifying their ``main.chpl`` from the
    dependency pool. 

  - Library dependencies are included by specifying their ``lib.chpl`` from the
    dependency pool. 

  - Compiler options from the manifest will also be passed here.

  - The name of the binary will be the project name, and will be placed in the
    ``/target`` directory.

  - example: ``chpl --main-module src/main.chpl ~/.mason/src/Curl/src/main.chpl -o target/hello_world``

``mason run`` will, in turn:

* Invoke ``build``.

* Run the resulting executable.

  - Runtime options may be included in the manifest, or may be passed to
    ``build`` on the command line. Command line options take precedence. 


Future Work
-----------

The first version of the package manager will be very simple with limited
functionality. There are several additional features we wish to eventually
pursue. This section is dedicated to the subset of those features that have
been considered or are partially designed.

Naming Conventions: main.chpl and packages
++++++++++++++++++++++++++++++++++++++++++

If no module is declared in a file, then the entire file is in a module named after
the file. If we force users to have ``main.chpl`` be their package file, then their
modules will be called ``main`` by default, and ``use main;`` is not ergonomic.

There are a few options to resolve this:

* Users should declare a module inside ``main.chpl`` by convention.

  - Seems to be the standard already, but more work for the user.

* We provide an option in the manifest to build a main file other than ``main.chpl``.  

  - Not difficult, but it's more work for the user.

* ``mason`` will enforce that the main file be named after the package name, as in
  Python package managers.

  - Currently, all packages are in PascalCase, while all chpl files are in lowercase.
    Either main files would have to be in PascalCase, or the packages would have to
    be lowercase, or we'd lowercase the package name and see if it matches the file.

C Dependencies
++++++++++++++

``mason`` will support managing C dependencies in future versions. Unlike
Cargo, the management of these C dependencies will *not* be implemented as part
of the package manager.
Instead, ``mason`` will
interface with a tool specifically designed for managing C dependencies.
This is to further avoid reinvention of solutions to
hard problems.  It does have the downside of adding a dependency to our package
manager, which is not something to be taken lightly.
Presently, Nix_ is a strong candidate for this. However, Nix currently requires
being installed as root (or at least becomes much more complicated if it is
not). Nix also only works on linux/osx right now. Cygwin support is not ruled
out, but not actively worked on.

**Example**

Lets go through an example from our package modules with a C dependency and see
how it would look as a package.


The LAPACK package with high level bindings:

::

  lapack/
    Mason.toml
    src/
      LAPACK.chpl

.. code-block:: ini

  # lapack/Mason.toml
  [package]
  name = "lapack"
  version = "0.1.0"
  authors = ["Ian Bertolacci <ian@example.com>"]
  license = "Apache-2.0"
  description = "High level bindings to LAPACK"

  [dependencies]
  lapack-lib = "0.1.0"


The LAPACK package with native bindings:

::

    lapack-lib/
      Mason.toml
      src/
        LAPACK_lib.chpl

.. code-block:: ini

  # lapack-lib/Mason.toml
  [package]
  name = "lapack-lib"
  version = "0.1.0"
  authors = ["Ian Bertolacci <ian@example.com>"]
  license = "Apache-2.0"
  description = "Native bindings to liblapack"

  links = "lapack"
  includes = "lapacke.h"

  # C dependencies
  [requires]
  liblapack = "3.3.0"


Things to note:
  * ``requires`` is a list of nix packages to be in the environment when
    building your program.  It's recommended to provide these, but they may not
    be used.
  * ``links`` is the library that is expected to be on your search path and will
    be added to the compile line.
  * ``includes`` is the header file that is expected to be on your search path
    and will be added to the compile line.

.. code-block:: shell

  mason build

to download our lapack dependency, and build the program. The dependency will
be downloaded and placed in ``~/.mason/src/``. Nix will be used to resolve the
external dependencies and packages if it is available. Otherwise, libraries and
headers are expected to be placed on the normal search paths.


Other Future Work
+++++++++++++++++

* Support for binary packages
* Truly centralized registry with cached packages
* Improved tooling to assist in automating parts of source code -> manifest file
  * e.g. ``mason new <project-name> --app``


.. _Medium: https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527#.id7wa9vae
.. _crates.io: https://crates.io/
.. _cargo: http://doc.crates.io/guide.html
.. _nix: https://nixos.org/nix/
.. _Ecosystem-Pulse: http://pkg.julialang.org/pulse.html
