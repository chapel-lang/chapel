Error Handling in Chapel
========================

Status:
  Draft

Authors:
  Greg Titus, Kyle Brady, Michael Ferguson, Preston Sahabu

Abstract
--------

A proposal for how error handling should work in Chapel.


Rationale
+++++++++

Chapel currently lacks a general strategy for errors. The current standard
library primarily uses two approaches, and each has serious drawbacks:

* ``halt()``
    
  * Halting the program is not appropriate in library code.

* optional ``out`` arguments, ex. ``out error: syserr``

  * ``if`` argument provided, assumes user will handle it; ``else halt()``
  * Only returns error codes.
  * Doesn't permit users to add new error codes or new types of errors.

A more general strategy is desired, one that supports robust code,
propagates errors, and provides useful messages when errors are not handled.


Model: Swift Error Handling
---------------------------

This error handling proposal was originally inspired by the Swift_ error
handling strategy.

Swift's strategy is appealing because it:

* represents a middle ground between exceptions and error codes;
* is easier to implement than stack-unwinding since it re-uses the existing
  return mechanisms; and
* fits well with existing task parallelism.

Syntax
++++++

* Functions that can throw an error are declared with ``throws``:

::

  func canThrowErrors() throws { … }
  func cannotThrowErrors() { … }

* Calls that throw must be decorated with ``try`` or ``try!``.

  * ``try`` propagates the error to an enclosing ``do``/``catch`` block or out
    of a throwing function.
  * ``try!`` halts if an error occurred.

* Programs can catch errors with ``do``/``catch`` statements:

::

  do {
    try canThrowErrors()
    try! canThrowErrors() // will halt on failure
  } catch {
    writeln("The first call failed!")
  }

Decorating statements that throw
++++++++++++++++++++++++++++++++

The Swift error handling approach includes the use of ``try`` to mark statements
that can throw. This design addresses the most serious criticism of exceptions
as a language feature - that they make the control flow possibilities hard to
reason about. By marking each statement that can throw, the control flow
possibilities can again be reasoned about with local information only.


Feedback Received (7/20)
------------------------

1. ``try`` is verbose within ``do`` blocks. While it clarifies control flow
   within the block, it would be tiresome to repeat with throwing functions
   that are closely related (ex. I/O). 

2. ``try`` is also verbose from an iteration perspective. For example, 
   ``writeln("hello world")`` would have to be prefaced with a ``try``
   statement if it were strictly enforced.

3. Repeated ``try`` statements may also desensitize users from
   paying close attention to ``try`` and ``throws``.

4. ``main()`` ought to have some sort of reasonable response to an error
   being propagated up to it.

Potential solutions
+++++++++++++++++++

1. **Elide** ``try``.
  
* Within ``do`` blocks, ``try`` is only a visual aide to track control
  flow. It is reasonable for developers to track that a procedure throws
  without this assistance because it's already in a ``do`` block. However,
  ``try!`` would be permitted inside ``do`` blocks for critical failures.

* Outside of ``do`` blocks, ``try`` or ``try!`` can be elided on throwing
  procedure calls depending on the calling procedure's signature. If the
  calling procedure ``throws``, then ``try``, else ``try!``.

* The downside of this is that it would be possible to pass errors of a
  called procedure through the callee without any visual indication of
  which call is throwing. This could lead to poorly handled error cases.
    
2. **Elide** ``try`` **with a compiler flag.**

* Same as (1), but we would add an option to enforce marking statements
  with ``try`` for a thoroughly checked version. This addresses the
  potential downside of only eliding ``try`` without losing the ability
  to draft code quickly.

3. **Eliminate** ``do``.

* ``do`` is already a keyword in Chapel, so it would take more effort to 
  determine that the ``do`` is being used in association with a ``catch``.

* In its place, ``try`` could be defined for single and compound statements.

* The downside is that ``try`` could no longer be used in an expression
  form, so assignments that might throw an error may look more awkward.

::

  var a = try canThrowErrors(); // expression
  try var a = canThrowErrors(); // statement

4. **Cleaning up after an error.**

* It is often necessary to cleanup state if an error occurs. To capture this,
  ``do``/``catch`` could be associated with a ``finally`` block that will
  run when the ``do`` (or ``try``) block is exited.

* Swift's version of this is ``defer``, which runs when the scope it is
  defined in is exited. This is a more general form of ``finally`` which
  may better fit Chapel's needs. 

Enacted solution
++++++++++++++++

This CHIP will move forward with a combination of the first three solutions.


Chapel Error Handling
---------------------

Syntax
++++++

* Functions that can throw an error are declared with ``throws``:

::

  proc canThrowErrors() throws { … }
  proc cannotThrowErrors() { … }

* Statements that contain calls to functions that throw should be marked:

  * ``try`` propagates the error.

    * If an error is thrown, it will be passed to a matching ``catch`` block.

    * If none exists, the error will be passed to an enclosing ``catch`` block.

    * If none exists, the error will be passed out of the function, hence the
      procedure must ``throw``.

  * ``try!`` will ``halt()`` if an error occurs.

  * Both may be used with single and compound statements.
  
* Errors can be handled with ``catch`` statements.

Here is an example.

::

  try {
    canThrowErrors();      // handled by catch on failure
    try! canThrowErrors(); // halts on failure
  } catch e {
    writeln("The first call failed!")
  }

Default vs strict mode
++++++++++++++++++++++

To address the desire for both fast prototyping and enforced error handling,
the compiler will run checks in one of two modes, based on a flag.

1. **Default.** If a call to a throwing procedure is not marked with a ``try`` or
   ``try!``, the program will compile and the call will ``halt()`` on an error,
   as if the procedure were called with ``try!``.

2. **Strict.** If a call to a throwing procedure is not marked with a ``try`` or
   ``try!``, the compiler will raise an error.

Error types
+++++++++++

* Errors are classes that extend a base class ``Error``.

* Errors will not be typechecked, but an error hierarchy is permitted.

::

  class MyBaseError: Error {}
  class MySubError: MyBaseError {}

* Errors can be matched against in ``catch`` blocks. They will be checked in
  order, so even if a better fitting type is present, it will not be chosen
  if a matching general type precedes it. If a type is not specified,
  any ``Error`` will match.

:: 

  try {
    ...
  } catch e: MySubError {
    ...
  } catch e: MyBaseError {
    ...
  } catch e {
    ...
  }

Implementation
++++++++++++++

Given that the compiler will enforce the handling of errors, it is possible
for them to be implemented with the ``out`` argument method described in
the introduction.

For example, here is some Chapel code that handles an error:

.. code-block:: chapel

  class IllegalArgumentError: Error {} 

  proc nohandle(arg): A {
    var value: A = callee(arg);
    return value;
  }

  proc handler(arg): A throws {
    do {
      var value: A = try callee(arg);
    } catch e: IllegalArgumentError {
      return DEFAULT_A;
    } catch e: Error {
      throw e;
    } 
  }

  proc callee(arg): A throws {
    if arg then
      return new A;
    else
      throw new IllegalArgumentError();
  }

The compiler could translate this into the following Chapel code:

.. code-block:: chapel

  class IllegalArgumentError: Error {} 

  proc nohandle(arg): A {
    var _e: Error;
    var value: A = callee(arg, _e);
    if _e then
      halt(e.message());
    return value;
  }

  proc handler(arg, out _e: Error): A {
    var _e_in: Error;
    var value: A = callee(arg, _e_in);
    if _e_in: IllegalArgumentError {
      delete _e_in;
      return DEFAULT_A;
    } else if _e_in {
      _e = _e_in; 
      return;
    }
    return value;
  }

  proc callee(arg, out _e: Error): A {
    if arg then
      return new A;
    else {
      _e = new IllegalArgumentError();
      return;
    }
  }


Examples
--------

Example 1: Simple Errors
++++++++++++++++++++++++

As an example, this is a function currently (Jan 2016) on our Timer record in
the standard modules:

.. code-block:: chapel

    proc start() : void {
      if !running {
        running = true;
        time    = chpl_now_timevalue();
      } else {
        halt("start called on a timer that has not been stopped");
      }
    }

It calls `halt` when the timer is already running, which is not very friendly.
With our proposal this would instead be:

.. code-block:: chapel

    proc start() throws : void {
      if !running {
        running = true;
        time    = chpl_now_timevalue();
      } else {
        throw new Error("start called on a timer that has not been stopped");
      }
    }

This function can now be used as follows:

.. code-block:: chapel

    var my_timer: Timer;
    try! my_timer.start();
    do {
      try my_timer.start();
    } catch e: Error {
      writeln(Error.message);
    }
    try! my_timer.start(); // Will halt the program!

Example 2: File IO
++++++++++++++++++

A common place for errors is interactions with the filesystem, we currently
handle these with two strategies, out arguments and halting.

.. code-block:: chapel

  var err: syserr;
  var file = open("my_data.dat", error=err);
  if !err {
    var channel = file.writer(err);
    if !err {
      channel.write(1, 2, 4, 8, err);
      if err {
        halt("Failed to write out data");
      }
    } else {
      halt("Failed to open channel");
    }
  } else {
   halt("Failed to open file");
  }

.. code-block:: chapel

  do {
    var file = try open("my_data.dat");
    var channel = try file.writer(err);
    try channel.write(1, 2, 4, 8, err);
  } catch  e: IOError {
    halt(e.message());
  }

  // Equivalent to:

  var file = try! open("my_data.dat");
  var channel = try! file.writer(err);
  try! channel.write(1, 2, 4, 8, err);

Example 3: Errors In cobegins
+++++++++++++++++++++++++++++

`cobegin`, and other task parallel constructs create tasks which could have
errors. These errors will be provided at task join.

.. code-block:: chapel

  proc encounterError() throws { throw new Error(); }
  proc noError() throws { return; }
  do {
    try cobegin {
      try encounterError();
      try noError();
      try encounterError();
    }
  } catch errors: CobeginErrors { // could use a better name
    for e in errors {
      writeln(e); // Would print out two lines
    }
  }

Example 4: Errors In Iterators
++++++++++++++++++++++++++++++
This is the current `glob` iterator in the `FileSystem` module:

.. code-block:: chapel

  iter glob(pattern: string = "*"): string {
    use chpl_glob_c_interface;
    var glb : glob_t;

    const err = chpl_glob(pattern.localize().c_str(), 0, glb);
    if (err != 0 && err != GLOB_NOMATCH) then
      __primitive("chpl_error", c"unhandled error in glob()");
    const num = chpl_glob_num(glb).safeCast(int);
    for i in 0..num-1 do
      yield chpl_glob_index(glb, i.safeCast(size_t)): string;

    globfree(glb);
  }

The new version would look like:

.. code-block:: chapel

  iter glob(pattern: string = "*"): string {
    ...
    if (err != 0 && err != GLOB_NOMATCH) then
      throw new Error("unhandled error in glob()");
    ...
  }

Which can then be used like this:

.. code-block:: chapel

    do {
      try for x in glob() {
        writeln(x);
      }
    } catch e: Error {
      writeln("Error in glob");
    }

Raising an error will halt the execution of the iterator. Errors in follower
iterations in `coforall` and `forall` loops may still allow some iteration to
occur. All errors will be reported at task join, as in example 3.


Example 5: Errors In Runtime Operations
+++++++++++++++++++++++++++++++++++++++

Many kinds of runtime operations in Chapel have the potential to fail (say if
you are out of memory). This class of errors will not be mandatory to check
for. But, if one is encountered at runtime and you do not check for it, your
program will halt.

.. code-block:: chapel

    do {
      try on Locales[0] {
        writeln("Hello!");
      }
    } catch e: OutOfMemoryError {
      free_large_object();
      // This on statement does not have a try, and will halt execution if it fails
      on Locales[0] {
        writeln("Hello!");
      }
    }


Future Design Work
------------------

* Throwing errors from iterators
* Ability to catch errors generated in runtime layers:

  * communication
  * memory allocation
  * task creation

* Task joins propagate errors to parent tasks:

  * Occurs at the end of sync/coforall/cobegin blocks


Implementation Notes
--------------------

Since this error handling strategy is based off returning either the value or
an error, better support for union types in chapel may be necessary.

.. _Swift: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html
