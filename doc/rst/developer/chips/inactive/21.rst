Chapel's Cryptography Library
=============================

Status:
  Inactive - Implemented

Author:
  Sarthak Munshi

Abstract
--------

This CHIP proposes using OpenSSL as a third-party module for Chapel's cryptography
library and the design structure for the same.

Current Issues / Motivation
---------------------------

OpenSSL is the crypto primitive of choice because of the drawbacks posed by other libraries.

	- libtomcrypt isn't maintained anymore.

	- libgcrypt has licensing issues.

	- libsodium is very abstracted and is void of many algorithms.


Design
-----------

There are multiple approaches we can take for creation of this module.

1. Automatic: Use the c2chapel tool to generate Chapel bindings automatically. *[Tried]*

2. Manual:

  1. Use extern blocks to write C and then use the functions directly *[Tried]*
  2. Manually generate Chapel bindings using extern calls. *[Current method]*
  
  
Although using the c2chapel tool would have been the fastest way to get the work done, it doesn't work well on Openssl's libcrypto. I encountered many errors such as no support of inline assembly, ability to support the many custom types OpenSSL has and improper generation of bindings where uchar* or "old C" was used in general. 

For example, c2chapel generates the following bindings for OpenSSL's digest functions.

.. code-block:: c

  // Generated by c2chapel
  extern proc EVP_get_digestbyname(name : c_string) : c_ptr(EVP_MD);
  extern proc EVP_MD_CTX_init(ref ctx : EVP_MD_CTX) : c_int;
  extern proc EVP_DigestInit_ex(ref ctx : EVP_MD_CTX, ref type_arg : EVP_MD, ref impl : ENGINE) : c_int;
  extern proc EVP_DigestFinal_ex(ref ctx : EVP_MD_CTX, ref md : c_uchar, ref s : c_uint) : c_int;
  // gives error for EVP_DigestUpdate due to the presence of size_t type.

  // Manually working
  extern proc EVP_get_digestbyname(name: c_string): EVP_MD_PTR;
  extern proc EVP_MD_CTX_init(ref ctx: EVP_MD_CTX): c_int;
  extern proc EVP_DigestInit_ex(ref ctx: EVP_MD_CTX, const types: EVP_MD_PTR, impl: ENGINE_PTR): c_int;
  extern proc EVP_DigestUpdate(ref ctx: EVP_MD_CTX, const d: c_void_ptr, cnt: size_t): c_int;
  extern proc EVP_DigestFinal_ex(ref ctx: EVP_MD_CTX, md: c_ptr(c_uchar), ref s: c_uint): c_int;
   

In reality we tend to tweak the code in the first snippet to actually use it (second snippet). 
	
Using extern blocks was the next logical step as writing C functions for OpenSSL is easy and debugging is also not an issue due to the immense help available online. But it reduces the code maintainability.

In the design for this module, I would be manually writing extern calls (also using c2chapel wherever helpful) for the OpenSSL functions we intend on using. This may slow down the process a little but increases the overall code maintainability. OpenSSL's EVP API is used for this process.

As far as the latter is concerned, I have been able to accomplish some preliminary work on it with the help of Andrea (panzone).

The design approach can be briefly summarized using the figure below.

.. image:: http://oi65.tinypic.com/2uhvb47.jpg

OpenSSL has separate modules/files for each kind of cipher it contains. For example, `aes_128_cbc` is to be used totally differently from how `aes_256_ecb` would be used. Including every possible combination into the library would make the process slow and highly complicated. This would result in lots of Support files over OpenSSL's files and then the API on top of it.

Thus, the architecture includes using the EVP API for our purpose. The many custom types of the EVP API such as `EVP_CIPHER_CTX` can cause issues when writing Chapel bindings. Hence, a Chapel wrapper becomes mandatory to avoid this complication.

The Chapel wrapper contains the Chapel bindings for the OpenSSL C functions. The wrapper also contains Chapel functions that will be called by the Crypto API.


Why EVP?
_________

OpenSSL's native API is quite verbose and unnecessary for our purpose. EVP has certain advantages such as:

- Hardware acceleration
- Abstracts unnecessary complications
- Unified interface (`eg.` Entire AES can be coupled within a single module)

Demo
---------------------

A demo has been prepared in order to better illustrate the design of this library. This demo covers the cryptographic algorithms that are marked `DONE` (in the list below).

- [ ] Private Key Ciphers:

  - [DONE] AES 128/192/256
  
    - [DONE] CBC Mode
    - [DONE] CFB Mode
    - [DONE] EFB Mode
    - [DONE] OFB Mode

  - [ ] Blowfish
  - [ ] Twofish
  - [ ] DES

- [ ] Public Key Ciphers:

  - [ ] RSA
  - [ ] ECC
  
- [ ] Hashing Functions:

  - [DONE] MD5
  - [DONE] SHA-1/256/384/512
  
- [ ] PRNGs:

  - [ ] SOBER 128
  
- [ ] Message Authentication:

  - [ ] CMAC


The demo is available `here 
<https://github.com/saru95/openssl-layer-test/tree/master/Chapel%20Wrapper>`_ with execution instructions in the corresponding README.


Features
---------

- Only system-wide installation of OpenSSL would be supported. No new environment variable is added. A file using Crypto.chpl will not build if OpenSSL is not available.


Chapel Wrapper Structure
-------------------------

The Chapel Wrapper (interface between OpenSSL and Crypto module API) contains the following things:

- extern calls which link the OpenSSL primitives with Chapel.

- Chapel routines that aid the Crypto module API.

The Chapel wrapper consist of multiple files split according to the type of cryptography protocol used. A typical directory structure can be described as below:

.. code-block:: c

  	├── Crypto.chpl
	├── CryptoSupport
	│   ├── aesSupport.chpl
	│   ├── hashSupport.chpl
	    ├── multiple other support files
