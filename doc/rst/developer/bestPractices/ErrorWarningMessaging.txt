===========================================
How To Generate Warnings And Error Messages
===========================================

--print-callstack-on-error
--------------------------

The option --print-callstack-on-error makes the compiler print the
complete (compile-time) call chain at the point an error or warning is
issued. This may be useful because the cause of the issue may not be
at the location reported in the warning/error.


In Chapel code
--------------

* compile-time - use these functions:

      compilerWarning() - reports a "warning"
      compilerError()   - reports an "error" and halts compilation

  - Arguments: any number of strings known at compile time
    (e.g. literals or params).

  - Compile-time-known control flow (e.g. 'if' on a param boolean expression)
    can be used to guard when they are issued.

  - Advanced: if the last argument is an int, it is the "errorDepth":
    the error is reported as if it is in the function that deep in the
    Chapel call stack (not counting those in internal modules or
    generated by the compiler). 0 is for the location of the call to
    compilerWarning/Error itself. The default is 1.
    (Note: as of this writing, this will not necessarily work.
     Use --print-callstack-on-error if needed.)

  - These are defined in modules/internal/ChapelBase.chpl
    and also presented in the language spec.

* run-time - use these functions:

      halt()       - unconditional error
      assert(test) - assertion

  - Both functions accept an arbitrary number of additional arguments,
    which are printed as part of the error message.
    (modules/internal/ChapelIO.chpl)


In the runtime library
----------------------

* Respond to the user's erroneous actions:

      chpl_warning(const char* message, int32_t lineno, chpl_string filename)
      chpl_error(const char* message, int32_t lineno, chpl_string filename)

* Indicate an issue with the library code itself:

      chpl_internal_error(const char* message)

* (See runtime/src/error.c.)


In the compiler
---------------

* Respond to the user's actions/errors:

      USR_PRINT - information message
      USR_WARN  - warning
      USR_FATAL - error, abort compilation
      USR_FATAL_CONT  - error, abort compilation at the end of the current
                        pass (or upon a call to USR_STOP)

* Issues with the compiler code itself (internal errors):

      INT_FATAL - error, abort compilation
      INT_ASSERT - an assertion

  Between these two, INT_FATAL is unconditional whereas INT_ASSERT fires
  only if its sole argument is false.

  Also, INT_ASSERT is intended to become a no-op in production builds of
  the compiler, whereas INT_FATAL will be in effect in any build.

* Each of the above macros (except USR_FATAL_CONT and INT_ASSERT)
  takes a format string and optional arguments, which are all passed
  to printf or similar.

  If the format string is preceded by an AST node (BaseAST*), then
  that node's file and line number are printed before the error message.

  (See compiler/include/misc.h.)
