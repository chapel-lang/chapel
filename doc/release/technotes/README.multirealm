===============================
Multi-realm execution in Chapel
===============================

Chapel has traditionally assumed that the set of locales on which a
program is running are reasonably homogenous -- for example, that they
can run the same executables and use the same data format.  To support
loosely-coupled heterogeneous computing in Chapel, we have recently
been investigating a concept we're calling the 'realm' to describe
locales of distinct types.  For example, to run on a series of
networked workstations of various types, you might use one realm to
describe the linux nodes, a second to describe the sun nodes, and a
third to describe the darwin (Mac OS X) nodes.  

In a multi-realm execution, each realm contains a member variable for
numLocales, LocaleSpace, and Locales, describing the locale resources
of that realm type.  In this model, traditional Chapel programs can be
viewed as single-realm executions where the realm type is determined
by the CHPL_TARGET_PLATFORM environment variable and the numLocales,
LocaleSpace, and Locales members of the single realm are exposed as
global variables.

This release includes a prototype implementation of multi-realm
execution, and this README provides some technical notes on using the
features.  It starts with a description of the new concepts in Chapel
added to support realms.  It then goes on to describe how to compile
and execute multi-realm programs using GASNET (single-architecture
only) and PVM (multi-architecture).  It ends with some troubleshooting
notes.  Note that this README generally assumes that you're familiar
with Chapel and have used it to compile and run programs.  If not, you
may wish to start with the top-level Chapel README.


-----------------------
New Language Constructs
-----------------------

This section describes new Chapel constructs that have been added to
support multi-realm programming.  See
$CHPL_HOME/examples/tutorials/multirealm.chpl for an example program
that demonstrates them in practice.  For an early technical paper
proposing the realm concept, please refer to:

   http://chapel.cray.com/realms-deliv7.pdf.


Language constructs that support multi-realm programming are as
follows:


type realm;

    a type describing a realm within the Chapel program analogous to
    locale in traditional Chapel.


config param realmTypes: string = CHPL_TARGET_PLATFORM;

    a configuration parameter describing the realms to target,
    separated by spaces.  Set by default to CHPL_TARGET_PLATFORM,
    suggesting a single-realm execution for traditional usage.
    Override using the compiler flag: -srealmTypes="realm1 realm2
    realm3 ..."


param numRealms: int(32) = ...;

    a parameter value describing the number of realms that the Chapel
    program was compiled for.  Determined by the number of platforms
    specified in the realmTypes variable.


const RealmSpace: domain(1) = [0..#numRealms];
const Realms: [RealmSpace] realm = ...;

    a domain and array available within the Chapel program to describe
    the set of realms on which the program is executing.


realm.id

    the unique ID of a realm value, equivalent to its index in
    RealmSpace.


realm.rtype

    a string describing the type of a realm value as specified by its
    substring in the realmTypes parameter.


realm.numLocales
realm.LocaleSpace
realm.Locales

    members of a realm value describing the number of locales, and the
    set of locales belonging to that realm.


totNumLocales
AllLocaleSpace
AllLocales

    global variables describing the set of locales across all realms,
    and the array of realms in sorted order


thisRealm

    a global identifier that refers to the realm in which the current
    task is executing.  Similar to "here" for locales.


locale.id
locale.uid

    a locale value's "id" member is its local ID within a realm,
    corresponding to its index in that realm's LocaleSpace.  Its uid
    member is a globally unique ID, corresponding to its index in
    AllLocaleSpace.


locale.myRealm

    a locale value can be queried as to the realm it belongs to
    
    
on <realm-expr> ...

    an expression of realm type can be used in an on-clause.  This
    will cause the task to execute on locale #0 of that realm.


----------------------------------------------
Simulating multi-realm executions using GASNet
----------------------------------------------

Assuming you are already set up to execute multi-locale programs using
GASNet (as described in $CHPL_HOME/doc/README.multilocale), it is
quite easy to try out Chapel's multi-realm features.  However, by
design GASNet does not support communication between distinct
architectures, so therefore it can only be used to experiment with
multi-realm features on a single architectural type (negating the
purpose of realms, but providing a simple way to try the concepts).

To compile a Chapel program for multiple realms using GASNet, set up
your environment variables as usual and then compile using a
command-line like:

  chpl ...normal arguments... -srealmTypes="linux linux linux"

The -srealmTypes flag says to set the config param "realmTypes" to the
specified value.  Here, the mention of linux three times indicates our
desire to run on three realms, each one a linux platform (due to
GASNet's homogeneous assumptions).

Then, to run the program, use a command-line like:

  ./a.out --localesPerRealm='#nl1 #nl2 #nl3'

This specifies that the program should be launched using #nl1 locales
in the first realm, #nl2 locales in the second realm, and #nl3 locales
in the third realm.  The assignment of machine resources to locales is
governed by GASNet's normal mechanisms for job launch as described in
README.multilocale and/or the GASNet documentation.

To execute a true multi-realm execution using multiple architectures,
you'll need to use the PVM implementation described in the next
section.


-------------------------------
Multi-realm execution using PVM
-------------------------------

PVM is a communication layer jointly developed by ORNL, the University
of Tennessee Knoxville, and Emory University which provides message
passing capabilities between heterogeneous architectures.  Our
prototype implementation of multi-realm Chapel is built using PVM.
For more information about PVM refer to $CHPL_HOME/third-party/README
and $CHPL_HOME/third-party/pvm/README.


GENERAL CAVEATS:

In our current implementation, all hosts that are used to run a
multi-realm Chapel program must use the same native pointer size
(e.g., sizeof(void*) in the C compiler).  We are currently working on
relaxing this assumption.


BUILDING CHAPEL FOR MULTI-REALM EXECUTION:

Set CHPL_COMM to pvm, cd to $CHPL_HOME/third-party, and make pvm:

    [g]make pvm

Then build the Chapel compiler and runtime as you normally would.
Repeat these steps for each host type you wish to use (See note above
regarding the location of CHPL_HOME).  A machine's host type can be
found by running '$CHPL_HOME/util/platform.pl --host'.


SETTING UP YOUR ENVIRONMENT TO USE PVM:

PVM requires certain environment variables to be set in your shell's
config file (e.g., .bashrc, .cshrc):

  CHPL_HOME =  ...
  PVM_ROOT  =  $CHPL_HOME/third-party/pvm/pvm-3.4.6/pvm3
  PVM_RSH   =  `which ssh`
  PVM_DPATH =  $PVM_ROOT/lib/pvmd

In addition, $PVM_ROOT/bin and $PVM_ROOT/lib must be in your
executable search path.

Note that this README assumes that you will be using ssh to execute
commands between nodes.  If you can use rsh instead, you are welcome
to leave PVM_RSH unset and substitute 'rsh' for 'ssh' in the
descriptions below.

You should also set up your environment so that you can ssh between
the nodes you are targeting without providing a password, for example
using ssh-agent/ssh-add (not strictly required for compilation, but
convenient, and required for running).

It is strongly advised that you test your PVM installation between the
hosts that you wish to use for your Chapel program.  See the sample
programs and Readme in
$CHPL_HOME/third-party/pvm/pvm-3.4.6/pvm3/examples to test your PVM
installation.

For Chapel's use, host names must be specified in a hostfile in
$CHPL_HOME, one for each host type, with a single host name per line.
It is advisable to use fully qualified domain names in the hostfiles.

  hostfile.<hosttype1> -- lists all nodes of the first host type
  hostfile.<hosttype2> -- lists all nodes of the second host type
  ...

On the host from which you will be compiling and launching, you can
optionally specify a directory for each host type that you are
targeting, specifying where binaries should be stored for that host.

  CHPL_MULTIREALM_LAUNCH_DIR_<hosttype> = <path to binary>

These directories do not have to be the same on all the hosts.  If the
variable is not specified for a particular host, the compiler and
launcher will assume a symmetric file system with the current host.


COMPILING A MULTI-REALM CHAPEL PROGRAM

To help with the process of compiling a Chapel program for multiple
target platforms, we have provided a wrapper script to the Chapel
compiler, located in $CHPL_HOME/util/chpl-multirealm.  This script is
run from a single machine (the compile host) and will invoke the
Chapel compiler for each specified target host, generating a binary
for each host type.  The script accepts all the usual Chapel compiler
arguments.  To invoke the compiler, it ssh's to the first machine
listed in the corresponding hostfile (described above).  

Because of its approach, the chpl-multirealm script assumes that the
file system across the target hosts is symmetric, which is to say the
same logical paths need to exist on each machine.  In particular:

* CHPL_HOME must reside in the same location on all hosts

* The directory from which you invoke a multi-realm compilation must
  exist on all hosts

* The Chapel source files being compiled (whether specified via a
  relative or absolute path) must exist on all hosts at the same
  location

Note that there is no requirement to use the chpl-multirealm script,
it is simply provided for convenience.  If you cannot use it due to
the assumptions above (or simply choose not to use it), you can invoke
the chpl compiler on each platform by hand, ensuring that the same
options (and environment variables that specify compilation options)
are the same for each invocation of the compiler.

The chpl-multirealm script requires the configuration parameter
realmTypes to be set to a quoted list of host types to build for:

  chpl-multirealm -srealmTypes='hosttype1 hosttype2 ..' <flags> <Chapel files>

For example, to compile $CHPL_HOME/examples/tutorials/multirealm.chpl
to run between a Mac running darwin and a Linux host, you would use:

  % chpl-multirealm -srealmTypes='darwin linux' -o multirealm multirealm.chpl

Assuming the first entry in your hostfile.darwin is
'darwinchapel.cray.com' and the first entry in your hostfile.linux is
'linuxchapel.cray.com', the above invocation of chpl-multirealm will
use ssh to launch a remote compilation of multirealm.chpl on
darwinchapel.cray.com, generating the binaries multirealm_darwin and
multirealm_darwin_real.  The location of these files will depend
either on the environment variable CHPL_MULTIREALM_LAUNCH_DIR_darwin,
if specified or the current working directory if not.  It will then
use ssh to launch a remote compilation of multirealm.chpl on
linuxchapel.cray.com, generating the binaries multirealm_linux and
multirealm_linux_real.  The location of these files will depend either
on the environment variable CHPL_MULTIREALM_LAUNCH_DIR_linux, if
specified, or the current working directory if not.

The binaries ending with '_real' are the actual Chapel program and
multirealm_darwin and multirealm_linux are the launcher programs.  The
program may be started using either of the two launchers from the
corresponding host type.


RUNNING A MULTI-REALM CHAPEL PROGRAM

Running a multi-realm Chapel program is similar to running a regular
Chapel program with the additional required argument,
--localesPerRealm, which takes a quoted list of locales per host type
to run (zero is a valid number of locales).

  launcher_hosttype --localesPerRealm='l1 l2 ..'

If the enviroment variable CHPL_MULTIREALM_LAUNCH_DIR_<hosttype> is
set for one of the realm types you've compiled for, that path will be
used to locate the '_real' binary by the launcher.  If this
environment variable is not set for a particular host,
launcher_hosttype will assume a symmetric file system and look for the
'_real' binary in the same directory that was used to invoke the
launcher program.

For the example above, assume the following environment variables are
set:

  CHPL_MULTIREALM_LAUNCH_DIR_darwin = /home/chapel/bin/darwin
  CHPL_MULTIREALM_LAUNCH_DIR_linux  = /home/chapel/bin/linux

Assume the file multirealm_darwin_real is in the directory
/home/chapel/bin/darwin on darwinchapel.cray.com.  Assume the file
multirealm_linux_real is in the directory /home/chapel/bin/linux on
linuxchapel.cray.com.

You can launch the multirealm program from either a darwin host or a
linux host.  For example,

On linuxchapel.cray.com, run:

  % multirealm_linux --localesPerRealm='2 1'

This command will launch multirealm_darwin_real on the first two hosts
specified in $CHPL_HOME/hostfile.darwin and multirealm_linux_real on
the first host specified in $CHPL_HOME/hostfile.linux.

On darwinchapel.cray.con, run:

  % multirealm_darwin --localesPerRealm='2 4'

This command will launch multirealm_darwin_real on the first two hosts
specified in $CHPL_HOME/hostfile.darwin and multirealm_linux_real on
the first four hosts specified in $CHPL_HOME/hostfile.linux.


-------------------
Troubleshooting PVM
-------------------

If your build does not succeed, look for lines like the following:

  Starting build on darwinchapel.cray.com.
  ...

  Finished build on darwinchapel.cray.com.

This should tell you for which host and host type the build error
occured.  For that host, check the required environment variables.  In
addition,

  - Make sure the CHPL_HOME is the same as it is on the host from
    which the build was launched.

  - Make sure you have built the compiler and runtime for the
    appropriate CHPL_COMM layer.

  - Make sure the source file(s) are in the same location as on the
    compile host.

  - Make sure the directory in which you have invoked chpl-multirealm
    exists on the remote host.


As suggested above, it is strongly recommended that you test your PVM
installation outside of the Chapel multi-realm environment.  The
following are the most common errors that occur when using PVM.

If you see this error:

   libpvm [pid15724] /tmp/pvmd.25134: No such file or directory
   <PVM launcher>: error: Problem starting PVM daemon (-29)

There was a problem starting the PVM binary on the remote host.

  - Make sure you have built the proper PVM for your architecture.

  - Make sure you have set all the PVM required environment variables
    on the remote host.

  - Make sure that your PATH on the remote host includes $PVM_ROOT/bin
    and $PVM_ROOT/lib.

If you see this error:

   <PVM launcher>: error: Remote error on darwinchapel (-6) --
   shutting down host

PVM could not connect to the remote host (darwinchapel, in this
example).

  - Make sure your host name in the hostfile.<hosttype> is correct and
    reachable from the launch host.

  - Make sure you can ssh to and from the remote host without
    specifying a password.
