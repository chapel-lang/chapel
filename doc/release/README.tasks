===================================
Chapel programs, tasks, and threads
===================================

Chapel programs create new tasks via the begin, cobegin, and coforall
statements.  Tasks are computations that can conceptually execute
concurrently, though they may or may not do so in practice.  Tasks are
executed using threads, where the implementation of these threads may
vary depending on the target platform ($CHPL_TARGET_PLATFORM), tasking
package (($CHPL_TASKS), and threading package ($CHPL_THREADS) selected
by the user.  For a brief introduction to these variables, refer to
README.chplenv.  This document describes the currently-supported tasking
and threading options in more detail.


--------------------------------------------
CHPL_TASKS == fifo, CHPL_THREADS == pthreads
--------------------------------------------

FIFO tasking and POSIX threads (or pthreads) is the default tasking
implementation for all platforms other than the Cray XMT.  It is
attractive in its portability, though it may be somewhat heavier-weight
on some platforms than necessary for Chapel's purposes.

In the current implementation, Chapel tasks are mapped to pthreads
such that each task is executed by a single thread and is run to
completion before giving up that thread.  Pthreads are pooled by
default so that rather than creating and destroying threads over a
program's lifetime, threads are created and then kept around to
execute other tasks later.

The number of threads per locale used to implement a Chapel program is
controlled by a configuration constant named maxThreads.  If
maxThreads has a value of 0, the Chapel program will create as many
threads as it needs to execute the program, up to any system- or
library-defined limits.  (The program will generate a runtime warning
if it ever tries to create a thread and the system prevents it from
doing so, due to resource limitations for example.)

If maxThreads has a non-zero value, that value specifies the maximum
number of threads per locale that will be created to execute the
Chapel program.  If the system or libraries have stricter constraints
on maxThreads than this value, a warning will be generated when no
more threads can be created.

The user can set maxThreads just like any other configuration
variable, using --maxThreads=# or -smaxThreads=# on the generated
executable's command-line.

If not set by the user, maxThreads typically defaults to 0 (an
unbounded number of threads).  The main exception to this is when
executing programs compiled using CHPL_COMM = gasnet, in which case
maxThreads is set to a smaller number (e.g., 127 or 255) due to
assumptions made in the GASNet implementation.  (There are ways to
work around this assumption on certain platforms -- please contact us
at chapel_info@cray.com or peruse the GASNet documentation if you need
to do so.)

When the maximum number of threads (specified by maxThreads or the
system limit) has been reached, any additional tasks are added to a
task pool in the Chapel runtime, waiting for a thread to become
available.  When an existing thread completes execution of its task,
it will go to the task pool to select a new task for execution.

Generally speaking, the Chapel programmer can make no assumptions
about the scheduling of threads or the mapping of tasks to threads,
apart from those semantics defined by the language specification.

The value of maxThreads can have a major impact on performance.  For
programs with low inter-task dependences and high computational
intensity, setting maxThreads roughly equal to the number of cores on
each locale can lead to near-optimal performance.  However, for
programs with lots of fine-grain synchronization in which tasks
frequently block on synchronization/single variables, maxThreads can
often exceed the number of cores without an adverse effect on
performance since blocked threads may not consume the CPU's cycles.

Note that setting maxThreads too low can also result in program
deadlock.  For example, for programs written with an assumption that a
larger number of tasks are executing concurrently, setting maxThreads
too low can result in deadlock if there are not enough threads to
implement all of the required tasks.  The -b/--blockreport flag can
help debug programs like this that appear to be deadlocked.

Several methods on the locale type are available to query the state of
the task pool and threads:

* queuedTasks(): returns the number of tasks in the task pool that are
    ready to run, but have not yet begun executing.

* runningTasks(): returns the number of tasks that have begun
    executing, but have not yet finished.  Note that this number can
    exceed the number of non-idle threads because there are cases in
    which one thread is working on more than one task, e.g., if a task
    is blocked waiting on something.

* blockedTasks(): returns the number of tasks that are blocked because
    they are waiting on a sync or single variable.  In the current
    implementation, this method will not generate meaningful
    information unless the program was run with the -b/--blockreport
    flag, in order to avoid unnecessary overheads.

* totalThreads(): returns the number of threads that have been created
    since the program started executing, regardless of whether they
    are busy or idle.

* idleThreads(): returns the number of threads are idle, i.e., not
    assigned to any task.

In order to use these methods, you have to specify the locale you wish
to query, as in here.runningTasks(), where 'here' is the current
locale.

These methods are available in all tasking/threading options, but
currently they only return meaningful values for FIFO tasking and the
pthreads threading layer.

If you have further questions about task and thread scheduling, please
contact chapel_info@cray.com.


---------------------------------------
CHPL_TASKS == mta, CHPL_THREADS == none
---------------------------------------

Setting CHPL_TASKS to mta only makes sense when targeting the Cray XMT
platform.  This platform has hardware support for executing multiple
threads, and Chapel tasks are mapped to these hardware thread contexts
by compiling them down to the "future" construct supported by the
platform's dialect of C.

This tasking model has been implemented, but has not yet been
extensively used, so users with access to an XMT are likely to be
exploring uncharted areas.  We'd be curious to hear about any
experiences you have at chapel_info@cray.com.


----------------------------------------
CHPL_TASKS == none, CHPL_THREADS == none
----------------------------------------

Setting CHPL_TASKS to "none" indicates that you do not wish to have
multiple Chapel tasks actually execute concurrently.  By default, this
is equivalent to using the Chapel compiler's --serial flag, which has
the effect of (i) ignoring begin keywords, (ii) converting cobegins into
traditional block statements, and (iii) converting forall and coforall
loops into for loops.  In other words, it removes all constructs that
introduce new tasks and executes those tasks serially.  This can be
overridden using the --no-serial compiler flag, which will use a single
thread to execute tasks added to a task pool, similar to the behavior
described in the FIFO tasking section above.  As with FIFO tasking, each
task will be scheduled to run to completion, so if blocks on a sync or
single variable, the program will deadlock.


-----------------
Future Directions
-----------------

As Chapel's task parallel implementation matures, we expect to have
multiple task->thread scheduling policies from literally creating and
destroying new threads with each task (for programmers who want full
control over a thread's lifetime) to automated work stealing and load
balancing at the other end of the spectrum (for programmers who would
prefer not to manage threads or whose programs cannot trivially be
load balanced manually).  Our hope is to leverage existing open source
threading and task management software and to collaborate with others
in these areas, so please contact us at chapel_info@cray.com if you'd
like to work with us in this area.
