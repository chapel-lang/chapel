This directory contains a start towards work on the revamped compiler.
This directory uses a different directory structure from the old compiler
- see below for rationale.

The effort of creating a revamped compiler is called "dyno".

For now, this work is being done in this directory but the expectation is
that eventually it will swap places with the compiler/ directory (so any
old-compiler code still used is put into subdirectories according to the
organization described below).

Part of improving the compiler will involve adjusting the directory
structure used to store sources and headers. This addresses three problems:

 1. it's not always clear where to find a header/source file - the
    convention varies within the compiler
 2. the current structure is not compatible with refactoring the compiler
    into a library and multiple tools using that library
 3. the current structure makes namespacing harder

### old compiler structure

The current structure is to
 * separate out the .cpp files into subdirectories by topic (AST,
   resolution, optimizations). These are currently stored under
   `compiler` so, for example, we have `compiler/AST`.
 * store all include files used by multiple topics in `compiler/include`.
 * store include files used only within a single topic within that topic
   directory. For example, we have some header files in
   `compiler/resolution`.

### dyno structure

We generally try to follow the LLVM project's directory structure. The
structure (for each LLVM project) is this:

 * For code that goes into the library:
   * store .cpp files in `lib/<topic>`
   * store C++ `.h` files forming the library API into
     `include/<project-name>/ and C API `.h` files (if any) in
     `include/<project-name>-c/`. Header files that are relevant to a
     particular topic go into `include/<project-name>/<topic>` and almost
     all header files go into these topic subdirectories. The
     <project-name> here is something like 'chpl' for us and this just
     makes it so that the headers included have the same path as if they
     were installed in e.g. `/usr/include`. So you can have e.g.
     #include "chpl/uast/BlockStmt.h".
   * store `.h` files that are for use only within the project in
     `lib/<topic>`
   * For example, within the LLVM project there is
     `include/llvm/Analysis/AliasAnalysis.h` and
     `llvm/lib/Analysis/AliasAnalysis.cpp`.

 * For code that does not go into a library and only supports a tool,
   store it in `tool/<tool-name>`. For example, there is an LLVM tool
   called `opt` and the sources for it are stored in `tools/opt`.

In particular, for our project, I would expect we end up with this structure:
```
  runtime/ (could also be called chpl-rt/ in the future)
  compiler/  (could also be called chpl/ in the future)
     include/chpl
       uast/ (new AST headers forming library API will go here)
       resolution/ (headers forming API for new resolver)
       (nothing from the old compiler since it does not present a library interface)

     lib/
       uast/ (new AST source code)
       resolution/ (resolution code)
       ...

     tools/
        chpl/
          include/ (current contents of compiler/include)
          AST/ (current contents of compiler/AST)
          ...
          main/ (source code only used in `chpl` and not in compiler-as-a-library - could contain contents of `compiler/main` today)
```

Please note that when we `#include` a header we will do so assuming that
`dyno/include` is in the `-I` path and so is the current `lib` subdir.


### a note about namespaces

Unless there is a good reason not to, the Chapel compiler library code
should be in the chpl namespace.

Other than that, it is a style matter to decide when to introduce a new
namespace. Here is some guidance about when to do so:
 * when creating a bunch of similar types that we'd like to be able to
   easily distinguish (e.g. uast vs old ast)
 * when creating a bunch of free functions that we'd like to be able to
   bundle since they are related

In particular, all topic directories need to have a namespace.
 * today we make an exception for `util`

### a note about file names

.h and .cpp files defining primarily a specific type should go into a
file sharing that type name. Type names in dyno use an InitialUpperCase.
So we have e.g. NumericLiteral.h / NumericLiteral.cpp.

In contrast, .h and .cpp files defining a collection of things that
aren't a specific type should go into a file using lower case and dashes.
For example, we have scope-queries.h and scope-queries.cpp.

### error system policy and recommendations

Dyno is home to the new error system, which is inteded to provide friendlier,
more helpful, and better looking error messages than the production compiler
currently does. This is accomplished in part by letting the C++ programmer
working on Dyno create specialized sub-classes of `ErrorBase`, which have
customized output functionality and can store additional context about the
error. For example, an error message class might store the type of a variable,
a reference to a variable's declaration, etc. However, Dyno also provides a
simpler error reporting mechanism, via `Context::error` and similar methods,
which does not require creating a new class. This means that a Dyno programmer
is faced with a few choices when they need to report an error.

#### When to use simple errors over class-based errors?
In general, we want to avoid pointless boilerplate. Thus, if your error's
output format is no different than the "usual" format for simple errors
(that is, if the error you need to report will simply print the error message
and the code location, without any additional help or information), it doesn't
make sense to duplicate that functionality in a new error class. Thus, you
should opt for using a simple (class-less) error.

On the other hand, you probably want a class-based error if you want to do any
of the following:
* Specialize the error message for particular situations (e.g., "can't use
  `new owned` for non-class datatypes" in general, and "can't use
  `new owned` for records, which are not the same as classes").
* Print additional help for the error message (e.g., "did you mean to write X?").
* Show code from more than the default location, or not show any code at all.

#### One class or many classes?
Sometimes, many related errors are reported in the same place in the code.
The error are typically similar, and might even require the same "contextual
information". So, where do you draw the line between specializing error messages
and creating new classes?

The _heuristic_ we have been using is "if the same code reports many versions
of the error, make it one class". For instance, we might report an error if
an actual has a type incompatible with a formal; the error is reported if
a value is passed to a type, a type is passed to a value, or a param is passed
to a type. Since the same code, within a few lines of each other, reports
each version of this error, it seems best to make the error a single class.
In this case, the error message is specialized in the `write` method. Beyond
that, it seems to make sense to make separate classes for different types of
errors. Note that this is a heuristic; it's not clear if there is a hard rule
to this question.
