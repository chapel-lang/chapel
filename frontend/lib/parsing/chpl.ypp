/*
 * Copyright 2020-2023 Hewlett Packard Enterprise Development LP
 * Copyright 2004-2019 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//
// Chapel Parser Conventions
//
// opt_       -- optional
//      _expr -- expression
//      _ls   -- list
//      _stmt -- statement
//      _type -- type
//
// The rules are listed in depth-first order from stmt and expr
//

// A note about parser actions:
//
//  $1 $2 etc refer to the result of the components of the nonterminal
//        (and midrule actions count for these numbers)
//  $$ is the result of this nonterminal
//  @1 @2 etc refer to the locations
//  @$ is the location of the entire construct

// A note about memory management within the parser:
//
//  Several grammar rules produce an allocated type (e.g. AstNode*
//  pointing to some sort of allocated expression). When one of these
//  rules produces a result, that result needs to be either
//  freed or wired up into another structure to be freed later.

// A note about clearing comments for statements:
//
//  After gathering top level comments that precede the statement, you'll
//  want to clear expression-level comments preceding the start of the body.
//  Here are some examples:
//
//    Clear no comments (c1 and c2 are preserved):
//      defer /* c1 */ /* c2 */ writeln('a');
//    Clear everything before the '{' (c1 and c2 are discarded):
//      defer /* c1 */ /* c2 */ { writeln('a'); }
//    Clear everything before the '{' (c1 is discarded):
//      for 0..15 /* c1 */ {}
//    Clear everything before the 'do' (c1 is discarded):
//      'while true /* c1 */ do /* c2 */ writeln('a');
//
// After gathering top level comments, if the statement body is a block,
// clear every comment to the left of the '{'. Otherwise, if the body is
// a non-block statement, preserve comments immediately preceding the
// statement, but clear any expression-level comments before that point.

// "%code requires" puts the code in the .h and in the .cpp files
// "%code" (without "requires") puts the code in the .cpp file
// Note that the generated flex scanner includes the generated bison .h
// file, so something in "%code requires" is available in the scanner, too.
%code requires {
  #include "parser-dependencies.h"
  #include "chpl/util/assertions.h"
}

// It would be better if Flex could generate these for itself
%code requires {
  #ifndef _BISON_CHAPEL_DEFINES_0_
  #define _BISON_CHAPEL_DEFINES_0_

  #define YYLEX_NEWLINE                  -1
  #define YYLEX_SINGLE_LINE_COMMENT      -2
  #define YYLEX_BLOCK_COMMENT            -3

  typedef void* yyscan_t;

  namespace chpl {
    int processNewline(yyscan_t scanner);
  }

  #endif
}

//
// Definition of YYSTYPE - the "semantic value" type returned by parser
// productions. Individual productions have a type specified with %type
// but that's really just an element in the union defined below.
//
// We used to use %union but stopped doing that when defining the push
// parser.
//

%code requires {
  #ifndef _BISON_CHAPEL_DEFINES_1_
  #define _BISON_CHAPEL_DEFINES_1_

  // TODO: Replace me with bool.
  enum ThrowsTag {
    ThrowsTag_DEFAULT,
    ThrowsTag_THROWS,
  };

  using ParserExprList = std::vector<AstNode*>;
  using UniqueStrList = std::vector<PODUniqueString>;

  // these structures do not use constructors to avoid
  // errors about being in the union below. Additionally
  // they only have pointer or numeric fields.

  struct WhereAndLifetime {
    AstNode* where;
    ParserExprList* lifetime;
  };
  static inline
  WhereAndLifetime makeWhereAndLifetime(AstNode* w, ParserExprList* lt) {
    WhereAndLifetime ret = {w, lt};
    return ret;
  }

  // This is used to propagate any comments that hug the top of a statement
  // upwards through parser rules.
  struct CommentsAndStmt {
    std::vector<ParserComment>* comments;
    AstNode* stmt;
  };
  static inline
  CommentsAndStmt makeCommentsAndStmt(std::vector<ParserComment>* comments,
                                      AstNode* stmt) {
    CommentsAndStmt ret = {comments, stmt};
    return ret;
  }
  static inline
  CommentsAndStmt makeCommentsAndStmt(std::vector<ParserComment>* comments,
                                      owned<AstNode> stmt) {
    return makeCommentsAndStmt(comments, stmt.release());
  }

  // A struct for storing a partially constructed function prototype
  // during parsing for linkage_spec/fn_decl_stmt/etc
  // It is just saving some components of a function to be used
  // when building the FunctionDecl.
  struct FunctionParts {
    bool isBodyNonBlockExpression;
    std::vector<ParserComment>* comments;
    ErroneousExpression* errorExpr; // only used for parser error
    Attributes* attributes;
    Decl::Visibility visibility;
    Decl::Linkage linkage;
    AstNode* linkageNameExpr;
    bool isInline;
    bool isOverride;
    Function::Kind kind;
    Formal::Intent thisIntent;
    Formal* receiver;
    Identifier* name;
    Function::ReturnIntent returnIntent;
    bool throws;
    ParserExprList* formals;
    AstNode* returnType;
    AstNode* where;
    ParserExprList* lifetime;
    ParserExprList* body;
  };

  // A struct to thread along some pieces of a module before it is built.
  struct ModuleParts {
    std::vector<ParserComment>* comments;
    Attributes* attributes;
    Decl::Visibility visibility;
    Module::Kind kind;
    PODUniqueString name;
  };

  // A struct to thread along some pieces of a type before it is built.
  struct TypeDeclParts {
    std::vector<ParserComment>* comments;
    Decl::Visibility visibility;
    Decl::Linkage linkage;
    AstNode* linkageName;
    Attributes* attributes;
    PODUniqueString name;
    asttags::AstTag tag;
  };

  // This is produced by do_stmt. It records whether the do_stmt statements
  // were produced following a 'do' or not. E.g...
  // do { ... } vs { ... }
  struct BlockOrDo {
    CommentsAndStmt cs;
    bool usesDo;
  };

  struct SizedStr {
    const char* allocatedData; // *not* a uniqued string!
    long size;
  };

  struct MaybeNamedActual {
    AstNode* expr;
    PODUniqueString name;
  };
  static inline
  MaybeNamedActual makeMaybeNamedActual(AstNode* expr,
                                        PODUniqueString name) {
    MaybeNamedActual ret = {expr, name};
    return ret;
  }
  static inline
  MaybeNamedActual makeMaybeNamedActual(AstNode* expr) {
    PODUniqueString emptyName = PODUniqueString::get();
    MaybeNamedActual ret = {expr, emptyName};
    return ret;
  }

  using MaybeNamedActualList = std::vector<MaybeNamedActual>;

  // These currently all need to be POD types (i.e. pointers and ints)
  // rather than say std::vector to keep bison working with the current
  // strategy. In the future we could probably switch to a more
  // C++ mode of using bison.
  union YYCHPL_STYPE {
    // The lexer only uses these
    PODUniqueString uniqueStr;
    SizedStr sizedStr;
    AstNode* expr;

    // The remaining types are used only in parser productions

    // integer/enum values

    asttags::AstTag astTag;
    Formal::Intent intentTag;
    Function::Kind functionKind;
    Function::ReturnIntent returnTag;
    Decl::Linkage linkageTag;
    Module::Kind moduleKind;
    New::Management newManagement;
    TaskVar::Intent taskIntent;
    Decl::Visibility visibilityTag;
    ThrowsTag throwsTag;
    Variable::Kind variableKind;

    // simple pointer values
    Attributes* attribute;
    Block* block;
    Call* call;
    Function* function;
    Module* module;
    WithClause* withClause;

    // values that are temporary groupings
    BlockOrDo blockOrDo;
    CommentsAndStmt commentsAndStmt;
    TypeDeclParts typeDeclParts;
    FunctionParts functionParts;
    MaybeNamedActual maybeNamedActual;
    MaybeNamedActualList* maybeNamedActualList;
    ModuleParts moduleParts;
    ParserExprList* exprList;
    UniqueStrList* uniqueStrList;
    WhereAndLifetime lifetimeAndWhere;
  };

  // Put our types in a different namespace to avoid conflicting with the
  // production compiler parser's YYSTYPE/YYLTYPE.
  #define YYSTYPE YYCHPL_STYPE
  #define YYLTYPE YYCHPL_LTYPE

  // Note that the 'YYSTYPE_IS_TRIVIAL' macro tells the generated parser
  // that YYSTYPE only contains simple scalars (it can be bitcopied).
  // This is normally communicated by the '%union' directive, but we
  // stopped using that.
  #define YYCHPL_STYPE_IS_TRIVIAL 1

  #endif
}

// YYLTYPE is the type that represents a source code location.
// It is possible to define YYLTYPE (and this grammar used to in
// order to handle chpldoc comments). This parser uses instead the
// strategy of saving doc-comments in ParserContext.
// The default YYLTYPE includes:
//   first_line
//   first_column
//   last_line
//   last_column

//
// Definition of the additional parameter to yypush_parse
//

%code requires {
  // forward declare ParserContext
  struct ParserContext;
}

//
// Provide declaration for debugging and yyerror
//
%code provides {
  extern int yychpl_debug;

  void yychpl_error(YYLTYPE*       loc,
                    ParserContext* context,
                    const char*    errorMessage);
}

%code provides {
  // include ParserContext.h here because it depends
  // upon YYLTYPE and other types defined by the generated parser
  // headers.
  #include "ParserContext.h"
  // include override of macro used to compute locations
  #include "parser-yylloc-default.h"
}

%code {
  // include the definition of methods for ParserContext
  #include "ParserContextImpl.h"
  // include helper macros for use in writing productions
  #include "parser-help.h"
  // include implementation of error logging hook
  #include "parser-yyerror.h"
}

// Bison 3.7 is not strictly required long-term but requiring it here
// should minimize the size of the diffs as we update the generated parser.
// Requiring 3.7 does not seem onerous since the generated parser is
// checked in.
%require "3.7"

// The names for the output files
%defines "bison-chpl-lib.h"
%output  "bison-chpl-lib.cpp"

%debug
%verbose

// These would print out expected token names, but that might just
// add unnecessary complexity for someone new to the language ...
//%define parse.lac full
//%define parse.error verbose

%locations
%define api.pure full
%define api.push-pull push

%define api.prefix {yychpl_}

%lex-param { ParserContext* context }
%parse-param { ParserContext* context }

%start program

//
// identifiers and literals
//
%token <uniqueStr> TIDENT
%token <uniqueStr> TQUERIEDIDENT
%token <uniqueStr> INTLITERAL
%token <uniqueStr> REALLITERAL
%token <uniqueStr> IMAGLITERAL
%token <expr> STRINGLITERAL
%token <expr> BYTESLITERAL
%token <expr> CSTRINGLITERAL
%token <sizedStr> EXTERNCODE

//
// keywords (alphabetical)
//
%token <uniqueStr> TALIGN TAS TATOMIC
%token <uniqueStr> TBEGIN TBREAK TBOOL TBORROWED TBY TBYTES
%token <uniqueStr> TCATCH TCLASS TCOBEGIN TCOFORALL TCOMPLEX
%token <uniqueStr> TCONFIG TCONST TCONTINUE
%token <uniqueStr> TDEFER TDELETE TDEPRECATED TDMAPPED TDO TDOMAIN
%token <uniqueStr> TELSE TENUM TEXCEPT TEXPORT TEXTERN
%token <uniqueStr> TFALSE TFOR TFORALL TFOREACH TFORWARDING
%token <uniqueStr> TIF TIMAG TIMPORT TIN TINCLUDE
%token <uniqueStr> TINDEX TINLINE TINOUT TINT TITER TINITEQUALS
%token <uniqueStr> TIMPLEMENTS TINTERFACE
%token <uniqueStr> TLABEL TLAMBDA TLET TLIFETIME TLOCAL TLOCALE
%token <uniqueStr> TMANAGE TMINUSMINUS TMODULE
%token <uniqueStr> TNEW TNIL TNOINIT TNONE TNOTHING
%token <uniqueStr> TON TONLY TOPERATOR TOTHERWISE TOUT TOVERRIDE TOWNED
%token <uniqueStr> TPARAM TPLUSPLUS TPRAGMA TPRIMITIVE TPRIVATE
%token <uniqueStr> TPROC TPROTOTYPE TPUBLIC TPROCLP
%token <uniqueStr> TREAL TRECORD TREDUCE TREF TREQUIRE TRETURN
%token <uniqueStr> TSCAN TSELECT TSERIAL TSHARED TSINGLE TSPARSE
%token <uniqueStr> TSTRING TSUBDOMAIN TSYNC
%token <uniqueStr> TTHEN TTHIS TTHROW TTHROWS TTRUE TTRY TTRYBANG TTYPE
%token <uniqueStr> TUINT TUNDERSCORE TUNION TUNMANAGED TUNSTABLE TUSE
%token <uniqueStr> TVAR TVOID
%token <uniqueStr> TWHEN TWHERE TWHILE TWITH
%token <uniqueStr> TYIELD
%token <uniqueStr> TZIP

//
// operators and punctuation (alphabetical)
//
%token <uniqueStr> TALIAS TAND
%token <uniqueStr> TASSIGN
%token <uniqueStr> TASSIGNBAND TASSIGNBOR TASSIGNBXOR
%token <uniqueStr> TASSIGNDIVIDE TASSIGNEXP
%token <uniqueStr> TASSIGNLAND TASSIGNLOR TASSIGNMINUS TASSIGNMOD
%token <uniqueStr> TASSIGNMULTIPLY TASSIGNPLUS TASSIGNREDUCE
%token <uniqueStr> TASSIGNSL TASSIGNSR
%token <uniqueStr> TBANG TBAND TBNOT TBOR TBXOR
%token <uniqueStr> TCOLON TCOMMA
%token <uniqueStr> TDIVIDE TDOT TDOTDOT TDOTDOTDOT
%token <uniqueStr> TEQUAL TEXP TGREATER
%token <uniqueStr> TGREATEREQUAL
%token <uniqueStr> THASH
%token <uniqueStr> TLESS
%token <uniqueStr> TLESSEQUAL
%token <uniqueStr> TMINUS TMOD
%token <uniqueStr> TNOTEQUAL
%token <uniqueStr> TOR
%token <uniqueStr> TPLUS
%token <uniqueStr> TQUESTION
%token <uniqueStr> TSEMI TSHIFTLEFT TSHIFTRIGHT TSTAR TSWAP

//
// braces
//
%token TLCBR TRCBR TLP TRP TLSBR TRSBR

//
// keywords, operators, and punctuation that requires precedence
//
%left TNOELSE
%left TELSE TTHROWS


// Right associative to encourage shifting to happen.
%right TTYPE TPARAM TREF TVAR TCONST
%right TCOMMA

// Add the 'internal_type_type_def' types here to resolve s/r for
// function types/exprs, as well as TIDENT.
%nonassoc TBOOL TINT TUINT TREAL TIMAG TCOMPLEX TBYTES TSTRING
          TDOMAIN TINDEX TLOCALE TNOTHING TVOID TIDENT
%nonassoc TFALSE TNONE TTHIS TTRUE

%left TFOR TFORALL TFOREACH TIF TATOMIC TSYNC TSINGLE
%left TIN
%left TALIGN TBY THASH
%left TOR
%left TAND
%left TEQUAL TNOTEQUAL
%left TLESSEQUAL TGREATEREQUAL TLESS TGREATER
%left TDOTDOT TDOTDOTOPENHIGH
// These are not currently supported, though we've discussed adding them
//%left TDOTDOTOPENLOW TDOTDOTOPENBOTH
%left TPLUS TMINUS
%left TBOR
%left TBXOR
%left TBAND
%left TSHIFTLEFT TSHIFTRIGHT
%right TUPLUS TUMINUS
%left TSTAR TDIVIDE TMOD
%right TBNOT TLNOT
%left TREDUCE TSCAN TDMAPPED
%right TEXP
%left TCOLON

%right TBORROWED TOWNED TUNMANAGED TSHARED
%left TQUESTION TBANG
%right TNEW
%left TDOT TLP TRSBR TLCBR
%nonassoc TPRAGMA TALIAS

%type <throwsTag> opt_throws_error
%type <moduleKind> opt_prototype
%type <visibilityTag> opt_access_control
%type <intentTag> required_intent_tag opt_formal_intent_tag opt_this_intent_tag

%type <returnTag>  opt_ret_tag
%type <astTag> class_tag

%type <uniqueStr> ident_use ident_def reserved_word_ident formal_ident_def
%type <uniqueStr> internal_type_ident_def reserved_type_ident_use
%type <uniqueStr> fn_ident assignop_ident op_ident all_op_name opt_label_ident
%type <uniqueStr> implements_type_ident implements_type_error_ident

%type <commentsAndStmt> decl_base
%type <commentsAndStmt> deprecated_decl_stmt
%type <commentsAndStmt> deprecated_enum_item
%type <commentsAndStmt> deprecated_class_level_stmt

%type <commentsAndStmt> unstable_decl_stmt
%type <commentsAndStmt> unstable_enum_item
%type <commentsAndStmt> unstable_class_level_stmt

// statement lists
%type <exprList> program
%type <exprList> toplevel_stmt_ls
%type <exprList> stmt_ls

// individual statements
%type <commentsAndStmt> toplevel_stmt
%type <moduleParts> module_decl_start
%type <commentsAndStmt> module_decl_stmt
%type <commentsAndStmt> include_module_stmt
%type <exprList> block_stmt_body
%type <commentsAndStmt> block_stmt

%type <expr> import_expr
%type <commentsAndStmt> use_stmt import_stmt require_stmt
%type <exprList> import_ls
%type <exprList> renames_ls use_renames_ls opt_only_ls

// These are exprList so that they can include preceeding comments
%type <commentsAndStmt> implements_stmt interface_stmt
%type <exprList>  ifc_formal_ls
%type <expr>   ifc_formal

%type <exprList> class_level_stmt_ls

%type <commentsAndStmt> stmt tryable_stmt
%type <blockOrDo> do_stmt
%type <commentsAndStmt> if_stmt loop_stmt
%type <commentsAndStmt> select_stmt
%type <commentsAndStmt> manage_stmt
%type <exprList> manager_expr_ls
%type <expr> manager_expr
%type <commentsAndStmt> assignment_stmt

%type <typeDeclParts> class_start
%type <commentsAndStmt> class_level_stmt
%type <commentsAndStmt> inner_class_level_stmt
%type <commentsAndStmt> forwarding_decl_stmt
%type <attribute> forwarding_decl_start
%type <commentsAndStmt> extern_export_decl_stmt
%type <commentsAndStmt> extern_block_stmt
%type <commentsAndStmt> return_stmt
%type <commentsAndStmt> try_stmt
%type <commentsAndStmt> throw_stmt
%type <exprList> catch_expr_ls
%type <expr> catch_expr
%type <expr> catch_expr_inner

%type <variableKind> var_decl_type

%type <commentsAndStmt> type_alias_decl_stmt
%type <variableKind> type_alias_decl_stmt_start
%type <exprList> type_alias_decl_stmt_inner_ls
%type <commentsAndStmt> type_alias_decl_stmt_inner

%type <functionParts> fn_decl_stmt
%type <commentsAndStmt> fn_decl_stmt_complete
%type <commentsAndStmt> class_decl_stmt
%type <commentsAndStmt> enum_decl_stmt

%type <commentsAndStmt> var_decl_stmt
%type <exprList> var_decl_stmt_inner_ls tuple_var_decl_stmt_inner_ls
%type <commentsAndStmt> var_decl_stmt_inner

%type <exprList> function_body_stmt opt_function_body_stmt

%type <commentsAndStmt> when_stmt
%type <exprList> when_stmt_ls

%type <expr> array_type
%type <expr> opt_type opt_ret_type ret_array_type ret_type colon_ret_type
%type <expr> opt_fn_type_ret_type
%type <expr> opt_colon_formal_type formal_array_type opt_formal_array_elt_type
%type <expr> colon_formal_type
%type <expr> formal_type
%type <functionParts> lambda_decl_start
%type <expr> lambda_decl_expr
%type <typeDeclParts> enum_header_lcbr
%type <exprList> enum_ls

%type <expr> range_literal_expr cast_expr tuple_expand_expr
%type <expr> super_expr
%type <expr> zippered_iterator
%type <expr> call_base_expr call_expr dot_expr
%type <expr> lhs_expr
%type <expr> unary_op_expr binary_op_expr
%type <expr> parenthesized_expr expr
%type <maybeNamedActual> actual_expr
%type <expr> bool_literal str_bytes_literal literal_expr
%type <expr> stmt_level_expr sub_type_level_expr type_level_expr scalar_type
%type <exprList> lifetime_components_expr
%type <expr> lifetime_expr lifetime_ident
%type <lifetimeAndWhere> opt_lifetime_where
%type <expr> ident_expr for_expr cond_expr nil_expr new_expr
%type <expr> let_expr ifvar
%type <uniqueStr> reduce_scan_op_expr
%type <expr> reduce_expr scan_expr opt_init_expr
%type <expr> opt_init_type formal_var_arg_expr
%type <expr> opt_try_expr opt_expr
%type <expr> tuple_component tuple_var_decl_component
%type <expr> formal named_formal
%type <commentsAndStmt> enum_item
%type <expr> query_expr ifc_constraint

%type <newManagement> new_maybe_decorated
%type <exprList> opt_inherit simple_expr_ls expr_ls assoc_expr_ls tuple_expr_ls
%type <maybeNamedActualList> opt_actual_ls actual_ls
%type <exprList> task_intent_ls
%type <exprList> forall_intent_ls
%type <withClause> opt_task_intent_ls task_intent_clause forall_intent_clause

%type <functionParts> fn_decl_stmt_start fn_decl_stmt_inner
%type <functionParts> fn_type fn_expr
%type <exprList> fn_type_formal_ls opt_fn_type_formal_ls
%type <expr> fn_type_formal
%type <exprList> opt_formal_ls req_formal_ls formal_ls formal_ls_inner
%type <expr> fn_decl_receiver_expr
%type <functionKind> proc_iter_or_op
%type <functionParts> linkage_spec
%type <linkageTag> extern_or_export extern_export_decl_stmt_start
%type <expr> intent_expr
%type <taskIntent> task_var_prefix

%%

program:
  toplevel_stmt_ls                    { context->topLevelStatements = $1; }
;

toplevel_stmt_ls:
                                      { $$ = context->makeList(); }
| toplevel_stmt_ls toplevel_stmt      { $$ = context->appendList($1, $2); }
;

// Switch between plain statements and those preceded by pragmas
toplevel_stmt:
   stmt
|  pragma_ls stmt
  {
    $$ = context->buildPragmaStmt(@2, $2);
  }
;

// Sequence of pragmas
pragma_ls:
  TPRAGMA STRINGLITERAL
  {
    context->notePragma(@$, $2);
  }
| pragma_ls TPRAGMA STRINGLITERAL
  {
    auto loc = context->makeSpannedLocation(@2, @3);
    context->notePragma(loc, $3);
  }
;

stmt:
  tryable_stmt      // (no '->finishStmt()' required b/c 'tryable_stmt' did it)
| deprecated_decl_stmt      { $$ = context->finishStmt($1); }
| unstable_decl_stmt        { $$ = context->finishStmt($1); }
| include_module_stmt       { $$ = context->finishStmt($1); }
| block_stmt                { $$ = context->finishStmt($1); }
| use_stmt                  { $$ = context->finishStmt($1); }
| import_stmt               { $$ = context->finishStmt($1); }
| require_stmt              { $$ = context->finishStmt($1); }
| extern_block_stmt         { $$ = context->finishStmt($1); }
| implements_stmt           { $$ = context->finishStmt($1); }
| interface_stmt            { $$ = context->finishStmt($1); }
| TDEFER stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1,
                               false, @1, $2);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Defer::build(BUILDER, LOC(@$), blockStyle,
                             std::move(stmts));
    CommentsAndStmt ret = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(ret);
  }
| try_stmt                  { $$ = context->finishStmt(@$, $1); }
| return_stmt               { $$ = context->finishStmt($1); }
| TBREAK opt_label_ident TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto ident = !$2.isEmpty() ? Identifier::build(BUILDER, LOC(@2), $2)
                               : nullptr;
    auto node = Break::build(BUILDER, LOC(@$), std::move(ident));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TCONTINUE opt_label_ident TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto ident = !$2.isEmpty() ? Identifier::build(BUILDER, LOC(@2), $2)
                               : nullptr;
    auto node = Continue::build(BUILDER, LOC(@$), std::move(ident));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TLABEL ident_def stmt
  {
    $$ = context->buildLabelStmt(@$, $2, $3);
  }
| TYIELD opt_try_expr TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto node = Yield::build(BUILDER, LOC(@$), toOwned($2));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| error TSEMI
  {
    $$ = STMT(@$, ErroneousExpression::build(BUILDER, LOC(@1)));
    context->resetDeclStateOnError();
  }
;

tryable_stmt:
  assignment_stmt           { $$ = context->finishStmt($1); }
| if_stmt                   { $$ = $1; } // Don't clear stored comments.
| loop_stmt                 { $$ = $1; } // Don't clear stored comments.
| select_stmt               { $$ = context->finishStmt($1); }
| manage_stmt               { $$ = context->finishStmt($1); }
| stmt_level_expr TSEMI     { $$ = context->finishStmt(STMT(@$,$1)); }
| throw_stmt                { $$ = context->finishStmt($1); }
| TBEGIN opt_task_intent_ls stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    YYLTYPE locBodyAnchor = context->makeLocationAtLast(@2);
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1,
                               false, locBodyAnchor, $3);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Begin::build(BUILDER, LOC(@$), toOwned($2), blockStyle,
                             std::move(stmts));
    CommentsAndStmt ret = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(ret);
  }
| TCOBEGIN opt_task_intent_ls block_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    YYLTYPE locBodyAnchor = context->makeLocationAtLast(@2);
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1,
                               false, locBodyAnchor, $3);
    CHPL_ASSERT(blockStyle == BlockStyle::EXPLICIT);
    auto taskBodies = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Cobegin::build(BUILDER, LOC(@$), toOwned($2),
                               std::move(taskBodies));
    CommentsAndStmt ret = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(ret);
  }
| TDELETE simple_expr_ls TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto exprs = context->consumeList($2);
    auto node = Delete::build(BUILDER, LOC(@$), std::move(exprs));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TLOCAL expr do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @3, $3);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Local::build(BUILDER, LOC(@$), toOwned($2), blockStyle,
                             std::move(stmts));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TLOCAL do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @2, $2);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Local::build(BUILDER, LOC(@$), blockStyle, std::move(stmts));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TON expr do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @3, $3);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = On::build(BUILDER, LOC(@$), toOwned($2), blockStyle,
                          std::move(stmts));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TSERIAL expr do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @3, $3);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Serial::build(BUILDER, LOC(@$), toOwned($2), blockStyle,
                              std::move(stmts));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TSERIAL do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @2, $2);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Serial::build(BUILDER, LOC(@$), blockStyle, std::move(stmts));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TSYNC stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1,
                               false, @1, $2);
    auto stmts = context->consumeAndFlattenTopLevelBlocks(exprLst);
    auto node = Sync::build(BUILDER, LOC(@$), blockStyle,
                            std::move(stmts));
    CommentsAndStmt ret = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(ret);
  }
;

deprecated_decl_stmt:
  decl_base
| TDEPRECATED STRINGLITERAL
  {
    context->noteDeprecation(@$, $2);
  }
  decl_base
  {
    $$ = $4;
  }
| TDEPRECATED
  {
    context->noteDeprecation(@$, nullptr);
  }
  decl_base
  {
    $$ = $3;
  }
;

decl_base:
  module_decl_stmt
| class_level_stmt
;

unstable_decl_stmt:
  TUNSTABLE STRINGLITERAL
  {
    context->noteUnstable(@$, $2);
  }
  decl_base
  {
    $$ = $4;
  }
| TUNSTABLE
  {
    context->noteUnstable(@$, nullptr);
  }
  decl_base
  {
    $$ = $3;
  }
;

module_decl_start:
  opt_access_control opt_prototype TMODULE ident_def
    {
      // take into account location of public/private, if any
      auto loc = context->declStartLoc(@3);

      ModuleParts parts = {
        .comments=context->gatherComments(loc),
        .attributes=context->buildAttributes(@$).release(),
        .visibility=$1,
        .kind=$2,
        .name=$4
      };

      $$ = parts;
      context->resetDeclState();
      context->clearComments();
    }
;

module_decl_stmt:
   module_decl_start TLCBR TRCBR
    {
      context->clearCommentsBefore(@2);

      ModuleParts parts = $1;
      ParserExprList* body = context->makeList();
      context->appendList(body, context->gatherComments(@3));
      auto mod = Module::build(BUILDER, LOC(@1), toOwned(parts.attributes),
                               parts.visibility,
                               parts.name,
                               parts.kind,
                               context->consumeList(body));
      CommentsAndStmt cs = {parts.comments, mod.release()};
      $$ = cs;
    }
| module_decl_start TLCBR stmt_ls TRCBR
    {
      context->clearCommentsBefore(@2);

      ModuleParts parts = $1;
      ParserExprList* body = $3;
      context->appendList(body, context->gatherComments(@4));
      auto mod = Module::build(BUILDER, LOC(@1), toOwned(parts.attributes),
                               parts.visibility,
                               parts.name,
                               parts.kind,
                               context->consumeList(body));
      CommentsAndStmt cs = {parts.comments, mod.release()};
      $$ = cs;
    }
| module_decl_start TLCBR error TRCBR
    {
      ModuleParts parts = $1;
      auto err = ErroneousExpression::build(BUILDER, LOC(@3));
      ParserExprList* body = context->makeList(std::move(err));
      auto mod = Module::build(BUILDER, LOC(@1), toOwned(parts.attributes),
                               parts.visibility,
                               parts.name,
                               parts.kind,
                               context->consumeList(body));
      CommentsAndStmt cs = {parts.comments, mod.release()};
      $$ = cs;
    }
;

opt_access_control:
           { $$ = context->noteVisibility(Decl::DEFAULT_VISIBILITY); }
| TPUBLIC  { context->noteDeclStartLoc(@1);
             $$ = context->noteVisibility(Decl::PUBLIC); }
| TPRIVATE { context->noteDeclStartLoc(@1);
             $$ = context->noteVisibility(Decl::PRIVATE); }
;

opt_prototype:
             { $$ = Module::DEFAULT_MODULE_KIND; }
| TPROTOTYPE { context->noteDeclStartLoc(@1);
               $$ = Module::PROTOTYPE;  }
;

include_module_stmt:
  TINCLUDE opt_access_control opt_prototype TMODULE ident_def TSEMI
  {
    auto node = Include::build(BUILDER, LOC(@$), context->visibility, $3, $5);
    $$ = STMT(@$, node.release());
    context->visibility = Decl::DEFAULT_VISIBILITY;
  }
;

/* Grouping of statements into blocks.

   Note:  There cannot be a blank production appearing immediately after TLCBR
   as this results in a shift/reduce conflict with the statement level
   expression expr TDOT expr (see domain literals).  This production (and the
   the other productions on which it depends) were purposefully redefined
   without blank productions to allow the full version of dot_expr to appear at
   the statement level.
*/
block_stmt_body:
  TLCBR TRCBR
  {
    $$ = context->blockToParserExprList(@1, @2, nullptr);
  }
| TLCBR stmt_ls TRCBR
  {
    $$ = context->blockToParserExprList(@1, @3, $2);
  }
| TLCBR error TRCBR
  {
    context->clearComments();
    // create a list of stmts that just has an ErroneousExpr
    auto errorExpr = ErroneousExpression::build(BUILDER, LOC(@2));
    ParserExprList* lst = context->makeList(errorExpr.release());
    $$ = lst;
  }
;

block_stmt:
  block_stmt_body
  {
    // comments from before the opening bracket will have been
    // gathered into stmt_ls when that was parsed, so pull out any
    // comments that occur before the opening bracket.
    // (This would be simpler to handle with midrule actions but those
    //  lead to parser conflicts).
    CommentsAndStmt cs = {0};
    cs.comments = context->gatherCommentsFromList($1, @1);

    // Create the BlockStmt
    auto blockstmt = Block::build(BUILDER, LOC(@$), context->consumeList($1));
    cs.stmt = blockstmt.release();
    $$ = cs;
  }
;

// Sequence of toplevel_stmts
stmt_ls:
  toplevel_stmt                        { $$ = context->makeList($1); }
| stmt_ls toplevel_stmt                { context->appendList($1, $2); }
;

renames_ls:
  expr
  {
    $$ = context->makeList($1);
  }
| all_op_name
  {
    $$ = context->makeList(context->buildIdent(@1, $1));
  }
| expr TAS expr
  {
    auto as = context->buildAsExpr(@1, @3, toOwned($1), toOwned($3));
    $$ = context->makeList(as);
  }
| renames_ls TCOMMA expr
  {
    $$ = context->appendList($1, $3);
  }
| renames_ls TCOMMA all_op_name
  {
    $$ = context->appendList($1, context->buildIdent(@3, $3));
  }
| renames_ls TCOMMA expr TAS expr
  {
    auto as = context->buildAsExpr(@3, @5, toOwned($3), toOwned($5));
    $$ = context->appendList($1, as);
  }
;

/* Separated so that use statements can rename their module to "_", but nothing
   else can */
use_renames_ls:
  expr
  {
    auto node = context->buildVisibilityClause(@$, toOwned($1), false);
    $$ = context->makeList(node);
  }
| expr TAS expr
  {
    auto as = context->buildAsExpr(@1, @3, toOwned($1), toOwned($3));
    auto node = context->buildVisibilityClause(@$, toOwned(as), false);
    $$ = context->makeList(node);
  }
| expr TAS TUNDERSCORE
  {
    auto ident = toOwned(context->buildIdent(@3, $3));
    auto as = context->buildAsExpr(@1, @3, toOwned($1), std::move(ident));
    auto node = context->buildVisibilityClause(@$, toOwned(as), false);
    $$ = context->makeList(node);
  }
| use_renames_ls TCOMMA expr
  {
    auto node = context->buildVisibilityClause(@3, toOwned($3), false);
    $$ = context->appendList($1, node);
  }
| use_renames_ls TCOMMA expr TAS expr
  {
    auto as = context->buildAsExpr(@3, @5, toOwned($3), toOwned($5));
    auto locVisClause = context->makeSpannedLocation(@3, @5);
    auto node = context->buildVisibilityClause(locVisClause, toOwned(as), false);
    $$ = context->appendList($1, node);
  }
| use_renames_ls TCOMMA expr TAS TUNDERSCORE
  {
    auto ident = context->buildIdent(@5, $5);
    auto as = context->buildAsExpr(@3, @5, toOwned($3), toOwned(ident));
    auto locVisClause = context->makeSpannedLocation(@3, @5);
    auto node = context->buildVisibilityClause(locVisClause, toOwned(as), false);
    $$ = context->appendList($1, node);
  }
;

opt_only_ls:
  /* nothing */   { $$ = nullptr; }
| renames_ls      { $$ = $1; }
;

use_stmt:
  opt_access_control TUSE use_renames_ls TSEMI
  {
    $$ = context->buildMultiUseStmt(@$, $1, $3);
    context->resetDeclState();
  }
| opt_access_control TUSE expr TEXCEPT renames_ls TSEMI
  {
    auto locVisibilityClause = context->makeSpannedLocation(@3, @5);
    $$ = context->buildSingleUseStmt(@$, locVisibilityClause, $1, toOwned($3),
                                     VisibilityClause::EXCEPT,
                                     $5);
    context->resetDeclState();
  }
| opt_access_control TUSE expr TAS expr TEXCEPT renames_ls TSEMI
  {
    auto as = context->buildAsExpr(@3, @5, toOwned($3), toOwned($5));
    auto locVisibilityClause = context->makeSpannedLocation(@3, @7);
    $$ = context->buildSingleUseStmt(@$, locVisibilityClause, $1, toOwned(as),
                                     VisibilityClause::EXCEPT,
                                     $7);
    context->resetDeclState();
  }
| opt_access_control TUSE expr TAS TUNDERSCORE TEXCEPT renames_ls TSEMI
  {
    auto ident = toOwned(context->buildIdent(@5, $5));
    auto as = context->buildAsExpr(@3, @5, toOwned($3), std::move(ident));
    auto locVisibilityClause = context->makeSpannedLocation(@3, @7);
    $$ = context->buildSingleUseStmt(@$, locVisibilityClause, $1, toOwned(as),
                                     VisibilityClause::EXCEPT,
                                     $7);
    context->resetDeclState();
  }
| opt_access_control TUSE expr TONLY opt_only_ls TSEMI
  {
    auto locVisibilityClause = context->makeSpannedLocation(@3, @5);
    $$ = context->buildSingleUseStmt(@$, locVisibilityClause, $1, toOwned($3),
                                     VisibilityClause::ONLY,
                                     $5);
    context->resetDeclState();
  }
| opt_access_control TUSE expr TAS expr TONLY opt_only_ls TSEMI
  {
    auto as = context->buildAsExpr(@3, @5, toOwned($3), toOwned($5));
    auto locVisibilityClause = context->makeSpannedLocation(@3, @7);
    $$ = context->buildSingleUseStmt(@$, locVisibilityClause, $1, toOwned(as),
                                     VisibilityClause::ONLY,
                                     $7);
    context->resetDeclState();
  }
| opt_access_control TUSE expr TAS TUNDERSCORE TONLY opt_only_ls TSEMI
  {
    auto ident = toOwned(context->buildIdent(@5, $5));
    auto as = context->buildAsExpr(@3, @5, toOwned($3), std::move(ident));
    auto locVisibilityClause = context->makeSpannedLocation(@3, @7);
    $$ = context->buildSingleUseStmt(@$, locVisibilityClause, $1, toOwned(as),
                                     VisibilityClause::ONLY,
                                     $7);
    context->resetDeclState();
  }
;

import_stmt:
  opt_access_control TIMPORT import_ls TSEMI
  {
    $$ = context->buildImportStmt(@$, $1, $3);
    context->resetDeclState();
  }
;

import_expr:
  expr
  {
    $$ = context->buildVisibilityClause(@$, toOwned($1), true);
  }
| expr TDOT all_op_name
  {
    auto dot = Dot::build(BUILDER, LOC(@$), toOwned($1), $3).release();
    $$ = context->buildVisibilityClause(@$, toOwned(dot), true);
  }
| expr TAS ident_use
  {
    auto ident = toOwned(context->buildIdent(@3, $3));
    auto as = context->buildAsExpr(@1, @3, toOwned($1), std::move(ident));
    $$ = context->buildVisibilityClause(@$, toOwned(as), true);
  }
| expr TDOT TLCBR renames_ls TRCBR
  {
    $$ = context->buildVisibilityClause(@$, toOwned($1),
                                        VisibilityClause::BRACES,
                                        context->consumeList($4), true);
  }
;

import_ls:
  import_expr                   { $$ = context->makeList($1); }
| import_ls TCOMMA import_expr  { $$ = context->appendList($1, $3); }
;

require_stmt:
  TREQUIRE expr_ls TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto node = Require::build(BUILDER, LOC(@$), context->consumeList($2));
    $$ = { .comments=comments, .stmt=node.release() };
  }
;

assignment_stmt:
  lhs_expr assignop_ident opt_try_expr TSEMI
    {
      $$ = STMT(@$, context->buildBinOp(@$, $1, $2, $3));
    }
| lhs_expr TSWAP           opt_try_expr TSEMI
    {
      $$ = STMT(@$, context->buildBinOp(@$, $1, $2, $3));
    }
| lhs_expr TASSIGNREDUCE   opt_try_expr TSEMI
    {
      $$ = STMT(@$, context->buildBinOp(@$, $1, $2, $3));
    }
| lhs_expr TASSIGNLAND     opt_try_expr TSEMI
    {
      $$ = STMT(@$, context->buildBinOp(@$, $1, $2, $3));
    }
| lhs_expr TASSIGNLOR      opt_try_expr TSEMI
    {
      $$ = STMT(@$, context->buildBinOp(@$, $1, $2, $3));
    }
| lhs_expr TASSIGN         TNOINIT TSEMI
    {
      $$ = STMT(@$, context->buildBinOp(@$, $1, $2, context->buildIdent(@3, $3)));
    }
;

// Here are some nonterminals for identifiers

opt_label_ident:
         { $$ = STR(""); }
| TIDENT { $$ = $1; }
;

reserved_word_ident:
  TNONE
| TTHIS
| TFALSE
| TTRUE
| internal_type_ident_def
;

ident_def:
  TIDENT
| reserved_word_ident
;

/* Represents a use of an identifier. This is not used as often as you
   might think for various reasons:
     * things that allow scalar types more naturally use ident_expr,
       which returns an Expr* rather than a const char*
     * very special identifier-like things, like domain, borrowed, etc,
       need separate parsing rules anyway. These are handled by
       reserved_type_ident_use.
 */
ident_use:
  TIDENT                   { $$ = $1; }
| TTHIS                    { $$ = $1; }
;

/* Error message has been moved to post-parse. */
internal_type_ident_def:
  TBOOL
| TINT
| TUINT
| TREAL
| TIMAG
| TCOMPLEX
| TBYTES
| TSTRING
| TSYNC
| TSINGLE
| TOWNED
| TSHARED
| TBORROWED
| TUNMANAGED
| TDOMAIN
| TINDEX
| TLOCALE
| TNOTHING
| TVOID
;

scalar_type:
  TBOOL    { $$ = context->buildIdent(@$, $1); }
| TENUM    { $$ = context->buildIdent(@$, $1); }
| TINT     { $$ = context->buildIdent(@$, $1); }
| TUINT    { $$ = context->buildIdent(@$, $1); }
| TREAL    { $$ = context->buildIdent(@$, $1); }
| TIMAG    { $$ = context->buildIdent(@$, $1); }
| TCOMPLEX { $$ = context->buildIdent(@$, $1); }
| TBYTES   { $$ = context->buildIdent(@$, $1); }
| TSTRING  { $$ = context->buildIdent(@$, $1); }
| TLOCALE  { $$ = context->buildIdent(@$, $1); }
| TNOTHING { $$ = context->buildIdent(@$, $1); }
| TVOID    { $$ = context->buildIdent(@$, $1); }
;

reserved_type_ident_use:
  /* These reserved words can also be used as types but in fewer
     places in the parser. Additionally their type versions have
     different names. */
  TSYNC
| TSINGLE
| TDOMAIN
| TINDEX
;

do_stmt:
  TDO stmt      { $$ = { $2, true }; }
| block_stmt    { $$ = { $1, false }; }
;

return_stmt:
  TRETURN TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto node = Return::build(BUILDER, LOC(@$), /*value*/ nullptr);
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TRETURN opt_try_expr TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto node = Return::build(BUILDER, LOC(@$), toOwned($2));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
;

deprecated_class_level_stmt:
  class_level_stmt
| TDEPRECATED STRINGLITERAL
  {
    context->noteDeprecation(@$, $2);
  }
  class_level_stmt
  {
    $$ = $4;
  }
| TDEPRECATED
  {
    context->noteDeprecation(@$, nullptr);
  }
  class_level_stmt
  {
    $$ = $3;
  }
;

unstable_class_level_stmt:
  TUNSTABLE STRINGLITERAL
  {
    context->noteUnstable(@$, $2);
  }
  class_level_stmt
  {
    $$ = $4;
  }
| TUNSTABLE
  {
    context->noteUnstable(@$, nullptr);
  }
  class_level_stmt
  {
    $$ = $3;
  }
;

class_level_stmt:
  TSEMI
    {
      $$ = STMT(@$, context->buildEmptyStmt(@$));
    }
| inner_class_level_stmt
    {
      // visibility should be default when inner_class_level_stmt is parsed
      $$ = context->finishStmt($1);
      context->visibility = Decl::DEFAULT_VISIBILITY;
    }
| TPUBLIC {context->noteDeclStartLoc(@1);
           context->noteVisibility(Decl::PUBLIC);} inner_class_level_stmt
    {
      $$ = context->finishStmt($3);
      context->visibility = Decl::DEFAULT_VISIBILITY;
    }
| TPRIVATE {context->noteDeclStartLoc(@1);
            context->noteVisibility(Decl::PRIVATE);} inner_class_level_stmt
    {
      $$ = context->finishStmt($3);
      context->visibility = Decl::DEFAULT_VISIBILITY;
    }
;

inner_class_level_stmt:
  fn_decl_stmt_complete
| var_decl_stmt
| enum_decl_stmt
| type_alias_decl_stmt
| class_decl_stmt
| forwarding_decl_stmt
| extern_export_decl_stmt
;

forwarding_decl_stmt:
  forwarding_decl_start expr TSEMI
    {
      $$ = context->buildForwardingDecl(@$, toOwned($1), toOwned($2),
                                        VisibilityClause::NONE, nullptr);
    }
| forwarding_decl_start expr TEXCEPT renames_ls TSEMI
    {
      $$ = context->buildForwardingDecl(@$, toOwned($1), toOwned($2),
                                        VisibilityClause::EXCEPT, $4);
    }
| forwarding_decl_start expr TONLY opt_only_ls TSEMI
    {
      $$ = context->buildForwardingDecl(@$, toOwned($1), toOwned($2),
                                        VisibilityClause::ONLY, $4);
    }
| forwarding_decl_start var_decl_stmt
    {
      $$ = context->buildForwardingDecl(@$, toOwned($1), $2);
    }
;

forwarding_decl_start:
  TFORWARDING
  {
    $$ = context->buildAttributes(@$).release();
    context->resetAttributePartsState();
  }
;

extern_or_export:
  TEXTERN { $$ = Decl::EXTERN; }
| TEXPORT { $$ = Decl::EXPORT; }
;

extern_export_decl_stmt_start:
  extern_or_export
  {
    // Sets the start location only if it is still unset.
    context->noteDeclStartLoc(@1);
    $$ = context->noteLinkage($1);
  }
;

extern_export_decl_stmt:
  extern_export_decl_stmt_start class_start opt_inherit
  TLCBR class_level_stmt_ls TRCBR
  {
    $$ = context->buildAggregateTypeDecl(@1, $2, @3, $3, @4, $5, @6);
    context->exitScope($2.tag, $2.name);
  }
| extern_export_decl_stmt_start STRINGLITERAL class_start opt_inherit
  TLCBR class_level_stmt_ls TRCBR
  {
    // Set the linkage name since it will be nullptr otherwise.
    $3.linkageName = $2;
    $$ = context->buildAggregateTypeDecl(@1, $3, @4, $4, @5, $6, @7);
    context->exitScope($3.tag, $3.name);
  }
| extern_export_decl_stmt_start opt_expr fn_decl_stmt
  {
    auto loc = context->declStartLoc(@1);

    AstNode* optExpr = $2;
    FunctionParts fp = $3;

    auto commentList = context->appendList(context->makeList(),
                                           fp.comments);

    auto comments = context->gatherCommentsFromList(commentList, loc);
    delete commentList;

    fp.linkage = $1;
    fp.comments = comments;
    fp.linkageNameExpr = optExpr;
    $$ = context->buildExternExportFunctionDecl(@$, fp);
  }
| extern_export_decl_stmt_start opt_expr
  {
    context->storeVarDeclLinkageName($2);
  }
  var_decl_type var_decl_stmt_inner_ls TSEMI
  {
    $$ = context->buildVarOrMultiDeclStmt(@$, $5);
    context->resetDeclState();
  }
| extern_export_decl_stmt_start opt_expr TTYPE
  {
    context->storeVarDeclLinkageName($2);
    context->noteVarDeclKind(Variable::TYPE);
  }
  type_alias_decl_stmt_inner_ls TSEMI
  {
    $$ = context->buildVarOrMultiDeclStmt(@$, $5);
    context->resetDeclState();
  }
;

extern_block_stmt:
  TEXTERN EXTERNCODE
  {
    $$ = context->buildExternBlockStmt(@1, $2);
  }
;

loop_stmt:
  TDO stmt TWHILE expr TSEMI
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1,
                               false, @1, $2);
    // If the body is not a block, snag any comments before the 'while'.
    if (blockStyle == BlockStyle::IMPLICIT) {
      exprLst = context->appendList(exprLst, context->gatherComments(@3));
    }
    auto body = context->consumeToBlock(@1, exprLst);
    auto node = DoWhile::build(BUILDER, LOC(@$), blockStyle,
                               std::move(body),
                               toOwned($4));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TWHILE expr do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @3, $3);
    auto body = context->consumeToBlock(@3, exprLst);
    auto node = While::build(BUILDER, LOC(@1), toOwned($2),
                             blockStyle,
                             std::move(body));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TWHILE ifvar do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @3, $3);
    auto body = context->consumeToBlock(@3, exprLst);
    auto node = While::build(BUILDER, LOC(@1), toOwned($2),
                             blockStyle,
                             std::move(body));
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TCOFORALL expr TIN expr opt_task_intent_ls do_stmt
  {
    $$ = context->buildCoforallLoopStmt(@1, @2, @6, $2, $4, $5, $6);
  }
| TCOFORALL expr TIN zippered_iterator opt_task_intent_ls do_stmt
  {
    $$ = context->buildCoforallLoopStmt(@1, @2, @6, $2, $4, $5, $6);
  }
| TCOFORALL expr opt_task_intent_ls do_stmt
  {
    $$ = context->buildCoforallLoopStmt(@1, @1, @4, nullptr, $2, $3, $4);
  }
| TFOR expr TIN expr do_stmt
  {
    $$ = context->buildForLoopStmt(@1, @2, @5, $2, $4, $5);
  }
| TFOR expr TIN zippered_iterator do_stmt
  {
    $$ = context->buildForLoopStmt(@1, @2, @5, $2, $4, $5);
  }
| TFOR expr do_stmt
  {
    $$ = context->buildForLoopStmt(@1, @1, @3, nullptr, $2, $3);
  }
| TFOR zippered_iterator do_stmt
  {
    $$ = context->buildForLoopStmt(@1, @1, @3, nullptr, $2, $3);
  }
| TFOR TPARAM ident_def TIN expr do_stmt
  {
    std::vector<ParserComment>* comments;
    ParserExprList* exprLst;
    BlockStyle blockStyle;
    context->prepareStmtPieces(comments, exprLst, blockStyle, @1, @6, $6);
    AstNode* ident = context->buildIdent(@3, $3);
    auto index = context->buildLoopIndexDecl(@3, toOwned(ident));
    auto body = context->consumeToBlock(@6, exprLst);
    auto node = For::build(BUILDER, LOC(@1), std::move(index),
                           toOwned($5),
                           blockStyle,
                           std::move(body),
                           /*isExpressionLevel*/ false,
                           /*isParam*/ true);
    CommentsAndStmt cs = { .comments=comments, .stmt=node.release() };
    $$ = context->finishStmt(cs);
  }
| TFORALL expr TIN expr                                   do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @2, @5, $2, $4, nullptr, $5);
  }
| TFORALL expr TIN expr              forall_intent_clause do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @2, @6, $2, $4, $5, $6);
  }
| TFORALL expr TIN zippered_iterator                      do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @2, @5, $2, $4, nullptr, $5);
  }
| TFORALL expr TIN zippered_iterator forall_intent_clause do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @2, @6, $2, $4, $5, $6);
  }
| TFORALL          expr                                   do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @1, @3, nullptr, $2, nullptr, $3);
  }
| TFORALL          expr              forall_intent_clause do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @1, @4, nullptr, $2, $3, $4);
  }
| TFORALL          zippered_iterator                      do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @1, @3, nullptr, $2, nullptr, $3);
  }
| TFORALL          zippered_iterator forall_intent_clause do_stmt
  {
    $$ = context->buildForallLoopStmt(@1, @1, @4, nullptr, $2, $3, $4);
  }
| TFOREACH expr TIN expr                                   do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @2, @5, $2, $4, nullptr, $5);
  }
| TFOREACH expr TIN expr              forall_intent_clause do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @2, @6, $2, $4, $5, $6);
  }
| TFOREACH expr TIN zippered_iterator                      do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @2, @5, $2, $4, nullptr, $5);
  }
| TFOREACH expr TIN zippered_iterator forall_intent_clause do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @2, @6, $2, $4, $5, $6);
  }
| TFOREACH          expr                                   do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @1, @3, nullptr, $2, nullptr, $3);
  }
| TFOREACH          expr              forall_intent_clause do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @1, @4, nullptr, $2, $3, $4);
  }
| TFOREACH          zippered_iterator                      do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @1, @3, nullptr, $2, nullptr, $3);
  }
| TFOREACH          zippered_iterator forall_intent_clause do_stmt
  {
    $$ = context->buildForeachLoopStmt(@1, @1, @4, nullptr, $2, $3, $4);
  }
| TLSBR expr_ls TIN expr TRSBR stmt
  {
    $$ = context->buildBracketLoopStmt(@1, @2, @5, $2, $4, nullptr, $6);
  }
| TLSBR expr_ls TIN expr forall_intent_clause TRSBR stmt
  {
    $$ = context->buildBracketLoopStmt(@1, @2, @6, $2, $4, $5, $7);
  }
| TLSBR expr_ls TIN zippered_iterator TRSBR stmt
  {
    $$ = context->buildBracketLoopStmt(@1, @2, @5, $2, $4, nullptr, $6);
  }
| TLSBR expr_ls TIN zippered_iterator forall_intent_clause TRSBR stmt
  {
    $$ = context->buildBracketLoopStmt(@1, @2, @6, $2, $4, $5, $7);
  }
| TLSBR expr_ls TRSBR stmt
  {
    $$ = context->buildBracketLoopStmt(@1, @2, @3, $2, nullptr, $4);
  }
| TLSBR expr_ls forall_intent_clause TRSBR stmt
  {
    $$ = context->buildBracketLoopStmt(@1, @2, @4, $2, $3, $5);
  }
| TLSBR zippered_iterator TRSBR stmt
  {
    auto iterExprs = context->makeList($2);
    $$ = context->buildBracketLoopStmt(@1, @2, @3, iterExprs, nullptr, $4);
  }
| TLSBR zippered_iterator forall_intent_clause TRSBR stmt
  {
    auto iterExprs = context->makeList($2);
    $$ = context->buildBracketLoopStmt(@1, @2, @4, iterExprs, $3, $5);
  }
;

zippered_iterator:
  TZIP TLP expr_ls TRP
  {
    auto exprs = context->consumeList($3);
    auto node = Zip::build(BUILDER, LOC(@$), std::move(exprs));
    $$ = node.release();
  }
;

if_stmt:
  TIF expr TTHEN stmt %prec TNOELSE
  {
    $$ = context->buildConditionalStmt(true, @1, @3, $2, $4);
  }
| TIF expr block_stmt %prec TNOELSE
  {
    $$ = context->buildConditionalStmt(false, @1, @3, $2, $3);
  }
| TIF expr TTHEN stmt TELSE stmt
  {
    $$ = context->buildConditionalStmt(true, @1, @3, @5, $2, $4, $6);
  }
| TIF expr block_stmt TELSE stmt
  {
    $$ = context->buildConditionalStmt(false, @1, @3, @4, $2, $3, $5);
  }
| TIF ifvar TTHEN stmt %prec TNOELSE
  {
    $$ = context->buildConditionalStmt(true, @1, @3, $2, $4);
  }
| TIF ifvar block_stmt %prec TNOELSE
  {
    $$ = context->buildConditionalStmt(false, @1, @3, $2, $3);
  }
| TIF ifvar TTHEN stmt TELSE stmt
  {
    $$ = context->buildConditionalStmt(true, @1, @3, @5, $2, $4, $6);
  }
| TIF ifvar block_stmt TELSE stmt
  {
    $$ = context->buildConditionalStmt(false, @1, @3, @4, $2, $3, $5);
  }
| TIF expr assignop_ident expr TTHEN stmt %prec TNOELSE
  {
    auto op = context->buildBinOp(@3, $2, $3, $4);
    $$ = context->buildConditionalStmt(true, @1, @5, op, $6);
  }
| TIF expr assignop_ident expr block_stmt %prec TNOELSE
  {
    auto op = context->buildBinOp(@3, $2, $3, $4);
    $$ = context->buildConditionalStmt(false, @1, @5, op, $5);
  }
| TIF expr assignop_ident expr TTHEN stmt TELSE stmt
  {
    auto op = context->buildBinOp(@3, $2, $3, $4);
    $$ = context->buildConditionalStmt(true, @1, @5, @7, op, $6, $8);
  }
| TIF expr assignop_ident expr block_stmt TELSE stmt
  {
    auto op = context->buildBinOp(@3, $2, $3, $4);
    $$ = context->buildConditionalStmt(false, @1, @5, @6, op, $5, $7);
  }
;

ifvar:
  TVAR   ident_def TASSIGN expr
  {
    auto varDecl = Variable::build(BUILDER, LOC(@$),
                                   /*attributes*/ nullptr,
                                   Decl::DEFAULT_VISIBILITY,
                                   Decl::DEFAULT_LINKAGE,
                                   /*linkageName*/ nullptr,
                                   /*name*/ $2,
                                   Variable::VAR,
                                   /*isConfig*/ false,
                                   context->currentScopeIsAggregate(),
                                   /*typeExpression*/ nullptr,
                                   toOwned($4));
    $$ = varDecl.release();
  }
| TCONST ident_def TASSIGN expr
  {
    auto varDecl = Variable::build(BUILDER, LOC(@$),
                                   /*attributes*/ nullptr,
                                   Decl::DEFAULT_VISIBILITY,
                                   Decl::DEFAULT_LINKAGE,
                                   /*linkageName*/ nullptr,
                                   /*name*/ $2,
                                   Variable::CONST,
                                   /*isConfig*/ false,
                                   context->currentScopeIsAggregate(),
                                   /*typeExpression*/ nullptr,
                                   toOwned($4));
    $$ = varDecl.release();
  }
;

interface_stmt:
  TINTERFACE ident_def TLP ifc_formal_ls TRP block_stmt
  {
    $$ = context->buildInterfaceStmt(@$, $2, $4, @6, $6);
  }
| TINTERFACE ident_def                       block_stmt
  {
    $$ = context->buildInterfaceStmt(@$, $2, nullptr, @3, $3);
  }
;

ifc_formal_ls:
  ifc_formal                      { $$ = context->makeList($1); }
| ifc_formal_ls TCOMMA ifc_formal { context->appendList($1, $3); }
;

ifc_formal:
  // implicitly 'type' intent, could specify explicitly - see #16966
  ident_def  { $$ = context->buildInterfaceFormal(@1, $1); }
;

// which types are allowed in 'T implements IFC'
implements_type_ident:
  TIDENT
| TBOOL
| TINT
| TUINT
| TREAL
| TIMAG
| TCOMPLEX
| TBYTES
| TSTRING
| TLOCALE
| TNOTHING
| TVOID
| implements_type_error_ident
  {
    context->syntax(@$, "type '%s' cannot implement an interface.", $1.c_str());
    $$ = $1;
  }
;

// these are not allowed as types in 'T implements IFC'
implements_type_error_ident:
  TNONE
| TTHIS
| TFALSE
| TTRUE
/* it would be nice to include these, alas they cause shift/reduce conflicts:
| TSYNC
| TSINGLE
| TOWNED
| TSHARED
| TBORROWED
| TUNMANAGED
*/
| TDOMAIN
| TINDEX
;

implements_stmt:
  TIMPLEMENTS ident_def TLP actual_ls TRP TSEMI
  {
    $$ = context->buildImplementsStmt(@$, YLOC2(@2, @5), $2, $4);
  }
| implements_type_ident TIMPLEMENTS ident_def TSEMI
  {
    $$ = context->buildImplementsStmt(@$, @1, $1, @3, $3, nullptr);
  }
| implements_type_ident TIMPLEMENTS ident_def TLP actual_ls TRP TSEMI
  {
    $$ = context->buildImplementsStmt(@$, @1, $1, YLOC2(@3, @6), $3, $5);
  }
;

ifc_constraint:
  TIMPLEMENTS ident_def TLP actual_ls TRP
  {
    $$ = context->buildImplementsConstraint(@$, YLOC2(@2, @5), $2, $4);
  }
| implements_type_ident TIMPLEMENTS ident_def
  {
    $$ = context->buildImplementsConstraint(@$, @1, $1, @3, $3, nullptr);
  }
| implements_type_ident TIMPLEMENTS ident_def TLP actual_ls TRP
  {
    $$ = context->buildImplementsConstraint(@$, @1, $1, YLOC2(@3, @6), $3, $5);
  }
;

try_stmt:
  TTRY     tryable_stmt
  {
    $$ = context->buildTryExprStmt(@$, $2, false);
  }
| TTRYBANG tryable_stmt
  {
    $$ = context->buildTryExprStmt(@$, $2, true);
  }
| TTRY     block_stmt      catch_expr_ls
  {
    $$ = context->buildTryCatchStmt(@$, $2, $3, false);
  }
| TTRYBANG block_stmt      catch_expr_ls
  {
    $$ = context->buildTryCatchStmt(@$, $2, $3, true);
  }
;

catch_expr_ls:
                            { $$ = context->makeList(); }
| catch_expr_ls catch_expr  { $$ = context->appendList($1, $2); }
;

catch_expr:
  TCATCH                          block_stmt
  {
    $$ = context->buildCatch(@$, nullptr, $2, false);
  }
| TCATCH     catch_expr_inner     block_stmt
  {
    $$ = context->buildCatch(@$, $2, $3, false);
  }
| TCATCH TLP catch_expr_inner TRP block_stmt
  {
    $$ = context->buildCatch(@$, $3, $5, true);
  }
;

catch_expr_inner:
  ident_def
  {
    $$ = Variable::build(BUILDER, LOC(@$), /*attributes*/ nullptr,
                         Decl::DEFAULT_VISIBILITY,
                         Decl::DEFAULT_LINKAGE,
                         /*linkageName*/ nullptr,
                         /*name*/ $1,
                         Variable::VAR,
                         /*isConfig*/ false,
                         /*isField*/ false,
                         /*typeExpression*/ nullptr,
                         /*initExpression*/ nullptr).release();
  }
| ident_def TCOLON expr
  {
    $$ = Variable::build(BUILDER, LOC(@$), /*attributes*/ nullptr,
                         Decl::DEFAULT_VISIBILITY,
                         Decl::DEFAULT_LINKAGE,
                         /*linkageName*/ nullptr,
                         /*name*/ $1,
                         Variable::VAR,
                         /*isConfig*/ false,
                         /*isField*/ false,
                         /*typeExpression*/ toOwned($3),
                         /*initExpression*/ nullptr).release();
  }
;

throw_stmt:
  TTHROW expr TSEMI
  {
    auto comments = context->gatherComments(@1);
    auto node = Throw::build(BUILDER, LOC(@$), toOwned($2));
    $$ = { .comments=comments, .stmt=node.release() };
  }

select_stmt:
  TSELECT expr TLCBR when_stmt_ls TRCBR
  {
    $$ = context->buildSelectStmt(@$, toOwned($2), $4);
  }
| TSELECT expr TLCBR error TRCBR
  {
    auto comments = context->gatherComments(@$);
    auto node = ErroneousExpression::build(BUILDER, LOC(@4));
    $$ = { .comments=comments, .stmt=node.release() };
  }
;

when_stmt_ls:
                          { $$ = context->makeList(); }
| when_stmt_ls when_stmt  { $$ = context->appendList($1, $2); }
;

when_stmt:
  TWHEN expr_ls do_stmt
  {
    $$ = context->buildWhenStmt(@$, $2, $3);
  }
| TOTHERWISE stmt
  {
    BlockOrDo blockOrDo = { .cs=$2, .usesDo=false };
    $$ = context->buildWhenStmt(@$, nullptr, blockOrDo);
  }
| TOTHERWISE TDO stmt
  {
    BlockOrDo blockOrDo = { .cs=$3, .usesDo=true };
    $$ = context->buildWhenStmt(@$, nullptr, blockOrDo);
  }
;

manager_expr:
  expr TAS var_decl_type ident_def
  {
    $$ = context->buildManagerExpr(@$, $1, $3, @4, $4);
    context->resetDeclState();
  }
| expr TAS ident_def
  {
    $$ = context->buildManagerExpr(@$, $1, @3, $3);
  }
| expr
  {
    $$ = $1;
  }
;

manager_expr_ls:
  manager_expr                          { $$ = context->makeList($1); }
| manager_expr_ls TCOMMA manager_expr   { $$ = context->appendList($1, $3); }
;

manage_stmt:
  TMANAGE manager_expr_ls do_stmt
  {
    $$ = context->buildManageStmt(@$, $2, @3, $3);
  }
;

/** DECLARATION STATEMENTS ***************************************************/

class_decl_stmt:
  class_start opt_inherit TLCBR class_level_stmt_ls TRCBR
    {
      $$ = context->buildAggregateTypeDecl(@$, $1, @2, $2, @3, $4, @5);
      context->exitScope($1.tag, $1.name);
    }
| class_start opt_inherit TLCBR error TRCBR
    {
      auto contents =
        context->makeList(ErroneousExpression::build(BUILDER, LOC(@4)));
      $$ = context->buildAggregateTypeDecl(@$, $1, @2, $2, @3, contents, @5);
      context->exitScope($1.tag, $1.name);
    }
  /* see also extern_export_decl_stmt */
;

class_start:
  class_tag ident_def
  {
    $$ = context->enterScopeAndBuildTypeDeclParts(@1, $2, $1);
  }
;

class_tag:
  TCLASS   { $$ = asttags::Class; }
| TRECORD  { $$ = asttags::Record; }
| TUNION   { $$ = asttags::Union; }
;

opt_inherit:
                  { $$ = nullptr; }
| TCOLON expr_ls  { $$ = $2; }
;

class_level_stmt_ls:
  {
    /* nothing */
    $$ = context->makeList();
  }
| class_level_stmt_ls deprecated_class_level_stmt
  {
    context->appendList($1, $2);
  }
| class_level_stmt_ls unstable_class_level_stmt
  {
    context->appendList($1, $2);
  }
| class_level_stmt_ls pragma_ls deprecated_class_level_stmt
  {
    context->appendList($1, context->buildPragmaStmt(@3, $3));
  }
| class_level_stmt_ls pragma_ls unstable_class_level_stmt
  {
    context->appendList($1, context->buildPragmaStmt(@3, $3));
  }
;

enum_decl_stmt:
  enum_header_lcbr enum_ls TRCBR
    {
      TypeDeclParts parts = $1;
      ParserExprList* list = $2;
      // get any comments after the last element but before the closing brace
      context->appendList(list, context->gatherComments(@3));

      auto decl = Enum::build(BUILDER, LOC(@$), toOwned(parts.attributes),
                              parts.visibility,
                              parts.name,
                              context->consumeList(list));
      CommentsAndStmt cs = {parts.comments, decl.release()};
      $$ = cs;
      context->exitScope(asttags::Enum, parts.name);
      context->resetDeclState();
      context->clearComments();
    }
| enum_header_lcbr error TRCBR
    {
      TypeDeclParts parts = $1;
      auto err = ErroneousExpression::build(BUILDER, LOC(@2));
      CommentsAndStmt cs = {parts.comments, err.release()};
      $$ = cs;
      context->exitScope(asttags::Enum, parts.name);
      context->resetDeclState();
      context->clearComments();
    }
;

enum_header_lcbr:
  TENUM ident_def TLCBR
  {
    $$ = context->enterScopeAndBuildTypeDeclParts(@1, $2, asttags::Enum);
  }
;

enum_ls:
  deprecated_enum_item
  {
    $$ = context->makeList($1);
    context->resetAttributePartsState();
  }
| enum_ls TCOMMA
  {
    $$ = $1;
    context->clearCommentsBefore(@2);
    context->resetAttributePartsState();
  }
| enum_ls TCOMMA
  {
    context->clearCommentsBefore(@2);
    context->resetAttributePartsState();
  }
  deprecated_enum_item
  {
    context->appendList($1, $4);
    context->resetAttributePartsState();
  }
|
  unstable_enum_item
  {
    $$ = context->makeList($1);
    context->resetAttributePartsState();
  }
| enum_ls TCOMMA
  {
    context->clearCommentsBefore(@2);
    context->resetAttributePartsState();
  }
  unstable_enum_item
  {
    context->appendList($1, $4);
    context->resetAttributePartsState();
  }

;

deprecated_enum_item:
  enum_item
| TDEPRECATED STRINGLITERAL
  {
    context->noteDeprecation(@$, $2);
  }
  enum_item
  {
    $$ = $4;
  }
| TDEPRECATED
  {
    context->noteDeprecation(@$, nullptr);
  }
  enum_item
  {
    $$ = $3;
  }
;

unstable_enum_item:
  TUNSTABLE STRINGLITERAL
  {
    context->noteUnstable(@$, $2);
  }
  enum_item
  {
    $$ = $4;
  }
| TUNSTABLE
  {
    context->noteUnstable(@$, nullptr);
  }
  enum_item
  {
    $$ = $3;
  }
;

enum_item:
  ident_def
    {
      auto decl = EnumElement::build(BUILDER, LOC(@$),
                                     context->buildAttributes(@$),
                                     $1);
      $$ = STMT(@$, decl.release());
    }
| ident_def TASSIGN expr
    {
      auto decl = EnumElement::build(BUILDER, LOC(@$),
                                     context->buildAttributes(@$),
                                     $1,
                                     toOwned($3));
      $$ = STMT(@$, decl.release());
      context->clearCommentsBefore(@3);
    }
;

lambda_decl_start:
  TLAMBDA
    {
      FunctionParts fp = context->makeFunctionParts(false, false);
      context->noteDeclStartLoc(@1);
      auto loc = context->declStartLoc(@$);
      fp.comments = context->gatherComments(loc);
      fp.attributes = context->buildAttributes(@$).release();
      fp.visibility = context->visibility;
      context->resetAttributePartsState();
      fp.kind = Function::PROC;
      $$ = fp;
    }
;

lambda_decl_expr:
  lambda_decl_start req_formal_ls opt_ret_tag opt_type
  opt_throws_error
  opt_lifetime_where
    {
      context->clearComments();
      context->resetDeclState();
      context->enterScope(asttags::Function, STR("lambda"));
    }
  function_body_stmt
    {
      FunctionParts fp = $1;
      fp.name = context->buildIdent(@1, STR("lambda"));
      fp.formals = $2;
      fp.returnIntent = $3;
      fp.returnType = $4;
      fp.throws = ($5 == ThrowsTag_THROWS);
      WhereAndLifetime wl = $6;
      fp.lifetime = wl.lifetime;
      fp.where = wl.where;
      fp.body = $8;

      context->clearComments();
      context->exitScope(asttags::Function, STR("lambda"));

      $$ = context->buildLambda(@$, fp);
    }
;

linkage_spec_empty:
;

linkage_spec:
  linkage_spec_empty { $$ = context->makeFunctionParts(false, false); }
| TINLINE            { context->noteDeclStartLoc(@1);
                       $$ = context->makeFunctionParts(true, false); }
| TOVERRIDE          { context->noteDeclStartLoc(@1);
                       $$ = context->makeFunctionParts(false, true); }
;

opt_fn_type_formal_ls:
                                          { $$ = context->makeList(); }
| fn_type_formal_ls                       { $$ = $1; }
;

fn_type_formal_ls:
  fn_type_formal                          { $$ = context->makeList($1); }
| fn_type_formal_ls TCOMMA fn_type_formal { $$ = context->appendList($1, $3); }
;

fn_type_formal:
  named_formal
  { $$ = $1; }
  /* TODO: Would like to get rid of TCOLON here, but Bison... */
| required_intent_tag TCOLON formal_type
  { $$ = context->buildAnonFormal(@$, @1, $1, $3); }
| formal_type
  { $$ = context->buildAnonFormal(@$, $1); }
;

// TODO: We would like to replace the alternate with 'ret_type', but that
// leads to some reduce/reduce conflicts.
opt_fn_type_ret_type:
  %prec TNOELSE   { $$ = nullptr; }
| TCOLON expr     { $$ = $2; }
;

//
// TODO: If you want to have spaces between the 'proc' and '(' text in the
// TPROCLP token you will need to unfactor a bunch of stuff revolving
// around 'fn_decl_receiver_expr', e.g., consider:
// 'proc (borrowed class?).hash()'
// -> Can we revert to TPROC TLP and then use precedence to fix this?
// TODO: We need the return expression to be 'ret_type', not 'expr'.
//
fn_type:
  TPROCLP opt_fn_type_formal_ls TRP opt_ret_tag opt_fn_type_ret_type
  opt_throws_error
  {
    FunctionParts fp = context->makeFunctionParts(false, false);
    fp.kind = Function::PROC;
    fp.name = context->buildIdent(@1, STR("proc"));
    fp.formals = $2;
    fp.returnIntent = $4;
    fp.returnType = $5;
    fp.throws = ($6 == ThrowsTag_THROWS);
    fp.body = nullptr;
    fp.comments = nullptr;
    fp.attributes = nullptr;
    fp.visibility = context->visibility;
    $$ = fp;
  }
;

// TODO: This needs to use the old style formal list instead.
fn_expr:
  fn_type
  {
    context->clearComments();
    context->resetDeclState();
    context->enterScope(asttags::Function, STR("proc"));
  }
  block_stmt_body
  {
    FunctionParts fp = $1;
    fp.isBodyNonBlockExpression = false;
    fp.body = $3;
    context->clearComments();
    context->exitScope(asttags::Function, STR("proc"));
    $$ = fp;
  }
| fn_type TALIAS
  {
    context->clearComments();
    context->resetDeclState();
    context->enterScope(asttags::Function, STR("proc"));
  }
  expr
  {
    FunctionParts fp = $1;
    fp.isBodyNonBlockExpression = true;
    fp.body = context->makeList($4);
    context->clearComments();
    context->exitScope(asttags::Function, STR("proc"));
    $$ = fp;
  }
;

fn_decl_stmt_complete:
  fn_decl_stmt
    {
      $$ = context->buildRegularFunctionDecl(@$, $1);
    }
;

fn_decl_stmt:
  fn_decl_stmt_inner
  opt_ret_tag opt_ret_type
  opt_throws_error opt_lifetime_where
  {
    context->clearComments();
    context->resetDeclState();

    // May never have been built if there was a syntax error.
    if ($1.errorExpr == nullptr) {
      context->enterScope(asttags::Function, $1.name->name());
    }
  }
  opt_function_body_stmt
  {
    FunctionParts fp = $1;
    fp.returnIntent = $2;
    fp.returnType = $3;
    fp.throws = ($4 == ThrowsTag_THROWS);
    WhereAndLifetime wl = $5;
    fp.body = $7;
    fp.lifetime = wl.lifetime;
    fp.where = wl.where;
    context->clearComments();

    // May never have been built if there was a syntax error.
    if ($1.errorExpr == nullptr) {
      context->exitScope(asttags::Function, $1.name->name());
    }

    $$ = fp;
  }
;

fn_decl_stmt_inner:
  fn_decl_stmt_start opt_this_intent_tag fn_ident opt_formal_ls
    {
      FunctionParts fp = $1;
      fp.thisIntent = $2;
      fp.name = context->buildIdent(@3, $3);
      fp.formals = $4;
      $$ = fp;
    }
| fn_decl_stmt_start opt_this_intent_tag assignop_ident opt_formal_ls
    {
      FunctionParts fp = $1;
      fp.thisIntent = $2;
      fp.name = context->buildIdent(@3, $3);
      fp.formals = $4;
      $$ = fp;
    }
| fn_decl_stmt_start opt_this_intent_tag fn_decl_receiver_expr TDOT fn_ident opt_formal_ls
    {
      FunctionParts fp = $1;
      fp.thisIntent = $2;
      fp.receiver = Formal::build(BUILDER, LOC(@3), /*attributes*/ nullptr,
                                  STR("this"), $2, toOwned($3),
                                  nullptr).release();
      fp.name = context->buildIdent(@5, $5);
      fp.formals = $6;
      $$ = fp;
    }
| fn_decl_stmt_start opt_this_intent_tag fn_decl_receiver_expr TDOT assignop_ident opt_formal_ls
    {
      FunctionParts fp = $1;
      fp.thisIntent = $2;
      fp.receiver = Formal::build(BUILDER, LOC(@3), /*attributes*/ nullptr,
                                  STR("this"), $2, toOwned($3),
                                  nullptr).release();
      fp.name = context->buildIdent(@5, $5);
      fp.formals = $6;
      $$ = fp;
    }
| fn_decl_stmt_start opt_this_intent_tag error opt_formal_ls
    {
      FunctionParts fp = $1;
      fp.errorExpr = ErroneousExpression::build(BUILDER, LOC(@$)).release();
      $$ = fp;
    }
;

fn_decl_stmt_start:
  linkage_spec proc_iter_or_op
    {
      FunctionParts fp = $1;
      context->noteDeclStartLoc(@2);
      auto loc = context->declStartLoc(@$);
      fp.comments = context->gatherComments(loc);
      fp.attributes = context->buildAttributes(@$).release();
      fp.visibility = context->visibility;
      context->resetAttributePartsState();
      fp.kind = $2;
      $$ = fp;
    }
;

fn_decl_receiver_expr:
  ident_expr
| TLP expr TRP        { $$ = $2; }
;

fn_ident:
  ident_def
| op_ident
| ident_def TBANG
  {
    std::string s = $1.c_str();
    s += "!";
    $$ = STR(s.c_str());
  }
;

op_ident:
  TBAND
| TBOR
| TBXOR
| TBNOT
| TEQUAL
| TNOTEQUAL
| TLESSEQUAL
| TGREATEREQUAL
| TLESS
| TGREATER
| TPLUS
| TMINUS
| TSTAR
| TDIVIDE
| TSHIFTLEFT
| TSHIFTRIGHT
| TMOD
| TEXP
| TBANG
| TBY
| THASH
| TALIGN
| TSWAP
| TINITEQUALS
| TCOLON
;

assignop_ident:
  TASSIGN
| TASSIGNPLUS
| TASSIGNMINUS
| TASSIGNMULTIPLY
| TASSIGNDIVIDE
| TASSIGNMOD
| TASSIGNEXP
| TASSIGNBAND
| TASSIGNBOR
| TASSIGNBXOR
| TASSIGNSR
| TASSIGNSL
;


all_op_name:
  op_ident
| assignop_ident
;

formal_var_arg_expr:
  TDOTDOTDOT             { $$ = nullptr; }
| TDOTDOTDOT expr        { $$ = $2; }
| TDOTDOTDOT query_expr  { $$ = $2; }
;

opt_formal_ls:
                     { $$ = context->parenlessMarker; }
| TLP formal_ls TRP  { $$ = $2; }
;

req_formal_ls:
  TLP TRP                   { $$ = context->makeList(); }
| TLP formal_ls_inner TRP   { $$ = $2; }
;

formal_ls_inner:
  formal                         { $$ = context->makeList($1); }
| formal_ls_inner TCOMMA formal  { $$ = context->appendList($1, $3); }
;

formal_ls:
                           { $$ = context->makeList(); }
| formal_ls_inner          { $$ = $1; }
;

formal:
  named_formal
;

formal_ident_def:
  ident_def
| TUNDERSCORE
;

named_formal:
  opt_formal_intent_tag formal_ident_def opt_colon_formal_type opt_init_expr
  {
    $$ = context->buildFormal(@$, $1, $2, $3, $4);
  }
| pragma_ls opt_formal_intent_tag formal_ident_def opt_colon_formal_type
  opt_init_expr
  {
    $$ = context->buildFormal(@$, $2, $3, $4, $5, true);
  }
| opt_formal_intent_tag formal_ident_def opt_colon_formal_type
  formal_var_arg_expr
  {
    $$ = context->buildVarArgFormal(@$, $1, $2, $3, $4);
  }
| pragma_ls opt_formal_intent_tag formal_ident_def opt_colon_formal_type
  formal_var_arg_expr
  {
    $$ = context->buildVarArgFormal(@$, $2, $3, $4, $5, true);
  }
| opt_formal_intent_tag TLP tuple_var_decl_stmt_inner_ls TRP
  opt_colon_formal_type opt_init_expr
  {
    $$ = context->buildTupleFormal(@$, $1, $3, $5, $6);
  }
| opt_formal_intent_tag TLP tuple_var_decl_stmt_inner_ls TRP
  opt_colon_formal_type formal_var_arg_expr
  {
    $$ = context->syntax(@$, "variable-length argument may not be grouped in a tuple.");
  }
;

opt_formal_intent_tag:
  %prec TFOR {
    context->noteIsBuildingFormal(true);
    $$ = Formal::DEFAULT_INTENT;
  }
| required_intent_tag
  {
    context->noteIsBuildingFormal(true);
    $$ = $1;
  }
;

required_intent_tag:
  TIN         { $$ = Formal::IN; }
| TINOUT      { $$ = Formal::INOUT; }
| TOUT        { $$ = Formal::OUT; }
| TCONST TIN  { $$ = Formal::CONST_IN; }
| TCONST TREF { $$ = Formal::CONST_REF; }
| TCONST      { $$ = Formal::CONST; }
| TPARAM      { $$ = Formal::PARAM; }
| TREF        { $$ = Formal::REF; }
| TTYPE       { $$ = Formal::TYPE; }
;

opt_this_intent_tag:
                { $$ = Formal::DEFAULT_INTENT; }
| TPARAM        { $$ = Formal::PARAM; }
| TREF          { $$ = Formal::REF; }
| TCONST TREF   { $$ = Formal::CONST_REF; }
| TCONST        { $$ = Formal::CONST; }
| TTYPE         { $$ = Formal::TYPE; }
;

proc_iter_or_op:
  TPROC     { $$ = Function::PROC; }
| TITER     { $$ = Function::ITER; }
| TOPERATOR { $$ = Function::OPERATOR; }
;

opt_ret_tag:
    %prec TNOELSE   { $$ = Function::DEFAULT_RETURN_INTENT; }
| TCONST            { $$ = Function::CONST; }
| TCONST TREF       { $$ = Function::CONST_REF; }
| TREF              { $$ = Function::REF; }
| TPARAM            { $$ = Function::PARAM; }
| TTYPE             { $$ = Function::TYPE; }
;

opt_throws_error:
          %prec TNOELSE   { $$ = ThrowsTag_DEFAULT; }
| TTHROWS                 { $$ = ThrowsTag_THROWS; }

opt_function_body_stmt:
  TSEMI               { context->clearComments(); $$ = nullptr; }
| function_body_stmt  { $$ = $1; }
;

function_body_stmt:
  block_stmt_body   { $$ = $1; }
| return_stmt       { context->clearComments(); $$ = context->makeList($1); }
;

query_expr:
  TQUERIEDIDENT   { $$ = context->buildTypeQuery(@$, $1); }
;


opt_lifetime_where:
  { $$ = makeWhereAndLifetime(nullptr, nullptr); }
| TWHERE expr
  { $$ = makeWhereAndLifetime($2, nullptr); }
| TLIFETIME lifetime_components_expr
  { $$ = makeWhereAndLifetime(nullptr, $2); }
| TWHERE expr TLIFETIME lifetime_components_expr
  { $$ = makeWhereAndLifetime($2, $4); }
| TLIFETIME lifetime_components_expr TWHERE expr
  { $$ = makeWhereAndLifetime($4, $2); }
;

lifetime_components_expr:
  lifetime_expr
  { $$ = context->makeList($1); }
| lifetime_components_expr TCOMMA lifetime_expr
  { $$ = context->appendList($1, $3); }
;

lifetime_expr:
  lifetime_ident TASSIGN      lifetime_ident
    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| lifetime_ident TLESS        lifetime_ident
    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| lifetime_ident TLESSEQUAL   lifetime_ident
    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| lifetime_ident TEQUAL       lifetime_ident
    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| lifetime_ident TGREATER     lifetime_ident
    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| lifetime_ident TGREATEREQUAL lifetime_ident
    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| TRETURN lifetime_ident
    { $$ = Return::build(BUILDER, LOC(@$), toOwned($2)).release(); }
;

lifetime_ident:
  TIDENT { $$ = context->buildIdent(@1, $1); }
| TTHIS  { $$ = context->buildIdent(@1, $1); }
;

type_alias_decl_stmt:
  type_alias_decl_stmt_start type_alias_decl_stmt_inner_ls TSEMI
  {
    $$ = context->buildVarOrMultiDeclStmt(@$, $2);
    context->resetDeclState();
  }
;

// Extern types are handled in the 'extern_export_decl_stmt' above.
type_alias_decl_stmt_start:
  TTYPE
  {
    $$ = context->noteVarDeclKind(Variable::TYPE);
  }
| TCONFIG TTYPE
  {
    $$ = context->noteVarDeclKind(Variable::TYPE);
    context->noteIsVarDeclConfig(true);
  }
;

type_alias_decl_stmt_inner_ls:
  type_alias_decl_stmt_inner
  {
    $$ = context->makeList($1);
  }
| type_alias_decl_stmt_inner_ls TCOMMA type_alias_decl_stmt_inner
  {
    $$ = context->appendList($1, $3);
  }
;

type_alias_decl_stmt_inner:
  ident_def opt_init_type
  {
    // TODO (dlongnecke-cray): Add a helper to build this and var_decl_stmt.
    auto node = Variable::build(BUILDER, LOC(@$),
                                context->buildAttributes(@$),
                                context->visibility,
                                context->linkage,
                                context->consumeVarDeclLinkageName(),
                                /*name*/ $1,
                                context->varDeclKind,
                                context->isVarDeclConfig,
                                context->currentScopeIsAggregate(),
                                /*typeExpression*/ nullptr,
                                toOwned($2));
      // Gather the comments like a statement does.
      $$ = STMT(@1, node.release());
      context->clearComments();
  }
;

opt_init_type:
  { $$ = nullptr; }
| TASSIGN type_level_expr
  { $$ = $2; }
| TASSIGN array_type
  {
    // Cannot be a type_level_expr as expr inherits from type_level_expr.
    $$ = $2;
  }
;

var_decl_type:
  TPARAM      { $$ = context->noteVarDeclKind(Variable::PARAM); }
| TCONST TREF { $$ = context->noteVarDeclKind(Variable::CONST_REF); }
| TREF        { $$ = context->noteVarDeclKind(Variable::REF); }
| TCONST      { $$ = context->noteVarDeclKind(Variable::CONST); }
| TVAR        { $$ = context->noteVarDeclKind(Variable::VAR); }
;

var_decl_stmt:
  TCONFIG
  {
    // Use a mid-rule action to thread along 'isVarDeclConfig'.
    context->noteIsVarDeclConfig(true);
  }
  var_decl_type var_decl_stmt_inner_ls TSEMI {
    $$ = context->buildVarOrMultiDeclStmt(@$, $4);
    context->resetDeclState();
  }
| var_decl_type var_decl_stmt_inner_ls TSEMI
  {
    $$ = context->buildVarOrMultiDeclStmt(@$, $2);
    context->resetDeclState();
  }
;

var_decl_stmt_inner_ls:
  var_decl_stmt_inner
    {
      $$ = context->makeList($1);
    }
| var_decl_stmt_inner_ls TCOMMA var_decl_stmt_inner
    {
      $$ = context->appendList($1, $3);
    }
;

var_decl_stmt_inner:
  ident_def opt_type opt_init_expr
    {
      auto varDecl = Variable::build(BUILDER, LOC(@$),
                                     context->buildAttributes(@$),
                                     context->visibility,
                                     context->linkage,
                                     context->consumeVarDeclLinkageName(),
                                     /*name*/ $1,
                                     context->varDeclKind,
                                     context->isVarDeclConfig,
                                     context->currentScopeIsAggregate(),
                                     toOwned($2), toOwned($3));
      // gather the comments like a statement does
      $$ = STMT(@1, varDecl.release());
      context->clearComments();
    }
| TLP tuple_var_decl_stmt_inner_ls TRP opt_type opt_init_expr
    {
      auto intentOrKind = (TupleDecl::IntentOrKind) context->varDeclKind;
      auto tupleDecl = TupleDecl::build(BUILDER, LOC(@$),
                                        context->buildAttributes(@$),
                                        context->visibility,
                                        context->linkage,
                                        intentOrKind,
                                        context->consumeList($2),
                                        toOwned($4),
                                        toOwned($5));
      $$ = STMT(@1, tupleDecl.release());
      context->clearComments();
    }
;

tuple_var_decl_component:
  TUNDERSCORE
  {
    $$ = context->buildTupleComponent(@$, $1);
  }
| ident_def
  {
    $$ = context->buildTupleComponent(@$, $1);
  }
| TLP tuple_var_decl_stmt_inner_ls TRP
  {
    $$ = context->buildTupleComponent(@$, $2);
  }
;

tuple_var_decl_stmt_inner_ls:
  tuple_var_decl_component
    { $$ = context->makeList($1); }
| tuple_var_decl_stmt_inner_ls TCOMMA
    { $$ = $1; }
| tuple_var_decl_stmt_inner_ls TCOMMA tuple_var_decl_component
    { $$ = context->appendList($1, $3); }
;

/** TYPES ********************************************************************/

opt_init_expr:
                        { $$ = nullptr; }
| TASSIGN TNOINIT       { $$ = context->buildIdent(@2, $2); }
| TASSIGN opt_try_expr  { $$ = $2; }
;

ret_array_type:
  TLSBR TRSBR type_level_expr
  {
    $$ = context->buildArrayType(@$, @1, /*domainExprs*/ nullptr, $3);
  }
| TLSBR TRSBR
  {
    $$ = context->buildArrayType(@$, @1, nullptr, nullptr);
  }
| TLSBR expr_ls TRSBR type_level_expr
  {
    $$ = context->buildArrayType(@$, @2, $2, $4);
  }
| TLSBR expr_ls TRSBR
  {
    $$ = context->buildArrayType(@$, @2, $2, /*typeExpr*/ nullptr);
  }
| TLSBR TRSBR ret_array_type
  {
    $$ = context->buildArrayType(@$, @1, /*domainExprs*/ nullptr, $3);
  }
| TLSBR expr_ls TRSBR ret_array_type
  {
    $$ = context->buildArrayType(@$, @2, $2, $4);
  }
| TLSBR error TRSBR
  {
    $$ = context->syntax(@$, "invalid expression for domain of array return type.");
  }
;

ret_type:
  type_level_expr         { $$ = $1; }
| ret_array_type          { $$ = $1; }
| reserved_type_ident_use { $$ = context->buildIdent(@1, $1); }
| error                   { $$ = ErroneousExpression::build(BUILDER, LOC(@1)).release(); }
;

colon_ret_type:
  TCOLON ret_type { $$ = $2; }
| error                          { $$ = ErroneousExpression::build(BUILDER, LOC(@1)).release(); }
;

opt_ret_type:
                    { $$ = nullptr; }
| colon_ret_type
;

opt_type:
                                 { $$ = nullptr; }
| TCOLON type_level_expr         { $$ = $2; }
| TCOLON array_type              { $$ = $2; }
| TCOLON reserved_type_ident_use { $$ = context->buildIdent(@2, $2); }
| error                          { $$ = ErroneousExpression::build(BUILDER, LOC(@1)).release(); }
;

/* NOTE: Some things about the following rule concern me (blc), but I
   don't have the time to fix them now, so am noting them for the
   future when someone runs into them:

   (1) there are 3 cases rather than the 4 I would expect based on symmetry
       ('in' vs. not x 'type_level_expr' vs. 'array_type')

   (2) it seems strange to me that the thing being iterated over is an
       'expr_ls' in the first two cases, but an 'expr' in the third

   (3) it also seems strange that the stuff preceding TIN would be an
       'expr_ls' rather than something simpler, like a nested
       parenthesization of identifiers; perhaps this is to support the
       establishment of an explicit type declaration, though I thought we
       didn't support that yet
*/
array_type:
  TLSBR expr_ls TRSBR type_level_expr
  {
    $$ = context->buildArrayType(@$, @2, $2, $4);
  }
| TLSBR expr_ls TRSBR array_type
  {
    $$ = context->buildArrayType(@$, @2, $2, $4);
  }
| TLSBR expr_ls TIN expr TRSBR type_level_expr
  {
    $$ = context->buildArrayTypeWithIndex(@$, @2, $2, $4, $6);
  }
| TLSBR error TRSBR
  {
    $$ = ErroneousExpression::build(BUILDER, LOC(@2)).release();
  }
;

opt_formal_array_elt_type:
                        { $$ = nullptr; }
| type_level_expr       { $$ = $1; }
| query_expr            { $$ = $1; }
;

formal_array_type:
  TLSBR TRSBR opt_formal_array_elt_type
  {
    auto domainLoc = context->makeSpannedLocation(@1, @2);
    $$ = context->buildArrayType(@$, domainLoc, /*domainExprs*/ nullptr, $3);
  }
| TLSBR expr_ls TRSBR opt_formal_array_elt_type
  {
    $$ = context->buildArrayType(@$, @2, $2, $4);
  }

// Johnk: Unclear to me what the type should be when [<range>][] <type> is encountered.
//        At present buildArrayRuntimeType is undefined when gNil is passed and
//        the second argument is a formal_array_type.
| TLSBR TRSBR formal_array_type
  {
    auto domainLoc = context->makeSpannedLocation(@1, @2);
    $$ = context->buildArrayType(@$, domainLoc, /*domainExprs*/ nullptr, $3);
  }
| TLSBR expr_ls TRSBR formal_array_type
  {
    $$ = context->buildArrayType(@$, @2, $2, $4);
  }
| TLSBR expr_ls TIN expr TRSBR opt_formal_array_elt_type
  {
    $$ = context->buildArrayTypeWithIndex(@$, @2, $2, $4, $6);
  }
;

formal_type:
  type_level_expr
| query_expr
| reserved_type_ident_use   { $$ = context->buildIdent(@1, $1); }
| formal_array_type
;

colon_formal_type:
  TCOLON formal_type             { $$ = $2; }
;

opt_colon_formal_type:
                        { $$ = nullptr; }
| colon_formal_type     { $$ = $1; }
;

/** EXPRESSIONS **************************************************************/

expr_ls:
  expr                       { $$ = context->makeList($1); }
| query_expr                 { $$ = context->makeList($1); }
| expr_ls TCOMMA expr        { $$ = context->appendList($1, $3); }
| expr_ls TCOMMA query_expr  { $$ = context->appendList($1, $3); }
;

simple_expr_ls:
  expr                             { $$ = context->makeList($1); }
| simple_expr_ls TCOMMA expr       { $$ = context->appendList($1, $3); }
;

tuple_component:
  TUNDERSCORE   { $$ = context->buildIdent(@1, $1); }
| opt_try_expr  { $$ = $1; }
| query_expr    { $$ = $1; }
;

tuple_expr_ls:
  tuple_component TCOMMA tuple_component
  {
    $$ = context->appendList(context->makeList($1), $3);
  }
| tuple_expr_ls TCOMMA tuple_component
  {
    $$ = context->appendList($1, $3);
  }
;

opt_actual_ls:
             { $$ = new MaybeNamedActualList(); }
| actual_ls  { $$ = $1; }
;

actual_ls:
  actual_expr
    { MaybeNamedActualList* lst = new MaybeNamedActualList();
      lst->push_back($1);
      $$ = lst;
    }
| actual_ls TCOMMA actual_expr
    {
      MaybeNamedActualList* lst = $1;
      lst->push_back($3);
      $$ = lst;
    }
;

actual_expr:
  ident_use TASSIGN query_expr   { $$ = makeMaybeNamedActual($3, $1); }
| ident_use TASSIGN opt_try_expr { $$ = makeMaybeNamedActual($3, $1); }
| query_expr                     { $$ = makeMaybeNamedActual($1); }
| opt_try_expr                   { $$ = makeMaybeNamedActual($1); }
;

ident_expr:
  ident_use      { $$ = context->buildIdent(@1, $1); }
| scalar_type    { $$ = $1; }
;

/* Expressions which represent types.  type_level_exprs can appear within formal
 * function parameter specifications as well as part of variable declarations.

   NOTE: Array type expressions do not appear in this production as array type
   specifications are different for formal array parameters and variable arrays.
   As such, array type expressions are individually defined for formal array
   parameters and variables. */
type_level_expr:
  sub_type_level_expr %prec TNOELSE
  { $$ = $1; }
| sub_type_level_expr TQUESTION %prec TQUESTION
  { $$ = context->buildUnaryOp(@$, $2, $1); }
| TQUESTION
  { $$ = context->buildIdent(@$, $1); }
| fn_type
  { $$ = context->buildFunctionType(@$, $1); }
;

// TODO: It would be nice if '?' could be an `expr`, but then 'borrowed?'
// would not work.
sub_type_level_expr:
  nil_expr
| lhs_expr                  // var b: a.type || (?,?) || foo()
| cond_expr                 // type b = if b then uint else int
| unary_op_expr             // We allow binary exprs as types...why not unary?
| binary_op_expr            // tuples, expr dmapped expr, overloaded binary ops
| TSINGLE expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }
| TINDEX TLP opt_actual_ls TRP
  { $$ = context->buildTypeConstructor(@$, $1, $3); }
| TDOMAIN TLP opt_actual_ls TRP
  { $$ = context->buildTypeConstructor(@$, $1, $3); }
| TSUBDOMAIN TLP opt_actual_ls TRP
  { $$ = context->buildTypeConstructor(@$, $1, $3); }
| TSPARSE TSUBDOMAIN TLP actual_expr TRP
  {
    auto locInner = context->makeSpannedLocation(@2, @5);
    auto inner = context->buildTypeConstructor(locInner, $2, $4);
    $$ = context->buildTypeConstructor(@$, $1, inner);
  }
| TATOMIC expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }
| TSYNC expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }

| TOWNED
  { $$ = Identifier::build(BUILDER, LOC(@1), $1).release(); }
| TOWNED expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }
| TUNMANAGED
  { $$ = Identifier::build(BUILDER, LOC(@1), $1).release(); }
| TUNMANAGED expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }
| TSHARED
  { $$ = Identifier::build(BUILDER, LOC(@1), $1).release(); }
| TSHARED expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }
| TBORROWED
  { $$ = Identifier::build(BUILDER, LOC(@1), $1).release(); }
| TBORROWED expr
  { $$ = context->buildTypeConstructor(@$, $1, $2); }
| TCLASS
  { $$ = Identifier::build(BUILDER, LOC(@1), $1).release(); }
| TRECORD
  { $$ = Identifier::build(BUILDER, LOC(@1), $1).release(); }
;

for_expr:
  TFOR expr TIN expr TDO expr %prec TFOR
  {
    auto index = context->buildLoopIndexDecl(@2, toOwned($2));
    $$ = For::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                    BlockStyle::IMPLICIT,
                    context->consumeToBlock(@6, $6),
                    /*isExpressionLevel*/ true,
                    /*isParam*/ false).release();
  }
| TFOR expr TIN zippered_iterator TDO expr %prec TFOR
  {
    auto index = context->buildLoopIndexDecl(@2, toOwned($2));
    $$ = For::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                    BlockStyle::IMPLICIT,
                    context->consumeToBlock(@6, $6),
                    /*isExpressionLevel*/ true,
                    /*isParam*/ false).release();
  }
| TFOR expr TDO expr %prec TFOR
  {
    $$ = For::build(BUILDER, LOC(@$), /*index*/ nullptr, toOwned($2),
                    BlockStyle::IMPLICIT,
                    context->consumeToBlock(@4, $4),
                    /*isExpressionLevel*/ true,
                    /*isParam*/ false).release();
  }
| TFOR expr TIN expr TDO TIF expr TTHEN expr %prec TNOELSE
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    auto ifExpr = Conditional::build(BUILDER, LOC2(@6, @9), toOwned($7),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@9, $9),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@6, @9);
    $$ = For::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                    BlockStyle::IMPLICIT,
                    context->consumeToBlock(ifLoc, ifExpr.release()),
                    /*isExpressionLevel*/ true,
                    /*isParam*/ false).release();
  }
| TFOR expr TIN zippered_iterator TDO TIF expr TTHEN expr %prec TNOELSE
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    auto ifExpr = Conditional::build(BUILDER, LOC2(@6, @9), toOwned($7),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@9, $9),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@6, @9);
    $$ = For::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                    BlockStyle::IMPLICIT,
                    context->consumeToBlock(ifLoc, ifExpr.release()),
                    /*isExpressionLevel*/ true,
                    /*isParam*/ false).release();
  }
| TFOR expr TDO TIF expr TTHEN expr %prec TNOELSE
  {
    auto ifExpr = Conditional::build(BUILDER, LOC2(@4, @7), toOwned($5),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@7, $7),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@4, @7);
    $$ = For::build(BUILDER, LOC(@$), /*index*/ nullptr,
                    toOwned($2),
                    BlockStyle::IMPLICIT,
                    context->consumeToBlock(ifLoc, ifExpr.release()),
                    /*isExpressionLevel*/ true,
                    /*isParam*/ false).release();
  }
| TFORALL expr TIN expr TDO expr %prec TFOR
  {
    auto index = context->buildLoopIndexDecl(@2, toOwned($2));
    $$ = Forall::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                       /*withClause*/ nullptr,
                       BlockStyle::IMPLICIT,
                       context->consumeToBlock(@6, $6),
                       /*isExpressionLevel*/ true).release();
  }
| TFORALL expr TIN zippered_iterator TDO expr %prec TFOR
  {
    auto index = context->buildLoopIndexDecl(@2, toOwned($2));
    $$ = Forall::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                       /*withClause*/ nullptr,
                       BlockStyle::IMPLICIT,
                       context->consumeToBlock(@6, $6),
                       /*isExpressionLevel*/ true).release();
  }
| TFORALL expr TDO expr %prec TFOR
  {
    $$ = Forall::build(BUILDER, LOC(@$), /*index*/ nullptr, toOwned($2),
                       /*withClause*/ nullptr,
                       BlockStyle::IMPLICIT,
                       context->consumeToBlock(@4, $4),
                       /*isExpressionLevel*/ true).release();
  }
| TFORALL expr TIN expr TDO TIF expr TTHEN expr %prec TNOELSE
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    auto ifExpr = Conditional::build(BUILDER, LOC2(@6, @9), toOwned($7),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@9, $9),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@6, @9);
    $$ = Forall::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                       /*withClause*/ nullptr,
                       BlockStyle::IMPLICIT,
                       context->consumeToBlock(ifLoc, ifExpr.release()),
                       /*isExpressionLevel*/ true).release();
  }
| TFORALL expr TIN zippered_iterator TDO TIF expr TTHEN expr %prec TNOELSE
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    auto ifExpr = Conditional::build(BUILDER, LOC2(@6, @9), toOwned($7),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@9, $9),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@6, @9);
    $$= Forall::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                      /*withClause*/ nullptr,
                      BlockStyle::IMPLICIT,
                      context->consumeToBlock(ifLoc, ifExpr.release()),
                      /*isExpressionLevel*/ true).release();
  }
| TFORALL expr TDO TIF expr TTHEN expr %prec TNOELSE
  {
    auto ifExpr = Conditional::build(BUILDER, LOC2(@4, @7), toOwned($5),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@7, $7),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@4, @7);
    $$ = Forall::build(BUILDER, LOC(@$), /*index*/ nullptr,
                       toOwned($2),
                       /*withClause*/ nullptr,
                       BlockStyle::IMPLICIT,
                       context->consumeToBlock(ifLoc, ifExpr.release()),
                       /*isExpressionLevel*/ true).release();
  }
| TLSBR expr_ls TRSBR expr %prec TFOR
  {
    owned<AstNode> iterand = nullptr;
    auto iterExprs = context->consumeList($2);
    if (iterExprs.size() > 1) {
      iterand = Domain::build(BUILDER, LOC(@2), false, std::move(iterExprs));
    } else {
      iterand = std::move(iterExprs[0]);
    }
    CHPL_ASSERT(iterand != nullptr);
    $$ = BracketLoop::build(BUILDER, LOC(@$), /*index*/ nullptr,
                            std::move(iterand),
                            /*withClause*/ nullptr,
                            BlockStyle::IMPLICIT,
                            context->consumeToBlock(@4, $4),
                            /*isExpressionLevel*/ true).release();
  }
| TLSBR expr_ls TIN expr TRSBR expr %prec TFOR
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    $$ = BracketLoop::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                            /*withClause*/ nullptr,
                            BlockStyle::IMPLICIT,
                            context->consumeToBlock(@6, $6),
                            /*isExpressionLevel*/ true).release();
  }
| TLSBR expr_ls TIN zippered_iterator TRSBR expr %prec TFOR
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    $$ = BracketLoop::build(BUILDER, LOC(@$), std::move(index), toOwned($4),
                            /*withClause*/ nullptr,
                            BlockStyle::IMPLICIT,
                            context->consumeToBlock(@6, $6),
                            /*isExpressionLevel*/ true).release();
  }
| TLSBR expr_ls TIN expr TRSBR TIF expr TTHEN expr %prec TNOELSE
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    auto ifExpr = Conditional::build(BUILDER, LOC2(@6, @9), toOwned($7),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@9, $9),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@6, @9);
    $$ = BracketLoop::build(BUILDER, LOC(@$), std::move(index),
                            toOwned($4),
                            /*withClause*/ nullptr,
                            BlockStyle::IMPLICIT,
                            context->consumeToBlock(ifLoc, ifExpr.release()),
                            /*isExpressionLevel*/ true).release();
  }
| TLSBR expr_ls TIN zippered_iterator TRSBR TIF expr TTHEN expr %prec TNOELSE
  {
    auto index = context->buildLoopIndexDecl(@2, $2);
    auto ifExpr = Conditional::build(BUILDER, LOC2(@6, @9), toOwned($7),
                                     BlockStyle::IMPLICIT,
                                     context->consumeToBlock(@9, $9),
                                     /*isExpressionLevel*/ true);
    auto ifLoc = context->makeSpannedLocation(@6, @9);
    $$ = BracketLoop::build(BUILDER, LOC(@$), std::move(index),
                            toOwned($4),
                            /*withClause*/ nullptr,
                            BlockStyle::IMPLICIT,
                            context->consumeToBlock(ifLoc, ifExpr.release()),
                            /*isExpressionLevel*/ true).release();
  }
;

cond_expr:
  TIF expr TTHEN expr TELSE expr
  {
    auto node  = Conditional::build(BUILDER, LOC(@$), toOwned($2),
                                    BlockStyle::IMPLICIT,
                                    context->consumeToBlock(@4, $4),
                                    BlockStyle::IMPLICIT,
                                    context->consumeToBlock(@6, $6),
                                    /*isExpressionLevel*/ true);
    $$ = node.release();
  }
/* MPF: it would be nice to match TIF expr TTHEN expr but
   the attempt below leads to reduce-reduce conflicts:
      TIF expr TTHEN expr %prec TNOELSE
   with for_expr.
 */
;

nil_expr:
  TNIL      { $$ = context->buildIdent(@1, $1); }
;

/* Expressions permitted at the statement level as <stmt_level_expr> TSEMI.
   Keeping stmt_level_expr from appearing in any other expression productions
   was done intentionally to allow for easier promotion/demotion of expressions
   to the statement level. */
stmt_level_expr:
  nil_expr
| ident_expr
| dot_expr
| call_expr
| lambda_decl_expr
| new_expr
| let_expr
;

opt_task_intent_ls:
                                { $$ = nullptr; }
| task_intent_clause            { $$ = $1; }
;

task_intent_clause:
  TWITH TLP task_intent_ls TRP
  {
    auto exprs = context->consumeList($3);
    auto node = WithClause::build(BUILDER, LOC(@$), std::move(exprs));
    $$ = node.release();
  }
;

task_intent_ls:
  intent_expr                         { $$ = context->makeList($1); }
| task_intent_ls TCOMMA intent_expr   { $$ = context->appendList($1, $3); }
;

forall_intent_clause:
  TWITH TLP forall_intent_ls TRP
  {
    auto exprs = context->consumeList($3);
    auto node = WithClause::build(BUILDER, LOC(@$), std::move(exprs));
    $$ = node.release();
  }
;

forall_intent_ls:
  intent_expr                          { $$ = context->makeList($1); }
| forall_intent_ls TCOMMA intent_expr  { $$ = context->appendList($1, $3); }
;

intent_expr:
  task_var_prefix ident_expr opt_type opt_init_expr
  {
    if (auto ident = $2->toIdentifier()) {
      auto name = ident->name();
      auto node = TaskVar::build(BUILDER, LOC(@$), /*attributes*/ nullptr,
                                 name,
                                 /*intent*/ $1,
                                 toOwned($3),
                                 toOwned($4));
      $$ = node.release();
    } else {
      $$ = context->syntax(@$, "expected identifier for task variable name.");
    }
  }
| reduce_scan_op_expr TREDUCE ident_expr
  {
    $$ = context->buildReduceIntent(@$, @1, $1, $3);
  }
| expr                TREDUCE ident_expr
  {
    $$ = context->buildReduceIntent(@$, @1, $1, $3);
  }
;

task_var_prefix:
  TCONST       { $$ = TaskVar::CONST;     }
| TIN          { $$ = TaskVar::IN;        }
| TCONST TIN   { $$ = TaskVar::CONST_IN;  }
| TREF         { $$ = TaskVar::REF;       }
| TCONST TREF  { $$ = TaskVar::CONST_REF; }
| TVAR         { $$ = TaskVar::VAR;       }
;

new_maybe_decorated:
  TNEW         %prec TNOELSE
    { $$ = New::DEFAULT_MANAGEMENT; }
| TNEW TOWNED
    { $$ = New::OWNED; }
| TNEW TSHARED
    { $$ = New::SHARED; }
| TNEW TUNMANAGED
    { $$ = New::UNMANAGED; }
| TNEW TBORROWED
    { $$ = New::BORROWED; }
;

new_expr:
  /* Handles the typical new cases, e.g. new C(); new owned C() */
  new_maybe_decorated expr %prec TNEW
  {
    $$ = context->buildNewExpr(@$, $1, $2);
  }
  /* TODO: handles e.g. new (typefn())(initargs) */
  /* TODO TODO: Flag these with asserts in the old compiler parser and
                see if we can remove them. */
| TNEW TOWNED TLP expr TRP TLP opt_actual_ls TRP %prec TNOELSE
  {
    AstList actuals;
    std::vector<UniqueString> actualNames;
    context->consumeNamedActuals($7, actuals, actualNames);
    auto call = FnCall::build(BUILDER, LOC(@$),
                              toOwned($4),
                              std::move(actuals),
                              std::move(actualNames),
                              /* square */ false);
    $$ = context->buildNewExpr(@$, New::OWNED, call.release());
  }
| TNEW TSHARED TLP expr TRP TLP opt_actual_ls TRP %prec TNOELSE
  {
    AstList actuals;
    std::vector<UniqueString> actualNames;
    context->consumeNamedActuals($7, actuals, actualNames);
    auto call = FnCall::build(BUILDER, LOC(@$),
                              toOwned($4),
                              std::move(actuals),
                              std::move(actualNames),
                              /* square */ false);
    $$ = context->buildNewExpr(@$, New::SHARED, call.release());
  }
| TNEW TOWNED TLP expr TRP TLP opt_actual_ls TRP TQUESTION
  {
    AstList actuals;
    std::vector<UniqueString> actualNames;
    context->consumeNamedActuals($7, actuals, actualNames);
    auto base = context->buildUnaryOp(@4, $9, $4);
    auto call = FnCall::build(BUILDER, LOC(@$),
                              toOwned(base),
                              std::move(actuals),
                              std::move(actualNames),
                              /* square */ false);
    $$ = context->buildNewExpr(@$, New::OWNED, call.release());
  }
| TNEW TSHARED TLP expr TRP TLP opt_actual_ls TRP TQUESTION
  {
    AstList actuals;
    std::vector<UniqueString> actualNames;
    context->consumeNamedActuals($7, actuals, actualNames);
    auto base = context->buildUnaryOp(@4, $9, $4);
    auto call = FnCall::build(BUILDER, LOC(@$),
                              toOwned(base),
                              std::move(actuals),
                              std::move(actualNames),
                              /* square */ false);
    $$ = context->buildNewExpr(@$, New::SHARED, call.release());

  }
;

let_expr:
  TLET var_decl_stmt_inner_ls TIN expr
  {
    $$ = context->buildLetExpr(@$, $2, $4);
  }
;

range_literal_expr:
  expr TDOTDOT expr
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::DEFAULT, toOwned($1),
                      toOwned($3)).release();
  }
| expr TDOTDOTOPENHIGH expr
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::OPEN_HIGH, toOwned($1),
                      toOwned($3)).release();
  }
| expr TDOTDOT
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::DEFAULT, toOwned($1),
                      /*upperBound*/ nullptr).release();
  }
| TDOTDOT expr
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::DEFAULT,
                      /*lowerBound*/ nullptr,
                      toOwned($2)).release();
  }
| TDOTDOTOPENHIGH expr
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::OPEN_HIGH,
                      /*lowerBound*/ nullptr,
                      toOwned($2)).release();
  }
| TDOTDOT
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::DEFAULT,
                      /*lowerBound*/ nullptr,
                      /*upperBound*/ nullptr).release();
  }
/* The following cases would extend the current '..<' open range
   interval constructor to also support '<..' and '<..<'.  This
   concept didn't win enough support to merge as present, but are here
   in case we change our minds in a future release.

| expr TDOTDOTOPENLOW expr
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::OPEN_LOWER, toOwned($1),
                      toOwned($3)).release();
  }
| expr TDOTDOTOPENBOTH expr
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::OPEN_BOTH, toOwned($1),
                      toOwned($3)).release();
  }
| expr TDOTDOTOPENLOW
  {
    $$ = Range::build(BUILDER, LOC(@$), Range::OPEN_LOWER, toOwned($1),
                      nullptr).release();
  }
*/
;

cast_expr:
  expr TCOLON expr
  {
    $$ = context->buildBinOp(@$, $1, $2, $3);
  }
;

tuple_expand_expr:
  TLP TDOTDOTDOT expr TRP
  {
    $$ = context->buildUnaryOp(@$, $2, $3);
  }
;

super_expr:
  fn_expr { $$ = context->buildFunctionExpr(@$, $1); }
| expr
;

expr:
  literal_expr
| for_expr
| type_level_expr
| reduce_expr
| scan_expr
| lambda_decl_expr
| new_expr
| let_expr
| ifc_constraint
| tuple_expand_expr
| cast_expr
| range_literal_expr
;

opt_expr:
                  { $$ = nullptr; }
| expr            { $$ = $1; }
;

opt_try_expr:
  TTRY expr       { $$ = context->buildTryExpr(@$, $2, false); }
| TTRYBANG expr   { $$ = context->buildTryExpr(@$, $2, true); }
| super_expr      { $$ = $1; }
;

lhs_expr:
  ident_expr
| call_expr
| dot_expr
| parenthesized_expr
;

/* Representations of values which can be invoked as functions.
 *
 * NOTE:  In order to allow expr to be invoked as a function
 *        opt_actual_ls, and every production it relies on, would need to be
 *        reworked to not permit the empty production. */
call_base_expr:
  lhs_expr
| expr TBANG                    { $$ = context->buildUnaryOp(@$,
                                                             STR("postfix!"),
                                                             $1); }
| sub_type_level_expr TQUESTION { $$ = context->buildUnaryOp(@$, $2, $1); }
| lambda_decl_expr
| str_bytes_literal
;

call_expr:
  call_base_expr TLP opt_actual_ls TRP
    {
      AstList actuals;
      std::vector<UniqueString> actualNames;
      context->consumeNamedActuals($3, actuals, actualNames);
      auto fnCall = FnCall::build(BUILDER, LOC(@$),
                                  toOwned($1),
                                  std::move(actuals),
                                  std::move(actualNames),
                                  /* square */ false);
      $$ = fnCall.release();
    }
| call_base_expr TLSBR opt_actual_ls TRSBR
    {
      AstList actuals;
      std::vector<UniqueString> actualNames;
      context->consumeNamedActuals($3, actuals, actualNames);
      auto fnCall = FnCall::build(BUILDER, LOC(@$),
                                  toOwned($1),
                                  std::move(actuals),
                                  std::move(actualNames),
                                  /* square */ true);
      $$ = fnCall.release();
    }
| TPRIMITIVE TLP opt_actual_ls TRP
    {
      $$ = context->buildPrimCall(@$, $3);
    }
;

dot_expr:
  expr TDOT ident_use
    { $$ = Dot::build(BUILDER, LOC(@$), toOwned($1), $3).release(); }
| expr TDOT TTYPE
    { $$ = Dot::build(BUILDER, LOC(@$), toOwned($1), $3).release(); }
| expr TDOT TDOMAIN
    { $$ = Dot::build(BUILDER, LOC(@$), toOwned($1), $3).release(); }
| expr TDOT TLOCALE
    { $$ = Dot::build(BUILDER, LOC(@$), toOwned($1), $3).release(); }
| expr TDOT TBYTES TLP TRP
    {
      $$ = FnCall::build(BUILDER, LOC(@$),
                         Dot::build(BUILDER, LOC(@$), toOwned($1), $3),
                         false).release();
    }
| expr TDOT TBYTES TLSBR TRSBR
    {
      $$ = FnCall::build(BUILDER, LOC(@$),
                         Dot::build(BUILDER, LOC(@$), toOwned($1), $3),
                         true).release();
    }
;

/* ( <expr> ) -- A parenthesized expression.  The parens are stripped.
 * ( <expr> , ) -- A one-tuple.  (Trailing comma is disallowed for longer tuples.)
 * ( <tuple_expr_ls> ) -- Two-tuples and up.  A tuple_expr_ls contains at least 2 elements.
 */
parenthesized_expr:
  TLP tuple_component TRP           { $$ = $2; }
| TLP tuple_component TCOMMA TRP
  {
    $$ = Tuple::build(BUILDER, LOC(@$), context->consume($2)).release();
  }
| TLP tuple_expr_ls TRP
  {
    $$ = Tuple::build(BUILDER, LOC(@$), context->consumeList($2)).release();
  }
| TLP tuple_expr_ls TCOMMA TRP
  {
    $$ = Tuple::build(BUILDER, LOC(@$), context->consumeList($2)).release();
  }
;

bool_literal:
  TFALSE { $$ = BoolLiteral::build(BUILDER, LOC(@$), false).release(); }
| TTRUE  { $$ = BoolLiteral::build(BUILDER, LOC(@$), true).release(); }
;

str_bytes_literal:
  STRINGLITERAL   { $$ = $1; }
| BYTESLITERAL    { $$ = $1; }
;

literal_expr:
  bool_literal
| str_bytes_literal
| INTLITERAL     { $$ = context->buildNumericLiteral(@$, $1, INTLITERAL); }
| REALLITERAL    { $$ = context->buildNumericLiteral(@$, $1, REALLITERAL); }
| IMAGLITERAL    { $$ = context->buildNumericLiteral(@$, $1, IMAGLITERAL); }
| CSTRINGLITERAL      { $$ = $1; }
| TNONE               { $$ = context->buildIdent(@$, $1); }
| TLCBR expr_ls TRCBR
  {
    $$ = Domain::build(BUILDER, LOC(@$), true,
                       context->consumeList($2)).release();
  }
| TLCBR expr_ls TCOMMA TRCBR
  {
    $$ = Domain::build(BUILDER, LOC(@$), true,
                       context->consumeList($2)).release();
  }
| TLSBR expr_ls TRSBR
  {
    $$ = Array::build(BUILDER, LOC(@$), context->consumeList($2)).release();
  }
| TLSBR expr_ls TCOMMA TRSBR
  {
    $$ = Array::build(BUILDER, LOC(@$), context->consumeList($2), true).release();
  }
| TLSBR assoc_expr_ls TRSBR
  {
    $$ = Array::build(BUILDER, LOC(@$), context->consumeList($2), false, true).release();
  }
| TLSBR assoc_expr_ls TCOMMA TRSBR
  {
    $$ = Array::build(BUILDER, LOC(@$), context->consumeList($2), true, true).release();
  }

;

assoc_expr_ls:
  expr TALIAS expr
  {
    auto node = context->buildBinOp(@$, $1, $2, $3);
    $$ = context->makeList(node);
  }
| assoc_expr_ls TCOMMA expr TALIAS expr
  {
    auto loc = context->makeSpannedLocation(@3, @5);
    auto node = context->buildBinOp(loc, $3, $4, $5);
    $$ = context->appendList($1, node);
  }
;

binary_op_expr:
  expr TPLUS expr          { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TMINUS expr         { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TSTAR expr          { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TDIVIDE expr        { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TSHIFTLEFT expr     { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TSHIFTRIGHT expr    { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TMOD expr           { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TEQUAL expr         { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TNOTEQUAL expr      { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TLESSEQUAL expr     { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TGREATEREQUAL expr  { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TLESS expr          { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TGREATER expr       { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TBAND expr          { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TBOR expr           { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TBXOR expr          { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TAND expr           { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TOR  expr           { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TEXP expr           { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TBY expr            { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TALIGN expr         { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr THASH expr          { $$ = context->buildBinOp(@$, $1, $2, $3); }
| expr TDMAPPED expr       { $$ = context->buildBinOp(@$, $1, $2, $3); }
;

unary_op_expr:
  TPLUS expr %prec TUPLUS        { $$ = context->buildUnaryOp(@$, $1, $2); }
| TMINUS expr %prec TUMINUS      { $$ = context->buildUnaryOp(@$, $1, $2); }
| TMINUSMINUS expr %prec TUMINUS { $$ = context->buildUnaryOp(@$, $1, $2); }
| TPLUSPLUS expr %prec TUPLUS    { $$ = context->buildUnaryOp(@$, $1, $2); }
| TBANG expr %prec TLNOT         { $$ = context->buildUnaryOp(@$, $1, $2); }
| expr TBANG                     { $$ = context->buildUnaryOp(@$,
                                                              STR("postfix!"),
                                                              $1); }
| TBNOT expr                     { $$ = context->buildUnaryOp(@$, $1, $2); }
;

reduce_expr:
  expr TREDUCE expr
  {
    $$ = context->buildReduce(@$, @1, $1, $3);
  }
| expr TREDUCE zippered_iterator
  {
    $$ = context->buildReduce(@$, @1, $1, $3);
  }
| reduce_scan_op_expr TREDUCE expr
  {
    $$ = context->buildReduce(@$, @1, $1, $3);
  }
| reduce_scan_op_expr TREDUCE zippered_iterator
  {
    $$ = context->buildReduce(@$, @1, $1, $3);
  }
;

scan_expr:
  expr TSCAN expr
  {
    $$ = context->buildScan(@$, @1, $1, $3);
  }
| expr TSCAN zippered_iterator
  {
    $$ = context->buildScan(@$, @1, $1, $3);
  }
| reduce_scan_op_expr TSCAN expr
  {
    $$ = context->buildScan(@$, @1, $1, $3);
  }
| reduce_scan_op_expr TSCAN zippered_iterator
  {
    $$ = context->buildScan(@$, @1, $1, $3);
  }
;


reduce_scan_op_expr:
  TPLUS
| TSTAR
| TAND
| TOR
| TBAND
| TBOR
| TBXOR
;
