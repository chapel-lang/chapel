\sekshun{Ranges}
\label{Ranges}
\index{ranges}

A \emph{range} is a first-class, constant-space representation of a
regular sequence of integer indices.
Ranges support iteration over the sequences they represent
and are the basis for defining domains (\rsec{Domains}).

Ranges are presented as follows:
\begin{itemize}
\item definition of the key range concepts \rsec{Range_Concepts}
\item range types \rsec{Range_Types}
\item range values \rsec{Range_Values}
\item range assignment \rsec{Range_Assignment}
\item operators on ranges \rsec{Range_Operators}
\item predefined functions on ranges \rsec{Predefined_Range_Functions}
\end{itemize}


\section{Range Concepts}
\label{Range_Concepts}
\index{ranges!concepts}

\index{ranges!represented sequence}
\index{ranges!sequence}
A range has four primary properties. Together they define the sequence
of indices that the range represents, or the \emph{represented sequence},
as follows.

\begin{itemize}

\index{ranges!low bound}
\item The \emph{low bound} is either an integer or -$\infty$.

\index{ranges!high bound}
\item The \emph{high bound} is either an integer or +$\infty$.
  The low and high bounds determine the span of the represented sequence.
%
  Chapel does not represent $\infty$ explicitly. Instead, infinite
  bound(s) are represented implicitly in the range's type
  (\rsec{Range_Types}).
  When the low and/or high bound is $\infty$, the represented sequence
  is unbounded in the corresponding direction(s).

\index{ranges!stride}
\item The \emph{stride} is a non-zero integer.
  It defines the distance between any two adjacent members of the
  represented sequence.
  The sign of the stride indicates the direction of the sequence:
  \begin{itemize}
  \item[$\bullet$] $stride > 0$ indicates an increasing sequence,
  \item[$\bullet$] $stride < 0$ indicates a decreasing sequence.
  \end{itemize}

\index{ranges!alignment}
\index{ranges!alignment!ambiguous}
\item The \emph{alignment} is either an integer or is \emph{ambiguous}.
  It defines how the represented sequence's members are aligned relative to 0.
%REVIEW: vass: please put a better definition of "alignment" above
% if you can make one.
% (BTW see also the definition of "aligned integer" below.)
  For a range with a stride other than 1 or -1, 
  ambiguous alignment means that the represented sequence is undefined.
  In such a case, certain operations discussed later result in an error.

\begin{openissue}
We consider disallowing ambiguous alignment for ranges whose both bounds
are integers (not $\infty$), in order to enable more efficient
implementation.
\end{openissue}

\end{itemize}

More formally, the represented sequence for the range
$(low, high, stride, alignmt)$
contains all indices $ix$ such that:

\begin{tabular}{ll}

$low \leq ix \leq high$ and $ix \equiv alignmt \pmod{|stride|}$ &
 if $alignmt$ is not ambiguous \\
$low \leq ix \leq high$ &
 if $stride = 1$ or $stride = -1$ \\
the represented sequence is undefined &
 otherwise

\end{tabular}

\index{ranges!represented sequence!increasing}
\index{ranges!represented sequence!decreasing}
The sequence, if defined, is increasing if $stride > 0$ and decreasing if $stride < 0$.

\index{ranges!empty}
If the represented sequence is defined but
there are no indices satisfying the applicable equation(s) above,
the range and its represented sequence are \emph{empty}.

\index{ranges!aligned integer}
We will say that an integer $ix$ is \emph{aligned}
w.r.t. the range $(low, high, stride, alignmt)$
if:
\begin{itemize}
\item $alignmt$ is not ambiguous and $ix \equiv alignmt \pmod{|stride|}$, or
\item $stride$ is 1 or -1.
\end{itemize}
\noindent Furthermore, $\infty$ is never aligned.

Ranges have the following additional properties.
\begin{itemize}

\index{ranges!alignment!ambiguous}
\item A range is \emph{ambiguously aligned} if
  \begin{itemize}
  \item its alignment is ambiguous, and
  \item its stride is neither 1 nor -1.
  \end{itemize}

\index{ranges!first index}
\item The \emph{first index} is the first member of the represented sequence.

  A range \emph{has no} first index when the first member is undefined,
  that is, in the following cases:
  \begin{itemize}
  \item the range is ambiguously aligned,
  \item the represented sequence is empty,
  \item the represented sequence is increasing and the low bound is -$\infty$,
  \item the represented sequence is decreasing and the high bound is +$\infty$.
  \end{itemize}

\index{ranges!last index}
\item The \emph{last index} is the last member of the represented sequence.

  A range \emph{has no} last index when the last member is undefined,
  that is, in the following cases:
  \begin{itemize}
  \item it is ambiguously aligned,
  \item the represented sequence is empty,
  \item the represented sequence is increasing and the high bound is +$\infty$,
  \item the represented sequence is decreasing and the low bound is -$\infty$.
  \end{itemize}

\index{ranges!aligned low bound}
\item The \emph{aligned low bound} is the smallest integer that is
  greater than or equal to the low bound and is aligned w.r.t. the range,
  if such an integer exists.
% For now we are allowing an empty range to have an aligned low bound.

  The aligned low bound equals the smallest member of the represented
  sequence, when both exist.

\index{ranges!aligned high bound}
\item The \emph{aligned high bound} is the largest integer that is
  less than or equal to the high bound and is aligned w.r.t. the range,
  if such an integer exists.
% For now we are allowing an empty range to have an aligned high bound.

  The aligned high bound equals the largest member of the represented
  sequence, when both exist.

% Can re-introduce this if needed, but need to discuss the definition.
% The intention is that a range is "naturally aligned" IFF
% its alignment does not need to be printed out.
%
%A range is \emph{naturally aligned} if it has a positive stride and its
%alignment coincides with its low bound, or it has a negative stride and its
%alignment coincides with its high bound.
%Specifically, a range with \chpl{low}, \chpl{high}, \chpl{stride}
%and \chpl{alignment} values of $l$, $h$, $s$ and $a$ (respectively) is naturally aligned if:
%\begin{itemize}
%\item It is \chpl{bounded}, its stride is positive, and $a = l ({\rm modulo} s)$,
%\item It is \chpl{bounded}, its stride is negative, and $a = h ({\rm modulo} s)$,
%\item It is \chpl{boundedLow} and $a = l ({\rm modulo} s)$,
%\item It is \chpl{boundedHigh} and $a = h ({\rm modulo} s)$ or
%\item It is $boundedNone$ and $a = 0$.
%\end{itemize}
%\noindent The \chpl{isNaturallyAligned} predicate returns \chpl{true} when the operand
%range is naturally aligned.  When a range is formatted for output, the alignment
%is printed only if the range is not naturally aligned.
%\index{ranges!alignment!natural}

\index{ranges!iterable}
\item The range is \emph{iterable}, that is, it is legal to iterate over it,
  if is has the first index.

\end{itemize}

%REVIEW: any other properties to include in the above?


\section{Range Types}
\label{Range_Types}
\index{ranges!types}
\index{types!range}

The type of a range is characterized by three parameters:
\begin{itemize}

\index{ranges!idxType}
\index{ranges!stride type}
\item \chpl{idxType} is the type of the indices of the range's
  represented sequence. However, when the range's low and/or high
  bound is $\infty$, the represented sequence also contains indices
  that are not representable by \chpl{idxType}.

  \chpl{idxType} must be an integral type and is \chpl{int} by default.
%
  The range's low bound and high bound (when they are not $\infty$)
  and alignment are of the type \chpl{idxType}. The range's stride
  is of the signed integer type that has the same bit size as \chpl{idxType}.

\index{ranges!boundedType}
\item \chpl{boundedType} indicates which of the range's bounds are not $\infty$.
  \chpl{boundedType} is an enumeration constant of the type
  \chpl{BoundedRangeType}. It is discussed further below.

\index{ranges!stridable}
\item \chpl{stridable} is a boolean that determines whether the range's stride
  can take on values other than 1.
  \chpl{stridable} is \chpl{false} by default.
  A range is called \emph{stridable}
  if its type's \chpl{stridable} is \chpl{true}.

\end{itemize}

\chpl{boundedType} is one of the constants of the following type:

\begin{chapel}
enum BoundedRangeType { bounded, boundedLow, boundedHigh, boundedNone };
\end{chapel}

The value of \chpl{boundedType} determines which bounds of the range
are integers (making the range ``bounded'', as opposed to infinite,
in the corresponding direction(s))
as follows:

\begin{itemize}

\index{ranges!bounded}
\item \chpl{bounded}:
  both bounds are integers.

\index{ranges!boundedLow}
\item \chpl{boundedLow}:
  the low bound is an integer (the high bound is +$\infty$).

\index{ranges!boundedHigh}
\item \chpl{boundedHigh}:
  the high bound is an integer (the low bound is -$\infty$).

\index{ranges!boundedNone}
\item \chpl{boundedNone}:
  neither bound is an integer (both bounds are $\infty$).

\end{itemize}

\noindent \chpl{boundedType} is \chpl{BoundedRangeType.bounded} by default.

The parameters \chpl{idxType}, \chpl{boundedType} and \chpl{stridable}
affect all values of the corresponding range type.
For example, the range's low bound is -$\infty$ if and only if
the \chpl{boundedType} of that range's type is either \chpl{boundedHigh}
or \chpl{boundedNone}.

\begin{rationale}
Providing \chpl{boundedType} and \chpl{stridable} in a range's type
allows the compiler to identify the more common cases
where the range is \chpl{bounded} and/or its stride is 1.
The compiler can also detect user and library code that is
specialized to these cases.
As a result, the compiler has the opportunity to optimize these
cases and the specialized code more aggressively.
\end{rationale}

%REVIEW: vass: we need to come up with a common way to define
% generic types prior to the generics chapter.

% gotta specify syntax for 'range-type' because it's referenced in Types.tex
A range type has the following syntax:
\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}

That is, a range type is obtained as if by invoking the range type constructor
(\rsec{Type_Constructors}) that has the following header:

\begin{chapel}
  proc range(type idxType = int,
             param boundedType = BoundedRangeType.bounded,
             param stridable = false) type
\end{chapel}

As a special case, the keyword \chpl{range} without a parenthesized
argument list refers to the range type with the default values
of all its parameters, i.e.,
\chpl{range(int, BoundedRangeType.bounded, false)}.

\begin{chapelexample}{rangeVariable.chpl}
The following declaration declares a variable \chpl{r}
that can represent ranges of 32-bit integers,
with both high and low bounds specified,
and the ability to have a stride other than 1.
\begin{chapel}
var r: range(int(32), BoundedRangeType.bounded, stridable=true);
\end{chapel}
\begin{chapelpost}
writeln(r);
var i32: int(32) = 3;
r = i32..13 by 3 align 1;
writeln(r);
\end{chapelpost}
\begin{chapeloutput}
1..0
3..13 by 3 align 1
\end{chapeloutput}
\end{chapelexample}


\section{Range Values}
\label{Range_Values}
\index{ranges!values}

A range value consists of the range's four primary properties
(\rsec{Range_Concepts}):
low bound, high bound, stride and alignment.

\subsection{Range Literals}
\label{Range_Literals}
\index{ranges!literals} 

Range literals are specified with the following syntax.

\begin{syntax}
range-literal:
  expression .. expression
  expression ..
  .. expression
  ..
\end{syntax}

The expressions to the left and to the right of \chpl{..}, when given,
are called the low bound and the high bound expression, respectively.

The type of a range literal is a range with the following parameters:

\begin{itemize}

\item \chpl{idxType} is determined as follows:
  \begin{itemize}

  \item If both the low bound and the high bound expressions are given
        and have the same integral type, then \chpl{idxType} is that type.

%REVIEW: not precise. E.g. it does not allow one bound to be converted
% to another bound's type. Also, should be the most specific such type.
  \item If both the low bound and the high bound expressions are given
        and an implicit conversion is allowed from each expression's type
        to the same integral type, then \chpl{idxType} is that
        integral type.

%REVIEW: should be the most specific integral type.
  \item If only one bound expression is given and it has an integral type
        or an implicit conversion is allowed from that expression's type
        to an integral type, then \chpl{idxType} is that integral type.

  \item If neither bound expression is given, then \chpl{idxType} is
        \chpl{int}.

  \item Otherwise, the range literal is not legal.
  \end{itemize}

\item \chpl{boundedType} is a value of the type \chpl{BoundedRangeType}
that is determined as follows:
  \begin{itemize}

  \item \chpl{bounded}, if both the low bound and the high bound expressions
         are given,

  \item \chpl{boundedLow}, if only the high bound expression is given,

  \item \chpl{boundedHigh}, if only the low bound expression is given,

  \item \chpl{boundedNone}, if neither bound expression is given.
  \end{itemize}

\item \chpl{stridable} is \chpl{false}.

\end{itemize}

The value of a range literal is as follows:

\begin{itemize}

\item The low bound is given by the low bound expression,
if present, and is -$\infty$ otherwise.

\item The high bound is given by the upper bound expression,
if present, and is +$\infty$ otherwise.

\item The stride is 1.

\item The alignment is ambiguous.

\end{itemize}


\subsection{Default Values}
\label{Range_Default_Values}
\index{ranges!default values}

The default value for a range type depends on the type's
\chpl{boundedType} parameter as follows:

\begin{itemize}

\item \chpl{1..0} (an empty range) if \chpl{boundedType} is \chpl{bounded}

\item \chpl{1..} if \chpl{boundedType} is \chpl{boundedLow}

\item \chpl{..0} if \chpl{boundedType} is \chpl{boundedHigh}

\item \chpl{..} if \chpl{boundedType} is \chpl{boundedNone}

\end{itemize}

\begin{rationale}
We use 0 and 1 to represent an empty range because these values
are available for any \chpl{idxType}.

We have not found the natural choice of the default value for
\chpl{boundedLow} and \chpl{boundedHigh} ranges.
The values indicated above are distinguished by the following property.
Slicing the default value for a \chpl{boundedLow} range with
the default value for a \chpl{boundedHigh} range (or visa versa)
produces an empty range, matching the default value for a
\chpl{bounded} range
\end{rationale}


\section{Common Operations}
\label{Ranges_Common_Operations}
\index{ranges!operations}

All operations on a range return a new range rather than modifying the existing one.  This
supports a coding style in which all ranges are \emph{immutable} (i.e. declared
as \chpl{const}).  

\begin{rationale}

The intention is to provide ranges as immutable objects.

Immutable objects may be cached without
creating coherence concerns.  They are also inherently thread-safe.  In terms of
implementation, immutable objects are created in a consistent state and stay that way:
Outside of constructors, internal consistency checks can be dispensed with.

These are the same arguments as were used to justify making strings immutable in Java and C\#.

\end{rationale}

%REVIEW: vass: this should really be implicit conversion
% and apply uniformly, like e.g. numeric implicit conversions.
%If needed, define also explicit range conversions.
\subsection{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}

Assigning one range to another results in the target range
copying the low and high bounds, stride, and alignment
from the source range.

Range assignment is legal when:
\begin{itemize}
\item An implicit conversion is allowed from \chpl{idxType} of the source range
       to \chpl{idxType} of the destination range type,
\item the two range types have the same \chpl{boundedType}, and
\item either the destination range is stridable or the source range's
      stride is 1.
\end{itemize}

\subsection{Range Comparisons}
\label{Range_Comparisons}
\index{ranges!comparisons}

Ranges can be compared using equality and inequality.

\begin{protohead}
proc ==(r1: range(?), r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the two ranges have the same represented sequence
or the same four primary properties,
and \chpl{false} otherwise.
%REVIEW: present examples of equal ranges whose low/high bounds differ
% or one is ambiguously aligned (with low>high) and the other is not.
\end{protobody}

\subsection{Iterating over Ranges}
\label{Iterating_over_Ranges}
\index{ranges!iteration}

A range can be used as an iterator expression in a loop. This is legal
only if the range is iterable. In this case the loop iterates over the
members of the range's represented sequence, in the order defined by
the sequence. If the range is empty, no iterations are executed.

\begin{craychapel}
An attempt to iterate over a range causes an error if adding stride to
the range's last index overflows its index type, i.e. if the sum is
greater than the index type's maximum value, or smaller than its
minimum value.
\end{craychapel}

\subsubsection{Iterating over Unbounded Ranges in Zippered Iterations}
\label{Iterating_over_Unbounded_Ranges_in_Zippered_Iterations}
\index{ranges!iteration!zippered}

When a range with the first index but without the last index is used
in a zippered iteration (~\rsec{Zipper_Iteration}),
it generates as many indices as needed
to match the other iterator(s).

\begin{chapelexample}{zipWithUnbounded.chpl}
The code
\begin{chapel}
for i in zip(1..5, 3..) do
  write(i, "; ");
\end{chapel}
\begin{chapelpost}
writeln();
\end{chapelpost}
produces the output 
\begin{chapelprintoutput}{}
(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); 
\end{chapelprintoutput}
\end{chapelexample}

%REVIEW: perhaps define implicit/explicit conversions as well
% under "Common Operations"?


\section{Range Operators}
\label{Range_Operators}
\index{ranges!operators}

The following operators can be applied to range
expressions and are described in this section: stride (\chpl{by}),
alignment (\chpl{align}), count (\chpl{\#}) and slicing (\chpl{\(\)}
or \chpl{\[\]}).
Chapel also defines a set of functions that operate on ranges.
They are described in \rsec{Predefined_Range_Functions}.

\begin{syntax}
range-expression:
  expression
  strided-range-expression
  counted-range-expression
  aligned-range-expression
  sliced-range-expression
\end{syntax}

\subsection{By Operator}
\label{By_Operator_For_Ranges}
\index{ranges!strided}
\index{by (range)@\chpl{by} (range)}
\index{operators!by (range)@\chpl{by} (range)}
\index{ranges!by operator@\chpl{by} operator}

The \chpl{by} operator selects a subsequence of the range's represented sequence,
optionally reversing its direction.
The operator takes two arguments, a base range and an integral step.
It produces a new range whose represented sequence contains
each $|$step$|$-th element of the base range's represented sequence.
The operator reverses the direction of the represented sequence if step$<$0.
If the resulting sequence is increasing,
it starts at the base range's aligned low bound, if it exists.
If the resulting sequence is decreasing,
it starts at the base range's aligned high bound, if it exists.
%
Otherwise, the base range's alignment is used to determine
which members of the represented sequence to retain.
%
If the base range's represented sequence is undefined,
the resulting sequence is undefined, too.

The syntax of the \chpl{by} operator is:
\begin{syntax}
strided-range-expression:
  range-expression `by' step-expression

step-expression:
  expression
\end{syntax}

The type of the step must be a signed or unsigned integer of the same
bit size as the base range's \chpl{idxType}, or an implicit conversion must be allowed
to that type from the step's type.
It is an error for the step to be zero.

\begin{future}
We may consider allowing the step to be of any integer type,
for maximum flexibility.
\end{future}

The type of the result of the \chpl{by} operator is the type of the
base range, but with the \chpl{stridable} parameter set to \chpl{true}.

Formally, the result of the \chpl{by} operator is a range with the following
primary properties:

\begin{itemize}

\item The low and upper bounds are the same as those of the base range.

\item The stride is the product of the base range's stride
      and the step, cast to the base range's stride type before multiplying.

\item The alignment is:

  \begin{itemize}
 
  \item the aligned low bound of the base range, if such exists
        and the stride is positive;

  \item the aligned high bound of the base range, if such exists
        and the stride is negative;

  \item the same as that of the base range, otherwise.

  \end{itemize}

\end{itemize}

\begin{chapelexample}{rangeByOperator.chpl}
In the following declarations, range \chpl{r1} represents the odd integers
between 1 and 20. Range \chpl{r2} strides \chpl{r1} by two and represents
every other odd integer between 1 and 20: 1, 5, 9, 13 and 17.
\begin{chapel}
var r1 = 1..20 by 2;
var r2 = r1 by 2;
\end{chapel}
\begin{chapelpost}
writeln(r1);
writeln(r2);
\end{chapelpost}
\begin{chapeloutput}
1..20 by 2
1..20 by 4
\end{chapeloutput}
\end{chapelexample}

%REVIEW we were not happy with this rationale at 7/19/2011 spec review
\begin{rationale}
{\it Why isn't the high bound specified first if the stride is
negative?}  The reason for this choice is that the \chpl{by} operator
is binary, not ternary.  Given a range \chpl{R} initialized
to \chpl{1..3}, we want \chpl{R by -1} to contain the ordered sequence
$3,2,1$.  But then \chpl{R by -1} would be different from \chpl{3..1
by -1} even though it should be identical by substituting the value in
R into the expression.
\end{rationale}


\subsection{Align Operator}
\label{Align_Operator}
\index{ranges!align}
\index{align@\chpl{align}}
\index{operator!align@\chpl{align}}

The \chpl{align} operator can be applied to any range, and creates a new range
with the given alignment.  

The syntax for the \chpl{align} operator is:
\begin{syntax}
aligned-range-expression:
  range-expression `align' expression
\end{syntax}
\noindent The type of the resulting range expression is the same as that of the
range appearing as the left operand.  An implicit conversion from
the type of the right operand to the index type of the operand range
must be allowed.
The resulting range has the
same low and high bounds and stride as the source range. The
alignment equals the \chpl{align} operator's right operand
and therefore is not ambiguous. 

\begin{chapelexample}{alignedStride.chpl}
\begin{chapel}
var r1 = 0 .. 10 by 3 align 0;
for i in r1 do
  write(" ", i);			// Produces "0 3 6 9".
writeln();

var r2 = 0 .. 10 by 3 align 1;
for i in r2 do
  write(" ", i);			// Produces "1 4 7 10".
writeln();
\end{chapel}
\begin{chapeloutput}
 0 3 6 9
 1 4 7 10
\end{chapeloutput}
\end{chapelexample}

When the stride is negative, the same indices are printed in reverse:
\begin{chapelexample}{alignedNegStride.chpl}
\begin{chapel}
var r3 = 0 .. 10 by -3 align 0;
for i in r3 do
  write(" ", i);			// Produces "9 6 3 0".
writeln();

var r4 = 0 .. 10 by -3 align 1;
for i in r4 do
  write(" ", i);			// Produces "10 7 4 1".
writeln();
\end{chapel}
\begin{chapeloutput}
 9 6 3 0
 10 7 4 1
\end{chapeloutput}
\end{chapelexample}

To create a range aligned relative to its \chpl{first} index, use
the \chpl{offset} method (\rsec{Range_Offset_Method}).


\subsection{Count Operator}
\label{Count_Operator}
\index{ranges!count operator}
\index{ranges!#@\chpl{#}}
\index{operators!# (range)@\chpl{#} (range)}

The \chpl{#} operator takes a range and an integral count and creates a new
range containing the specified number of indices.  The low or high bound of the
left operand is preserved, and the other bound adjusted to provide the specified
number of indices.  If the count is positive, indices are taken from the start
of the range; if the count is negative, indices are taken from the end of the
range.  The count must be less than or equal to the \chpl{length} of the range.

\begin{syntax}
counted-range-expression:
  range-expression # expression
\end{syntax}

The type of the count expression must be a signed or unsigned integer
of the same bit size as the base range's \chpl{idxType}, or an
implicit conversion must be allowed to that type from the count's
type.

The type of the result of the \chpl{#} operator is the type of the
range argument.

Depending on the sign of the count and the stride, the high or low bound is
unchanged and the other bound is adjusted so that it is $c * stride - 1$ units
away.  Specifically:
\begin{itemize}
\item If the count times the stride is positive, the low bound is preserved
and the high bound is adjusted to be one less than the low bound plus that
product.
\item Iff the count times the stride is negative, the high bound is preserved
and the low bound is adjusted to be one greater than the high bound plus that
product.
\end{itemize}

\begin{rationale}
Following the principle of preserving as much information from the original
range as possible, we must still choose the other bound so that
exactly \emph{count} indices lie within the range.  Making the two bounds lie
$count * stride - 1$ apart will achieve this, regardless of the current
alignment of the range.

This choice also has the nice symmetry that the alignment can be adjusted
without knowing the bounds of the original range, and the same number of indices
will be produced:
\begin{chapel}
r # 4 align 0   // Contains four indices.
r # 4 align 1   // Contains four indices.
r # 4 align 2   // Contains four indices.
r # 4 align 3   // Contains four indices.
\end{chapel}
\end{rationale}

It is an error to apply the count operator with a positive count to a range that
has no first index.  It is also an error to apply the count operator
with a negative count to a range that has no last index.
It is an error to apply the count operator to a range that is ambiguously aligned.
%REVIEW: vass: does not have to be an error -
% just produce a range whose alignment is ambiguous.

\begin{chapelexample}{rangeCountOperator.chpl}
The following declarations result in equivalent ranges.
\begin{chapel}
var r1 = 1..10 by -2 # -3;
var r2 = ..6 by -2 # 3;
var r3 = -6..6 by -2 # 3;
var r4 = 1..#6 by -2;
\end{chapel}
\begin{chapelpost}
writeln(r1 == r2 \&\& r2 == r3 \&\& r3 == r4);
writeln((r1, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
true
(1..6 by -2, 1..6 by -2, 1..6 by -2, 1..6 by -2)
\end{chapeloutput}
Each of these ranges represents the ordered set of three indices: 6, 4, 2.
\end{chapelexample}

\subsection{Arithmetic Operators}
\label{Range_Arithmetic}
\index{ranges!arithmetic operators}
\index{operators!arithmetic!range}

The following arithmetic operators are defined on ranges and integral
types:

\begin{chapel}
proc +(r: range, s: integral): range
proc +(s: integral, r: range): range
proc -(r: range, s: integral): range
\end{chapel}

The \chpl{+} and \chpl{-} operators apply the scalar via the operator
to the range's low and high bounds, producing a shifted version of the
range.  If the operand range is unbounded above or below, the missing bounds
are ignored.
The index type of the resulting range is the type of the value
that would result from an addition between the scalar value and a value
with the range's index type.  The bounded and stridable parameters for
the result range are the same as for the input range.

The stride of the resulting range is the same as the stride of the
original. The alignment of the resulting range is shifted by the same amount as
the high and low bounds.  It is permissible to apply the shift operators to a
range that is ambiguously aligned.  In that case, the resulting range is also
ambiguously aligned.

\begin{chapelexample}{rangeAdd.chpl}
The following code creates a bounded, non-stridable range \chpl{r}
which has an index type of \chpl{int} representing the indices ${0, 1, 2, 3}$.  
It then uses the \chpl{+} operator to create a second range \chpl{r2}
representing the indices ${1, 2, 3, 4}$.  The \chpl{r2} range is bounded,
non-stridable, and is represented by indices of type \chpl{int}.
% REVIEW: bradc: More interesting example?
\begin{chapel}
var r = 0..3;
var r2 = r + 1;    // 1..4
\end{chapel}
\begin{chapelpost}
writeln((r, r2));
\end{chapelpost}
\begin{chapeloutput}
(0..3, 1..4)
\end{chapeloutput}
\end{chapelexample}


\subsection{Range Slicing}
\label{Range_Slicing}
\index{ranges!slicing}

Ranges can be \emph{sliced} using other ranges to create new
sub-ranges.  The resulting range represents the intersection between
the two ranges' represented sequences.  The stride and alignment of the resulting range are adjusted as
needed to make this true.
\chpl{idxType} and the sign of the stride of the result are determined
by the first operand.

Range slicing is specified by the syntax:
\begin{syntax}
sliced-range-expression:
  range-expression ( range-expression )
  range-expression [ range-expression ]
\end{syntax}

If either of the operand ranges is ambiguously aligned, then the resulting range
is also ambiguously aligned.  In this case, the result is valid only if the
strides of the operand ranges are relatively prime.  Otherwise, an error is
generated at run time.

\begin{rationale}
If the strides of the two operand ranges are relatively prime, then they are
guaranteed to have some elements in their intersection, regardless whether their
relative alignment can be determined.  In that case, the bounds and stride in the resulting
range are valid with respect to the given inputs.
The alignment can be supplied later to create a valid range.

If the strides are not relatively prime, then the result of the slicing
operation would be completely ambiguous.  The only reasonable action for the
implementation is to generate an error.
\end{rationale}

If the resulting represented sequence cannot be expressed as a range of the
expected type, an error is generated. This can happen, for example, when
the operands represent all odd and all even numbers, or when the first
operand is an unbounded range with unsigned \chpl{idxType} and the second
operand represents only negative numbers.

\begin{chapelexample}{rangeSlicing.chpl}
In the following example, \chpl{r} represents the integers from 1 to
20 inclusive.  Ranges \chpl{r2} and \chpl{r3} are defined using range
slices and represent the indices from 3 to 20 and the odd integers
between 1 and 20 respectively. Range \chpl{r4} represents the odd
integers between 1 and 20 that are also divisible by 3.
%REVIEW: bradc: Give <l,h,s,a> values?
\begin{chapel}
var r = 1..20;
var r2 = r[3..];
var r3 = r[1.. by 2];
var r4 = r3[0.. by 3];
\end{chapel}
\begin{chapelpost}
writeln((r, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
(1..20, 3..20, 1..20 by 2, 1..20 by 6 align 3)
\end{chapeloutput}
\end{chapelexample}


\section{Predefined Functions on Ranges}
\label{Predefined_Range_Functions}
\index{ranges!predefined functions}

\subsection{Range Type Parameters}
\label{Range_Type_Accessors}
\index{ranges!type accessors}

\index{ranges!boundedType@\chpl{boundedType}}
\index{predefined functions!boundedType@\chpl{boundedType}}
\begin{protohead}
proc $range$.boundedType : BoundedRangeType
\end{protohead}
\begin{protobody}
Returns the \chpl{boundedType} parameter of the range's type.
\end{protobody}

\index{ranges!idxType@\chpl{idxType}}
\index{predefined functions!idxType@\chpl{idxType}}
\begin{protohead}
proc $range$.idxType : type
\end{protohead}
\begin{protobody}
Returns the \chpl{idxType} parameter of the range's type.
\end{protobody}

\index{ranges!stridable@\chpl{stridable}}
\index{predefined functions!stridable@\chpl{stridable}}
\begin{protohead}
proc $range$.stridable : bool
\end{protohead}
\begin{protobody}
Returns the \chpl{stridable} parameter of the range's type.
\end{protobody}

\subsection{Range Properties}
\label{Range_Properties}
\index{ranges!properties}

Most of the methods in this subsection report on
the range properties defined in \rsec{Range_Concepts}.
A range's represented sequence can be examined, for example,
by iterating over the range in a for loop \rsec{The_For_Loop}.

\begin{openissue}
The behavior of the methods that report properties that may be
undefined, $\infty$, or ambiguous, may change.
\end{openissue}

\index{ranges!aligned@\chpl{aligned}}
\index{predefined functions!aligned@\chpl{aligned}}
\begin{protohead}
proc $range$.aligned : bool
\end{protohead}
%REVIEW: better name?
\begin{protobody}
Reports whether the range's alignment is \emph{not} ambiguous.
\end{protobody}

\index{ranges!alignedHigh@\chpl{alignedHigh}}
\index{predefined functions!alignedHigh@\chpl{alignedHigh}}
\begin{protohead}
proc $range$.alignedHigh : idxType
\end{protohead}
\begin{protobody}
Returns the range's aligned high bound.
If the aligned high bound is undefined (does not exist),
the behavior is undefined.
\end{protobody}
\begin{chapelexample}{alignedHigh.chpl}
The following code:
\begin{chapel}
var r = 0..20 by 3;
writeln(r.alignedHigh);
\end{chapel}
produces the output
\begin{chapelprintoutput}{}
18
\end{chapelprintoutput}
\end{chapelexample}

\index{ranges!alignedLow@\chpl{alignedLow}}
\index{predefined functions!alignedLow@\chpl{alignedLow}}
\begin{protohead}
proc $range$.alignedLow : idxType
\end{protohead}
\begin{protobody}
Returns the range's aligned low bound.
If the aligned low bound is undefined (does not exist),
the behavior is undefined.
\end{protobody}

\index{ranges!alignment@\chpl{alignment}}
\index{predefined functions!alignment@\chpl{alignment}}
\begin{protohead}
proc $range$.alignment : idxType
\end{protohead}
\begin{protobody}
Returns the range's alignment.
If the alignment is ambiguous, the behavior is undefined.
See also \chpl{aligned}.
\end{protobody}

\index{ranges!first@\chpl{first}}
\index{predefined functions!first@\chpl{first}}
\begin{protohead}
proc $range$.first : idxType
\end{protohead}
\begin{protobody}
Returns the range's first index.
If the range has no first index, the behavior is undefined.
See also \chpl{hasFirst}.
\end{protobody}

\index{ranges!hasFirst@\chpl{hasFirst}}
\index{predefined functions!hasFirst@\chpl{hasFirst}}
\begin{protohead}
proc $range$.hasFirst(): bool
\end{protohead}
\begin{protobody}
Reports whether the range has the first index.
\end{protobody}

\index{ranges!hasHighBound@\chpl{hasHighBound}}
\index{predefined functions!hasHighBound@\chpl{hasHighBound}}
\begin{protohead}
proc $range$.hasHighBound() param: bool
\end{protohead}
\begin{protobody}
Reports whether the range's high bound is \emph{not} +$\infty$.
\end{protobody}

\index{ranges!hasLast@\chpl{hasLast}}
\index{predefined functions!hasLast@\chpl{hasLast}}
\begin{protohead}
proc $range$.hasLast(): bool
\end{protohead}
\begin{protobody}
Reports whether the range has the last index.
\end{protobody}

\index{ranges!hasLowBound@\chpl{hasLowBound}}
\index{predefined functions!hasLowBound@\chpl{hasLowBound}}
\begin{protohead}
proc $range$.hasLowBound() param: bool
\end{protohead}
\begin{protobody}
Reports whether the range's low bound is \emph{not} -$\infty$.
\end{protobody}

\index{ranges!high@\chpl{high}}
\index{predefined functions!high@\chpl{high}}
\begin{protohead}
proc $range$.high : idxType
\end{protohead}
\begin{protobody}
Returns the range's high bound.
If the high bound is +$\infty$, the behavior is undefined.
See also \chpl{hasHighBound}.
\end{protobody}

% Can re-introduce this if needed, but need to define natural alignment first.
%\begin{protohead}
%proc $range$.isNaturallyAligned(): bool
%\end{protohead}
%\begin{protobody}
%Reports whether the range is naturally aligned.
%\end{protobody}

\index{ranges!isAmbiguous@\chpl{isAmbiguous}}
\index{predefined functions!isAmbiguous@\chpl{isAmbiguous}}
\begin{protohead}
proc $range$.isAmbiguous(): bool
\end{protohead}
\begin{protobody}
Reports whether the range is ambiguously aligned.
\end{protobody}

\index{ranges!last@\chpl{last}}
\index{predefined functions!last@\chpl{last}}
\begin{protohead}
proc $range$.last : idxType
\end{protohead}
\begin{protobody}
Returns the range's last index.
If the range has no last index, the behavior is undefined.
See also \chpl{hasLast}.
\end{protobody}

\index{ranges!length@\chpl{length}}
\index{predefined functions!length@\chpl{length}}
\begin{protohead}
proc $range$.length : idxType
\end{protohead}
\begin{protobody}
Returns the number of indices in the range's represented sequence.
If the represented sequence is infinite or is undefined,
an error is generated.
\end{protobody}

\index{ranges!low@\chpl{low}}
\index{predefined functions!low@\chpl{low}}
\begin{protohead}
proc $range$.low : idxType
\end{protohead}
\begin{protobody}
Returns the range's low bound.
If the low bound is -$\infty$, the behavior is undefined.
See also \chpl{hasLowBound}.
\end{protobody}

\index{ranges!size@\chpl{size}}
\index{predefined functions!size@\chpl{size}}
\begin{protohead}
proc $range$.size : idxType
\end{protohead}
\begin{protobody}
Same as $range$.length.
\end{protobody}

\index{ranges!stride@\chpl{stride}}
\index{predefined functions!stride@\chpl{stride}}
\begin{protohead}
proc $range$.stride : int(numBits(idxType))
\end{protohead}
\begin{protobody}
Returns the range's stride. This will never return 0.
If the range is not stridable, this will always return 1.
\end{protobody}

\subsection{Other Queries}
\label{Range_Queries}
\index{ranges!other queries}

\index{ranges!boundsCheck@\chpl{boundsCheck}}
\index{predefined functions!boundsCheck@\chpl{boundsCheck}}
\begin{protohead}
proc $range$.boundsCheck(r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{false} if either range is ambiguously aligned.
Returns \chpl{true} if range \chpl{r2} lies entirely within this range
and \chpl{false} otherwise.  
\end{protobody}

\index{ranges!ident@\chpl{ident}}
\index{predefined functions!ident@\chpl{ident}}
\begin{protohead}
proc ident(r1: range(?), r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the two ranges are the same in every respect: i.e. the
two ranges have the same \chpl{idxType},
\chpl{boundedType}, \chpl{stridable}, \chpl{low}, \chpl{high}, \chpl{stride} and
\chpl{alignment} values.
%REVIEW: bradc: Might be nice if only the field properties (and not the type params) were
%compared?  Types could be compared separately using '=='?
\end{protobody}

\index{ranges!indexOrder@\chpl{indexOrder}}
\index{predefined functions!indexOrder@\chpl{indexOrder}}
\begin{protohead}
proc $range$.indexOrder(i: idxType): idxType
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the range's represented sequence, returns an integer giving
the ordinal index of \chpl{i} within the sequence using 0-based indexing.
Otherwise, returns \chpl{(-1):idxType}.
It is an error to invoke \chpl{indexOrder} if the represented sequence
is not defined or the range does not have the first index.
\end{protobody}

\begin{example}
The following calls show the order of index 4 in each of the given
ranges:
\begin{chapel}
(0..10).indexOrder(4) == 4
(1..10).indexOrder(4) == 3
(3..5).indexOrder(4) == 1
(0..10 by 2).indexOrder(4) == 2
(3..5 by 2).indexOrder(4) == -1
\end{chapel}
\end{example}

\index{ranges!member@\chpl{member}}
\index{predefined functions!member@\chpl{member}}
\begin{protohead}
proc $range$.member(i: idxType): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range's represented sequence
contains \chpl{i}, \chpl{false} otherwise.
It is an error to invoke \chpl{member} if the represented sequence
is not defined.
\end{protobody}

\index{ranges!member@\chpl{member}}
\index{predefined functions!member@\chpl{member}}
\begin{protohead}
proc $range$.member(other: range): bool
\end{protohead}
\begin{protobody}
Reports whether \chpl{other} is a subrange of the receiver. That is,
if the represented sequences of the receiver and \chpl{other}
are defined and the receiver's sequence contains all members of the
\chpl{other}'s sequence.
%REVIEW: bradc: How different than boundsCheck?
\end{protobody}

\subsection{Range Transformations}
\label{Range_Transformations}
\index{ranges!transformations}

\index{ranges!alignHigh@\chpl{alignHigh}}
\index{predefined functions!alignHigh (range)@\chpl{alignHigh} (range)}
\begin{protohead}
proc $range$.alignHigh()
\end{protohead}
\begin{protobody}
Sets the high bound of this range to its aligned high bound, if it is defined.
Generates an error otherwise.
\end{protobody}

\index{ranges!alignLow@\chpl{alignLow}}
\index{predefined functions!alignLow (range)@\chpl{alignLow} (range)}
\begin{protohead}
proc $range$.alignLow()
\end{protohead}
\begin{protobody}
Sets the low bound of this range to its aligned low bound, if it is defined.
Generates an error otherwise.
\end{protobody}

\index{ranges!expand@\chpl{expand}}
\index{predefined functions!expand (range)@\chpl{expand}}
\begin{protohead}
proc $range$.expand(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range whose bounds are extended by $i$ units on each end.  If $i <
0$ then the resulting range is contracted by its absolute value.  In symbols,
given that the operand range is represented by the tuple $(l,h,s,a)$, the result
is $(l-i,h+i,s,a)$.  The stride and alignment of the original range are preserved.
If the operand range is ambiguously aligned, then so is the resulting range.
\end{protobody}

\index{ranges!exterior@\chpl{exterior}}
\index{predefined functions!exterior (range)@\chpl{exterior} (range)}
\begin{protohead}
proc $range$.exterior(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range containing the indices just outside the low or high bound of
the range (low if $i < 0$ and high otherwise).  The stride and alignment of the
original range are preserved.  Let the operand range
be denoted by the tuple $(l,h,s,a)$.  Then:
\begin{itemize}
\item[] if $i < 0$, the result is $(l+i,l-1,s,a)$,
\item[] if $i > 0$, the result is $(h+1,h+i,s,a)$, and
\item[] if $i = 0$, the result is $(l,h,s,a)$.
\end{itemize}
If the operand range is ambiguously aligned, then so is the resulting range.
\end{protobody}

\index{ranges!interior@\chpl{interior}}
\index{predefined functions!interior (range)@\chpl{interior} (range)}
\begin{protohead}
proc $range$.interior(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range containing the indices just inside the low or high bound of
the range (low if $i < 0$ and high otherwise).  The stride and alignment of the
original range are preserved.  Let the operand range
be denoted by the tuple $(l,h,s,a)$.  Then:
\begin{itemize}
\item[] if $i < 0$, the result is $(l,l-(i-1),s,a)$,
\item[] if $i > 0$, the result is $(h-(i-1),h,s,a)$, and
\item[] if $i = 0$, the result is $(l,h,s,a)$.
\end{itemize}
This differs from the behavior of the count operator, in that \chpl{interior()}
preserves the alignment, and it uses the low and high bounds rather
than \chpl{first} and \chpl{last} to establish the bounds of the resulting range.
If the operand range is ambiguously aligned, then so is the resulting range.
\end{protobody}

\index{ranges!offset@\chpl{offset}}
\index{predefined functions!offset (range)@\chpl{offset} (range)}
\begin{protohead}
proc $range$.offset(n: idxType)
\end{protohead}
\label{Range_Offset_Method}
\begin{protobody}
Returns a new range whose alignment is this range's first index plus
\chpl{n}. The new alignment, therefore, is not ambiguous.
If the range has no first index, a run-time error is generated.
\end{protobody}

\index{ranges!translate@\chpl{translate}}
\index{predefined functions!translate (range)@\chpl{translate} (range)}
\begin{protohead}
proc $range$.translate(i: integral)
\end{protohead}
\begin{protobody}
Returns a new range with its \chpl{low}, \chpl{high} and \chpl{alignment} values
adjusted by $i$.  The \chpl{stride} value is preserved.
If the range's alignment is ambiguous, the behavior is undefined.
%REVIEW: vass: can define this to produce ambiguous alignment in such cases.
\end{protobody}

