\sekshun{Ranges}
\label{Ranges}
\index{ranges}

Ranges represent a regular sequence of integer indices.  
Ranges support iteration over the
indices they represent as described in ~\rsec{The_For_Loop}.

Ranges have an integral base type, one of four types of \emph{boundedness} and
are \emph{stridable} or not (\rsec{Range_Types}).  The \emph{low
bound}, \emph{high bound}, \emph{stride} and \emph{alignment} of a range
determines the sequence of values it represents (\rsec{Range_Values}).

The fields contained in a range are described in \rsec{Range_Fields}.
Subsequent sections describe how to specify a range literally
(\rsec{Range_Literals}), the effect of assigning one range to another
(\rsec{Range_Assignment}), operators which apply a stride
(\rsec{By_Operator_For_Ranges}) or an alignment (\rsec{Align_Operator}), and the
count operator (\rsec{Count_Operator}).  Section \rsec{Range_Slicing} describes
range slicing, which yields a range representing the intersection of the two
operand ranges.

The final section (\rsec{Predefined_Range_Functions}) lists the remaining
functions in the range library, divided into the following subsections: type
accessors (\rsec{Range_Type_Accessors}), field accessors
(\rsec{Range_Field_Accessors}), predicates (\rsec{Range_Predicates}), queries
(\rsec{Range_Queries}) and transformations (\rsec{Range_Transformations}).

\section{Range Types}
\label{Range_Types}
\index{ranges!types}

The type of a range is characterized by three things:
\begin{enumerate}
\item the type of the indices being represented, 
\item the boundedness of the range,
\item whether or not the range is \emph{stridable}.
\end{enumerate}
\index{ranges!bounded}
\index{ranges!unbounded}
\index{ranges!stridable}
\index{ranges!alignment}


In a range, the type of the low bound, the high bound and the alignment are
determined by the type parameter \emph{idxType}.
This must be one of the \chpl{int} or
\chpl{uint} types.  The default type is \chpl{int}.
The type of a range's stride is the signed equivalent of its \emph{idxType}.

%% I'm hiding this.  Users can yelp if they want ranges on reals. (hilde 2011/03/22)
%%\begin{openissue}
%%It has been hypothesized that ranges of other types, such as floating
%%point values, might also be of interest to represent a range of legal
%%tolerances, for example.  If you believe such support would be of
%%interest to you, please let us know.
%%\end{openissue}

The boundedness of the range is represented using an enumerated
parameter named \emph{boundedType} of type \chpl{BoundedRangeType}.
Legal values are \chpl{bounded}, \chpl{boundedLow},
\chpl{boundedHigh}, and \chpl{boundedNone}.  
\begin{chapel}
enum BoundedRangeType { bounded, boundedLow, boundedHigh, boundedNone };
\end{chapel}
\noindent
The first value specifies
a bounded range while the other three values specify a range in which
the high bound is omitted, the low bound is omitted, or both bounds
are omitted, respectively.  The default value is \chpl{bounded}.

If a range is stridable, it may have a stride and an
\emph{alignment}.  The stride is the difference between neighboring indices; the
alignment determines the modulus of the indices described.  If a range is not
stridable, its effective stride is $1$ and its alignment is $0$.
% NOTE: bradc  Yeah? What if its stridable and |stride| is |1|?  Are we saying too
% much too soon?
The stridability of a range is represented by a boolean parameter
named \chpl{stridable}.  The default value is \chpl{false}.  If this parameter
is set to \chpl{true}, the range's stride can take on any signed integer value
other than 0 of the same bit-width as \chpl{idxType}.

If \chpl{stridable} is set to \chpl{true}, the alignment value can also be set.
It can take on any integer value representable by
the \emph{idxType}.  For a given alignment $a$ and stride $s$, each index $i$
in the range's sequence obeys the relation $i = a ({\rm modulo} s)$.

\begin{rationale}
The \emph{boundedType} and \emph{stridable} parameters are used
to optimize the generated code for common cases of ranges, as well as
to optimize the implementation of domains and arrays defined using ranges.
\end{rationale}

The syntax of a range type is summarized as follows:
\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}
\noindent The \sntx{named-expression-list} contains any combination of
  the \chpl{idxType}, \chpl{boundedType} and \chpl{stridable} parameters.

\begin{chapelexample}{rangeVariable.chpl}
The following declaration declares a variable \chpl{r}
of range type that can represent ranges of 64-bit integers, with both
high and low bounds specified, the ability to have a stride other
than 1 and an alignment other than zero.
\begin{chapel}
var r: range(int(64), BoundedRangeType.bounded, stridable=true);
\end{chapel}
\begin{chapelpost}
writeln(r);
var i64: int(64) = 3;
r = i64..13 by 3 align 1;
writeln(r);
\end{chapelpost}
\begin{chapeloutput}
1..0
3..13 by 3 align 1
\end{chapeloutput}
\end{chapelexample}

\section{Range Values}
\label{Range_Values}

All ranges are characterized by a low bound~$l$, a high bound~$h$, stride~$s$
and alignment~$a$.  The sequence produced by iterating upon a range is bounded
below by $l$ and above by $h$.  The stride determines the difference between
successive indices in the sequence.  An alignment value $a$ applied to a range
with stride $s$ causes the indices $i$ produced by an iterator to obey the
equation $i = a ({\rm modulo} s)$.

The \emph{aligned low bound} $b$ is the first index greater than or equal to $l$
that matches the alignment.  That is, $b$ is the lowest index such that $b \geq
l, b = a ({\rm modulo} |s|)$.  Similarly, the \emph{aligned high bound} $e$ is
the highest index such that $e \leq h, e = a ({\rm modulo} |s|)$.
\index{ranges!aligned bounds}
If the stride is positive, the indices
described by the range are $b, b+s, b+2s, b+3s, ..., e$.
If the stride is negative, the indices
described by the range are $e, e+s, e+2s, e+3s, ..., b$.
If $l > h$, the range is considered
degenerate and represents an empty sequence. 

\section{Range Fields}
\label{Range_Fields}
\index{ranges!fields}

%NOTE: bradc: ``A range's semantics are defined by ?''
%NOTE: hilde: That was the intent of the preceding section.  This section
%introduces the fields which may be accessed through their respective accessors
%and describes when they are valid.
The fields in a range are given by:
\begin{tabular}{rl}
\chpl{low} the low bound,
\chpl{high} the high bound,
\chpl{stride} the stride,
\chpl{alignment} the alignment, and
%NOTE: bradc: These 4 are tautological.
%NOTE: hilde: An excellent example of mnemonic naming!
\chpl{aligned} whether the alignment field has been set explicitly.
%NOTE: bradc: Does this have to be a distinct thing instead of a special
%alignment value in semantics?
%NOTE: hilde: There are pros and cons to using special values.  Whether this
%field should be exposed to users is also worth discussing.
\end{tabular}
These fields are always valid, regardless of the choice of \chpl{boundedType}
and \chpl{stridable} parameters.  However, the accessors
(\rsec{Range_Field_Accessors}) may report an error
when specific values are entered, and certain cases are interpreted
specially, as enumerated below.

If the low bound exceeds the high bound, the range is degenerate: It contains no
indices.  
%REVIEW: bradc: Need to say what stride of 0 means? or say it cannot be 0?

A range has no \chpl{first} value if it has a positive stride and is \chpl{boundedHigh}
or \chpl{boundedNone} or if it has a negative stride and is \chpl{boundedLow}
or \chpl{boundedNone}.  If the range has no \chpl{first} value, then it cannot be iterated
upon.  If the range has a stride whose absolute value
is greater than 1 and its \chpl{aligned} flag is \chpl{false}, then its alignment is
\emph{ambiguous}.  If a range is ambiguously aligned, it cannot be iterated, and
other actions are prohibited as well.  Refer to the description of each operator or
range-related function for details.
\index{ranges!alignment!ambiguous}

The default value for a range is \chpl{1..0}, which is equivalent to \chpl{low}, \chpl{high}, \chpl{stride}
and \chpl{alignment} values of 1, 0, 1 and 1, respectively.

Depending on how the \chpl{stride} and \chpl{alignment} fields are set,
the \chpl{low} and \chpl{high} values will not necessarily appear in the
sequence generated by it (see~\rsec{The_For_Loop}).  Use the
accessors \chpl{alignedLow} and \chpl{alignedHigh} to obtain the actual low and
high values appearing in the sequence.  The accessors \chpl{first} and \chpl{last} provide
the first and last indices in the sequence, regardless whether the stride is
positive or negative.  

A range is \emph{naturally aligned} if it has a positive stride and its
alignment coincides with its low bound, or it has a negative stride and its
alignment coincides with its high bound.
Specifically, a range with \chpl{low}, \chpl{high}, \chpl{stride}
and \chpl{alignment} values of $l$, $h$, $s$ and $a$ (respectively) is naturally aligned if:
\begin{itemize}
\item It is \chpl{bounded}, its stride is positive, and $a = l ({\rm modulo} s)$,
\item It is \chpl{bounded}, its stride is negative, and $a = h ({\rm modulo} s)$,
\item It is \chpl{boundedLow} and $a = l ({\rm modulo} s)$,
\item It is \chpl{boundedHigh} and $a = h ({\rm modulo} s)$ or
\item It is $boundedNone$ and $a = 0$.
\end{itemize}
\noindent The \chpl{isNaturallyAligned} predicate returns \chpl{true} when the operand
range is naturally aligned.  When a range is formatted for output, the alignment
is printed only if the range is not naturally aligned.
\index{ranges!alignment!natural}

All ranges with a stride of $\pm 1$ are unambiguously aligned, regardless of the
state of the \chpl{aligned} flag.\footnote{That is because the effective
alignment is the \chpl{alignment} modulo the \chpl{stride}, which is
unambiguously zero.}  However, when the absolute value of its stride is 2 or
greater, a range may be ambiguously aligned.  See~\rsec{By_Operator_For_Ranges}
for details.


\section{Literal Range Values}
\label{Range_Literals}
\index{ranges!literals} 

Range literals are specified as follows:
\begin{syntax}
range-literal:
  bounded-range-literal
  unbounded-range-literal
\end{syntax}

\subsection{Bounded Range Literals}
\label{Bounded_Ranges}
\index{ranges!bounded}

A bounded range is specified by the syntax
\begin{syntax}
bounded-range-literal:
  expression .. expression
\end{syntax}
The first expression is taken to be the lower bound $l$ and the second
expression is taken to be the upper bound $h$.  The stride of the
range is 1 and can be modified using the \chpl{by} operator as described
in~\rsec{By_Operator_For_Ranges}.  

\index{ranges!integral index type}
The index type of the range type is determined by the type of the
low and high bound.  
%NOTE: bradc: Is this well-defined? clear?
It is either \chpl{int}, \chpl{uint},
\chpl{int(64)}, or \chpl{uint(64)}.  The index type of the range is obtained by
applying integral promotions to the low and high bounds.  The boundedness
of such a range is \chpl{bounded}.  The stridability of a range literal
is always \chpl{false}.

\subsection{Unbounded Range Literals}
\label{Unbounded_Ranges}
\index{ranges!unbounded}

Unbounded ranges are those in which the low and/or high bound is
omitted.  
An unbounded range is specified by the syntax
\begin{syntax}
unbounded-range-literal:
  expression ..
  .. expression
  ..
\end{syntax}

The first form results in a \chpl{boundedLow} range, the
second in a \chpl{boundedHigh} range, and the third in
a \chpl{boundedNone} range.  If a bound is given, the index type and alignment are determined
by that bound.

When used in zippered iteration (~\rsec{Zipper_Iteration}), the shape of an
unbounded range conforms to that of the other iterator.

\begin{chapelexample}{zipWithUnbounded.chpl}
The code
\begin{chapel}
for i in (1..5, 3..) do
  write(i, "; ");
\end{chapel}
\begin{chapelpost}
writeln();
\end{chapelpost}
\begin{chapeloutput}
(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); 
\end{chapeloutput}
produces the output ``(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); ''.
\end{chapelexample}

It is an error to iterate over a range which lacks a \chpl{first} value.
The \chpl{hasFirst} predicate is used internally to detect this (see~\rsec{Range_Predicates}).


\section{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}

Assigning one range to another results in its low, high, stride, alignment and
aligned values being copied from the source range to the destination range.

In order for range assignment to be legal, the index type of the
source range must be implicitly coercible to the index type of the
destination range, and the two range types must have the same boundedness.
It is legal to assign a non-stridable range to a stridable
range, but illegal to assign a stridable range to a non-stridable
range unless the stridable range has a stride of 1.


\section{Range Operators}
\label{Range_Operators}
\index{ranges!operators}

The following operators can be applied to range literals and
expressions and are described in this section: stride (\chpl{by}),
alignment (\chpl{align}), count (\chpl{\#}) and slicing (\chpl{\(\)}
or \chpl{\[\]}).
Chapel also defines a set of procedures and methods that operate on ranges.
They are described in \rsec{Predefined_Range_Functions}.

\begin{syntax}
range-expression:
  expression
  strided-range-expression
  counted-range-expression
  aligned-range-expression
  sliced-range-expression
\end{syntax}

\subsection{By Operator}
\label{By_Operator_For_Ranges}
\index{ranges!strided}
\index{ranges!by operator}
\index{by@\chpl{by}}

The \chpl{by} operator can be applied to any range to create a strided
range.  Its syntax is given by:
\begin{syntax}
strided-range-expression:
  range-expression `by' expression
\end{syntax}

The \chpl{by} operator takes a range and an integer value to yield a
new range that is strided by the integer.  Striding a strided range
results in a stride whose value is the product of the two strides.
The stride argument can either be of type \chpl{idxType} or some other
integer value that can be coerced to a signed integer value of the same
bit-width as \chpl{idxType}.  

The resulting range has the same \chpl{idxType} and \chpl{boundedType} as the
operand range, but has its \chpl{stridable} parameter set to \chpl{true}.
The low and high bounds of the operand range are preserved in the result.
The alignment of the new range depends on the \chpl{boundedType} of the range
and the sign of the resulting stride, as follows:
\begin{itemize}
\item If the range is \chpl{bounded} or \chpl{boundedLow} and  the resulting stride is positive, the new range is aligned on
the \chpl{alignedLow} value of the operand range.  
\item If the range
is \chpl{bounded} or \chpl{boundedHigh} and  the resulting stride is
negative, it is aligned with respect to the operand's \chpl{alignedHigh} value.
\item Otherwise, it has the same alignment as the operand range.
\end{itemize}

The alignment of the result is determined as follows:
\begin{itemize}
\item If the operand range is ambiguously aligned, then \chpl{aligned} is set to
false;
%NOTE: bradc: Is this right?
%NOTE: hilde: I think so ... .  It expresses the "poison bit" interpretation of
%ambiguous alignment, so you can't turn an ambiguously aligned range into an
%unambiguously aligned one by simply applying "by -1", for example.
\item If the \chpl{aligned} flag of the operand is \chpl{true}, then the
existing alignment is used; 
\item Otherwise, if stride of the resulting range has an absolute value greater
than 1 and its \chpl{first} value is defined (i.e.
\chpl{r.hasFirst() == true}), then \chpl{first} is used and \chpl{aligned} is set
to true.
\end{itemize}
See~\rsec{Range_Predicates} or the definition of \chpl{hasFirst}.

\begin{chapelexample}{rangeByOperator.chpl}
In the following declarations, range \chpl{r1} represents the odd integers
between 1 and 20. Range \chpl{r2} strides \chpl{r1} by two and represents
every other odd integer between 1 and 20: 1, 5, 9, 13 and 17.
\begin{chapel}
var r1 = 1..20 by 2;
var r2 = r1 by 2;
\end{chapel}
\begin{chapelpost}
writeln(r1);
writeln(r2);
\end{chapelpost}
\begin{chapeloutput}
1..20 by 2
1..20 by 4
\end{chapeloutput}
\end{chapelexample}

\begin{rationale}
{\it Why isn't the high bound specified first if the stride is
negative?}  The reason for this choice is that the \chpl{by} operator
is binary, not ternary.  Given a range \chpl{R} initialized
to \chpl{1..3}, we want \chpl{R by -1} to contain the ordered sequence
$3,2,1$.  But then \chpl{R by -1} would be different from \chpl{3..1
by -1} even though it should be identical by substituting the value in
R into the expression.
\end{rationale}


\subsection{Align Operator}
\label{Align_Operator}
\index{ranges!align operator}

The \chpl{align} operator can be applied to any range, and creates a new range
with the given alignment.  

The syntax for the \chpl{align} operator is:
\begin{syntax}
aligned-range-expression:
  range-expression `align' expression
\end{syntax}
\noindent The type of the resulting range expression is the same as that of the
range appearing as the left operand.  The type of the right operand must be
coercible to the index type of the operand range.  
The resulting range has the
same \chpl{low}, \chpl{high} and \chpl{stride} fields as the source range. The
alignment is set equal to the \chpl{align} operator's right operand.
The \chpl{aligned} flag is set to \chpl{true}, to signify that an explicit
alignment has been supplied.

\begin{chapelexample}{alignedStride.chpl}
\begin{chapel}
var r1 = 0 .. 10 by 3 align 0;
for i in r1 do
  write(" ", i);			// Produces "0 3 6 9".
writeln();

var r2 = 0 .. 10 by 3 align 1;
for i in r2 do
  write(" ", i);			// Produces "1 4 7 10".
writeln();
\end{chapel}
\begin{chapeloutput}
 0 3 6 9
 1 4 7 10
\end{chapeloutput}
\end{chapelexample}

When the stride is negative, the same indices are printed in reverse:
\begin{chapelexample}{alignedNegStride.chpl}
\begin{chapel}
var r3 = 0 .. 10 by -3 align 0;
for i in r3 do
  write(" ", i);			// Produces "9 6 3 0".
writeln();

var r4 = 0 .. 10 by -3 align 1;
for i in r4 do
  write(" ", i);			// Produces "10 7 4 1".
writeln();
\end{chapel}
\begin{chapeloutput}
 9 6 3 0
 10 7 4 1
\end{chapeloutput}
\end{chapelexample}

To align a range relative to its \chpl{first} index, use
the \chpl{offset} method (\rsec{Range_Offset_Method}).


\subsection{Count Operator}
\label{Count_Operator}
\index{ranges!count operator}

The \chpl{#} operator takes a range and an integral count and creates a new
range containing the specified number of indices.  The low or high bound of the
left operand is preserved, and the other bound adjusted to provide the specified
number of indices.  If the count is positive, indices are taken from the start
of the range; if the count is negative, indices are taken from the end of the
range.  The count must be less than or equal to the \chpl{length} of the range.

\begin{syntax}
counted-range-expression:
  range-expression # expression
\end{syntax}

The \emph{idxType} of the resulting range is the same type that would be
obtained by adding the integral count value to a value with the
range's \emph{idxType}.  
%NOTE: bradc: We should really define to use op. range's idxType.
The stride and alignment of the resulting range are the same as those
of the initial range.  

Depending on the sign of the count and the stride, the high or low bound is
unchanged and the other bound is adjusted so that it is $c * stride - 1$ units
away.  Specifically:
\begin{itemize}
\item If the count times the stride is positive, the low bound is preserved
and the high bound is adjusted to be one less than the low bound plus that
product.
\item Iff the count times the stride is negative, the high bound is preserved
and the low bound is adjusted to be one greater than the high bound plus that
product.
\end{itemize}

\begin{rationale}
Following the principle of preserving as much information from the original
range as possible, we must still choose the other bound so that
exactly \emph{count} indices lie within the range.  Making the two bounds lie
$count * stride - 1$ apart will achieve this, regardless of the current
alignment of the range.

This choice also has the nice symmetry that the alignment can be adjusted
without knowing the bounds of the original range, and the same number of indices
will be produced:
\begin{chapel}
r # 4 align 0   // Contains four indices.
r # 4 align 1   // Contains four indices.
r # 4 align 2   // Contains four indices.
r # 4 align 3   // Contains four indices.
\end{chapel}
\end{rationale}

It is an error to apply the count operator with a positive count to a range that
has no starting index.  It is also an error to apply the count operator
with a negative count to a range that has no end index.
It is an error to apply the count operator to a range that is ambiguously aligned.

\begin{chapelexample}{rangeCountOperator.chpl}
The following declarations result in equivalent ranges.
\begin{chapel}
var r1 = 1..10 by -2 # -3;
var r2 = ..6 by -2 # 3;
var r3 = -6..6 by -2 # 3;
var r4 = 1..#6 by -2;
\end{chapel}
\begin{chapelpost}
writeln(r1 == r2 \&\& r2 == r3 \&\& r3 == r4);
writeln((r1, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
true
(1..6 by -2, 1..6 by -2, 1..6 by -2, 1..6 by -2)
\end{chapeloutput}
Each of these ranges represents the ordered set of three indices: 6, 4, 2.
\end{chapelexample}

\subsection{Arithmetic Operators}
\label{Range_Arithmetic}
\index{ranges!arithmetic operators}

The following arithmetic operators are defined on ranges and integral
types:

\begin{chapel}
proc +(r: range, s: integral): range
proc +(s: integral, r: range): range
proc -(r: range, s: integral): range
\end{chapel}

The \chpl{+} and \chpl{-} operators apply the scalar via the operator
to the range's low and high bounds, producing a shifted version of the
range.  If the operand range is unbounded above or below, the missing bounds
are ignored.
The index type of the resulting range is the type of the value
that would result from an addition between the scalar value and a value
with the range's index type.  The bounded and stridable parameters for
the result range are the same as for the input range.

The stride of the resulting range is the same as the stride of the
original. The alignment of the resulting range is shifted by the same amount as
the high and low bounds.  It is permissible to apply the shift operators to a
range that is ambiguously aligned.  In that case, the resulting range is also
ambiguously aligned.

\begin{chapelexample}{rangeAdd.chpl}
The following code creates a bounded, non-stridable range \chpl{r}
which has an index type of \chpl{int} representing the indices ${0, 1, 2, 3}$.  
It then uses the \chpl{+} operator to create a second range \chpl{r2}
representing the indices ${1, 2, 3, 4}$.  The \chpl{r2} range is bounded,
non-stridable, and is represented by indices of type \chpl{int}.
% REVIEW: bradc: More interesting example?
\begin{chapel}
var r = 0..3;
var r2 = r + 1;    // 1..4
\end{chapel}
\begin{chapelpost}
writeln((r, r2));
\end{chapelpost}
\begin{chapeloutput}
(0..3, 1..4)
\end{chapeloutput}
\end{chapelexample}


\subsection{Range Slicing}
\label{Range_Slicing}
\index{ranges!slicing}

Ranges can be \emph{sliced} using other ranges to create new
sub-ranges.  The resulting range represents the intersection between
the two ranges.  The stride and alignment of the resulting range are adjusted as
needed to make this true.  Range slicing is specified by the syntax:
\begin{syntax}
sliced-range-expression:
  range-expression ( range-expression )
  range-expression [ range-expression ]
\end{syntax}

If either of the operand ranges is ambiguously aligned, then the resulting range
is also ambiguously aligned.  In this case, the result is valid only if the
strides of the operand ranges are relatively prime.  Otherwise, an error is
generated at run time.

\begin{rationale}
If the strides of the two operand ranges are relatively prime, then they are
guaranteed to have some elements in their intersection, regardless whether their
relative alignment can be determined.  In that case, all fields in the resulting
range are valid with respect to the given inputs except for the \chpl{alignment}
field.  The alignment can be supplied later to create a valid range.

If the strides are not relatively prime, then the result of the slicing
operation would be completely ambiguous.  The only reasonable action for the
implementation is to generate an error.
\end{rationale}

\begin{chapelexample}{rangeSlicing.chpl}
In the following example, \chpl{r} represents the integers from 1 to
20 inclusive.  Ranges \chpl{r2} and \chpl{r3} are defined using range
slices and represent the indices from 3 to 20 and the odd integers
between 1 and 20 respectively. Range \chpl{r4} represents the odd
integers between 1 and 20 that are also divisible by 3.
%NOTE: bradc: Give <l,h,s,a> values?
\begin{chapel}
var r = 1..20;
var r2 = r[3..];
var r3 = r[1.. by 2];
var r4 = r3[0.. by 3];
\end{chapel}
\begin{chapelpost}
writeln((r, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
(1..20, 3..20, 1..20 by 2, 1..20 by 6 align 3)
\end{chapeloutput}
\end{chapelexample}

\section{Predefined Functions on Ranges}
\label{Predefined_Range_Functions}
\index{ranges!predefined functions}

\subsection{Range Type Accessors}
\label{Range_Type_Accessors}

\begin{protohead}
proc $range$.idxType : type
\end{protohead}
\begin{protobody}
Returns the index type of the range.  
\end{protobody}

\begin{protohead}
proc $range$.boundedType : BoundedRangeType
\end{protohead}
\begin{protobody}
Returns boundedType of the range.  The boundedType of a range is a member of the
BoundedRangeType enumeration (\rsec{Range_Types}).
\end{protobody}

\begin{protohead}
proc $range$.stridable : bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is stridable, \chpl{false} otherwise.  If \chpl{stridable} is
\chpl{false}, the stride is effectively 1 and the alignment is effectively 0.
\end{protobody}

\subsection{Range Field Accessors}
\label{Range_Field_Accessors}
%REVIEW: hilde: Should field accessors be read/write?
\begin{protohead}
proc $range$.alignment : idxType
\end{protohead}
\begin{protobody}
Returns the alignment of the indices yielded by an iterator.  
\end{protobody}

\begin{protohead}
proc $range$.low : idxType
\end{protohead}
\begin{protobody}
Returns the low bound of the range.
\end{protobody}

\begin{protohead}
proc $range$.high : idxType
\end{protohead}
\begin{protobody}
Returns the high bound of the range.
\end{protobody}

\begin{protohead}
proc $range$.stride : int(numBits(idxType))
\end{protohead}
\begin{protobody}
Returns the stride of the range.  
% The value of the operand must not be zero.
\end{protobody}

\begin{protohead}
proc $range$.aligned : bool
\end{protohead}
\begin{protobody}
Returns the value of the aligned flag.
\end{protobody}

\subsection{Range Predicates}
\label{Range_Predicates}

\begin{protohead}
proc ==(r1: range(?), r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the two ranges produce the same sequence
and \chpl{false} otherwise.  The high and low bounds can differ between the two
ranges, and they will still compare equal as long as the same sequence is
produced by each.
\end{protobody}

\begin{protohead}
proc $range$.boundsCheck(r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{false} if either range is ambiguously aligned.
Returns \chpl{true} if range \chpl{r2} lies entirely within this range
and \chpl{false} otherwise.  
\end{protobody}

\begin{protohead}
proc $range$.ident(r1: range(?), r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the two ranges are the same in every respect: i.e. the
two ranges have the same \chpl{idxType},
\chpl{boundedType}, \chpl{stridable}, \chpl{low}, \chpl{high}, \chpl{stride} and
\chpl{alignment} and \chpl{aligned} values.
%NOTE: bradc: Might be nice if only the field values (and not the params) were
%compared?  Types could be compared separately using '=='?
\end{protobody}

\begin{protohead}
proc $range$.hasFirst(): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if this range has a low bound and a positive stride, or a high
bound and a negative stride.
Always returns \chpl{false} if this range is ambiguously aligned.
%NOTE: bradc: Define in terms of ident? Call start?
\end{protobody}

\begin{protohead}
proc $range$.hasLast(): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if this range has a high bound and a positive stride, or a low
bound and a negative stride.
Always returns \chpl{false} if this range is ambiguously aligned.
\end{protobody}

\begin{protohead}
proc $range$.hasLowBound() param: bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is bounded below (\chpl{boundedLow} or \chpl{bounded}).
Always returns \chpl{false} if this range is ambiguously aligned.
\end{protobody}

\begin{protohead}
proc $range$.hasHighBound() param: bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is bounded above (\chpl{boundedHigh} or \chpl{bounded}).
Always returns \chpl{false} if this range is ambiguously aligned.
\end{protobody}

\begin{protohead}
proc $range$.isNaturallyAligned() bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is naturally aligned and \chpl{false} otherwise.
Specifically,
\begin{itemize}
\item If the range is \chpl{bounded}, then
\begin{itemize}
\item If the stride is positive and the range is aligned on the low bound,
returns \chpl{true}; otherwise, returns \chpl{false}.
\item If the stride is negative and the range is aligned on the high bound,
returns \chpl{true}; otherwise, returnse \chpl{false}.
\item Otherwise, returns \chpl{false}.
\end{itemize}
\item If the range is \chpl{boundedLow} and the range is aligned on the low
bound, then returns \chpl{true}; otherwise, returns \chpl{false}.
\item If the range is \chpl{boundedHigh} and the range is aligned on the high
bound, then returns \chpl{true}; otherwise, returns \chpl{false}.
\item If the range is \chpl{boundedNone} and the alignment is 0, returns \chpl{true};
otherwise, returns \chpl{false}.
\end{itemize}
Note that this predicate ignores the \chpl{aligned} flag.
\end{protobody}

\begin{protohead}
proc $range$.isAmbiguous(): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if this range is ambiguously aligned, \chpl{false} otherwise.
\end{protobody}

\begin{protohead}
proc $range$.member(i: idxType): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if \chpl{i} is in the range; \chpl{false} otherwise.
Always returns \chpl{false} if this range is ambiguously aligned.
\end{protobody}

\begin{protohead}
proc $range$.member(other: range): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if every index in \chpl{other} is also in \chpl{this}, \chpl{false} otherwise.
Always returns \chpl{false} if this range is ambiguously aligned.
%NOTE: bradc: How different than boundsCheck?
\end{protobody}

\subsection{Range Queries}
\label{Range_Queries}

\begin{protohead}
proc $range$.alignedHigh : idxType
\end{protohead}
\begin{protobody}
Returns the aligned high bound of the range.  
%REVIEW: bradc: What if alignment is not well-defined?
The aligned high bound is the first
index in the range less than or equal to the high bound that is
aligned relative to the stored \chpl{stride} and \chpl{alignment} values.  That
is, if the high bound, stride and alignment are $h$, $s$ and $a$ respectively,
the aligned high bound $e$ is the highest index such that $e \leq h, e\!\mod |s| =
a\!\mod |s|$.
\end{protobody}
\begin{chapelexample}{alignedHigh.chpl}
The following code:
\begin{chapel}
var r = 0..20 by 3;
writeln(r.alignedHigh);
\end{chapel}
\begin{chapeloutput}
18
\end{chapeloutput}
produces the output ``18''.
\end{chapelexample}

\begin{protohead}
proc $range$.alignedLow : idxType
\end{protohead}
\begin{protobody}
Returns the aligned low bound of the range.  
The aligned low bound is the first
index in the range greater than or equal to the low bound that is
aligned relative to the stored \chpl{stride} and \chpl{alignment} values.  That
is, if the low bound, stride and alignment are $l$, $s$ and $a$ respectively,
the aligned low bound $b$ is the lowest index such that $b \geq l, b\!\mod |s| =
a\!\mod |s|$.
\end{protobody}

\begin{protohead}
proc $range$.first : idxType
\end{protohead}
\begin{protobody}
Returns the first index in the range.  If the stride is positive,
\chpl{alignedLow} is returned; otherwise, \chpl{alignedHigh} is returned.
\end{protobody}

\begin{protohead}
proc $range$.indexOrder(i: idxType): idxType
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the range, returns an integer giving
the ordinal index of \chpl{i} within the range using 0-based indexing.
Otherwise, returns \chpl{(-1):idxType}.
\end{protobody}

\begin{example}
The following calls show the order of index 4 in each of the given
ranges:
\begin{chapel}
(0..10).indexOrder(4) == 4
(1..10).indexOrder(4) == 3
(3..5).indexOrder(4) == 1
(0..10 by 2).indexOrder(4) == 2
(3..5 by 2).indexOrder(4) == -1
\end{chapel}
\end{example}
\begin{protohead}

proc $range$.last : idxType
\end{protohead}
\begin{protobody}
Returns the last index within the range.  In general, this is given
by \chpl{first + length * stride}.
\end{protobody}

\begin{protohead}
proc $range$.length : idxType
\end{protohead}
\begin{protobody}
Returns the number of indices in the range.
\end{protobody}

\subsection{Range Transformations}
\label{Range_Transformations}

\begin{protohead}
proc $range$.alignHigh()
\end{protohead}
\begin{protobody}
Sets the alignment of this range to its high bound.
If the operand range is ambiguously aligned, a run-time error is generated.
\end{protobody}

\begin{protohead}
proc $range$.alignLow()
\end{protohead}
\begin{protobody}
Sets the alignment of a range to its low bound.
If the operand range is ambiguously aligned, a run-time error is generated.
\end{protobody}

\begin{protohead}
proc $range$.expand(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range whose bounds are extended by $i$ units on each end.  If $i <
0$ then the resulting range is contracted by its absolute value.  In symbols,
given that the operand range is represented by the tuple $(l,h,s,a)$, the result
is $(l-i,h+i,s,a)$.  The stride and alignment of the original range are preserved.
If the operand range is ambiguously aligned, then so is the resulting range.
\end{protobody}

\begin{protohead}
proc $range$.exterior(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range containing the indices just outside the low or high bound of
the range (low if $i < 0$ and high otherwise).  The stride and alignment of the
original range are preserved.  Let the operand range
be denoted by the tuple $(l,h,s,a)$.  Then:
\begin{itemize}
\item[] if $i < 0$, the result is $(l+i,l-1,s,a)$,
\item[] if $i > 0$, the result is $(h+1,h+i,s,a)$, and
\item[] if $i = 0$, the result is $(l,h,s,a)$.
\end{itemize}
If the operand range is ambiguously aligned, then so is the resulting range.
\end{protobody}

\begin{protohead}
proc $range$.interior(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range containing the indices just inside the low or high bound of
the range (low if $i < 0$ and high otherwise).  The stride and alignment of the
original range are preserved.  Let the operand range
be denoted by the tuple $(l,h,s,a)$.  Then:
\begin{itemize}
\item[] if $i < 0$, the result is $(l,l-(i-1),s,a)$,
\item[] if $i > 0$, the result is $(h-(i-1),h,s,a)$, and
\item[] if $i = 0$, the result is $(l,h,s,a)$.
\end{itemize}
This differs from the behavior of the count operator, in that \chpl{interior()}
preserves the alignment, and it uses the low and high bounds rather
than \chpl{first} and \chpl{last} to establish the bounds of the resulting range.
If the operand range is ambiguously aligned, then so is the resulting range.
\end{protobody}

\begin{protohead}
proc $range$.offset(n: idxType)
\end{protohead}
\label{Range_Offset_Method}
\begin{protobody}
Sets the \chpl{align} field such that indices produced by the iterator are
aligned with \chpl{first + n}.  Sets the \chpl{aligned} flag to \chpl{true}.  
If the range has no \chpl{first} value (as determined
by the \chpl{hasFirst} predicate), then a run-time error is generated.
\end{protobody}

\begin{protohead}
proc $range$.translate(i: integral)
\end{protohead}
\begin{protobody}
Returns a new range with its \chpl{low}, \chpl{high} and \chpl{alignment} values
adjusted by $i$.  The \chpl{stride} and \chpl{aligned} values are preserved.
\end{protobody}

\begin{protohead}
\end{protohead}
\begin{protobody}
\end{protobody}

