\sekshun{Sequences}
\label{Sequences}

A sequence is an ordered set of elements of the same type.

\subsection{Sequence Literals}
\label{Sequence_Literals}
\index{sequences!literals}
\index{(/@\chpl{(/}}

Literal sequences are delimited by the braces \chpl{(/} and \chpl{/)}.
The expressions enclosed in these braces are elements of the sequence.
These expressions do not need to be literals themselves.
\begin{example}
The following code defines a sequence of integers:
\begin{chapel}
(/1, 1, 2, 3, 5, 8, 13, 21/)
\end{chapel}
\end{example}

\subsection{Sequence Type Definitions}
\label{Sequence_Type_Definitions}
\index{sequences!types}

\index{seq@\chpl{seq}}
A sequence type can be specified with an explicit element type using
the following syntax:
\begin{syntax}
sequence-type:
  `seq' `of' type
  `seq' ( type )
  `seq' ( `eltType' = type )
\end{syntax}

The element type of a sequence can be referred to by its
name \chpl{eltType}.  If \chpl{s} is a sequence, then the
type \chpl{s.eltType} refers to the type of its elements.

\subsection{Sequence Rank}
\label{Sequence_Rank}
\index{sequences!rank}

The rank of a sequence is determined as follows:
\begin{itemize}
\item
If the element type of the sequence is not a sequence, then the rank
of the sequence is 1.
\item
If the element type of the sequence is a sequence of rank $k$, then
the rank of the sequence is $k+1$.
\end{itemize}
\begin{example}
The rank of the sequence specified by the type
\begin{chapel}
  seq of seq of int
\end{chapel}
is two.
\end{example}

\subsection{Sequence Assignment}
\label{Sequence_Assignment}
\index{sequences!assignment}

Sequence assignment is by value.

\subsection{Iteration over Sequences}
\label{Iteration_over_Sequences}
\index{sequences!iteration}

Sequences can be iterated over within the context of a for or forall
loop.  The type of the index is the element type of the sequence.
\begin{example}
In the code
\begin{chapel}
var ss: seq of string = (/"one", "two", "three"/);
for s in ss do
  writeln(s);
\end{chapel}
the sequence of strings \chpl{ss} is iterated over with
index \chpl{s} of type string.  The output to this code is
\begin{chapel}
one
two
three
\end{chapel}
\end{example}

\subsection{Sequence Concatenation}
\label{Sequence_Concatenation}

\index{\#@\chpl{\#}}
The operator \chpl{#} is used to concatenate two sequences and to
append or prepend an element to a sequence.  In each case, the
operands are unchanged and a new sequence is returned.  When applied
to two sequences, the new sequence is the concatenation of the two
sequences.  When applied to an element and a sequence, the new
sequence is a copy of the sequence with the element prepended to it.
When applied to a sequence and an element, the new sequence is a copy
of the sequence with the element appended to it.

The concatenation, prepend, and append operations apply to expressions
of types according to the rules of function resolution as specified by
the following function prototypes:
\begin{chapel}
def #(s1: seq, s2: seq) where s1.type == s2.type // concatenate
def #(e, s: seq) where e.type:s.eltType // prepend
def #(s: seq, e) where e.type:s.eltType // append
\end{chapel}

\subsection{Sequence Indexing}
\label{Sequence_Indexing}

Sequences can be indexed into by applying a function call to them.
They can be indexed into by integers or tuples of integers.

\subsubsection{Sequence Indexing by Integers}
\label{Sequence_Indexing_by_Integers}

\index{sequences!indexing}
If \chpl{s} is a sequence and \chpl{i} is an integer, then the
expression \chpl{s(i)} is evaluated to return an element in the
sequence.  A runtime error occurs if \chpl{i} is zero or the absolute
value of \chpl{i} is greater than the length of the sequence.  Let the
elements of the sequence be denoted as $e_1, e_2, \ldots, e_n$ where
$n$ is the length of the sequence.  If \chpl{i} is positive,
then \chpl{s(i)} is the value $e_i$.  If \chpl{i} is negative,
then \chpl{s(i)} is the value $e_{n-i+1}$.

\subsubsection{Sequence Indexing by Tuples}
\label{Sequence_Indexing_by_Tuples}

\index{sequences!indexing}
If \chpl{s} is a sequence and \chpl{t} is a tuple of integers of size
$k$, then the expression \chpl{s(t)} indexes into the
sequence \chpl{s} $k$ times using the integers in the tuple.  In this
case, \chpl{s} must be a sequence whose rank is at least as great as
the size of \chpl{t}.  If \chpl{s} has rank less than the size of the
tuple, then the result is a sequence.

If the integers in tuple \chpl{t} are denoted as \chpl{i1}, \chpl{i2},
$\ldots$, \chpl{ik}, then the expression \chpl{s(t)} is equivalent to
the expression \chpl{s(i1)(i2)}$\ldots$\chpl{(ik)}.

A sequence can also be indexed by multiple integers.  The integers are
collected into a tuple and the sequence is then indexed by the tuple.

\subsection{Sequence Promotion of Scalar Functions}
\label{Sequence_Promotion_of_Scalar_Functions}

\index{scalar promotion}
\index{sequences!promotion}
Sequence promotion of a scalar function is defined over the sequence
and its {\em leaf element type}.  If the sequence has rank one, then
the leaf element type is the element type of the sequence.  If the
sequence has rank greater than one, then the leaf element type is
defined to be the first element type encountered by recursively
indexing into the sequence such that the element type is not a
sequence.

If a variable of type equal to the leaf element type of the sequence
can be passed to a function's formal argument according to the rules
of function resolution in~\rsec{Function_Resolution}, then the
sequence can be passed to this function and the function is said to be
sequence promoted.  In general, it is said to be scalar promoted since
types other than sequences may result in the promotion.

\subsubsection{Zipper Promotion}
\label{Zipper_Promotion}

\index{scalar promotion!zipper iteration}
Consider a function \chpl{f} with formal
arguments \chpl{s1}, \chpl{s2},~... that are sequence promoted and
formal arguments \chpl{a1}, \chpl{a2},~... that are not promoted.  The
call
\begin{chapel}
f(s1, s2, ..., a1, a2, ...)
\end{chapel}
is equivalent to
\begin{chapel}
[(e1, e2, ...) in (s1, s2, ...)] f(e1, e2, ..., a1, a2, ...)
\end{chapel}
The usual constraints of zipper iteration apply to zipper promotion so
the sequences must have the same shape.

The result of the promotion is a sequence of the same rank but the
leaf element type is the return type of the function that is promoted.

\begin{example}
Given a function defined as
\begin{chapel}
def foo(i: int, j: int) {
  write(i, " ", j, " ");
}
\end{chapel}
and a call to this function written
\begin{chapel}
foo((/1, 2, 3/), (/4, 5, 6/));
\end{chapel}
then the output is ``1 4 2 5 3 6 ''.
\end{example}

\subsubsection{Tensor Product Promotion}
\label{Tensor_Product_Promotion}
\index{scalar promotion!tensor product iteration}

If the function \chpl{f} were called by using square brackets instead
of parentheses, the equivalent rewrite would be
\begin{chapel}
[(e1, e2, ...) in [s1, s2, ...]] f(e1, e2, ..., a1, a2, ...)
\end{chapel}
There are no constraints on tensor product promotion.

The result of the promotion is a sequence of rank equal to the sum of
the ranks of the promoted arguments.  The leaf element type of the
sequence is the return type of the function that is promoted.

\begin{example}
Given a function defined as
\begin{chapel}
def foo(i: int, j: int) {
  write(i, " ", j, " ");
}
\end{chapel}
and a call to this function written
\begin{chapel}
foo[(/1, 2, 3/), (/4, 5, 6/)];
\end{chapel}
then the output is ``1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6 ''.
\end{example}

\subsection{Sequence Operators}
\label{Sequence_Operators}

Any operator that can be applied to the leaf element type of a
sequence can be applied to the sequence according to the rules of
zipper promotion.
\begin{example}
Given two sequences of integers
\begin{chapel}
var s1 = (/1, 2, 3, 4, 5/);
var s2 = (/5, 4, 3, 2, 1/);
\end{chapel}
the sequence that is returned by applying the equality operator to the
sequences is a sequence of bool values.  The code
\begin{chapel}
writeln(s1 == s2);
\end{chapel}
produces the output ``false false true false false.''
\end{example}

\subsection{Sequences in Logical Contexts}
\label{Sequences_in_Logical_Contexts}
\index{sequences!and conditional statements}
\index{sequences!and while statements}

When a sequence expression is used as a top-level expression in the
condition of a while statement, a do-while statement or an if
statement, the sequence is promoted to a sequence of bool values
following the implicit statement bool conversion
rule~(\rsec{Implicit_Statement_Bool_Conversions}) applied to the leaf
element type of the sequence.

The sequence of bool values is then implicitly reduced using
the \chpl{&&} operator to produce a single bool value.  Reductions are
defined in~\rsec{Reductions_and_Scans}.

\begin{status}
Neither the implicit conversion nor the implicit reduction is
currently implemented.
\end{status}

\subsubsection{Sequences in Select Statements}
\label{Sequences_in_Select_Statements}
\index{sequences!and select statements}

When a sequence expression is used as a top-level expression in the
condition of a select statement, there are two interpretations.  If
the condition in the when expression is itself a sequence, the
equality operator is used to compare the sequences and then an
implicit \chpl{&&} reduction is applied to produce a single bool
value.  If the condition in the when expression is a scalar, the
equality operator is used to compare the sequences and then an
implicit \chpl{||} reduction is applied to produce a single bool
value.

\begin{status}
The implicit reduction is currently not implemented.  Sequences cannot
be used in the condition of a select statement or in the when
expression.
\end{status}

\subsection{Filtering Predicates}
\label{Filtering_Predicates}
\index{sequences!and conditional expressions}

An if expression that is immediately enclosed by a forall expression
does not require an else part.  The result of the forall expression is
a sequence of rank one.
\begin{example}
The following expression returns every other element in a sequence
starting with the first:
\begin{chapel}
[i in 1..s.length] if i % 2 == 1 then s(i)
\end{chapel}
\end{example}

\subsection{Methods and Functions on Sequences}
\label{Methods_and_Functions_on_Sequences}

\subsubsection{The {\em length} Method}
\label{The_em_length_Method}
\index{length@\chpl{length}!on sequences}

\begin{chapel}
def seq.length
\end{chapel}

The length method requires no parentheses and returns the number of
elements in a sequence.

\subsubsection{The {\em reverse} Method}
\label{The_em_reverse_Method}
\index{reverse@\chpl{reverse}}

\begin{chapel}
def seq.reverse(dim: int = 1)
\end{chapel}

The reverse method returns the elements of a sequence in reverse
order.  An optional second argument is an int. If the value of this
argument is $d$, then the rank of the first argument must be at least
$d$. When $d$ is one, then the sequence is reversed. When $d$ is
greater than one, the expression \chpl{s.reverse(d)} is equivalent to
\begin{chapel}
[e in s] e.reverse(d-1)
\end{chapel}

\begin{status}
The \chpl{dim} argument is not implemented.
\end{status}

\subsubsection{The {\em spread} Function}
\label{The_em_spread_Function}
\index{spread@\chpl{spread}}

\begin{chapel}
def spread(s: seq, length: int, dim: int = 1)
\end{chapel}

The spread function takes a sequence of rank $k$ and returns a new
sequence of rank $k+1$.  When \chpl{dim} is equal to 1, the result is
a sequence where every element is equal to $s$.  The length of this
sequence is specified by \chpl{length}.  When \chpl{dim} is greater
than one, we generate the sequence:
\begin{chapel}
[e in s] spread(e, length, dim-1)
\end{chapel}

\begin{status}
The spread function is not implemented.
\end{status}

\subsubsection{The {\em transpose} Function}
\label{The_em_transpose_Function}
\index{transpose@\chpl{transpose}}

\begin{chapel}
def transpose(s: seq, dims = (2,1))
\end{chapel}

The transpose function will reorder both the values and change the
shape of the sequence. The optional \chpl{dims} argument is a tuple
that corresponds to a permutation of the values $1..p$ where $p$ is
less than or equal to the rank of the input sequence. This list
defines a permutation of the subscripts such that the following
relationship holds between the input and output sequences:
$$
    s'(i'_1,\ldots,i'_k) = s(i_1,\ldots,i_k)
$$
where
$$
    i_j = \left\{\begin{array}{ll}
                 i'_{\it dims(j)} & \mbox{if $j\le p$}\\
		 i'_j & \mbox{otherwise}
		 \end{array}
          \right.
$$

There is a somewhat complex requirement in the shape of the input
sequence so that this relation is well-defined. In the simple case of
a rank-2 input, we require that all elements of the sequence have the
same length.  In the general case we require all sequences selected by
a $q$-tuple to have the same length whenever an index position $q$ is
less than $p$.

\begin{status}
The transpose function is not implemented.
\end{status}

\subsubsection{The {\em reshape} Function}
\label{The_em_reshape_Function}
\index{reshape@\chpl{reshape}}

\begin{chapel}
reshape(s: seq, shape, fill)
\end{chapel}

This reshape function returns a sequence whose leaves are the same as
the first argument, in the same order but whose shape matches that
of \chpl{shape}. The \chpl{shape} argument might be a sequence or it
might be a tuple of ints. When it is a sequence, the output will
conform to that sequence. When the shape is a tuple, then the shape of
the output conforms to the shape of the arithmetic index set that
would be determined by \chpl{1..shape}.

If present, the \chpl{fill} argument specifies a value to be used to
pad the sequence if the number of leaf values in that sequence is too
few to conform with \chpl{shape}. If the input sequence has too many
values, it is truncated.

\begin{status}
The reshape function is not implemented.
\end{status}



\subsection{Conversions Between Sequences and Tuples}
\label{Conversions_Between_Sequences_and_Tuples}
\index{sequences!casts from tuples}
\index{tuples!casts from sequences}

A value of homogenous tuple type can be converted to a sequence by
applying a cast to the keyword \chpl{seq}.  The elements in the tuple
become the elements in the sequence and the sequence's length is the
size of the tuple.

A value of sequence type can be converted to a homogeneous tuple type
by applying a cast to a parameter of type int.  If the parameter has
value $k$ then the tuple is of size $k$ and the first $k$ elements in
the sequence are the elements in the tuple.
