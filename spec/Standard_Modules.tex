\sekshun{Standard Modules}
\label{Standard_Modules}
\index{standard modules}

This section describes modules that are automatically used by every
Chapel program as well as a set of standard modules that can be used
manually, provididing standard library support.  The automatic modules
are as follows:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{Math} & Math routines \\
             & \chpl{Standard} & Basic routines \\
             & \chpl{Types} & Routines related to primitive types \\
\end{tabular}

\noindent The standard modules include:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{BitOps} & Bit manipulation routines \\
             & \chpl{Norm}   & routines for computing vector and matrix norms \\
             & \chpl{Random} & Random number generation routines \\
             & \chpl{Search} & Generic searching routines \\
             & \chpl{Sort} & Generic sorting routines \\
             & \chpl{Time} & Types and routines related to time \\
\end{tabular}

There is an expectation that each of these modules will be extended
and that more standard modules will be defined over time.

\subsection{Automatic Modules}
\index{automatic modules}

Automatic modules are used by a Chapel program automatically.  There
is currently no way to avoid their use by a program though we
anticipate adding such a capability in the future.

\subsubsection{Math}
\label{Math}
\index{automatic modules!Math}

The module \chpl{Math} defines routines for mathematical computations.
This module is used by default; there is no need to explicitly use
this module.  The Math module defines routines that are derived from
and implemented via the standard C routines defined in \chpl{math.h}.

\vspace{1pc}

\begin{protohead}
def abs(i: int(?w)): int(w)
def abs(i: uint(?w)): uint(w)
def abs(x: real): real
def abs(x: real(32)): real(32)
def abs(x: complex): real
\end{protohead}
\begin{protobody}
Returns the absolute value of the argument.
\end{protobody}

\begin{protohead}
def acos(x: real): real
def acos(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc cosine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def acosh(x: real): real
def acosh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic cosine of the argument.  It is an error
if \chpl{x} is less than $1$.
\end{protobody}

\begin{protohead}
def asin(x: real): real
def asin(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc sine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def asinh(x: real): real
def asinh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
def atan(x: real): real
def atan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc tangent of the argument.
\end{protobody}

\begin{protohead}
def atan2(y: real, x: real): real
def atan2(y: real(32), x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc tangent of the two arguments.  This is equivalent to
the arc tangent of \chpl{y / x} except that the signs of \chpl{y}
and \chpl{x} are used to determine the quadrant of the result.
\end{protobody}

\begin{protohead}
def atanh(x: real): real
def atanh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic tangent of the argument.  It is an error
if \chpl{x} is less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def cbrt(x: real): real
def cbrt(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the cube root of the argument.
\end{protobody}

\begin{protohead}
def ceil(x: real): real
def ceil(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded up to the nearest integer.
\end{protobody}

\begin{protohead}
def conjg(a: complex(?w)): complex(w)
\end{protohead}
\begin{protobody}
Returns the conjugate of \chpl{a}.
\end{protobody}

\begin{protohead}
def cos(x: real): real
def cos(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the cosine of the argument.
\end{protobody}

\begin{protohead}
def cosh(x: real): real
def cosh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic cosine of the argument.
\end{protobody}

\begin{protohead}
def erf(x: real): real
def erf(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the error function of the argument defined as
$$\frac{2}{\sqrt{\pi}}\int^x_0e^{-t^2}dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
def erfc(x: real): real
def erfc(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the complementary error function of the argument.  This is
equivalent to \chpl{1.0 - erf(x)}.
\end{protobody}

\begin{protohead}
def exp(x: real): real
def exp(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def exp2(x: real): real
def exp2(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of $2$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def expm1(x: real): real
def expm1(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns one less than the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def floor(x: real): real
def floor(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded down to the nearest integer.
\end{protobody}

\begin{protohead}
def lgamma(x: real): real
def lgamma(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the absolute value of the gamma
function of the argument.
\end{protobody}

\begin{protohead}
def log(x: real): real
def log(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def log10(x: real): real
def log10(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the base 10 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def log1p(x: real): real
def log1p(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of \chpl{x+1}.  It is an error
if \chpl{x} is less than or equal to $-1$.
\end{protobody}

\begin{protohead}
def log2(i: int(?w)): int(w)
def log2(i: uint(?w)): uint(w)
def log2(x: real): real
def log2(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the base 2 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def nearbyint(x: real): real
def nearbyint(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
def rint(x: real): real
def rint(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
def round(x: real): real
def round(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument.  Cases halfway
between two integral values are rounded towards zero.
\end{protobody}

\begin{protohead}
def sin(x: real): real
def sin(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the sine of the argument.
\end{protobody}

\begin{protohead}
def sinh(x: real): real
def sinh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
def sqrt(x: real): real
def sqrt(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the square root of the argument.  It is an error if the
argument is less than zero.
\end{protobody}

\begin{protohead}
def tan(x: real): real
def tan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the tangent of the argument.
\end{protobody}

\begin{protohead}
def tanh(x: real): real
def tanh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic tangent of the argument.
\end{protobody}

\begin{protohead}
def tgamma(x: real): real
def tgamma(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the gamma function of the argument defined as
$$\int_0^\infty t^{x-1} e^{-t} dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
def trunc(x: real): real
def trunc(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the nearest integral value to the argument that is not larger
than the argument in absolute value.
\end{protobody}


\subsubsection{Standard}
\label{Standard}
\index{automatic modules!Standard}

\begin{protohead}
def ascii(s: string): int
\end{protohead}
\begin{protobody}
Returns the ASCII code number of the first letter in the
argument \chpl{s}.
\end{protobody}

\begin{protohead}
def assert(test: bool) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert}.
If \chpl{test} is true, no action is taken.
\end{protobody}

\begin{protohead}
def assert(test: bool, args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert} as well
as the rest of the arguments to the call.  If \chpl{test} is true, no
action is taken.
\end{protobody}

\begin{protohead}
def complex.re: real
\end{protohead}
\begin{protobody}
Returns the real component of the complex number.
\end{protobody}

\begin{protohead}
def complex.im: real
\end{protohead}
\begin{protobody}
Returns the imaginary component of the complex number.
\end{protobody}

\begin{protohead}
def complex.=re(f: real)
\end{protohead}
\begin{protobody}
Sets the real component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
def complex.=im(f: real)
\end{protohead}
\begin{protobody}
Sets the imaginary component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
def exit(status: int)
\end{protohead}
\begin{protobody}
Exits the program with code \chpl{status}.
\end{protobody}

\begin{protohead}
def halt() {
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
def halt(args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
def length(s: string): int
\end{protohead}
\begin{protobody}
Returns the number of characters in the argument \chpl{s}.
\end{protobody}

\begin{protohead}
def max(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the maximum of the arguments when compared using the
``greater-than'' operator.  The return type is inferred from the types
of the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
def min(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the minimum of the arguments when compared using the
``less-than'' operator.  The return type is inferred from the types of
the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
def string.substring(x): string
\end{protohead}
\begin{protobody}
Returns a value of string type that is a substring of the base
expression.  If \chpl{x} is $i$, a value of type \chpl{int}, then the
result is the $i$th character.  If \chpl{x} is a range, the result is
the substring where the characters in the substring are given by the
values in the range.
\end{protobody}


\subsubsection{Types}

\begin{protohead}
def numBits(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bits used to store the values of type \chpl{t}.
This is implemented for all numeric types and \chpl{bool}.
\end{protobody}


\begin{protohead}
def numBytes(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bytes used to store the values of type \chpl{t}.
This is implemented for all numeric types and \chpl{bool}.
\end{protobody}

\begin{protohead}
def max(type t): t
\end{protohead}
\begin{protobody}
Returns the maximum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

\begin{protohead}
def min(type t): t
\end{protohead}
\begin{protobody}
Returns the minimum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}



\subsection{Standard Modules}

Standard modules can be used by a Chapel program via the \chpl{use}
keyword.

\subsubsection{BitOps}
\label{BitOps}
\index{standard modules!BitOps}

The module \chpl{BitOps} defines routines that manipulate the bits of
values of integral types.

\vspace{1pc}

\begin{protohead}
def bitPop(i: integral): int
\end{protohead}
\begin{protobody}
Returns the number of bits set to one in the integral
argument \chpl{i}.
\end{protobody}

\begin{protohead}
def bitMatMultOr(i: uint(64), j: uint(64)): uint(64)
\end{protohead}
\begin{protobody}
Returns the bitwise matrix multiplication of \chpl{i} and \chpl{j}
where the values of \chpl{uint(64)} type are treated as $8 \times 8$
bit matrices and the combinator function is bitwise or.
\end{protobody}

\begin{protohead}
def bitRotLeft(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the left \chpl{shift} number of times.
\end{protobody}

\begin{protohead}
def bitRotRight(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the right \chpl{shift} number of times.
\end{protobody}


\subsubsection{Norm}
\label{Norm}
\index{standard modules!Norm}

The module \chpl{Norm} supports the computation of standard vector and
matrix norms on Chapel arrays.  The current interface is minimal and
should be expected to grow and evolve over time.

\begin{protohead}
enum normType {norm1, norm2, normInf, normFrob};
\end{protohead}
\begin{protobody}
An enumerated type indicating the different types of norms supported
by this module: 1-norm, 2-norm, infinity norm and Frobenius norm,
respectively.
\end{protobody}

\begin{protohead}
def norm(x: [], p: normType) where x.rank == 1 || x.rank == 2
\end{protohead}
\begin{protobody}
Compute the norm indicated by \chpl{p} on the 1D or 2D array \chpl{x}.
\end{protobody}

\begin{protohead}
def norm(x: [])
\end{protohead}
\begin{protobody}
Compute the default norm on array \chpl{x}.  For a 1D array this is
the 2-norm, for a 2D array, this is the Frobenius norm.
\end{protobody}


\subsubsection{Random}
\label{Random}
\index{standard modules!Random}

The module \chpl{Random} supports the generation of pseudo-random
values and streams of values.  The current interface is minimal and
should be expected to grow and evolve over time.

\begin{protohead}
class RandomStream
\end{protohead}
\begin{protobody}
Implements a pseudo-random stream of values.  Our current
implementation generates the values using a linear congruential
generator.  In future versions of this module, the RandomStream class
will offer a wider variety of algorithms for generating pseudo-random
values.
\end{protobody}

\begin{protohead}
const RandomStream.seed: int(64)
\end{protohead}
\begin{protobody}
The seed value for the random stream.  If no seed is specified in the
constructor, the millisecond value of the current time is used.  The
seed value must be an odd integer.  If an even integer is supplied,
the class constructor will increment it to obtain an odd integer.
\end{protobody}

\begin{protohead}
def RandomStream.fillRandom(x:[?D] real)
\end{protohead}
\begin{protobody}
Fill the argument array, \chpl{x}, with the next $|$\chpl{D}$|$ values
of the pseudo-random stream.  Arrays of arbitrary rank can be passed
to this routine, causing the 1D stream of values to be mapped to the
array elements according to the array's default iteration order.  Once
our implementation supports distributed arrays, this routine is
intended to fill the array's values in parallel.
\end{protobody}

\begin{protohead}
def RandomStream.fillRandom(x:[?D] complex)
\end{protohead}
\begin{protobody}
Similar to the previous routine, but for use with arrays of complex
values.  The elements are filled in the same order as above except
that pairs of values from the stream are assigned to each element, the
first to the real component, the second to the imaginary.  As this
module matures, we will support \chpl{fillRandom} for arrays of other
element types as well.
\end{protobody}

\begin{protohead}
def RandomStream.skipToNth(in n: integral)
\end{protohead}
\begin{protobody}
Skips ahead or back to the \chpl{n}-th value in the
random stream.  The value of n is assumed to be positive, such that
\chpl{n}~==~1 represents the initial value in the stream.
\end{protobody}

\begin{protohead}
def RandomStream.getNext(): real
\end{protohead}
\begin{protobody}
Returns the next value in the random stream as a real.
\end{protobody}

\begin{protohead}
def RandomStream.getNth(n: integral): real
\end{protohead}
\begin{protobody}
Returns the \chpl{n}-th value in the random stream as a real.  Equivalent to
calling \chpl{skipToNth(n)} followed by \chpl{getNext()}.
\end{protobody}

\begin{protohead}
SeedGenerator
\end{protohead}
\begin{protobody}
A symbol that can be used to generate seed values for the RandomStream
class.
\end{protobody}

\begin{protohead}
SeedGenerator.clockMS
\end{protohead}
\begin{protobody}
Generates a seed value using the milliseconds value from the current
time.  As this module matures, \chpl{SeedGenerator} will support
additional mechanisms for generating seed values.
\end{protobody}

\begin{protohead}
def fillRandom(x:[], initseed: int(64))
\end{protohead}
\begin{protobody}

A routine provided for convenience to support filling an array
\chpl{x} with pseudo-random values without explicitly constructing an
instance of the \chpl{RandomStream} class, useful for filling a single
array or multiple arrays which require no coherence between them.  The
\chpl{initseed} parameter corresponds to the \chpl{seed} member of the
\chpl{RandomStream} class and will default to the milliseconds value
of the current time if no seed value is provided.
\end{protobody}


\subsubsection{Search}
\label{Search}
\index{standard modules!Search}

The \chpl{Search} module is designed to support standard search
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
def LinearSearch(Data: [?Dom], val): (bool, index(Dom))
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential linear search.  Returns a tuple
indicating (1) whether or not the value was found and (2) the location
of the value if it was found, or the location where the value should
have been if it was not found.
\end{protobody}


\begin{protohead}
def BinarySearch(Data: [?Dom], val, in lo = Dom.low, in hi = Dom.high);
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential binary search.  If provided, only
the indices \chpl{lo} through \chpl{hi} will be considered, otherwise
the whole array will be searched.  Returns a tuple indicating (1)
whether or not the value was found and (2) the location of the value
if it was found, or the location where the value should have been if
it was not found.
\end{protobody}


\subsubsection{Sort}
\label{Sort}
\index{standard modules!Sort}

The \chpl{Sort} module is designed to support standard sorting
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
def InsertionSort(Data: [?Dom]) where Dom.rank == 1;
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential insertion
sort algorithm.
\end{protobody}

\begin{protohead}
def QuickSort(Data: [?Dom]) where Dom.rank == 1;
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential
implementation of the QuickSort algorithm.
\end{protobody}

\subsubsection{Time}
\label{Time}
\index{standard modules!Time}

The module \chpl{Time} defines routines that query the system time and
a record \chpl{Timer} that is useful for timing portions of code.

\vspace{1pc}

\begin{protohead}
record Timer
\end{protohead}
\begin{protobody}
A timer is used to time portions of code.  Its semantics are similar
to a stopwatch.
\end{protobody}

\begin{protohead}
enum TimeUnits { microseconds, milliseconds, seconds, minutes, hours };
\end{protohead}
\begin{protobody}
The enumeration TimeUnits defines units of time.  These units can be
supplied to routines in this module to specify the desired time units.
\end{protobody}

\begin{protohead}
enum Day { sunday=0, monday, tuesday, wednesday, thursday, friday, saturday };
\end{protohead}
\begin{protobody}
The enumeration Day defines the days of the week, with Sunday defined to be 0.
\end{protobody}


\begin{protohead}
def getCurrentDate(): (int, int, int)
\end{protohead}
\begin{protobody}
Returns the year, month, and day of the month as integers.  The year
is the year since 0.  The month is in the range 1 to 12.  The day is
in the range 1 to 31.
\end{protobody}

\begin{protohead}
def getCurrentDayOfWeek(): Day
\end{protohead}
\begin{protobody}
Returns the current day of the week.
\end{protobody}


\begin{protohead}
def getCurrentTime(unit: TimeUnits = TimeUnits.seconds): real
\end{protohead}
\begin{protobody}
Returns the elapsed time since midnight in the units specified.
\end{protobody}

\begin{protohead}
def Timer.clear()
\end{protohead}
\begin{protobody}
Clears the elapsed time stored in the Timer.
\end{protobody}

\begin{protohead}
def Timer.elapsed(unit: TimeUnits = TimeUnits.seconds): real
\end{protohead}
\begin{protobody}
Returns the cumulative elapsed time, in the units specified, between
calls to \chpl{start} and \chpl{stop}.  If the timer is running, the
elapsed time since the last call to \chpl{start} is added to the
return value.
\end{protobody}

\begin{protohead}
def Timer.start()
\end{protohead}
\begin{protobody}
Start the timer.  It is an error to start a timer that is already
running.
\end{protobody}

\begin{protohead}
def Timer.stop()
\end{protohead}
\begin{protobody}
Stops the timer.  It is an error to stop a timer that is not running.
\end{protobody}

\begin{protohead}
def sleep(t: uint)
\end{protohead}
\begin{protobody}
Delays a task for \chpl{t} seconds.
\end{protobody}

