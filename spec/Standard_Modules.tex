\sekshun{Standard Modules}
\label{Standard_Modules}
\index{standard modules}
\index{modules!standard}

Standard modules provide standard library support
and are available to every Chapel program.
The functions and other definitions of automatic modules are always
available to a Chapel program.
Optional modules can be accessed via use statements
(\rsec{Using_Modules}).  

The automatic modules
are as follows:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{Base} & Basic routines \\
             & \chpl{Math} & Math routines \\
             & \chpl{Types} & Routines related to primitive types \\
\end{tabular}

\noindent The optional modules include:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{AdvancedIters} & Advanced iterator functions \\
             & \chpl{BitOps} & Bit manipulation routines \\
             & \chpl{Norm}   & Routines for computing vector and matrix norms \\
             & \chpl{Search} & Generic searching routines \\
             & \chpl{Sort} & Generic sorting routines \\
             & \chpl{Time} & Types and routines related to time \\
             & \chpl{UtilMath} & Math-related utilities \\
\end{tabular}

There is an expectation that each of these modules will be extended
and that more standard modules will be defined over time.

We list functions in alphabetical order for each module.



\section{Automatic Modules}
\index{automatic modules (see also modules, standard, automatic)}
\index{standard modules!automatic (see also modules, standard, automatic)}
\index{modules!standard!automatic}

Automatic modules are used by a Chapel program automatically.  There
is currently no way to avoid their use by a program, although we
anticipate adding such a capability in the future.


\subsection{Base}
\label{Standard}
\index{modules!standard!Base@\chpl{Base}}
\index{modules!standard!automatic!Base@\chpl{Base}}

\begin{protohead}
proc ascii(s: string): int
\end{protohead}
\begin{protobody}
Returns the ASCII code number of the first letter in the
argument \chpl{s}.
\end{protobody}

\begin{protohead}
proc assert(test: bool)
proc assert(test: bool, args...)
\end{protohead}
\begin{protobody}
If \chpl{test} is true, no action is taken.
If \chpl{test} is false,
prints an error message to stderr giving the location of the call to \chpl{assert}
in the Chapel source, followed by the remaining arguments to the call, if any,
then exits the program.
\end{protobody}

\begin{protohead}
proc complex.re: real
\end{protohead}
\begin{protobody}
Returns the real component of the complex number.
\end{protobody}

\begin{protohead}
proc complex.im: real
\end{protohead}
\begin{protobody}
Returns the imaginary component of the complex number.
\end{protobody}

\begin{protohead}
proc complex.=re(f: real)
\end{protohead}
\begin{protobody}
Sets the real component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
proc complex.=im(f: real)
\end{protohead}
\begin{protobody}
Sets the imaginary component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
proc exit(status: int)
\end{protohead}
\begin{protobody}
Exits the program with code \chpl{status}.
\end{protobody}

\begin{protohead}
proc halt()
proc halt(args...)
\end{protohead}
\begin{protobody}
Prints an error message to stderr giving the location of the call to \chpl{halt}
in the Chapel source, followed by the arguments to the call, if any,
then exits the program.
\end{protobody}

\begin{protohead}
proc string.length: int
\end{protohead}
\begin{protobody}
Returns the number of characters in the base expression of type string.
\end{protobody}

\begin{protohead}
proc max(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the maximum of the arguments when compared using the
``greater-than'' operator.  The return type is inferred from the types
of the arguments as allowed by implicit conversions.
\end{protobody}

\begin{protohead}
proc min(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the minimum of the arguments when compared using the
``less-than'' operator.  The return type is inferred from the types of
the arguments as allowed by implicit conversions.
\end{protobody}

\begin{protohead}
proc string.size: int
\end{protohead}
\begin{protobody}
Same as string.length.
\end{protobody}

\begin{protohead}
proc string.substring(x): string
\end{protohead}
\begin{protobody}
Returns a value of string type that is a substring of the base
expression.  If \chpl{x} is $i$, a value of type \chpl{int}, then the
result is the $i$th character.  If \chpl{x} is a range, the result is
the substring where the characters in the substring are given by the
values in the range.
\end{protobody}

\begin{protohead}
proc typeToString(type t) param : string
\end{protohead}
\begin{protobody}
Returns a string parameter that represents the name of the
type \chpl{t}.
\end{protobody}

\begin{protohead}
proc warning(s:string)
proc warning(args...)
\end{protohead}
\begin{protobody}
Prints a warning to stderr giving the location of the call to \chpl{warning}
in the Chapel source, followed by the argument(s) to the call.
\end{protobody}


\subsection{Math}
\label{Math}
\index{modules!standard!Math@\chpl{Math}}
\index{modules!standard!automatic!Math@\chpl{Math}}

The module \chpl{Math} defines routines for mathematical computations.
This module is used by default; there is no need to explicitly use
this module.  The Math module defines routines that are derived from
and implemented via the standard C routines defined in \chpl{math.h}.

\vspace{1pc}

\begin{protohead}
proc abs(i: int(?w)): int(w)
proc abs(i: uint(?w)): uint(w)
proc abs(param i: integral) param
proc abs(x: real): real
proc abs(x: real(32)): real(32)
proc abs(x: imag): real;
proc abs(x: imag(32)): real(32);
proc abs(x: complex): real
\end{protohead}
\begin{protobody}
Returns the absolute value of the argument.
\end{protobody}

\begin{protohead}
proc acos(x: real): real
proc acos(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc cosine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
proc acosh(x: real): real
proc acosh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic cosine of the argument.  It is an error
if \chpl{x} is less than $1$.
\end{protobody}

\begin{protohead}
proc asin(x: real): real
proc asin(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc sine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
proc asinh(x: real): real
proc asinh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
proc atan(x: real): real
proc atan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc tangent of the argument.
\end{protobody}

\begin{protohead}
proc atan2(y: real, x: real): real
proc atan2(y: real(32), x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc tangent of the two arguments.  This is equivalent to
the arc tangent of \chpl{y / x} except that the signs of \chpl{y}
and \chpl{x} are used to determine the quadrant of the result.
\end{protobody}

\begin{protohead}
proc atanh(x: real): real
proc atanh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic tangent of the argument.  It is an error
if \chpl{x} is less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
proc cbrt(x: real): real
proc cbrt(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the cube root of the argument.
\end{protobody}

\begin{protohead}
proc ceil(x: real): real
proc ceil(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded up to the nearest integer.
\end{protobody}

\begin{protohead}
proc conjg(a: complex(?w)): complex(w)
\end{protohead}
\begin{protobody}
Returns the conjugate of \chpl{a}.
\end{protobody}

\begin{protohead}
proc cos(x: real): real
proc cos(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the cosine of the argument.
\end{protobody}

\begin{protohead}
proc cosh(x: real): real
proc cosh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic cosine of the argument.
\end{protobody}

\begin{protohead}
proc divceil(m: integral, n: integral)
proc divceil(param m: integral, param n: integral) param
\end{protohead}
\begin{protobody}
Returns
$\lceil\frac{m}{n}\rceil$,
i.e., the fraction $m/n$ rounded up to the nearest integer.
\end{protobody}

\begin{protohead}
proc divfloor(m: integral, n: integral)
proc divfloor(param m: integral, param n: integral) param
\end{protohead}
\begin{protobody}
Returns
$\lfloor\frac{m}{n}\rfloor$,
i.e., the fraction $m/n$ rounded down to the nearest integer.
\end{protobody}

\begin{protohead}
proc erf(x: real): real
proc erf(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the error function of the argument defined as
$$\frac{2}{\sqrt{\pi}}\int^x_0e^{-t^2}dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
proc erfc(x: real): real
proc erfc(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the complementary error function of the argument.  This is
equivalent to \chpl{1.0 - erf(x)}.
\end{protobody}

\begin{protohead}
proc exp(x: real): real
proc exp(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
proc exp2(x: real): real
proc exp2(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of $2$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
proc expm1(x: real): real
proc expm1(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns one less than the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
proc floor(x: real): real
proc floor(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded down to the nearest integer.
\end{protobody}

\begin{protohead}
const INFINITY: real(64);
\end{protohead}
\begin{protobody}
Supplies the floating point constant for infinity.
\end{protobody}

\begin{protohead}
proc isfinite(x: real): real
proc isfinite(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns whether or not a particular value is finite.
\end{protobody}

\begin{protohead}
proc isinf(x: real): real
proc isinf(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns whether or not a particular value is infinite.
\end{protobody}

\begin{protohead}
proc isnan(x: real): real
proc isnan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns whether or not a particular value is not a number.
\end{protobody}

\begin{protohead}
proc lgamma(x: real): real
proc lgamma(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the absolute value
of the gamma function of the argument.
\end{protobody}

\begin{protohead}
proc log(x: real): real
proc log(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
proc log10(x: real): real
proc log10(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the base 10 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
proc log1p(x: real): real
proc log1p(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of \chpl{x+1}.  It is an error
if \chpl{x} is less than or equal to $-1$.
\end{protobody}

\begin{protohead}
proc log2(i: int(?w)): int(w)
proc log2(i: uint(?w)): uint(w)
proc log2(x: real): real
proc log2(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the base 2 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
proc mod(x: real(?w), y: real(w)): real(w)
proc mod(m: integral, n: integral)
proc mod(param m: integral, param n: integral) param
\end{protohead}
\begin{protobody}
Computes the mod operator on the two numbers, defined as
\chpl{mod(x,y)} = $x - y \lfloor\frac{m}{n}\rfloor$.
\end{protobody}

\begin{protohead}
const NAN: real(64);
\end{protohead}
\begin{protobody}
Supplies the floating point constant for not a number.
\end{protobody}

\begin{protohead}
proc nearbyint(x: real): real
proc nearbyint(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
proc rint(x: real): real
proc rint(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
proc round(x: real): real
proc round(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument.  Cases halfway
between two integral values are rounded towards zero.
\end{protobody}

\begin{protohead}
proc sgn(i : int(?w)):   int(8);
proc sgn(i : uint(?w)): uint(8);
proc sgn(x : real(?w)):  int(8);
proc sgn(param i : integral) param;
\end{protohead}
\begin{protobody}
Returns the signum function of its argument:
1 if positive, -1 if negative, 0 if zero.
\end{protobody}

\begin{protohead}
proc sin(x: real): real
proc sin(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the sine of the argument.
\end{protobody}

\begin{protohead}
proc sinh(x: real): real
proc sinh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
proc sqrt(x: real): real
proc sqrt(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the square root of the argument.  It is an error if the
argument is less than zero.
\end{protobody}

\begin{protohead}
proc tan(x: real): real
proc tan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the tangent of the argument.
\end{protobody}

\begin{protohead}
proc tanh(x: real): real
proc tanh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic tangent of the argument.
\end{protobody}

\begin{protohead}
proc tgamma(x: real): real
proc tgamma(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the gamma function of the argument defined as
$$\int_0^\infty t^{x-1} e^{-t} dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
proc trunc(x: real): real
proc trunc(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the nearest integral value to the argument that is not larger
than the argument in absolute value.
\end{protobody}


\subsection{Types}
\label{Types_standard_module}
\index{modules!standard!Types@\chpl{Types}}
\index{modules!standard!automatic!Types@\chpl{Types}}

\begin{protohead}
proc isProperSubtype(type sub, type super) param : bool
\end{protohead}
\begin{protobody}
Indicates whether \chpl{sub} is a proper subtype of \chpl{super}.
The proper subtype relationship holds if \chpl{sub} is a class or
a record type that inherits, directly or indirectly, from \chpl{super}.
\end{protobody}

\begin{protohead}
proc isSubtype(type sub, type super) param : bool
\end{protohead}
\begin{protobody}
Indicates whether \chpl{sub} is a subtype of \chpl{super}.
The subtype relationship holds if the proper subtype relationship holds
(see \chpl{isProperSubtype}) or if \chpl{sub} is a subtype of \chpl{super}
are the same type.
\end{protobody}

\begin{protohead}
proc max(type t): t
\end{protohead}
\begin{protobody}
Returns the maximum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

\begin{protohead}
proc min(type t): t
\end{protohead}
\begin{protobody}
Returns the minimum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

\begin{protohead}
proc numBits(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bits used to store the values of type \chpl{t}.
This is implemented for all numeric types and fixed-width \chpl{bool} types.
It is not implemented for default-width \chpl{bool}.
\end{protobody}

\begin{protohead}
proc numBytes(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bytes used to store the values of type \chpl{t}.
This is implemented for all numeric types and fixed-width \chpl{bool} types.
It is not implemented for default-width \chpl{bool}.
\end{protobody}

The \chpl{Types} module also provides a set of type queries.
These are documented in the following README in the Chapel release:
\chpl{doc/technotes/README.typeQueries} .


\section{Optional Modules}
\index{optional modules (see also modules, optional)}
\index{modules!standard!optional}

Optional modules can be used by a Chapel program via the \chpl{use}
keyword (\rsec{Using_Modules}).


\subsection{AdvancedIters}
\label{AdvancedIters}
\index{modules!standard!AdvancedIters@\chpl{AdvancedIters}}

The \chpl{AdvancedIters} module contains several iterators that can be
used to drive a \chpl{forall} loop by performing dynamic and adaptive splitting
of a range's iterations.

\begin{protohead}
iter dynamic(r:range(?), chunkSize:int, numTasks:int=0) {
\end{protohead}
\begin{protobody}

  This iterator is equivalent to the dynamic scheduling approach of
  OpenMP: Given an input range \chpl{r}, each task (of
  \chpl{numTasks}) is assigned chunks of size \chpl{chunkSize} from
  \chpl{r} (or the remaining iterations if there are fewer than
  \chpl{chunkSize}). This continues until there are no remaining
  iterations in \chpl{r}.  If \chpl{numTasks} has the value 0, it will
  use the value indicated by \chpl{dataParTasksPerLocale}
  (\rsec{data_parallel_knobs}).

\end{protobody}

\begin{protohead}
iter guided(r:range(?), numTasks:int = 0)
\end{protohead}
\begin{protobody}
  This iterator is equivalent to the guided policy of OpenMP: Given an
  input range \chpl{r}, each task (of \chpl{numTasks}) is assigned
  chunks of variable size, until there are no remaining iterations in
  \chpl{r}. The size of each chunk is the number of unassigned
  iterations divided by the number of tasks, \chpl{numTasks}. The size
  decreases approximately exponentially to 1. The splitting strategy
  is therefore adaptive.  If \chpl{numTasks} has the value 0, it will
  use the value indicated by \chpl{dataParTasksPerLocale}
  (\rsec{data_parallel_knobs}).

\end{protobody}

\begin{protohead}
iter adaptive(r:range(?), numTasks:int = 0)
\end{protohead}
\begin{protobody}
  This iterator implements a naive adaptive binary splitting
  work-stealing strategy: Initially the leader iterator distributes
  the range to split, \chpl{r}, evenly among the \chpl{numTasks}
  tasks.  If \chpl{numTasks} has the value 0, it will use the value
  indicated by \chpl{dataParTasksPerLocale}
  (\rsec{data_parallel_knobs}).

  Then, each task performs adaptive splitting on its local
  sub-range's iterations. When a task exhausts its local iterations,
  it steals and splits from the range of another task (the
  victim). The splitting method on the local range and on the victim
  range is binary: i.e. the size of each chunk is computed as the
  number of unassigned iterations divided by 2. There are three
  stealing strategies that can be selected at compile time using the
  config param \chpl{methodStealing}:

\begin{itemize}

\item \chpl{methodStealing}=0 : Each task without work tries to steal
  from its neighbor range until it exhausts that range. Then the task
  continues with the next neighbor range, and so on until there is no
  more work.  This is the default policy.

\item \chpl{methodStealing}=1: Each task without work tries to steal
  once from its neighbor range, next from the following neighbor range
  and so on in a round-robin way until there is no more work.

\item \chpl{methodStealing}=2: Similar to method 0, but now the
  splitting in the victim range is performed from its tail.
\end{itemize}

\end{protobody}


\subsection{BitOps}
\label{BitOps}
\index{modules!standard!BitOps@\chpl{BitOps}}

The module \chpl{BitOps} defines routines that manipulate the bits of
values of integral types.

\vspace{1pc}

\begin{protohead}
proc bitPop(i: integral): int
\end{protohead}
\begin{protobody}
Returns the number of bits set to one in the integral
argument \chpl{i}.
\end{protobody}

\begin{protohead}
proc bitMatMultOr(i: uint(64), j: uint(64)): uint(64)
\end{protohead}
\begin{protobody}
Returns the bitwise matrix multiplication of \chpl{i} and \chpl{j}
where the values of \chpl{uint(64)} type are treated as $8 \times 8$
bit matrices and the combinator function is bitwise or.
\end{protobody}

\begin{protohead}
proc bitRotLeft(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the left \chpl{shift} number of times.
\end{protobody}

\begin{protohead}
proc bitRotRight(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the right \chpl{shift} number of times.
\end{protobody}


\subsection{Norm}
\label{Norm}
\index{modules!optional!Norm@\chpl{Norm}}

The module \chpl{Norm} supports the computation of standard vector and
matrix norms on Chapel arrays.  The current interface is minimal and
should be expected to grow and evolve over time.

\begin{protohead}
enum normType {norm1, norm2, normInf, normFrob};
\end{protohead}
\begin{protobody}
An enumerated type indicating the different types of norms supported
by this module: 1-norm, 2-norm, infinity norm and Frobenius norm,
respectively.
\end{protobody}

\begin{protohead}
proc norm(x: [], p: normType) where x.rank == 1 || x.rank == 2
\end{protohead}
\begin{protobody}
Compute the norm indicated by \chpl{p} on the 1D or 2D array \chpl{x}.
\end{protobody}

\begin{protohead}
proc norm(x: [])
\end{protohead}
\begin{protobody}
Compute the default norm on array \chpl{x}.  For a 1D array this is
the 2-norm, for a 2D array, this is the Frobenius norm.
\end{protobody}


\subsection{Search}
\label{Search}
\index{modules!optional!Search@\chpl{Search}}

The \chpl{Search} module is designed to support standard search
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
proc LinearSearch(Data: [?Dom], val): (bool, index(Dom))
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential linear search.  Returns a tuple
indicating (1) whether or not the value was found and (2) the location
of the value if it was found, or the location where the value should
have been if it was not found.
\end{protobody}

\begin{protohead}
proc BinarySearch(Data: [?Dom], val, in lo = Dom.low, in hi = Dom.high)
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential binary search.  If provided, only
the indices \chpl{lo} through \chpl{hi} will be considered, otherwise
the whole array will be searched.  Returns a tuple indicating (1)
whether or not the value was found and (2) the location of the value
if it was found, or the location where the value should have been if
it was not found.
\end{protobody}


\subsection{Sort}
\label{Sort}
\index{modules!optional!Sort@\chpl{Sort}}

The \chpl{Sort} module is designed to support standard sorting
routines.  The current interface is minimal and should be expected to
grow and evolve over time. Each of the following functions accepts an
optional boolean argument, \chpl{reverse}, which is \chpl{false} by
default. If \chpl{true}, then the sort function will order in reverse.

\begin{protohead}
proc BubbleSort(Data: [?Dom], reverse : bool = false) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential bubble sort
algorithm.
\end{protobody}

\begin{protohead}
proc HeapSort(Data: [?Dom], reverse : bool = false) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential heap sort
algorithm.
\end{protobody}

\begin{protohead}
proc InsertionSort(Data: [?Dom], reverse : bool = false) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential insertion
sort algorithm.
\end{protobody}

\begin{protohead}
proc MergeSort(Data: [?Dom], reverse : bool = false, minlen=16) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} using a parallel merge sort algorithm.
The optional minlen argument is the minimum sized array that will be
sorted using merge sort.  If the size is less than minlen, the
insertion sort algorithm will be used.

\end{protobody}

\begin{protohead}
proc QuickSort(Data: [?Dom], reverse : bool = false, minlen=16) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential
implementation of the QuickSort algorithm.  The optional minlen
argument is the minimum sized array that will be sorted using
QuickSort.  If the size is less than minlen, the insertion sort
algorithm will be used.
\end{protobody}

\begin{protohead}
proc SelectionSort(Data: [?Dom], reverse : bool = false) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential selection
sort algorithm.
\end{protobody}


\subsection{Time}
\label{Time}
\index{modules!optional!Time@\chpl{Time}}

The module \chpl{Time} defines routines that query the system time and
a record \chpl{Timer} that is useful for timing portions of code.

\vspace{1pc}

\begin{protohead}
record Timer
\end{protohead}
\begin{protobody}
A timer is used to time portions of code.  Its semantics are similar
to a stopwatch.
\end{protobody}

\begin{protohead}
enum TimeUnits { microseconds, milliseconds, seconds, minutes, hours };
\end{protohead}
\begin{protobody}
The enumeration TimeUnits defines units of time.  These units can be
supplied to routines in this module to specify the desired time units.
\end{protobody}

\begin{protohead}
enum Day { sunday=0, monday, tuesday, wednesday, thursday, friday, saturday };
\end{protohead}
\begin{protobody}
The enumeration Day defines the days of the week, with Sunday defined to be 0.
\end{protobody}

\begin{protohead}
proc getCurrentDate(): (int, int, int)
\end{protohead}
\begin{protobody}
Returns the year, month, and day of the month as integers.  The year
is the year since 0.  The month is in the range 1 to 12.  The day is
in the range 1 to 31.
\end{protobody}

\begin{protohead}
proc getCurrentDayOfWeek(): Day
\end{protohead}
\begin{protobody}
Returns the current day of the week.
\end{protobody}

\begin{protohead}
proc getCurrentTime(unit: TimeUnits = TimeUnits.seconds): real
\end{protohead}
\begin{protobody}
Returns the elapsed time since midnight in the units specified.
\end{protobody}

\begin{protohead}
proc Timer.clear()
\end{protohead}
\begin{protobody}
Clears the elapsed time stored in the Timer.  This routine can be called
whether or not the timer is running and doesn't change its status in that
regard.  If the timer is running it is restarted.
\end{protobody}

\begin{protohead}
proc Timer.elapsed(unit: TimeUnits = TimeUnits.seconds): real
\end{protohead}
\begin{protobody}
Returns the cumulative elapsed time, in the units specified, between
all pairs of calls to \chpl{start} and \chpl{stop} since the timer was
created or the last call to \chpl{clear}.  If the timer is running,
the elapsed time since the last call to \chpl{start} is added to the
return value.
\end{protobody}

\begin{protohead}
proc Timer.start()
\end{protohead}
\begin{protobody}
Starts the timer.  It is an error to start a timer that is already
running.
\end{protobody}

\begin{protohead}
proc Timer.stop()
\end{protohead}
\begin{protobody}
Stops the timer.  It is an error to stop a timer that is not running.
\end{protobody}

\begin{protohead}
proc sleep(t: uint)
\end{protohead}
\begin{protobody}
Delays a task for \chpl{t} seconds.
\end{protobody}


\subsection{UtilMath}
\label{StdModules_UtilMath}
\index{modules!optional!UtilMath@\chpl{UtilMath}}

The optional module \chpl{UtilMath} provides various math-related functions.
It supplements the automatic \chpl{Math} module (\rsec{Math}).

\begin{protohead}
proc divceilpos(m: int(?), n: int(?))
\end{protohead}
\begin{protobody}
Computes
$\lceil\frac{n}{m}\rceil$
for two strictly positive integers $m>0$, $n>0$.
For other $m$ and $n$ the behavior is undefined.
This function is expected to be faster than \chpl{divceil}.
\end{protobody}

\begin{protohead}
proc divfloorpos(m: int(?), n: int(?))
\end{protohead}
\begin{protobody}
Computes
$\lfloor\frac{n}{m}\rfloor$
for two strictly positive integers $m>0$, $n>0$.
For other $m$ and $n$ the behavior is undefined.
This function is expected to be faster than \chpl{divfloor}.
\end{protobody}

