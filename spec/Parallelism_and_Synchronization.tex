\sekshun{Parallelism and Synchronization}
\label{Parallelism_and_Synchronization}

Chapel is an {\em explicitly} parallel programming language.  The
programmer introduces parallelism into a program
via \sntx{parallel-statements} and \sntx{parallel-expressions}:
\begin{syntax}
parallel-statement:
  forall-statement
  cobegin-statement
  coforall-statement
  begin-statement
  sync-statement
  serial-statement
  atomic-statement

parallel-expression:
  forall-expression
\end{syntax}

In addition, some operations on arrays and domains, as well as
invocations of promotion, are executed in parallel.  The
term \emph{task} is used to refer to a distinct context of execution
that may be running concurrently.

This section is divided into five parts:
\begin{itemize}
\item \rsec{unstructured_task_parallelism}
describes the begin-statement, an unstructured way to introduce
concurrency into a program, and synchronization variables, an
unstructured mechanism for synchronizing a program.
\item \rsec{structured_task_parallelism}
describes the cobegin- and coforall-statement, structured ways to
introduce concurrency into a program, and the sync- and
serial-statement, structured ways to control and suppress parallelism.
\item \rsec{data_parallelism}
describes the forall-statement and -expression, constructs for
explicit data parallelism.
\item \rsec{atomicity}
describes the atomic-statement, a construct to support atomic
transactions.
\item \rsec{Memory_Consistency}
describes the memory consistency model.
\end{itemize}

\subsection{Unstructured Task-Parallel Constructs}
\label{unstructured_task_parallelism}

Chapel provides a simple construct, the begin-statement, to spawn
tasks, thus introducing concurrency into a program in an unstructured
way.  In addition, Chapel introduces two type qualifiers, \chpl{sync}
and \chpl{single}, for synchronization of tasks.

More structured ways to achieve concurrency are discussed
in~\rsec{structured_task_parallelism}.  These structured ways to
introduce concurrency may be easier to use in many common cases.  They
can be implemented using only the unstructured constructs described in
this section.

\subsubsection{The Begin Statement}
\label{Begin}
\index{begin@\chpl{begin}}

The begin-statement spawns a task to execute a statement.  The
begin-statement is thus an unstructured way to create a new task that
is executed only for its side-effects.  The syntax for the begin
statement is given by
\begin{syntax}
begin-statement:
  `begin' statement
\end{syntax}
Control continues concurrently with the statement following the
begin-statement.

\begin{example}
The code
\begin{chapel}
begin writeln("output from spawned task");
writeln("output from main task");
\end{chapel}
executes two \chpl{writeln} statements that output the strings to the
terminal, but the ordering is purposely unspecified.  There is no
guarantee as to which statement will execute first.  When the
begin-statement is executed, a new task is created that will execute
the \chpl{writeln} statement within it.  However, execution will
continue immediately with the next statement.
In~\rsec{Sync_Variables}, this same example will be synchronized so
that the output from the spawned task always happens second.
\end{example}

The following statements may not be lexically enclosed in
begin-statements: break-statements, continue-statements,
yield-statements, and return-statements.
\begin{openissue}
It is undecided whether yield-statement should be allowed inside the
following parallel statements (begin, cobegin, coforall, and forall).
The design of parallel iterators is currently ongoing.  If simple
iterators with yield-statements in parallel statements are allowed,
there would be an issue on how such iterators could be zippered.  This
issue is a high priority and there are a number of ideas on the table.
\end{openissue}

\subsubsection{Sync Variables}
\label{Sync_Variables}
\index{synchronization variables!sync@\chpl{sync}}
\index{sync@\chpl{sync}}

The use of and assignment to variables of \chpl{sync} type implicitly
control the execution order of a task, making them well-suited to
producer-consumer data sharing.

A sync variable is logically either {\em full} or {\em empty}.  When
it is empty, tasks that attempt to read that variable are suspended
until the variable becomes full by the next assignment to it, which
atomically changes the state to full.  When the variable is full, a
read of that variable consumes the value and atomically transitions
the state to empty.  If there is more than one task waiting on a sync
variable, one is non-deterministically selected to use the variable
and resume execution.  The other tasks continue to wait for the next
assignment.

If a task attempts to assign to a sync variable that is full, the task
is suspended and the assignment is delayed.  When the sync variable
becomes empty, the task is resumed and the assignment proceeds,
transitioning the state back to full.  If there are multiple tasks
attempting such an assignment, one is non-deterministically selected
to proceed and the other assignments continue to wait until the sync
variable is emptied again.

A sync variable is specified with a sync type given by the following
syntax:
\begin{syntax}
sync-type:
  `sync' type-specifier
\end{syntax}

\begin{example}
The code
\begin{chapel}
var finishedMainOutput$\mbox{{\bf \$}}$: sync bool;
begin {
  finishedMainOutput$\mbox{{\bf \$}}$;
  writeln("output from spawned task");
}
writeln("output from main task");
finishedMainOutput$\mbox{{\bf \$}}$ = true;
\end{chapel}
modifies the example in~\rsec{Begin}.  When the read of the sync
variable is encountered in the spawned task, the task waits until the
sync variable is assigned in the main task.
\end{example}

\begin{example}
Sync variables are useful for tallying data from multiple tasks as
well.  A sync variable of type \chpl{int} is read and then written
during an update so the full-empty semantics make these updates atomic
when used in a stylized way.  The code
\begin{chapel}
var count$\mbox{{\bf \$}}$: int;
begin count$\mbox{{\bf \$}}$ += 1;
begin count$\mbox{{\bf \$}}$ += 1;
begin count$\mbox{{\bf \$}}$ += 1;
\end{chapel}
spawns three tasks to increment \chpl{count$\mbox{{\bf \$}}$}.
If \chpl{count$\mbox{{\bf \$}}$} was not a sync variable, this code
would be unsafe because between the points at which one task
reads \chpl{count$\mbox{{\bf \$}}$} and
writes \chpl{count$\mbox{{\bf \$}}$}, another task may increment it.
\end{example}

\index{sync types!records and classes}
If the base type of a sync type is a class or a record, the sync
semantics only apply to the class or record, not to its individual
fields or methods.  A record or class type may have fields of sync
type to get sync semantics on individual field accesses.

\index{sync types!formal arguments}
If a formal argument is a sync type, the actual is passed by reference
and the argument itself is a valid lvalue.  The unqualified
type \chpl{sync} can also be used to specify a generic formal
argument.  In this case, the actual must be a sync variable and it is
passed by reference.

For generic formal arguments with unspecified types, an actual that
is \chpl{sync} is ``read'' before being passed to the function and the
generic formal argument's type is set to the base type of the actual.

\subsubsection{Single Variables}
\label{Single_Variables}
\index{synchronization variables!single@\chpl{single}}
\index{single@\chpl{single}}

A single (assignment) variable specializes sync variables by
restricting the number of times it can be assigned to no more than one
during its lifetime.  A use of a single variable before it is assigned
causes the task's execution to suspend until the variable is assigned.
Otherwise, the use proceeds as with normal variables and the task
continues.  After a single assignment variable is assigned, all tasks
with pending uses resume in an unspecified order.  A single variable
is specified with a single type given by the following syntax:
\begin{syntax}
single-type:
  `single' type-specifier
\end{syntax}

\begin{example}
In the code
\begin{chapel}
class Tree {
  var isLeaf: bool;
  var left, right: Tree;
  var value: int;

  def sum() {
    if (isLeaf) then 
       return value;

    var x$\mbox{{\bf \$}}$: single int;
    begin x$\mbox{{\bf \$}}$ = left.sum();
    var y = right.sum();
    return x$\mbox{{\bf \$}}$+y;
  }
}
\end{chapel}
the single variable \chpl{x$\mbox{{\bf \$}}$} is assigned by an
asynchronous task created with the begin statement.  The task
returning the sum waits on the reading of \chpl{x$\mbox{{\bf \$}}$}
until it has been assigned.
\end{example}

\subsubsection{Predefined Single and Sync Methods}
\label{Functions_on_Synchronization_Variables}
\index{synchronization variables!built-in methods on}

The following methods are defined for variables of sync and single
type.

\index{readFE@\chpl{readFE}}
\begin{protohead}
def (sync t).readFE(): t
\end{protohead}
\begin{protobody}
Wait for full, leave empty, and return the value of the sync variable.
This method blocks until the sync variable is full.  The state of the
sync variable is set to empty when this method completes.
\end{protobody}

\index{readFF@\chpl{readFF}}
\begin{protohead}
def (sync t).readFF(): t
def (single t).readFF(): t
\end{protohead}
\begin{protobody}
Returns the value of the sync or single variable.  This method blocks
until the sync or single variable is full.  The state of the sync or
single variable remains full when this method completes.
\end{protobody}

\index{readXX@\chpl{readXX}}
\begin{protohead}
def (sync t).readXX(): t
def (single t).readXX(): t
\end{protohead}
\begin{protobody}
Returns the value of the sync or single variable.  This method is non-blocking
and the state of the sync or single variable is unchanged when this method
completes.
\end{protobody}

\index{writeEF@\chpl{writeEF}}
\begin{protohead}
def (sync t).writeEF(v: t)
def (single t).writeEF(v: t)
\end{protohead}
\begin{protobody}
Assigns \chpl{v} to the value of the sync or single variable.  This
method blocks until the sync or single variable is empty.  The state
of the sync or single variable is set to full when this method
completes.
\end{protobody}

\index{writeFF@\chpl{writeFF}}
\begin{protohead}
def (sync t).writeFF(v: t)
\end{protohead}
\begin{protobody}
Assigns \chpl{v} to the value of the sync variable.  This method
blocks until the sync variable is full.  The state of the sync
variable remains full when this method completes.
\end{protobody}

\index{writeXF@\chpl{writeXF}}
\begin{protohead}
def (sync t).writeXF(v: t)
\end{protohead}
\begin{protobody}
Assigns \chpl{v} to the value of the sync variable.  This method is
non-blocking and the state of the sync variable is set to full when
this method completes.
\end{protobody}

\index{reset@\chpl{reset}}
\begin{protohead}
def (sync t).reset()
\end{protohead}
\begin{protobody}
Assigns the default value of type \chpl{t} to the value of the sync
variable.  This method is non-blocking and the state of the sync
variable is set to empty when this method completes.
\end{protobody}

\index{isFull@\chpl{isFull}}
\begin{protohead}
def (sync t).isFull: bool
def (single t).isFull: bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the sync or single variable is full and \chpl{false}
otherwise.  This method is non-blocking and the state of the sync or single
variable is unchanged when this method completes.
\end{protobody}

\begin{rationale}
In general, these methods are provided such that other traditional
synchronization primitives, such as semaphores and mutexes, can be
constructed.

In addition, the implicitly-invoked \chpl{readFE} and \chpl{writeEF}
methods (which can arguably be categorized as unnecessary due to the
implicit invocation) are provided to support programmers who wish to
make the semantics of these operations more explicit.  It might be
desirable to have a compiler option that disables the implicit
application of these methods.
\end{rationale}

\begin{example}
Given the following declarations
\begin{chapel}
var x$\mbox{{\bf \$}}$: single int;
var y: int;
\end{chapel}
the code
\begin{chapel}
x$\mbox{{\bf \$}}$ = 5;
y = x$\mbox{{\bf \$}}$;
\end{chapel}
is equivalent to
\begin{chapel}
x$\mbox{{\bf \$}}$.writeEF(5);
y = x$\mbox{{\bf \$}}$.readFF();
\end{chapel}
\end{example}

\subsection{Structured Task-Parallel Constructs}
\label{structured_task_parallelism}

Chapel provides two constructs, the cobegin- and coforall-statements,
to introduce concurrency in a more structured way.  These constructs
spawn multiple tasks but do not continue until the tasks have
completed.  In addition, Chapel provides two constructs, the sync- and
serial-statements, to suppress parallelism and insert synchronization.
All four of these constructs can be implemented through judicious uses
of the unstructured task-parallel constructs described in the previous
section.

\subsubsection{The Cobegin Statement}
\label{Cobegin}
\index{cobegin@\chpl{cobegin}}

The cobegin statement is used to introduce concurrency within a
block.  The \chpl{cobegin} statement syntax is
\begin{syntax}
cobegin-statement:
  `cobegin' block-statement
\end{syntax}
Each statement within the block statement is executed concurrently and
is considered a separate task.  Control continues when all of the
tasks have finished.

The following statements may not be lexically enclosed in
cobegin-statements: break-statements, continue-statements,
yield-statements, and return-statements.

\begin{openissue}
Whether to allow yield-statements in cobegin-statements is an open
issue; see note in~\rsec{Begin}.
\end{openissue}

\begin{example}
The cobegin-statement
\begin{chapel}
cobegin {
  stmt1();
  stmt2();
  stmt3();
}
\end{chapel}
is equivalent to the following code that uses only begin-statements
and single variables to introduce concurrency and synchronize:
\begin{chapel}
var s1$\mbox{{\bf \$}}$, s2$\mbox{{\bf \$}}$, s3$\mbox{{\bf \$}}$: single bool;
begin { stmt1(); s1$\mbox{{\bf \$}}$ = true; }
begin { stmt2(); s2$\mbox{{\bf \$}}$ = true; }
begin { stmt3(); s3$\mbox{{\bf \$}}$ = true; }
s1$\mbox{{\bf \$}}$; s2$\mbox{{\bf \$}}$; s3$\mbox{{\bf \$}}$;
\end{chapel}
Each begin-statement is executed concurrently but control does not
continue past the final line above until each of the single variables
is written, thereby ensuring that each of the functions has finished.
\end{example}

\subsubsection{The Coforall Loop}
\label{Coforall}
\index{coforall@\chpl{coforall}}
\index{coforall loops}

The coforall loop is a variant of the cobegin statement and a loop.
The syntax for the coforall loop is given by
\begin{syntax}
coforall-statement:
  `coforall' loop-control-part loop-body-part
\end{syntax}

The semantics of the \chpl{coforall} loop are identical to
a \chpl{cobegin} statement where each iteration of the \chpl{coforall}
loop is equivalent to a separate statement in a \chpl{cobegin} block.

Control continues with the statement following the \chpl{coforall}
loop only after all iterations have been completely evaluated.

The following statements may not be lexically enclosed in
coforall-statements: break-statements, continue-statements,
yield-statements, and return-statements.

\begin{openissue}
Whether to allow yield-statements in coforall-statements is an open
issue; see note in~\rsec{Begin}.
\end{openissue}

\begin{example}
The coforall-statement
\begin{chapel}
coforall i in iterator() {
  body();
}
\end{chapel}
is equivalent to the following code that uses only begin-statements
and sync and single variables to introduce concurrency and
synchronize:
\begin{chapel}
var runningCount$\mbox{{\bf \$}}$: sync int = 1;
var finished$\mbox{{\bf \$}}$: single bool;
for i in iterator() {
  runningCount$\mbox{{\bf \$}}$ += 1;
  begin {
    body();
    var tmp = runningCount$\mbox{{\bf \$}}$;
    runningCount$\mbox{{\bf \$}}$ = tmp-1;
    if tmp == 1 then finished$\mbox{{\bf \$}}$ = true;
  }
}
var tmp = runningCount$\mbox{{\bf \$}}$;
runningCount$\mbox{{\bf \$}}$ = tmp-1;
if tmp == 1 then finished$\mbox{{\bf \$}}$ = true;
finished$\mbox{{\bf \$}}$;
\end{chapel}
Each call to \chpl{body()} executes concurrently because it is in a
begin-statement.  The sync
variable \chpl{runningCount$\mbox{{\bf \$}}$} is used to keep track of
the number of executing tasks plus one for the main task.  When this
variable reaches zero, the single
variable \chpl{finished$\mbox{{\bf \$}}$} is used to signal that all
of the tasks have completed.  Thus control does not continue past the
last line until all of the tasks have completed.
\end{example}

\subsubsection{The Sync Statement}
\label{Sync_Statement}
\index{sync@\chpl{sync}}

The sync statement acts as a join of all dynamically encountered
begins from within a statement.  The syntax for the sync statement is
given by
\begin{syntax}
sync-statement:
  `sync' statement
\end{syntax}
The following statements may not be lexically enclosed in
sync-statements: break-statements, continue-statements,
yield-statements, and return-statements.

\begin{example}
The sync statement can be used to wait for many dynamically spawned
tasks.  Given the \chpl{Tree} class defined in the example
in~\rsec{Single_Variables} and an instance of this class
called \chpl{tree}, the code
\begin{chapel}
def concurrentUpdate(tree: Tree) {
  if requiresUpdate(tree) then
    begin update(tree);
  if !tree.isLeaf {
    searchAndUpdate(tree.left);
    searchAndUpdate(tree.right);
  }
}

sync searchAndUpdate(tree);
\end{chapel}
defines a function \chpl{concurrentUpdate} that recursively walks over
a tree and spawns a new task to update a node if the
function \chpl{requiresUpdate} evaluates to true.
(Both \chpl{requiresUpdate} and \chpl{update} are omitted as
irrelevant.)  The call to \chpl{searchAndUpdate} is made within
a \chpl{sync} statement to ensure that each of the spawned update
tasks finishes before execution continues.
\end{example}

\begin{example}
The sync statement
\begin{chapel}
sync {
  begin stmt1();
  begin stmt2();
}
\end{chapel}
is similar to the following cobegin statement
\begin{chapel}
cobegin {
  stmt1();
  stmt2();
}
\end{chapel}
except that if begin-statements are dynamically encountered
when \chpl{stmt1()} or \chpl{stmt2()} are executed, then the former
code will wait for these begin-statements to complete whereas the
latter code will not.
\end{example}

\subsubsection{The Serial Statement}
\label{Serial}
\index{serial@\chpl{serial}}

The \chpl{serial} statement can be used to dynamically disable
parallelism.  The syntax is:
\begin{syntax}
serial-statement:
  `serial' expression block-level-statement
\end{syntax}
where the expression evaluates to a bool type.  Independent of that
value, the \sntx{block-level-statement} is evaluated. If the
expression is true, any dynamically encountered code that would result
in new tasks is executed without spawning any new tasks.  In effect,
execution is serialized.

\begin{example}
Given the \chpl{Tree} class defined in the example
in~\rsec{Single_Variables} and an instance of this class
called \chpl{tree}, the code
\begin{chapel}
def concurrentUpdate(tree: Tree, depth: int = 1) {
  if requiresUpdate(tree) then
    update(tree);
  if !tree.isLeaf {
    serial depth > 4 cobegin {
      concurrentSearch(tree.left, depth+1);
      concurrentSearch(tree.right, depth+1);
    }
  }
}
\end{chapel}
defines a function \chpl{concurrentUpdate} that recursively walks over
a tree using cobegin-statements to update the left and right subtrees
in parallel.  The serial statement inhibits concurrent execution on
the tree for nodes that are deeper than four levels in the tree.  This
constrains the number of tasks that will be used for the update.
\end{example}

\begin{example}
The code
\begin{chapel}
serial true {
  begin stmt1();
  cobegin {
    stmt2();
    stmt3();
  }
  coforall i in iterator() do stmt4();
  forall i in iterator() do stmt5();
}
\end{chapel}
is equivalent to
\begin{chapel}
stmt1();
{
  stmt2();
  stmt3();
}
for i in iterator() do stmt4();
for i in iterator() do stmt5();
\end{chapel}
because the expression evaluated to determine whether to serialize
always evaluates to true.
\end{example}

\subsection{Data-Parallel Constructs}
\label{data_parallelism}

Chapel provides two explicit data-parallel constructs: the
forall-statement and the forall-expression.  In addition, promotion
over arrays, domains, ranges, and iterators results in data-parallel
tasks.

\subsubsection{The Forall Loop}
\label{Forall}
\index{forall@\chpl{forall}}
\index{forall loops}

The forall loop is a variant of the for loop that allows for the
concurrent execution of the loop body. The for loop is described
in~\rsec{The_For_Loop}. The syntax for the forall loop is given by
\begin{syntax}
forall-statement:
  `forall' loop-control-part loop-body-part
  [loop-control-part] statement
\end{syntax}
The second form of the loop is a syntactic convenience.

The forall loop evaluates the loop body once for each element in
the \sntx{iterator-expression}.  Each instance of the forall loop's
statement may be executed concurrently with each other, but this is
not guaranteed.  The definition of the iterator determines the actual
concurrency based on the specification of the iterator of the loop.

This differs from the semantics of the \chpl{coforall} loop, discussed
in~\rsec{Coforall}, where each iteration is guaranteed to run
concurrently.  The \chpl{coforall} loop thus has potentially higher
overhead than a forall loop, but in cases where concurrency is
required for correctness, it is essential.

Control continues with the statement following the forall loop only
after each iteration has been completely evaluated.

The following statements may not be lexically enclosed in
forall-statements: break-statements, continue-statements,
yield-statements, and return-statements.

\begin{openissue}
Whether to allow yield-statements in forall-statements is an open
issue; see note in~\rsec{Begin}.
\end{openissue}

\begin{example}
In the code
\begin{chapel}
forall i in 1..N do
  a(i) = b(i);
\end{chapel}
the user has stated that the element-wise assignments can execute
concurrently.  This loop may be performed serially, with maximum
concurrency where each loop body iteration instance is executed in a
separate task, or somewhere in between.  This loop can also be written
as
\begin{chapel}
[i in 1..N] a(i) = b(i);
\end{chapel}
\end{example}

\subsubsection{The Forall Expression}
\label{Forall_Expressions}
\index{forall expressions}

A forall expression can be used to enable concurrent evaluation of
sub-expressions.  The sub-expressions are evaluated once for each
element in the iterator expression.  The syntax of a forall expression
is given by
\begin{syntax}
forall-expression:
  `forall' loop-control-part `do' expression
  [loop-control-part] expression
\end{syntax}

\begin{example}
The code
\begin{chapel}
writeln(+ reduce [i in 1..10] i**2);
\end{chapel}
applies a reduction to a forall-expression that evaluates the square
of the indices in the range \chpl{1..10}.
\end{example}

\subsubsection{Filtering Predicates in Forall Expressions}
\label{Filtering_Predicates_Forall}
\index{forall expressions!and conditional expressions}

An if expression that is immediately enclosed by a forall expression
does not require an else part.
\begin{example}
The following expression returns every other element starting with the
first:
\begin{chapel}
[i in 1..s.length] if i % 2 == 1 then s(i)
\end{chapel}
\end{example}

\subsection{Atomic Statements}
\label{Atomic_Transactions}
\label{atomicity}
\index{atomic transactions}
\index{atomic@\chpl{atomic}}

The atomic statement creates an atomic transaction of a statement. The
statement is executed with transaction semantics in that the statement
executes entirely, the statement appears to have completed in a single
order and serially with respect to other atomic statements, and no
variable assignment is visible until the statement has completely
executed.

\begin{openissue}
This definition of an atomic statement is sometimes called {\em strong
atomicity} because the semantics are atomic to the entire program.
{\em Weak atomicity} is defined so that an atomic statement is atomic
only with respect to other atomic statements.  Chapel semantics are
still under design.
\end{openissue}

The syntax for the atomic statement is given by:
\begin{syntax}
atomic-statement:
  `atomic' statement
\end{syntax}

\begin{example}
The following code illustrates one possible use of atomic statements:
\begin{chapel}
var found = false;
atomic {
  if head == obj {
    found = true;
    head = obj.next;
  } else {
    var last = head;
    while last != null {
      if last.next == obj {
        found = true;
        last.next = obj.next;
        break;
      }
      last = last.next;
    }
  }
}
\end{chapel}
Inside the atomic statement is a sequential implementation of removing
a particular object denoted by \chpl{obj} from a singly linked list.
This is an operation that is well-defined, assuming only one task is
attempting it at a time. The atomic statement ensures that, for
example, the value of \chpl{head} does not change after it is first in
the first comparison and subsequently read to
initialize \chpl{last}. The variables eventually owned by this task
are \chpl{found}, \chpl{head}, \chpl{obj}, and the various \chpl{next}
fields on examined objects.
\end{example}

The effect of an atomic statement is dynamic.

\begin{example}
If there is a method associated with a list that removes an object,
that method may not be parallel safe, but could be invoked safely inside an
atomic statement:
\begin{chapel}
atomic found = head.remove(obj);
\end{chapel}
\end{example}

\subsection{Memory Consistency Model}
\label{Memory_Consistency}
\index{memory consistency model}

\begin{openissue}
This section is largely forthcoming.
\end{openissue}

We have been greatly helped in the design of Chapel's memory
consistency model by discussions in and readings for a seminar at the
University of Washington run by Dan Grossman and Luis Ceze as well as
the following paper: {\bf Jeremy Mason, William Pugh, and Sarita
V. Adve.}  {\bf The Java memory model.}  In {\bf Proceedings of the
32nd Symposium on Principles of Programming Languages}.  2005.

The Chapel memory consistency model is defined for programs that are
{\em data-race-free}.  Programs that are {\em data-race-free} are
sequentially consistent.  Otherwise, the program is incorrect and no
guarantees are made.  In this design choice, Chapel differs from Java
because the set of dynamic security concerns is different.

Writing and reading \chpl{sync} and \chpl{single} variables as well as
executing atomic-statements are the only ways in Chapel to correctly
synchronize a program.  It is an error to write to the same memory
location or read from and write to the same memory location in two
different tasks without any intervening synchronization.

\begin{example}
This has the direct consequence that one task cannot spin-wait on a
variable while another task writes to that variable.  The behavior of
the following code is undefined:
\begin{chapel}
var x: int;
cobegin {
  while x != 1 do ;  // spin wait
  x = 1;
}
\end{chapel}
While codes are more efficient in most cases if one avoids
spin-waiting altogether, this code could be rewritten with defined
behavior as follows:
\begin{chapel}
var x$\mbox{{\bf \$}}$: sync int;
cobegin {
  while x$\mbox{{\bf \$}}$.readXX() != 1 do ;  // spin wait
  x$\mbox{{\bf \$}}$.writeXF(1);
}
\end{chapel}
In this code, the first statement in the cobegin-statement executes a
loop until the variable is set to one.  The second statement in the
cobegin-statement sets the variable to one.  Neither of these
statements block.
\end{example}
