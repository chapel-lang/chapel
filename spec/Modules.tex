\sekshun{Modules}
\label{Modules}
\index{modules}

Chapel supports modules to manage name spaces.  A program consists of
one or more modules.  Every symbol, including variables, functions,
and types, is associated with some module.

Module definitions are described in~\rsec{Module_Definitions}.  The
relation between files and modules is described
in~\rsec{Implicit_Modules}.  Nested modules are described
in~\rsec{Nested_Modules}.  Module uses and explicit naming of symbols
are described in~\rsec{Using_Modules}.  The execution of a program and
module initialization is described in~\rsec{Program_Execution}.

\section{Module Definitions}
\label{Module_Definitions}
\index{module@\chpl{module}}
\index{modules!definitions}

A module is declared with the following syntax:
\begin{syntax}
module-declaration-statement:
  `module' module-identifier block-statement

module-identifier:
  identifier
\end{syntax}

A module's name is specified after the \chpl{module} keyword.
The \sntx{block-statement} opens the module's scope.  Symbols defined
in this block statement are defined in the module's scope and are
called \emph{top-level module symbols}.

Module declaration statements must be top-level statements within a
module.  A module that is declared within another module is called a
nested module~(\rsec{Nested_Modules}).

\section{Files and Implicit Modules}
\label{Implicit_Modules}
\index{modules!and files}

Multiple modules can be defined in the same file and need not bear any
relation to the file in terms of their names.

\begin{chapelexample}{two-modules.chpl}
The following file contains two explicitly named modules
(\rsec{Explicit_Naming}), MX and MY.
\begin{chapel}
module MX {
  var x: string = "Module MX";
  proc printX() {
    writeln(x);
  }
}

module MY {
  var y: string = "Module MY";
  proc printY() {
    writeln(y);
  }
}
\end{chapel}
\begin{chapelpost}
MX.printX();
MY.printY();
\end{chapelpost}
\begin{chapeloutput}
Module MX
Module MY
\end{chapeloutput}
Module MX defines top-level module symbols x and printX, while MY
defines top-level module symbols y and printY.
\end{chapelexample}

For any file that contains top-level statements other than module
declarations, the file itself is treated as the module declaration.
In this case,
\index{implicit modules}
\index{modules!implicit}
the module is implicit and takes its name from the base filename.  In
particular, the module name is defined as the remaining string after
removing the \chpl{.chpl} suffix and any path specification from the
specified filename.  If the resulting name is not a legal Chapel
identifier, it cannot be referenced in a use statement.

\begin{chapelexample}{implicit.chpl}
The following file, named myModule.chpl, defines an implicitly named
module called myModule.
\begin{chapel}
var x: int = 0;
var y: int = 1;

proc printX() {
  writeln(x);
}
proc printY() {
  writeln(y);
}
\end{chapel}
\begin{chapelpost}
printX();
printY();
\end{chapelpost}
\begin{chapeloutput}
0
1
\end{chapeloutput}
Module myModule defines the top-level module symbols x, y, printX, and
printY.
\end{chapelexample}


\section{Nested Modules}
\label{Nested_Modules}
\index{modules!nested}

A nested module is a module that is defined within another module, the
outer module.  Nested modules automatically have access to all of the
symbols in the outer module.  However, the outer module needs to
explicitly use a nested module to have access to its symbols.

A nested module can be used without using the outer module by
explicitly naming the outer module in the use statement.
\begin{chapelexample}{nested-use.chpl}
The code
\begin{chapelpre}
module libsci {
  writeln("Initializing libsci");
  module blas {
    writeln("\\tInitializing blas");
  }
}
module testmain { // used to avoid warnings
}
\end{chapelpre}
\begin{chapel}
use libsci.blas;
\end{chapel}
\begin{chapeloutput}
Initializing libsci
	Initializing blas
\end{chapeloutput}
uses a module named \chpl{blas} that is nested inside a module
named \chpl{libsci}.
\end{chapelexample}

Files with both module declarations and top-level statements result in
nested modules.

\begin{chapelexample}{nested.chpl}
The following file, named myModule.chpl, defines an
implicitly named module called myModule, with nested modules
MX and MY.
\begin{chapel}
module MX {
  var x: int = 0;
}

module MY {
  var y: int = 0;
}

use MX, MY;

proc printX() {
  writeln(x);
}

proc printY() {
  writeln(y);
}
\end{chapel}
\begin{chapelpost}
printX();
printY();
\end{chapelpost}
\begin{chapeloutput}
0
0
\end{chapeloutput}
\end{chapelexample}


\section{Using Modules}
\label{Using_Modules}
\index{modules!using}

A module can be used by code outside of that module.  This allows
access to the top-level module symbols without the need for explicit
naming~(\rsec{Explicit_Naming}).  Using modules is accomplished via
the use statement as defined in~\rsec{The_Use_Statement}.

\subsection{Explicit Naming}
\label{Explicit_Naming}
\index{modules!explicitly named}

All top-level module symbols can be named explicitly with the
following syntax:
\begin{syntax}
module-access-expression:
  module-identifier-list . identifier

module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list

\end{syntax}
This allows two variables that have the same name to be distinguished
based on the name of their module.  Using explicit module naming in a
function call restricts the set of candidate functions to those in the
specified module.

If code refers to symbols that are defined by multiple modules, the
compiler will issue an error.  Explicit naming can be used to
disambiguate the symbols in this case.

\begin{openissue}
It is currently unspecified whether the
first-named module is always at the outermost module level scope, or whether a
scope-search mechanism is used starting at the scope containing the
usage.
\end{openissue}

\begin{chapelexample}{ambiguity.chpl}
In the following example,
\begin{chapel}
module M1 {
  var x: int = 1;
  var y: int = -1;
  proc printX() {
    writeln("M1's x is: ", x);
  }
  proc printY() {
    writeln("M1's y is: ", y);
  }
}
 
module M2 {
  use M3;
  use M1;

  var x: int = 2;

  proc printX() {
    writeln("M2's x is: ", x);
  }

  proc main() {
    M1.x = 4;
    M1.printX();
    writeln(x);
    printX(); // This is not ambiguous
    printY(); // ERROR: This is ambiguous
  }
}

module M3 {
  var x: int = 3;
  var y: int = -3;
  proc printY() {
    writeln("M3's y is: ", y);
  }
}
\end{chapel}
\begin{chapeloutput}
ambiguity.chpl:22: In function 'main':
ambiguity.chpl:27: error: ambiguous call 'printY()'
ambiguity.chpl:34: note: candidates are: printY()
ambiguity.chpl:7: note:                 printY()
\end{chapeloutput}
The call to printX() is not ambiguous because M2's definition shadows
that of M1.  On the other hand, the call to printY() is ambiguous
because it is defined in both M1 and M3.  This will result in a
compiler error.
\end{chapelexample}


\subsection{Module Initialization}
\label{Module_Initialization}
\index{modules!initialization}

Module initialization occurs at program start-up.  All top-level
statements in a module other than function and type declarations are
executed during module initialization.

\begin{chapelexample}{init.chpl}
In the code,
\begin{chapelpre}
proc foo() {
    return 1;
}
\end{chapelpre}
\begin{chapel}
var x = foo();       // executed at module initialization
writeln("Hi!");      // executed at module initialization
proc sayGoodbye {
  writeln("Bye!");   // not executed at module initialization
}
\end{chapel}
\begin{chapeloutput}
Hi!
\end{chapeloutput}
The function foo() will be invoked and its result assigned to x.  Then
``Hi!'' will be printed.
\end{chapelexample}

Module initialization order is discussed
in~\rsec{Module_Initialization_Order}.


\section{Program Execution}
\label{Program_Execution}
\index{program execution}
\index{program initialization}

Chapel programs start by initializing all modules and then executing
the main function~(\rsec{The_main_Function}).

\subsection{The {\em main} Function}
\label{The_main_Function}

\index{main@\chpl{main}}
\index{functions!main@\chpl{main}}
The main function must be called \chpl{main} and must have zero
arguments.  It can be specified with or without parentheses.  In any
Chapel program, there is a single main function that defines the
program's entry point.  If a program defines multiple potential entry
points, the implementation may provide a compiler flag that
disambiguates between main functions in multiple modules.

\begin{craychapel}
In the Cray Chapel compiler implementation, the \emph{--
--main-module} flag can be used to specify the module from which the
main function definition will be used.
\end{craychapel}

\begin{chapelexample}{main-module.chpl}
Because it defines two \chpl{main} functions, the following code will yield an
error unless a main module is specified on the command line.
\begin{chapel}
module M1 {
  const x = 1;
  proc main() {
    writeln("M", x, "'s main");
  }
}
 
module M2 {
  use M1;

  const x = 2;
  proc main() {
    M1.main();
    writeln("M", x, "'s main");
  }
}
\end{chapel}
\begin{chapelcompopts}
--main-module M1 \# main\_module.M1.good
--main-module M2 \# main\_module.M2.good
\end{chapelcompopts}
If M1 is specified as the main module, the program will output:
\begin{chapelprintoutput}{main_module.M1.good}
M1's main
\end{chapelprintoutput}
If M2 is specified as the main module the program will output:
\begin{chapelprintoutput}{main_module.M2.good}
M1's main
M2's main
\end{chapelprintoutput}
Notice that main is treated like just another function if it is not in
the main module and can be called as such.
\end{chapelexample}

\index{exploratory programming}

%subsubsection{Programs with a Single Module}
%% \label{Programs_with_a_Single_Module}

To aid in exploratory programming, a default main function is
created if the program does not contain a user-defined main function.  The
default main function is equivalent to
\begin{chapel}
proc main() {}
\end{chapel}

\begin{chapelexample}{no-main.chpl}
The code
\begin{chapel}
writeln("hello, world");
\end{chapel}
\begin{chapeloutput}
hello, world
\end{chapeloutput}
is a legal and complete Chapel program.  The startup code for a Chapel program
first calls the module initialization code for the main module and then
calls \chpl{main()}.  This program's initialization function is the top-level
writeln() statement.  The module declaration is taken to be the entire file,
as described in~\rsec{Implicit_Modules}.
\end{chapelexample}


\subsection{Module Initialization Order}
\label{Module_Initialization_Order}
\index{modules!initialization order}

Module initialization is performed using the following algorithm.

Starting from the module that defines the main function, the modules named in
its use statements are visited depth-first and initialized in post-order.  If a
use statement names a module that has already been visited, it is not visited a
second time.  Thus, infinite recursion is avoided.

Modules used by a given module are visited in the order in which
they appear in the program text.  For nested modules, the
parent module and its uses are initialized before the nested module and its uses.

\begin{chapelexample}{init-order.chpl}
The code
\begin{chapel}
module M1 {
  use M2.M3;
  use M2;
  writeln("In M1's initializer");
  proc main() {
    writeln("In main");
  }
}

module M2 {
  use M4;
  writeln("In M2's initializer");
  module M3 {
    writeln("In M3's initializer");
  }
}

module M4 {
  writeln("In M4's initializer");
}
\end{chapel}
prints the following
\begin{chapelprintoutput}{}
In M4's initializer
In M2's initializer
In M3's initializer
In M1's initializer
In main
\end{chapelprintoutput}
M1, the main module, uses M2.M3 and then M2, thus M2.M3 must be
initialized.  Because M2.M3 is a nested module, M4 (which is used by
M2) must be initialized first.  M2 itself is initialized, followed by
M2.M3.  Finally M1 is initialized, and the main function is run.
\end{chapelexample}
