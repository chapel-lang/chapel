\sekshun{Modules}
\label{Modules}

\index{modules}

Chapel supports modules to manage name spaces.  A program consists of
one or more modules.  Every symbol, including variables, functions,
and types, is associated with some module.

Module definitions are described in~\rsec{Module_Definitions}.  The
relation between files and modules is described
in~\rsec{Implicit_Modules}.  Nested modules are described
in~\rsec{Nested_Modules}.  Module uses and explicit naming of symbols
are described in~\rsec{Using_Modules}.  The execution of a program and
module initialization is described in~\rsec{Program_Execution}.

\subsection{Module Definitions}
\label{Module_Definitions}

\index{module@\chpl{module}}

A module is declared with the following syntax:
\begin{syntax}
module-declaration-statement:
  `module' module-identifier block-statement

module-identifier:
  identifier
\end{syntax}

A module's name is specified after the \chpl{module} keyword.
The \sntx{block-statement} opens the module's scope.  Symbols defined
in this block statement are defined in the module's scope and are
called \emph{top-level module symbols}.

Module declaration statements must be top-level statements within a
module.  A module that is declared within another module is called a
nested module~(\rsec{Nested_Modules}).

\subsection{Implicit Modules}
\label{Implicit_Modules}
\index{modules!and files}

Multiple modules can be defined in the same file and need not bear any
relation to the file in terms of their names.

\begin{example}
The following file contains two explicitly named modules, MX and MY.
\begin{chapelpre}
% test_two_modules.chpl
\end{chapelpre}
\begin{chapel}
module MX {
  var x: int = 0;
  def printX() {
    writeln(x);
  }
}

module MY {
  var y: int = 0;
  def printY() {
    writeln(y);
  }
}
\end{chapel}
\begin{chapelpost}
use MX, MY;

MX.printX();
MY.printY();
\end{chapelpost}
\begin{chapeloutput}
0
0
\end{chapeloutput}
Module MX defines top-level module symbols x and printX, while MX
defines top-level module symbols y and printY.
\end{example}

For any file that contains top-level statements other than module
declarations, the file is treated as the module declaration.  In this
case, the module takes its name from the file.  If the file name is
not a legal Chapel identifier, the module name cannot be used in a use
statement.

\begin{example}
The following file, named myModule.chpl, defines an implicitly named
module called myModule.
\begin{chapelpre}
% test_implicit.chpl
\end{chapelpre}
\begin{chapel}
var x: int = 0;
var y: int = 0;

def printX() {
  writeln(x);
}
def printY() {
  writeln(y);
}
\end{chapel}
\begin{chapelpost}
printX();
printY();
\end{chapelpost}
\begin{chapeloutput}
0
0
\end{chapeloutput}
Module myModule defines the top-level module symbols x, y, printX, and
printY.
\end{example}


\subsection{Nested Modules}
\label{Nested_Modules}
\index{modules!nested}

A nested module is a module that is defined within another module, the
outer module.  Nested modules automatically have access to all of the
symbols in the outer module.  However, the outer module needs to
explicitly use a nested module to have access to its symbols.

A nested module can be used without using the outer module by
explicitly naming the module in the use statement.
\begin{example}
The code
\begin{chapelpre}
% test_nested_use.chpl
module libsci {
  writeln("Initializing libsci");
  module blas {
    writeln("\\tInitializing blas");
  }
}
\end{chapelpre}
\begin{chapel}
use libsci.blas;
\end{chapel}
\begin{chapeloutput}
Initializing libsci
	Initializing blas
\end{chapeloutput}
uses a module named \chpl{blas} that is nested inside a module
named \chpl{libsci}.
\end{example}

Files with both module declarations and top-level statements result in
nested modules.

\begin{example}
The following file, named myModule.chpl, defines an
implicitly named module called myModule, with nested modules
MX and MY.
\begin{chapelpre}
% test_nested.chpl
\end{chapelpre}
\begin{chapel}
module MX {
  var x: int = 0;
}

module MY {
  var y: int = 0;
}

use MX, MY;

def printX() {
  writeln(x);
}

def printY() {
  writeln(y);
}
\end{chapel}
\begin{chapelpost}
printX();
printY();
\end{chapelpost}
\begin{chapeloutput}
0
0
\end{chapeloutput}
\end{example}


\subsection{Using Modules}
\label{Using_Modules}
\index{modules!using}

A module can be used by code outside of that module.  This allows
access to the top-level module symbols without the need for explicit
naming~(\rsec{Explicit_Naming}).  Using modules is accomplished via
the use statement as defined in~\rsec{The_Use_Statement}.

\subsubsection{Explicit Naming}
\label{Explicit_Naming}

All top-level module symbols can be named explicitly with the
following syntax:
\begin{syntax}
module-access-expression:
  module-identifier-list . identifier

module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list

\end{syntax}
This allows two variables that have the same name to be distinguished
based on the name of their module.  Using explicit module naming in a
function call restricts the set of candidate functions to those in the
specified module.

If code refers to symbols that are defined by multiple modules, the
compiler will issue an error.  Explicit naming can be used to
disambiguated the symbols in this case.

\begin{example}
In the following example,
\begin{chapelpre}
% test_ambiguity.chpl
\end{chapelpre}
\begin{chapel}
module M1 {
  var x: int = 1;
  var y: int = -1;
  def printX() {
    writeln("M1's x is: ", x);
  }
  def printY() {
    writeln("M1's y is: ", y);
  }
}
 
module M2 {
  use M3;
  use M1;

  var x: int = 2;

  def printX() {
    writeln("M2's x is: ", x);
  }

  def main() {
    M1.x = 4;
    M1.printX();
    writeln(x);
    printX(); // This is not ambiguous
    printY(); // ERROR: This is ambiguous
  }
}

module M3 {
  var x: int = 3;
  var y: int = -3;
  def printY() {
    writeln("M3's y is: ", y);
  }
}
\end{chapel}
\begin{chapeloutput}
test_ambiguity.chpl:22: In function 'main':
test_ambiguity.chpl:27: error: ambiguous call 'printY()'
test_ambiguity.chpl:34: note: candidates are: printY()
test_ambiguity.chpl:7: note:                 printY()
\end{chapeloutput}
The call to printX() is not ambiguous because M2's definition shadows
that of M1.  On the other hand, the call to printY() is ambiguous
because it is defined in both M1 and M3.  This will result in a
compiler error.


\end{example}


\subsubsection{Module Initialization}
\label{Module_Initialization}
\index{modules!initialization}

Module initialization occurs at program start-up.  All top-level
statements in a module other than function and type declarations are
executed during module initialization.

\begin{example}
In the code,
\begin{chapelpre}
% test_init.chpl
def foo() {
    return 1;
}
\end{chapelpre}
\begin{chapel}
var x = foo();       // executed at module initialization
writeln("Hi!");      // executed at module initialization
def sayGoodbye {
  writeln("Bye!");   // not executed at module initialization
}
\end{chapel}
\begin{chapeloutput}
Hi!
\end{chapeloutput}
The function foo() will be invoked and its result assigned to x.  Then
``Hi!'' will be printed.
\end{example}

Module initialization order is discussed
in~\rsec{Module_Initialization_Order}.



\subsection{Program Execution}
\label{Program_Execution}

Chapel programs start by initializing all modules and then executing
the main function~(\rsec{The_main_Function}).

\subsubsection{The {\em main} Function}
\label{The_main_Function}

\index{main@\chpl{main}}
The main function must be called \chpl{main} and must have zero
arguments.  It can be specified with or without parentheses.  In any
Chapel program, there is a single main function that defines the
program's entry point.  If a program defines multiple potential entry
points, the implementation may provide a compiler flag that
disambiguates between main functions in multiple modules.

\begin{craychapel}
In the Cray Chapel compiler implementation, the \emph{--
--main-module} flag can be used to specify the module from which the
main function definition will be used.  Only modules passed to the
compiler on the command line will be searched for main functions
unless the \emph{-- --main-module} flag is used.
\end{craychapel}

\begin{example}
If the following code is compiled without specifying a main module, it
will yield an error.
\begin{chapelpre}
% test_main_module.chpl
\end{chapelpre}
\begin{chapel}
module M1 {
  const x = 1;
  def main() {
    writeln("M", x, "'s main");
  }
}
 
module M2 {
  use M1;

  const x = 2;
  def main() {
    M1.main();
    writeln("M", x, "'s main");
  }
}
\end{chapel}
\begin{chapelcompopts}
--main-module M1 \# test\_main\_module.M1.good
--main-module M2 \# test\_main\_module.M2.good
\end{chapelcompopts}
If M1 is specified as the main module, the program will output:
\begin{chapelprintoutput}
% test_main_module.M1.good
M1's main
\end{chapelprintoutput}
If M2 is specified as the main module the program will output:
\begin{chapelprintoutput}
% test_main_module.M2.good
M1's main\\
M2's main
\end{chapelprintoutput}
Notice that main is treated like just another function if it not in
the main module and can be called as such.
\end{example}

\index{exploratory programming}

%% \subsubsection{Programs with a Single Module}
%% \label{Programs_with_a_Single_Module}

To aid in exploratory programming, if the file(s) listed on the
compiler's command line only define a single module, the module need
not define a main function.  In this case, a default main function is
created to execute the module initialization code.
\begin{example}
The code
\begin{chapelpre}
% test_no_main.chpl
\end{chapelpre}
\begin{chapel}
writeln("hello, world");
\end{chapel}
\begin{chapeloutput}
hello, world
\end{chapeloutput}
is a legal and complete Chapel program.  Its initialization function,
which also serves as the program's main function, is the top-level
writeln() statement.  The module declaration is taken to be the file
as described in~\rsec{Implicit_Modules}.
\end{example}


\subsubsection{Module Initialization Order}
\label{Module_Initialization_Order}

Module initialization is performed using the following algorithm.

Module use can be represented by a directed graph over the modules.
Starting from the module that defines the main function, modules are
initialized in the order implied by a depth-first, post-order
traversal of the graph.  Modules are initialized in the order in which
they appear in the program text.  For nested modules, uses in the
parent module are initialized before uses in the nested module.

\begin{example}
The code
\begin{chapelpre}
% test_init_order.chpl
\end{chapelpre}
\begin{chapel}
module M1 {
  use M2.M3;
  use M2;
  writeln("In M1's initializer");
  def main() {
    writeln("In main");
  }
}

module M2 {
  use M4;
  writeln("In M2's initializer");
  module M3 {
    writeln("In M3's initializer");
  }
}

module M4 {
  writeln("In M4's initializer");
}
\end{chapel}
prints the following
\begin{chapelprintoutput}
In M4's initializer\\
In M2's initializer\\
In M3's initializer\\
In M1's initializer\\
In main
\end{chapelprintoutput}
M1, the main module, uses M2.M3 and then M2, thus M2.M3 must be
initialized.  Because M2.M3 is a nested module, M4 (which is used by
M2) must be initialized first.  M2 itself is initialized, followed by
M2.M3.  Finally M1 is initialized, and the main function is run.
\end{example}
