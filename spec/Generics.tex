\sekshun{Generics}
\label{Generics}

Chapel supports generic functions and types that are parameterizable
over both types and parameters.  The generic functions and types look
similar to non-generic functions and types already discussed.

\subsection{Generic Functions}
\label{Generic_Functions}
\index{functions!generic}
\index{generics!functions}

A function is generic if any of the following conditions hold:
\begin{itemize}
\item
Some formal argument is specified with an intent of \chpl{type} or
\chpl{param}.
\item
Some formal argument has no specified type and no default value.
\item
Some formal argument is specified with a queried type.
\item
The type of some formal argument is a generic type, e.g., \chpl{List}.
Queries may be inlined in generic types, e.g., \chpl{List(?eltType)}.
\item
The type of some formal argument is an array type where either the
element type is queried or omitted or the domain is queried or
omitted.
\end{itemize}
These conditions are discussed in the next sections.

\subsubsection{Formal Type Arguments}
\label{Formal_Type_Arguments}
\index{intents!type@\chpl{type}}

If a formal argument is specified with intent \chpl{type}, then a type
must be passed to the function at the call site.  A copy of the
function is instantiated for each unique type that is passed to this
function at a call site.  The formal argument has the semantics of a
type alias.
\begin{example}
The following code defines a function that takes two types at the call
site and returns a 2-tuple where the types of the components of the
tuple are defined by the two type arguments and the values are
specified by the types default values.
\begin{chapel}
def build2Tuple(type t, type tt) {
  var x1: t;
  var x2: tt;
  return (x1, x2);
}
\end{chapel}
This function is instantiated with ``normal'' function call syntax
where the arguments are types:
\begin{chapel}
var t2 = build2Tuple(int, string);
t2 = (1, "hello");
\end{chapel}
\end{example}

\subsubsection{Formal Parameter Arguments}
\label{Formal_Parameter_Arguments}
\index{intents!param@\chpl{param}}

If a formal argument is specified with intent \chpl{param}, then a
parameter must be passed to the function at the call site.  A copy of
the function is instantiated for each unique parameter that is passed
to this function at a call site.  The formal argument is a parameter.
\begin{example}
The following code defines a function that takes an integer parameter
\chpl{p} at the call site as well as a regular actual argument of
integer type \chpl{x}.  The function returns a homogeneous tuple of
size \chpl{p} where each component in the tuple has the value of
\chpl{x}.
\begin{chapel}
def fillTuple(param p: int, x: int) {
  var result: p*int;
  for param i in 1..p do
    result(i) = x;
  return result;
}
\end{chapel}
The function call \chpl{fillTuple(3, 3)} returns a 3-tuple where each
component contains the value \chpl{3}.
\end{example}

\subsubsection{Formal Arguments without Types}
\label{Formal_Arguments_without_Types}
\index{formal arguments!without types}

If the type of a formal argument is omitted, the type of the formal
argument is taken to be the type of the actual argument passed to the
function at the call site.  A copy of the function is instantiated for
each unique actual type.
\begin{example}
The example from the previous section can be extended to be generic on
a parameter as well as the actual argument that is passed to it by
omitting the type of the formal argument \chpl{x}.  The following code
defines a function that returns a homogeneous tuple of size \chpl{p}
where each component in the tuple is initialized to \chpl{x}:
\begin{chapel}
def fillTuple(param p: int, x) {
  var result: p*x.type;
  for param i in 1..p do
    result(i) = x;
  return result;
}
\end{chapel}
In this function, the type of the tuple is taken to be the type of the
actual argument.  The call \chpl{fillTuple(3, 3.14)} returns a 3-tuple
of real values \chpl{(3.14, 3.14, 3.14)}.  The return type is
\chpl{(real, real, real)}.
\end{example}

\subsubsection{Formal Arguments with Queried Types}
\label{Formal_Arguments_with_Queried_Types}
\index{formal arguments!queried types}

If the type of a formal argument is specified as a queried type, the
type of the formal argument is taken to be the type of the actual
argument passed to the function at the call site.  A copy of the
function is instantiated for each unique actual type.  The queried
type has the semantics of a type alias.
\begin{example}
The example from the previous section can be rewritten to use a
queried type for clarity:
\begin{chapel}
def fillTuple(param p: int, x: ?t) {
  var result: p*t;
  for param i in 1..p do
    result(i) = x;
  return result;
}
\end{chapel}
\end{example}

\subsubsection{Formal Arguments of Generic Type}
\label{Formal_Arguments_of_Generic_Type}
\index{formal arguments!generic types}

If the type of a formal argument is a generic type, the type of the
formal argument is taken to be the type of the actual argument passed
to the function at the call site with the constraint that the type of
the actual argument is an instantiation of the generic type.  A copy
of the function is instantiated for each unique actual type.
\begin{example}
The following code defines a function \chpl{writeTop} that takes an
actual argument that is a generic stack
(see~\rsec{Example_Generic_Stack}) and outputs the top element of the
stack.  The function is generic on the type of its argument.
\begin{chapel}
def writeTop(s: Stack) {
  write(s.top.item);
}
\end{chapel}
\end{example}

Types and parameters may be queried from the top-level types of formal
arguments as well.  In the example above, the formal argument's type
could also be specified as \chpl{Stack(?type)} in which case the
symbol \chpl{type} is equivalent to \chpl{s.itemType}.

Note that generic types which have default values for all of their
generic fields, \emph{e.g. range}, are not generic when simply
specified and require a query to mark the argument as generic.

\index{integral@\chpl{integral}}
\index{numeric@\chpl{numeric}}
\index{enumerated@\chpl{enumerated}}
The generic types \chpl{integral}, \chpl{numeric} and \chpl{enumerated}
are generic types that can only be instantiated with, respectively, the
signed and unsigned integral types, all of the numeric types, and
enumerated types.

\subsubsection{Formal Arguments of Generic Array Types}
\label{Formal_Arguments_of_Generic_Array_Types}
\index{formal arguments!array types}

If the type of a formal argument is an array where either the domain
or the element type is queried or omitted, the type of the formal
argument is taken to be the type of the actual argument passed to the
function at the call site.  If the domain is omitted, the domain of
the formal argument is taken to be the domain of the actual argument.

A queried domain may not be modified via the name to which it is bound
(see~\rsec{Association_of_Arrays_to_Domains} for rationale).

\subsection{Function Visibility in Generic Functions}
\label{Function_Visibility_in_Generic_Functions}
\index{generics!function visibility}

Function visibility in generic functions is altered depending on the
instantiation.  When resolving function calls made within generic
functions, the visible functions are taken from any call site at which
the generic function is instantiated for each particular
instantiation.  The specific call site chosen is arbitrary and it is
referred to as the \emph{point of instantiation}.

\begin{example}
Consider the following code which defines a generic
function \chpl{bar}:
\begin{chapel}
module M1 {
  record R {
    var x: int;
    def foo() { }
  }
}

module M2 {
  def bar(x) {
    x.foo();
  }
}

module M3 {
  use M1, M2;
  def main() {
    var r: R;
    bar(r);
  }
}
\end{chapel}
In the function \chpl{main}, the variable \chpl{r} is declared to be
of type \chpl{R} defined in module \chpl{M1} and a call is made to the
generic function \chpl{bar} which is defined in module \chpl{M2}.
This is the only place where \chpl{bar} is called in this program and
so it becomes the point of instantiation for \chpl{bar} when the
argument \chpl{x} is of type \chpl{R}.  Therefore, the call to
the \chpl{foo} method in \chpl{bar} is resolved by looking for visible
functions from within \chpl{main} and going through the use of
module \chpl{M1}.
\end{example}

If the generic function is only called indirectly through dynamic
dispatch, the point of instantiation is defined as the point at which
the derived type (the type of the implicit \chpl{this} argument) is
defined or instantiated (if the derived type is generic).

\begin{rationale}
Visible function lookup in Chapel's generic functions is handled
differently than in C++'s template functions in that there is no split
between dependent and independent types.

Also, dynamic dispatch and instantiation is handled differently.
Chapel supports dynamic dispatch over methods that are generic in some
of its formal arguments.

Note that the Chapel lookup mechanism is still under development and
discussion.  Comments or questions are appreciated.
\end{rationale}

\subsection{Generic Types}
\label{Generic_Types}
\index{generics!types}
\index{classes!generic}
\index{records!generic}

A class or record is generic if any of the following conditions hold:
\begin{itemize}
\item
The class contains a specified or unspecified type alias.
\item
The class contains a field that is a parameter.
\item
The class contains a field that has no type and no initialization
expression.
\end{itemize}

\subsubsection{Type Aliases in Generic Types}
\label{Type_Aliases_in_Generic_Types}
\index{type aliases!in classes or records}

Type aliases defined in a class or a record can be unspecified type
aliases; type aliases that are not bound to a type.  If a class or
record contains an unspecified type alias, the aliased type must be
specified whenever the type is used.

A type alias defined in a class or record is accessed as if it were a
field.  Moreover, it becomes an argument with intent \chpl{type} to
the default constructor for that class or record.  This makes the
default constructor generic.  When the default constructor is
instantiated, the type is instantiated where the type bound to the
type alias is set to be the type passed to the default constructor.

\begin{example}
The following code defines a class called \chpl{Node} that implements
a linked list data structure.  It is generic over the type of the
element contained in the linked list.
\begin{chapel}
class Node {
  type eltType;
  var data: eltType;
  var next: Node(eltType);
}
\end{chapel}
The call \chpl{new Node(real, 3.14)} creates a node in the linked list
that contains the value \chpl{3.14}.  The \chpl{next} field is set to
nil.  The type specifier \chpl{Node} is a generic type and cannot be
used to define a variable.  The type specifier \chpl{Node(real)}
denotes the type of the \chpl{Node} class instantiated over
\chpl{real}.  Note that the type of the \chpl{next} field is specified
as \chpl{Node(eltType)}; the type of \chpl{next} is the same type as
the type of the object that it is a field of.
\end{example}

\subsubsection{Parameters in Generic Types}
\label{Parameters_in_Generic_Types}
\index{parameters!in classes or records}

Parameters defined in a class or record do not require an
initialization expression.  If they do not have an initialization
expression, the parameter must be specified whenever the type is used.

A parameter defined in a class or record is accessed as if it were a
field.  This access returns a parameter.  Parameters defined in
classes or records become arguments with intent \chpl{param} to the
default constructor for that class or record.  This makes the default
constructor generic.  When the default constructor is instantiated,
the type is instantiated where the parameter is bound to the parameter
passed to the default constructor.

\begin{example}
The following code defines a class called \chpl{IntegerTuple} that is
generic over an integer parameter which defines the number of
components in the class.
\begin{chapel}
class IntegerTuple {
  param size: int;
  var data: size*int;
}
\end{chapel}
The call \chpl{new IntegerTuple(3)} creates an instance of the
\chpl{IntegerTuple} class that is instantiated over parameter
\chpl{3}.  The field \chpl{data} becomes a 3-tuple of integers.  The
type of this class instance is \chpl{IntegerTuple(3)}.  The type
specified by \chpl{IntegerTuple} is a generic type.
\end{example}

\subsubsection{Fields without Types}
\label{Fields_without_Types}
\index{fields!without types}

If a field in a class or record has no specified type or
initialization expression, the class or record is generic over the
type of that field.  The field must be specified when the class or
record is constructed or specified.  The field becomes an argument to
the default constructor that has no specified type and no default
value.  This makes the default constructor generic.  When the default
constructor is instantiated, the type is instantiated where the type
of the field becomes the type of the actual argument passed to the
default constructor.  When specifying the type of the class or record,
the type of this field should be ``passed'' to the specifier.

\begin{example}
The following code defines another class called \chpl{Node} that
implements a linked list data structure.  It is generic over the type
of the element contained in the linked list.  This code does not
specify the element type directly in the class as a type alias but
rather omits the type from the \chpl{data} field.
\begin{chapel}
class Node {
  var data;
  var next: Node(data) = nil;
}
\end{chapel}
A node with integer element type can be defined in the call to the
constructor.  The call \chpl{new Node(1)} defines a node with the
value \chpl{1}.  The code
\begin{chapel}
var list = new Node(1);
list.next = new Node(2);
\end{chapel}
defines a two-element list with nodes containing the values \chpl{1}
and \chpl{2}.  The type of each class could be specified
as \chpl{Node(int)}.
\end{example}

\subsubsection{Generic Methods}
\label{Generic_Methods}
\index{generics!methods}

All methods bound to generic classes or records are generic over the
implicit \chpl{this} argument and any other argument that is generic.

\subsection{Where Expressions}
\label{Where_Expressions}
\index{where@\chpl{where}}

The instantiation of a generic function can be constrained by {\em
where clauses}.  A where clause is specified in the definition of a
function~(\rsec{Function_Definitions}).  When a function is
instantiated, the expression in the where clause must be a parameter
expression and must evaluate to either \chpl{true} or \chpl{false}.
If it evaluates to \chpl{false}, the instantiation is rejected and the
function is not a possible candidate for function resolution.
Otherwise, the function is instantiated.
\begin{example}
Given two overloaded function definitions
\begin{chapel}
def foo(x) where x.type == int { $\ldots$ }
def foo(x) where x.type == real { $\ldots$ }
\end{chapel}
the call foo(3) resolves to the first definition because when the
second function is instantiated the where clause evaluates to false.
\end{example}

\subsection{User-Defined Compiler Diagnostics}
\label{User_Defined_Compiler_Errors}
\index{compiler diagnostics!user-defined}
\index{compiler errors!user-defined}
\index{compiler warnings!user-defined}
\index{compilerError}
\index{compilerWarning}

The special compiler diagnostic statements given by
\begin{syntax}
compiler-diagnostic-statement:
  `compilerError' ( expression-list ) ;
  `compilerWarning' ( expression-list ) ;

expression-list:
  expression
  expression , expression-list
\end{syntax}
generate a compiler diagnostic of the indicated severity 
if the function containing the statement may be called 
when the program is executed and the statement is
not eliminated by parameter folding.

The compiler diagnostic is defined by the expression list which can
contain string literals and types.  The diagnostic points to the spot
in the Chapel program from which the function containing
the \sntx{compiler-diagnostic-statement} is called.  Compilation halts
if a \chpl{compilerError} is encountered whereas it will continue
after encountering a \chpl{compilerWarning}.

Note that when a variable function is called in a context where the
implicit \chpl{setter} argument is true or false, both versions of the
variable function are resolved by the compiler.  Consequently,
the \chpl{setter} argument cannot be effectively used to guard a
compiler diagnostic statements.

\begin{example}
The following code shows an example of using user-defined compiler
diagnostics to generate warnings and errors:

\begin{chapel}
def foo(x, y) {
  if (x.type != y.type) then
    compilerError("foo() called with non-matching types: ", 
                  x.type, " != ", y.type);
  writeln("In 2-argument foo...");
}

def foo(x) {
  compilerWarning("1-argument version of foo called");
  writeln("In generic foo!");
}
\end{chapel}

The first routine generates a compiler error whenever the compiler
encounters a call to it where the two arguments have different types.
It prints out an error message indicating the types of the arguments.
The second routine generates a compiler warning whenver the compiler
encounters a call to it.

Thus, if the program foo.chpl contained the following calls:

\begin{numberedchapel}
foo(3.4);
foo("hi");
foo(1, 2);
foo(1.2, 3.4);
foo("hi", "bye");
foo(1, 2.3);
foo("hi", 2.3);
\end{numberedchapel}

\noindent compiling the program would generate output like:

\begin{commandline}
foo.chpl:1: warning: 1-argument version of foo called with type: real
foo.chpl:2: warning: 1-argument version of foo called with type: string
foo.chpl:6: error: foo() called with non-matching types: int != real
\end{commandline}

\end{example}

\subsection{Example: A Generic Stack}
\label{Example_Generic_Stack}

\begin{chapel}
class MyNode {
  type itemType;              // type of item
  var item: itemType;         // item in node
  var next: MyNode(itemType); // reference to next node (same type)
}

record Stack {
  type itemType;             // type of items
  var top: MyNode(itemType); // top node on stack linked list

  def push(item: itemType) {
    top = new MyNode(itemType, item, top);
  }

  def pop() {
    if isEmpty then
      halt("attempt to pop an item off an empty stack");
    var oldTop = top;
    top = top.next;
    return oldTop.item;
  }

  def isEmpty return top == nil;
}
\end{chapel}
