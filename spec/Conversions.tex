\sekshun{Conversions}
\label{Conversions}

A conversion allows an expression of one type to be converted into
another type.  Conversions can be either
implicit~(\rsec{Implicit_Conversions}) or
explicit~(\rsec{Explicit_Conversions}).

\subsection{Implicit Conversions}
\label{Implicit_Conversions}
\index{conversions!implicit}

Implicit conversions can occur during an assignment (from the
expression on the right-hand side to the variable on the left-hand
side) or during a function call (from the actual expression to the
formal argument).  An implicit conversion does not require a cast.

Implicit conversions are allowed between numeric
types~(\rsec{Implicit_Numeric_Conversions}), from enumerated types to
numeric types~(\rsec{Implicit_Enumeration_Conversions}), between class
types~(\rsec{Implicit_Class_Conversions}), and between record
types~(\rsec{Implicit_Record_Conversions}).  A special set of implicit
conversions are allowed from compile-time constants of type \chpl{int}
and \chpl{int(64)} to other smaller numeric types if the value is in
the range of the smaller numeric
type~(\rsec{Implicit_Compile_Time_Constant_Conversions}).  Lastly,
implicit conversions are supported from integral and class types to
bool in the context of a
statement~(\rsec{Implicit_Statement_Bool_Conversions}).

\subsubsection{Implicit Bool and Numeric Conversions}
\label{Implicit_Numeric_Conversions}
\index{conversions!numeric}
\index{conversions!bool}

The implicit numeric conversions are as follows:
\begin{itemize}
\item From \chpl{bool} to \chpl{bool(k)}, \chpl{int(8)}, \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(8)}, \chpl{uint(16)}, \chpl{uint(32)}, \chpl{uint(64)}, or \chpl{string} for any legal value of $k$
\item From \chpl{bool(j)} to \chpl{bool}, \chpl{bool(k)}, \chpl{int(8)}, \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(8)}, \chpl{uint(16)}, \chpl{uint(32)}, \chpl{uint(64)}, or \chpl{string} for any legal values of $j$ and $k$
\item From \chpl{int(8)} to \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{int(16)} to \chpl{int(32)}, \chpl{int(64)}, \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{int(32)} to \chpl{int(64)}, \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{int(64)} to \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{uint(8)} to \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(16)}, \chpl{uint(32)}, \chpl{uint(64)}, \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{uint(16)} to \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(32)}, \chpl{uint(64)}, \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{uint(32)} to \chpl{int(64)}, \chpl{uint(64)}, \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{uint(64)} to \chpl{real(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{real(32)} to \chpl{real(64)}, \chpl{complex(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{real(64)} to \chpl{complex(128)} or \chpl{string}
\item From \chpl{imag(32)} to \chpl{imag(64)}, \chpl{complex(64)}, \chpl{complex(128)}, or \chpl{string}
\item From \chpl{imag(64)} to \chpl{complex(128)} or \chpl{string}
\item From \chpl{complex(64)} to \chpl{complex(128)} or \chpl{string}
\item From \chpl{complex(128)} to \chpl{string}
\end{itemize}

The implicit numeric conversions do not result in any loss of
information except for the conversions from \chpl{int(64)}
or \chpl{uint(64)} to \chpl{real(64)} or \chpl{complex(128)} and from
any of the \chpl{real}, \chpl{imag}, or \chpl{complex} types
to \chpl{string}.

\begin{rationale}
In C\#, implicit conversions from \chpl{int(32)} or \chpl{int(64)}
to \chpl{real(32)} are supported and allow for a loss of precision.
Since the default \chpl{real} size is 64 and the default \chpl{int}
size is 32 in Chapel, we did not follow the lead of C\# in this regard
since it seemed unfortunate to favor \chpl{real(32)} over \chpl{real}
in the default case.  That is, given the \chpl{sqrt} function defined
over \chpl{real(32)} and \chpl{real}, it is preferable to choose the
version over \chpl{real} when calling with an actual of
type \chpl{int} rather than lose precision and half of the bits to
call the \chpl{real(32)} version.

Additionally, we don't allow implicit conversions from \chpl{int(8)}
or \chpl{int(16)} to \chpl{real(32)} because to do so would result in
an ambiguity when computing, e.g., \chpl{int(8) + int(8)}.
\end{rationale}

\subsubsection{Implicit Enumeration Conversions}
\label{Implicit_Enumeration_Conversions}
\index{conversions!enumeration}

An expression that is an enumerated type can be implicitly converted
to any integral type as long as all of the constants defined by the
enumerated type are within range of the integral type.  It can also be
implicitly converted to \chpl{string} where the string is the name of
the enumerated constant.

\subsubsection{Implicit Class Conversions}
\label{Implicit_Class_Conversions}
\index{conversions!class}

An expression of class type \chpl{D} can be implicitly converted to
another class type \chpl{C} provided that \chpl{D} is a subclass
of \chpl{C}.

\subsubsection{Implicit Record Conversions}
\label{Implicit_Record_Conversions}
\index{conversions!record}

An expression of record type \chpl{D} can be implicitly converted to
another record type \chpl{C} provided that \chpl{D} is a nominal
subtype of \chpl{C}.

\subsubsection{Implicit Compile-Time Constant Conversions}
\label{Implicit_Compile_Time_Constant_Conversions}
\index{conversions!parameter}

The following two implicit conversions of parameters are supported:
\begin{itemize}
\item A parameter of type \chpl{int(32)} can be implicitly converted
to \chpl{int(8)}, \chpl{int(16)}, or any unsigned integral type if the
value of the parameter is within the range of the target type.
\item A parameter of type \chpl{int(64)} can be implicitly converted
to \chpl{uint(64)} if the value of the parameter is nonnegative.
\end{itemize}

\subsubsection{Implicit Statement Bool Conversions}
\label{Implicit_Statement_Bool_Conversions}
\index{conversions!bool}

In the condition of an if-statement, while-loop, and do-while-loop,
the following implicit conversions are supported:
\begin{itemize}
\item An expression of integral type is taken to be true if it is non-zero and is otherwise false.
\item An expression of a class type is taken to be true if is not nil and is otherwise false.
\end{itemize}

\subsection{Explicit Conversions}
\label{Explicit_Conversions}
\index{conversions!explicit}

Explicit conversions require a cast in the code.  Casts are defined
in~\rsec{Casts}.  Explicit conversions are supported between more
types than implicit conversions, but explicit conversions are not
supported between all types.

The explicit conversions are a superset of the implicit conversions.

\subsubsection{Explicit Numeric Conversions}
\label{Explicit_Numeric_Conversions}
\index{conversions!numeric}

Explicit conversions are allowed from any numeric type, bool, or
string to any other numeric type, bool, or string.  The definitions of
how these explicit conversions work is forthcoming.

\subsubsection{Explicit Enumeration Conversions}
\label{Explicit_Enumeration_Conversions}
\index{conversions!enumeration}

Explicit conversions are allowed from any enumerated types to any
numeric type, bool, or string, and vice versa.

\subsubsection{Explicit Class Conversions}
\label{Explicit_Class_Conversions}
\index{conversions!class}

An expression of static class type \chpl{C} can be explicitly
converted to a class type \chpl{D} provided that \chpl{C} is derived
from \chpl{D} or \chpl{D} is derived from \chpl{C}.  In the event
that \chpl{D} is derived from \chpl{C}, it is a runtime error if the
the dynamic class type of \chpl{C} is not derived from or equal
to \chpl{D}.

\subsubsection{Explicit Record Conversions}
\label{Explicit_Record_Conversions}
\index{conversions!record}

An expression of record type \chpl{C} can be explicitly converted to
another record type \chpl{D} provided that \chpl{C} is derived
from \chpl{D}.  There are no explicit record conversions that are not
also implicit record conversions.
