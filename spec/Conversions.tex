\sekshun{Conversions}
\label{Conversions}

A conversion allows an expression of one type to be converted into
another type.  Conversions can be either
implicit~(\rsec{Implicit_Conversions}) or
explicit~(\rsec{Implicit_Conversions}).

\subsection{Implicit Conversions}
\label{Implicit_Conversions}
\index{conversions!implicit}

Implicit conversions can occur during an assignment (from the
expression on the right-hand side to the variable on the left-hand
side) or during a function call (from the actual expression to the
formal argument).  An implicit conversion does not require a cast.

Implicit conversions are allowed between numeric
types~(\rsec{Implicit_Numeric_Conversions}), from enumerated types to
numeric types~(\rsec{Implicit_Enumeration_Conversions}), between class
types~(\rsec{Implicit_Class_Conversions}), and between record
types~(\rsec{Implicit_Record_Conversions}).  A special set of implicit
conversions are allowed from compile-time constants of type \chpl{int}
and \chpl{int(64)} to other smaller numeric types if the value is in
the range of the smaller numeric
type~(\rsec{Implicit_Compile_Time_Constant_Conversions}).  Lastly,
implicit conversions are supported from integeral and class types to
bool in the context of a
statement~(\rsec{Implicit_Statement_Bool_Conversions}).

\subsubsection{Implicit Bool and Numeric Conversions}
\label{Implicit_Numeric_Conversions}
\index{conversions!numeric}
\index{conversions!bool}

The implicit numeric conversions are as follows:
\begin{itemize}
\item From \chpl{bool} to \chpl{int(8)}, \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(8)}, \chpl{uint(16)}, \chpl{uint(32)}, \chpl{uint(64)}, or \chpl{string}
\item From \chpl{int(8)} to \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{int(16)} to \chpl{int(32)}, \chpl{int(64)}, \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{int(32)} to \chpl{int(64)}, \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{int(64)} to \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{uint(8)} to \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(16)}, \chpl{uint(32)}, \chpl{uint(64)}, \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{uint(16)} to \chpl{int(32)}, \chpl{int(64)}, \chpl{uint(32)}, \chpl{uint(64)}, \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{uint(32)} to \chpl{int(64)}, \chpl{uint(64)}, \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{uint(64)} to \chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{real(32)} to \chpl{real(64)}, \chpl{real(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{real(64)} to \chpl{real(128)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{real(128)} to \chpl{complex(256)} or \chpl{string}
\item From \chpl{imag(32)} to \chpl{imag(64)}, \chpl{imag(128)}, \chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{imag(64)} to \chpl{imag(128)}, \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{imag(128)} to \chpl{complex(256)} or \chpl{string}
\item From \chpl{complex(64)} to \chpl{complex(128)}, \chpl{complex(256)}, or \chpl{string}
\item From \chpl{complex(128)} to \chpl{complex(256)}, or \chpl{string}
\item From \chpl{complex(256)} to \chpl{string}
\end{itemize}

The implicit numeric conversions do not result in any loss of
information except for the conversions from any of the \chpl{int}
and \chpl{uint} types to any of the \chpl{real} and \chpl{complex}
types and from any of the \chpl{real}, \chpl{imag}, and \chpl{complex}
types to \chpl{string} where there is a loss of precision.

\subsubsection{Implicit Enumeration Conversions}
\label{Implicit_Enumeration_Conversions}
\index{conversions!enumeration}

An expression that is an enumerated type can be implicitly converted
to any integral type as long as all of the constants defined by the
enumerated type are within range of the integral type.  It can also be
implicitly converted to \chpl{string} where the string is the name of
the enumerated constant.

\subsubsection{Implicit Class Conversions}
\label{Implicit_Class_Conversions}
\index{conversions!class}

An expression of class type \chpl{D} can be implicitly converted to
another class type \chpl{C} provided that \chpl{D} is a subclass
of \chpl{C}.

\subsubsection{Implicit Record Conversions}
\label{Implicit_Record_Conversions}
\index{conversions!record}

An expression of record type \chpl{D} can be implicitly converted to
another record type \chpl{C} provided that \chpl{D} is a nominal
subtype of \chpl{C}.

\subsubsection{Implicit Compile-Time Constant Conversions}
\label{Implicit_Compile_Time_Constant_Conversions}
\index{conversions!parameter}

The following two implicit conversions of parameters are supported:
\begin{itemize}
\item A parameter of type \chpl{int(32)} can be implicitly converted
to \chpl{int(8)}, \chpl{int(16)}, or any unsigned integral type if the
value of the parameter is within the range of the target type.
\item A parameter of type \chpl{int(64)} can be implicitly converted
to \chpl{uint(64)} if the value of the parameter is nonnegative.
\end{itemize}

\subsubsection{Implicit Statement Bool Conversions}
\label{Implicit_Statement_Bool_Conversions}
\index{conversions!bool}

In the condition of an if-statement, while-loop, and do-while-loop,
the following implicit conversions are supported:
\begin{itemize}
\item An expression of integral type is taken to be true if it is non-zero and is otherwise false.
\item An expression of a class type is taken to be true if is not nil and is otherwise false.
\end{itemize}

\subsection{Explicit Conversions}
\label{Explicit_Conversions}
\index{conversions!explicit}

Explicit conversions require a cast in the code.  Casts are defined
in~\rsec{Casts}.  Explicit conversions are supported between more
types than implicit conversions, but explicit conversions are not
supported between all types.

The explicit conversions are a superset of the implicit conversions.

\subsubsection{Explicit Numeric Conversions}
\label{Explicit_Numeric_Conversions}
\index{conversions!numeric}

Explicit conversions are allowed from any numeric type, bool, or
string to any other numeric type, bool, or string.  The definitions of
how these explicit conversions work is forthcoming.

\subsubsection{Explicit Enumeration Conversions}
\label{Explicit_Enumeration_Conversions}
\index{conversions!enumeration}

Explicit conversions are allowed from any enumerated types to any
numeric type, bool, or string, and vice versa.

\subsubsection{Explicit Class Conversions}
\label{Explicit_Class_Conversions}
\index{conversions!class}

An expression of static class type \chpl{C} can be explicitly
converted to a class type \chpl{D} provided that \chpl{C} is derived
from \chpl{D} or \chpl{D} is derived from \chpl{C}.  In the event
that \chpl{D} is derived from \chpl{C}, it is a runtime error if the
the dynamic class type of \chpl{C} is not derived from or equal
to \chpl{D}.

\subsubsection{Explicit Record Conversions}
\label{Explicit_Record_Conversions}
\index{conversions!record}

An expression of record type \chpl{C} can be explicitly converted to
another record type \chpl{D} provided that \chpl{C} is derived
from \chpl{D}.  There are no explicit record conversions that are not
also implicit record conversions.
