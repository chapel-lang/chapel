\sekshun{Variables}
\label{Variables}
\index{variables}

A variable is a symbol that represents memory.  Chapel is a
statically-typed, type-safe language so every variable has a type that
is known at compile-time and the compiler enforces that values
assigned to the variable can be stored in that variable as specified
by its type.

\section{Variable Declarations}
\label{Variable_Declarations}
\index{variables!declarations}
\index{declarations!variables}

Variables are declared with the following syntax:
\begin{syntax}
variable-declaration-statement:
  privacy-specifier[OPT] config-or-extern[OPT] variable-kind variable-declaration-list ;

config-or-extern: one of
  `config' $ $ $ $ `extern'

variable-kind:
  `param'
  `const'
  `var'
  `ref'
  `const ref'

variable-declaration-list:
  variable-declaration
  variable-declaration , variable-declaration-list

variable-declaration:
  identifier-list type-part[OPT] initialization-part
  identifier-list type-part no-initialization-part[OPT]

type-part:
  : type-expression

initialization-part:
  = expression

no-initialization-part:
  = `noinit'

identifier-list:
  identifier
  identifier , identifier-list
  tuple-grouped-identifier-list
  tuple-grouped-identifier-list , identifier-list

tuple-grouped-identifier-list:
  ( identifier-list )
\end{syntax}
A \sntx{variable-declaration-statement} is used to define one or more
variables.  If the statement is a top-level module statement, the
variables are module level; otherwise they are local.  Module level variables are
discussed in~\rsec{Module_Level_Variables}.  Local variables are discussed
in~\rsec{Local_Variables}.

The optional \sntx{privacy-specifier} keywords indicate the visibility
of module level variables to outside modules.  By default, variables
are publicly visible.  More details on visibility can be found in
~\rsec{Visibility_Of_Symbols}.

The optional keyword \chpl{config} specifies that the variables are
configuration variables, described in
Section~\rsec{Configuration_Variables}.  The optional keyword \chpl{extern}
indicates that the variable is externally defined.  Its name and type are used
within the Chapel program for resolution, but no space is allocated for it and
no initialization code emitted.
See \rsec{Shared_Data} for further details.

The \sntx{variable-kind} specifies whether the variables are
parameters (\chpl{param}), constants (\chpl{const}),
ref variables (\chpl{ref}), or regular
variables (\chpl{var}).  Parameters are compile-time constants whereas
constants are runtime constants.  Both levels of constants are
discussed in~\rsec{Constants}.
Ref variables are discussed in \rsec{Ref_Variables}.

The \sntx{type-part} of a variable declaration specifies the type of
the variable.  It is optional if the \sntx{initialization-part} is
specified.  If the \sntx{type-part} is omitted, the type of the
variable is inferred using local type inference described
in~\rsec{Local_Type_Inference}. If the \sntx{type-part} refers
to a generic type, then an \sntx{initialization-part} is required
and will be used to determine the type of the variable. In this event,
the compiler will fail with an error if the \sntx{initialization-part} is
not coercible to an instantiation of the generic type.

The \sntx{initialization-part} of a variable declaration specifies an
initial expression to assign to the variable.  If
the \sntx{initialization-part} is omitted, the \sntx{type-part} must
be present, and the variable is initialized to the default value of
its type as described in~\rsec{Default_Values_For_Types}.

If the \sntx{no-initialization-part} is present, the variable
declaration does not initialize the variable to any value, as
described in~\rsec{Noinit_Capability}. The result of any read of an
uninitialized variable is undefined until that variable is written.

Multiple variables can be defined in the
same \sntx{variable-declaration-list}.  The semantics of declaring
multiple variables that share an \sntx{initialization-part}
and/or \sntx{type-part} is defined in~\rsec{Multiple_Variable_Declarations}.

Multiple variables can be grouped together using a tuple notation as
described in~\rsec{Variable_Declarations_in_a_Tuple}.

\subsection{Default Initialization}
\label{Default_Values_For_Types}
\index{default initialization!variables}
\index{variables!default initialization}
\index{variables!default values}

If a variable declaration has no initialization expression, a variable
is initialized to the default value of its type.  The default values
are as follows:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Type} & {\bf Default Value} \\
\hline
{\tt bool(*)} & {\tt false} \\
{\tt int(*)} & {\tt 0} \\
{\tt uint(*)} & {\tt 0} \\
{\tt real(*)} & {\tt 0.0} \\
{\tt imag(*)} & {\tt 0.0i} \\
{\tt complex(*)} & {\tt 0.0 + 0.0i} \\
{\tt string} & {\tt ""} \\
enums & first enum constant \\
classes & {\tt nil} \\
records & default constructed record \\
ranges & {\tt 1..0} $ $ $ $ (empty sequence) \\
arrays & elements are default values \\
tuples & components are default values \\
sync/single & base default value and \emph{empty} status \\
atomic & base default value \\
\hline
\end{tabular}
\end{center}

\subsection{Deferred Initialization}
\label{Noinit_Capability}
\index{noinit}
\index{noinit!variables}

For performance purposes, a variable's declaration can specify that
the variable should not be default initialized by using
the \chpl{noinit} keyword in place of an initialization expression.
Since this variable should be written at a later point in order to be
read properly, it must be a regular variable (\chpl{var}).  It is
incompatible with declarations that require the variable to remain
unchanged throughout the program's lifetime, such as \chpl{const}
or \chpl{param}.  Additionally, its type must be specified at
declaration time.

The result of any read of this variable before it is written is
undefined; it exists and therefore can be accessed, but no guarantees
are made as to its contents.

\subsection{Local Type Inference}
\label{Local_Type_Inference}
\index{type inference}
\index{type inference!local}

If the type is omitted from a variable declaration, the type of the
variable is defined to be the type of the initialization expression.
With the exception of sync and single expressions, the declaration
\begin{chapel}
var v = e;
\end{chapel}
is equivalent to
\begin{chapel}
var v: e.type = e;
\end{chapel}
for an arbitrary expression \chpl{e}.  If \chpl{e} is of sync or
single type, the type of \chpl{v} is the base type of \chpl{e}.

\subsection{Multiple Variable Declarations}
\label{Multiple_Variable_Declarations}
\index{declarations!variables!multiple}
\index{variables!declarations!multiple}

All variables defined in the same \sntx{identifier-list} are defined
such that they have the same type and value, and so that the type and
initialization expression are evaluated only once.

\begin{chapelexample}{multiple.chpl}
In the declaration
\begin{chapel}
proc g() { writeln("side effect"); return "a string"; }
var a, b = 1.0, c, d:int, e, f = g();
\end{chapel}
\begin{chapelpost}
writeln((a,b,c,d,e,f));
\end{chapelpost}
variables \chpl{a} and \chpl{b} are of type \chpl{real} with
value \chpl{1.0}.  Variables \chpl{c} and \chpl{d} are of
type \chpl{int} and are initialized to the default value of \chpl{0}.
Variables \chpl{e} and \chpl{f} are of type \chpl{string} with
value \chpl{"a string"}.  The string \chpl{"side effect"} has been
written to the display once.  It is not evaluated twice.
\begin{chapeloutput}
side effect
(1.0, 1.0, 0, 0, a string, a string)
\end{chapeloutput}
\end{chapelexample}

The exact way that multiple variables are declared is defined as
follows:
\begin{itemize}
\item If the variables in the \sntx{identifier-list} are declared
with a type, but without an initialization expression as in
\begin{chapel}
var v1, v2, v3: t;
\end{chapel}
for an arbitrary type expression \chpl{t}, then the declarations are
rewritten so that the first variable is declared to be of
type \chpl{t} and each later variable is declared to be of the type of
the first variable as in
\begin{chapel}
var v1: t; var v2: v1.type; var v3: v1.type;
\end{chapel}

\item If the variables in the \sntx{identifier-list} are declared
without a type, but with an initialization expression as in
\begin{chapel}
var v1, v2, v3 = e;
\end{chapel}
for an arbitrary expression \chpl{e}, then the declarations are
rewritten so that the first variable is initialized by
expression \chpl{e} and each later variable is initialized by the
first variable as in
\begin{chapel}
var v1 = e; var v2 = v1; var v3 = v1;
\end{chapel}

\item If the variables in the \sntx{identifier-list} are declared
with both a type and an initialization expression as in
\begin{chapel}
var v1, v2, v3: t = e;
\end{chapel}
for an arbitrary type expression \chpl{t} and an arbitrary
expression \chpl{e}, then the declarations are rewritten so that the
first variable is declared to be of type \chpl{t} and initialized by
expression \chpl{e}, and each later variable is declared to be of the
type of the first variable and initialized by the result of calling
the function \chpl{readXX} on the first variable as in
\begin{chapel}
var v1: t = e; var v2: v1.type = readXX(v1); var v3: v1.type = readXX(v1);
\end{chapel}
where the function \chpl{readXX} is defined as follows:
\begin{chapel}
proc readXX(x: sync) return x.readXX();
proc readXX(x: single) return x.readXX();
proc readXX(x) return x;
\end{chapel}
Note that the use of the helper function \chpl{readXX()}
in this code fragment is solely for the purposes of illustration.
It is not actually a part of Chapel's semantics or implementation.
\end{itemize}

\begin{rationale}
This algorithm is complicated by the existence of \emph{sync}
and \emph{single} variables.  If these did not exist, we could rewrite
any multi-variable declaration such that later variables were simply
initialized by the first variable and the first variable was defined
as if it appeared alone in the \sntx{identifier-list}.  However,
both \emph{sync} and \emph{single} variables require careful handling
to avoid unintentional changes to their \emph{full}/\emph{empty}
state.
\end{rationale}

\section{Module Level Variables}
\label{Module_Level_Variables}
\index{variables!module level}

Variables declared in statements that are in a module but not in a
function or block within that module are module level variables.
Module level variables can be accessed anywhere within that module
after the declaration of that variable.  If they are public, they can
also be accessed in other modules that use that module.

\section{Local Variables}
\label{Local_Variables}
\index{variables!local}

Local variables are declared within block statements.  They can only
be accessed within the scope of that block statement (including all
inner nested block statements and functions).

A local variable only exists during the execution of code that lies
within that block statement.  This time is called the lifetime of the
variable.  When execution has finished within that block statement,
the local variable and the storage it represents is removed.
Variables of class type are the sole exception.  Initializers of class
types create storage that is not associated with any scope.  Such
storage can be reclaimed as described
in~\rsec{Class_Delete}.

\section{Constants}
\label{Constants}
\index{constants}

Constants are divided into two categories: parameters, specified with
the keyword \chpl{param}, are compile-time constants and constants,
specified with the keyword \chpl{const}, are runtime constants.

\subsection{Compile-Time Constants}
\label{Compile-Time_Constants}
\index{constants!compile-time}
\index{parameters}
\index{param@\chpl{param}}

A compile-time constant, or ``parameter'', must have a single value that is
known statically by the compiler.  Parameters are restricted to
primitive and enumerated types.

Parameters can be assigned expressions that are parameter expressions.
Parameter expressions are restricted to the following constructs:
\begin{itemize}
\item
 Literals of primitive or enumerated type.
\item
 Parenthesized parameter expressions.
\item
 Casts of parameter expressions to primitive or enumerated types.
\item
 Applications of the unary operators \verb@+@, \verb@-@, \verb@!@,
 and \verb@~@ on operands that are bool or integral parameter
 expressions.
\item
 Applications of the unary operators \verb@+@ and \verb@-@ on operands that are
 real, imaginary or complex parameter
 expressions.
\item
 Applications of the binary operators \verb@+@, \verb@-@, \verb@*@, \verb@/@, \verb@%@, \verb@**@, \verb@&&@, \verb@||@, \verb@&@, \verb@|@, \verb@^@, \verb@<<@, \verb@>>@, \verb@==@, \verb@!=@, \verb@<=@, \verb@>=@, \verb@<@, and \verb@>@ on operands that are bool or integral parameter expressions.
\item
 Applications of the binary
 operators \verb@+@, \verb@-@, \verb@*@, \verb@/@, \verb@**@, \verb@==@, \verb@!=@, \verb@<=@, \verb@>=@, \verb@<@,
 and \verb@>@ on operands that are real, imaginary or complex parameter expressions.
\item
 Applications of the string concatenation operator \verb@+@, string comparison operators \verb@==@, \verb@!=@, \verb@<=@, \verb@>=@, \verb@<@, \verb@>@, and the string length and ascii functions on parameter string expressions.
\item
 The conditional expression where the condition is a parameter and the
 then- and else-expressions are parameters.
\item
 Call expressions of parameter functions.  See~\rsec{Param_Return_Intent}.
\end{itemize}

\subsection{Runtime Constants}
\label{Runtime_Constants}
\index{constants!runtime}
\index{constants}
\index{const@\chpl{const}}

Runtime constants, or simply ``constants'', do not have the
restrictions that are associated with parameters.  Constants can be of
any type.  Whether initialized explicitly or via its type's default
value, a constant stores the same value throughout its lifetime.

A variable of a class type that is a constant is a constant reference.
That is, the variable always
points to the object that it was initialized to reference.
However, the fields of that object are allowed to be modified.

\section{Configuration Variables}
\label{Configuration_Variables}
\index{variables!configuration}
\index{constants!configuration}
\index{config@\chpl{config}}

If the keyword \chpl{config} precedes the
keyword \chpl{var}, \chpl{const}, or \chpl{param}, the variable,
constant, or parameter is called a configuration variable,
configuration constant, or configuration parameter respectively.  Such
variables, constants, and parameters must be at the module level.

The initialization of these variables can be set via implementation
dependent means, such as command-line switches or environment
variables.  The initialization expression in the program is ignored if
the initialization is alternatively set.

\index{parameters!configuration}
Configuration parameters are set at compilation time via compilation
flags or other implementation-defined means.  The value passed via
these means can be an arbitrary Chapel expression as long as the
expression can be evaluated at compile-time.  If present, the value thus
supplied overrides the default value appearing in the Chapel code.

\begin{chapelexample}{config-param.chpl}
For example,
\begin{chapel}
config param rank = 2;
\end{chapel}
\begin{chapelnoprint}
writeln(rank);
\end{chapelnoprint}
\begin{chapeloutput}
2
\end{chapeloutput}
sets an integer parameter \chpl{rank} to \chpl{2}.
At compile-time, this default value of \chpl{rank} can be overridden
with another parameter expression, such as \chpl{3} or \chpl{2*n},
provided \chpl{n} itself is a parameter. The \chpl{rank}
configuration variable can be used to write rank-independent code.
\end{chapelexample}

\section{Ref Variables}
\label{Ref_Variables}
\index{variables!ref}
\index{ref@\chpl{ref}}

A \emph{ref} variable is a variable declared using the \chpl{ref} keyword.
A ref variable serves as an alias to another variable, field or array element.
The declaration of a ref variable must contain \sntx{initialization-part},
which specifies what is to be aliased and can be a variable
or any lvalue expression.

Access or update to a ref variable is equivalent to access or update
to the variable being aliased. For example, an update to a ref variable
is visible via the original variable, and visa versa.

If the expression being aliased is a runtime constant variable,
a formal argument with a \chpl{const ref} concrete intent
(\rsec{Concrete Intents}), or a call to a function with a \chpl{const ref}
return intent (\rsec{Const_Ref_Return_Intent}), the corresponding
ref variable must be declared as \chpl{const ref}.
Parameter constants and expressions cannot be aliased.

\begin{openissue}
The behavior of a \chpl{const ref} alias to a non-\chpl{const} variable
is an open issue. The options include disallowing such an alias,
disallowing changes to the variable while it can be accessed via
a \chpl{const ref} alias, making changes visible through the alias,
and making the behavior undefined.
\end{openissue}

\begin{chapelexample}{refVariables.chpl}
For example, the following code:

\begin{chapel}
var myInt = 51;
ref refInt = myInt;                   // alias of a local or global variable
myInt = 62;
writeln("refInt = ", refInt);
refInt = 73;
writeln("myInt = ", myInt);

var myArr: [1..3] int = 51;
proc arrayElement(i) ref  return myArr[i];
ref refToExpr = arrayElement(3);      // alias to lvalue returned by a function
myArr[3] = 62;
writeln("refToExpr = ", refToExpr);
refToExpr = 73;
writeln("myArr[3] = ", myArr[3]);

const constArr: [1..3] int = 51..53;
const ref myConstRef = constArr[2];   // would be an error without 'const'
writeln("myConstRef = ", myConstRef);
\end{chapel}

prints out:

\begin{chapelprintoutput}{}
refInt = 62
myInt = 73
refToExpr = 62
myArr[3] = 73
myConstRef = 52
\end{chapelprintoutput}
\end{chapelexample}
