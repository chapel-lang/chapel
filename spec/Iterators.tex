\sekshun{Iterators}
\label{Iterators}
\index{iterators}

An iterator is a function that conceptually returns multiple values
rather than simply a single value.

\begin{openissue}
The parallel iterator story is under development.  It is expected that
the specification will be expanded regarding parallel iterators soon.
\end{openissue}

\subsection{Iterator Function Definitions}
\label{Iterator_Function_Definitions}
\index{iterator function definitions}

The syntax to declare an iterator function (or simply, ``iterator''), is given
by:
\begin{syntax}
iterator-declaration-statement:
  `iter' iterator-name argument-list[OPT] var-param-type-clause[OPT] where-clause[OPT]
  iterator-body

iterator-name:
  identifier

iterator-body:
  block-statement
  yield-statement
\end{syntax}

The syntax of an iterator declaration is similar to a function declaration, with
some key differences:
\begin{itemize}
\item The keyword \chpl{iter} is used instead of the keyword \chpl{proc}.
\item The name of the iterator cannot overload any operator.
\item \chpl{yield} statements may appear in the body of an iterator, but not in
a regular function.
\end{itemize}

\subsection{The Yield Statement}
\label{The_Yield_Statement}
\index{yield@\chpl{yield}}

The yield statement can only appear in iterators.  The syntax of the
yield statement is given by
\begin{syntax}
yield-statement:
  `yield' expression ;
\end{syntax}

When an iterator is executed and a yield is encountered, the value of the yield
expression is returned.  However, the state of execution of the iterator is
saved.  On its next invocation, execution resumes from the point immediately
following that yield statement.

When a return is encountered, the value is returned and
the iterator finishes.  An iterator also completes after the last
statement in the iterator function is executed.
An iterator need not contain any yield statements.


\subsection{Iterator Calls}
\label{Iterator_Calls}

The syntax used to call an interator is given by:
\begin{syntax}
iterator-call-expression:
  call-expression
\end{syntax}
This is identical to the function-call syntax.
%REVIEW: hilde
% Can iterator definitions and uses have field syntax?

All details of the \sntx{iterator-call-expression} semantics --- including
resolution, the use of parentheses versus brackets to delimit the parameter
list, calling the iterator without an argument list and named arguments ---
are identical with the corresponding semantics for function calls.
See~\rsec{Function_Calls}.

However, the result of an iterator call depends upon its context, as described below.

\subsubsection{Iterators in For and Forall Loops}
\label{Iterators_in_For_and_Forall_Loops}

When an iterator is accessed via a for or forall loop, the iterator is
evaluated alongside the loop body in an interleaved manner.  For each
iteration, the iterator yields a value and the body is executed.

\subsubsection{Iterators as Arrays}
\label{Iterators_as_Arrays}
\index{iterators!and arrays}

If an iterator function is captured into a new variable declaration or
assigned to an array, the iterator is iterated over in total and the
expression evaluates to a one-dimensional arithmetic array that
contains the values returned by the iterator on each iteration.
\begin{example}
Given an iterator
\begin{chapel}
iter squares(n: int): int {
  for i in 1..n do
    yield i * i;
}
\end{chapel}
\begin{chapelpost}
writeln(squares(5));
\end{chapelpost}
\begin{chapeloutput}
1 4 9 16 25
\end{chapeloutput}
the expression \chpl{squares(5)} evaluates to the array \chpl{1, 4, 9, 16, 25}.
\end{example}

\subsubsection{Iterators and Generics}
\label{Iterators_and_Generics}
\index{iterators!and generics}

An iterator call expression can be passed to a generic function argument that
has neither a declared type nor default value
(\rsec{Formal_Arguments_without_Types}).
In this case the iterator is passed without being evaluated.
Within the generic function the corresponding formal argument
can be used as an iterator, e.g. in for loops.
The arguments to the iterator call expression, if any, are evaluated
at the call site, i.e. prior to passing the iterator to the generic function.

\subsubsection{Recursive Iterators}
\label{Recursive_Iterators}
\index{iterators!recursive}

Recursive iterators are allowed. A recursive iterator invocation is
typically made by iterating over it in a loop.


\begin{example}
A post-order traversal of a tree data structure could be written like this:
\begin{chapel}
iter postorder(tree: Tree): string {
  if tree != nil {
    for child in postorder(tree.left) do
      yield child;
    for child in postorder(tree.right) do
      yield child;
    yield tree.data;
  }
}
\end{chapel}
By contrast, using calls \chpl{postorder(tree.left)}
and \chpl{postorder(tree.right)} as stand-alone statements would
result in generating temporary arrays containing the outcomes of these
recursive calls, which would then be discarded.
\end{example}

\subsection{Parallel Iterators}
\label{Parallel_Iterators}

Iterators used in explicit forall-statements or -expressions must be
parallel iterators.  Reductions, scans and promotion over serial
iterators will be serialized.

The definition of parallel iterators is forthcoming.  Parallel
iterators are defined over standard constructs in Chapel such as
ranges, domains, and arrays (including Block- and Cyclic-distributed
domains and arrays), thereby allowing these constructs to be used with
forall-statements and -expressions.
