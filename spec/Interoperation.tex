\sekshun{Interoperability}
\label{Interoperability}
\index{interoperability}

Chapel's interoperability features support cooperation between Chapel
and other languages.  They provide the ability to create software
systems that incorporate both Chapel and non-Chapel components.
Thus, they support the reuse of existing software components while
leveraging the unique features of the Chapel language.

Interoperability can be broken down in terms of the exchange of types, variables
and procedures, and whether these are imported or exported.  An overview of
procedure importing and exporting is provided in~\rsec{Interop_Overview}.
Details on sharing types, variables and procedures are supplied
in \rsec{Shared_Language_Elements}.
%  The creation and use of Chapel libraries is
%treated in~\rsec{Interop_Libraries}.  

\begin{craychapel}
For information on specific packages which have been integrated with
Chapel, see \chpl{doc/technotes}.
\end{craychapel}

\begin{future}

At present, the backend language for Chapel is C, which makes it relatively
easy to call C libraries from Chapel and vice versa.  To support a variety of
platforms without requiring recompilation, it may be desirable to move
to an intermediate-language model.

In that case, each supported platform must minimally support that virtual
machine.  However, in addition to increased portability, a virtual machine
model may expose elements of the underlying machine's programming model
(hardware task queues, automated garbage collection, etc.) that are not easily
rendered in C.  In addition, the virtual machine model can support run-time task
migration.

\end{future}

The remainder of this chapter documents Chapel support of interoperability through
the existing C-language backend.

\section{Interoperability Overview}
\label{Interop_Overview}
\index{interoperability!overview}

The following two subsections provide an overview of calling externally-defined
(C) routines in Chapel, and setting up Chapel routines so they can be called
from external (C) code.

\subsection{Calling External Functions}
\label{Calling_External_Functions}
\index{interoperability!external functions!calling}

To use an external function in a Chapel program, it is necessary to inform the
Chapel compiler of that routine's signature through an external function
declaration.  This permits Chapel to bind calls to that function signature
during function resolution.  The user must also supply a definition for the
referenced function by naming a C source file, an object file or an object
library on the \chpl{chpl} command line. 

An external procedure declaration has the following syntax:
\begin{syntax}
external-procedure-declaration-statement:
  `extern' external-name[OPT] `proc' function-name argument-list return-intent[OPT] return-type[OPT]
\end{syntax}

Chapel will call the external function using the parameter types supplied in
the \chpl{extern} declaration.  Therefore, in general, the type of each argument
in the supplied \sntx{argument-list} must be the Chapel equivalent of the
corresponding external type.  

The return value of the function can be used by Chapel only if its type is
declared using the optional \sntx{return-type} specifier.  If it is omitted,
Chapel assumes that no value is returned, or equivalently that the function
returns \chpl{void}.

At present, external iterators are not supported.  

\begin{future}
The overloading of function names is
also not supported directly in the compiler.  However, one can use
the \sntx{external-name} syntax to supply a name to be used by the linker.  In
this way, function overloading can be implemented ``by hand''.  This syntax also
supports calling external C++ routines: The \sntx{external-name} to use is the
mangled function name generated by the external compilation
environment\footnote{In UNIX-like programming environments, \chpl{nm} and \chpl{grep}
can be used to find the mangled name of a given function within an object file
or object library.}.
\end{future}

\begin{future}
Dynamic dispatch (polymorphism) is also unsupported in this version.  But this
is not ruled out in future versions.  Since Chapel already supports type-based
procedure declaration and resolution, it is a small step to translate a
type-relative extern method declaration into a virtual method table entry.  The
mangled name of the correct external function must be supplied for each
polymorphic type available.  However, most likely the generation of \chpl{.chpl}
header files from C and C++ libraries can be fully automated.
\end{future}

There are three ways to supply to the Chapel compiler the definition of an
external function: as a C source file (\chpl{.c} or \chpl{.h}), as an object
file and as an object library.  It is platform-dependent whether static
libraries (archives), dynamic libraries or both are supported.  See
the \chpl{chpl} man page for more information on how these file types are handled.

\subsection{Calling Chapel Functions}
\label{Calling_Chapel_Functions}
\index{interoperability!Chapel functions!calling}

To call a Chapel procedure from external code, it is necessary to expose the
corresponding function symbol to the linker.  This is done by adding
the \chpl{export} linkage specifier to the function definition.
The \chpl{export} specifier ensures that the corresponding procedure will be
resolved, even if it is not called within the Chapel program or library being
compiled.

An exported procedure declaration has the following syntax:
\begin{syntax}
exported-procedure-declaration-statement:
  `export' external-name[OPT] `proc' function-name argument-list return-intent[OPT] return-type[OPT]
    function-body
\end{syntax}

If the optional \sntx{external-name} is
supplied, then it is used verbatim as the exported function symbol.  Otherwise,
the Chapel name of the procedure is exported.  The rest of the procedure
declaration is the same as for a non-exported function.  An exported procedure can be
called from within Chapel as well.  Currently, iterators cannot be exported.

\begin{future}
Currently, exported functions cannot have generic, \chpl{param} or type arguments.
This is because such functions actually represent a family of functions,
specific versions of which are instantiated as need during function resolution.

Instantiating all possible versions of a template function is not
practical in general.  However, if explicit instantiation were supported in
Chapel, an explicit instantiation with the export linkage specifier would
clearly indicate that the matching template function was to be instantiated with
the given \chpl{param} values and argument types.
\end{future}

\section{Shared Language Elements}
\label{Shared_Language_Elements}
\index{interoperability!sharing}

This section provides details on how to share Chapel types, variables and
procedures with external code.  It is written assuming that the intermediate
language is C.

\subsection{Shared Types}

This subsection discusses how specific types are shared between Chapel and
external code.  

\subsubsection{Referring to Standard C Types}
\label{Referring_to_Standard_C_Types}
\index{interoperability!standard C types}
\index{interoperability!C types!standard}

In Chapel code, all standard C types must be expressed in terms of their Chapel
equivalents.  This is true, whether the entity is exported, imported or private.
Standard C types and their corresponding Chapel types are shown in the following
table.

\begin{tabular}{rlrlrl}
C Type & Chapel Type & C Type & Chapel Type & C Type & Chapel Type \\
\hline
\tt int8\_t  & \tt int(8)  & \tt uint8\_t  & \tt uint(8)  & \tt \_real32 & \tt real(32) \\
\tt int16\_t & \tt int(16) & \tt uint16\_t & \tt uint(16) & \tt \_real64 & \tt real(64) \\
\tt int32\_t & \tt int(32) & \tt uint32\_t & \tt uint(32) & \tt \_imag32 & \tt imag(32) \\
\tt int64\_t & \tt int(64) & \tt uint64\_t & \tt uint(64) & \tt \_imag64 & \tt imag(64) \\
\tt chpl\_bool & \tt bool & \tt  const char* & \tt c\_string \\
\tt \_complex64 & \tt complex(64) & \tt \_complex128 & \tt complex(128) \\
\end{tabular}

Standard C types are built-in.  Their Chapel equivalents do not have to be
declared using the \chpl{extern} keyword.

In C, the ``colloquial'' integer type names \chpl{char}, \chpl{signed
char}, \chpl{unsigned char}, (\chpl{signed}) \chpl{short}
(\chpl{int}), \chpl{unsigned short} (\chpl{int}),
(\chpl{signed}) \chpl{int}, \chpl{unsigned int},
(\chpl{signed}) \chpl{long} (\chpl{int}), \chpl{unsigned long} (\chpl{int}), (\chpl{signed}) \chpl{long
long} (\chpl{int}) and \chpl{unsigned long long} (\chpl{int}) may have an
implementation-defined width.\footnote{However, most implementations have settled
on using 8, 16, 32, and 64 bits (respectively) to
represent \chpl{char}, \chpl{short}, \chpl{int} and \chpl{long}, and \chpl{long
long} types}.  When referring to C types in a Chapel program, the burden of
making sure the type sizes agree is on the user.  A Chapel implementation must
ensure that all of the C equivalents in the above table are defined and have the
correct representation with respect to the corresponding Chapel type.

\subsubsection{Referring to External C Types}
\label{Referring_to_External_C_Types}
\index{interoperability!external C types}
\index{interoperability!C types!external}

An externally-defined type can be referenced using a external type declaration
with the following syntax.
\begin{syntax}
external-type-alias-declaration-statement:
  `extern' `type' type-alias-declaration-list ;
\end{syntax}

In each \sntx{type-alias-declaration}, if the \sntx{type-specifier} part is
supplied, then Chapel uses the supplied type specifier internally.  Otherwise,
it treats the named type as an opaque type.  The definition for an external type
must be supplied by a C header file named on the \chpl{chpl} command line.

Fixed-size C array types can be described within Chapel using its
homogenous tuple type.  For example, the C typedef
\begin{chapel}
typedef double vec[3];
\end{chapel}
can be described in Chapel using
\begin{chapel}
extern type vec = 3*real(64);
\end{chapel}


\subsubsection{Referring to External C Structs}
\label{Referring_to_External_C_Structs}
\index{interoperability!C structs!external}

External C struct types can be referred to within Chapel by prefixing
a Chapel \chpl{record} definition with the \chpl{extern} keyword.
\begin{syntax}
external-record-declaration-statement:
  `extern' simple-record-declaration-statement
\end{syntax}

For example, consider an external C structure defined in \chpl{foo.h} called \chpl{fltdbl}.
\begin{chapel}
    typedef struct _fltdbl {
      float x;
      double y;
    } fltdbl;
\end{chapel}
This type could be referred to within a Chapel program using
\begin{chapel}
   extern record fltdbl {
     var x: real(32);
     var y: real(64);
   }
\end{chapel}
\noindent
and defined by supplying \chpl{foo.h} on the \chpl{chpl} command line.

Within the Chapel declaration, some or all of the fields from the C
structure may be omitted.  The order of these fields need not match
the order they were specified within the C code.  Any fields that are
not specified (or that cannot be specified because there is no
equivalent Chapel type) cannot be referenced within the Chapel code.  Some
effort is made to preserve the values of the undefined fields when copying
these structs but Chapel cannot guarantee the contents or memory story of
fields of which it has no knowledge.

A C header file containing the struct's definition in C must be specified on the
chpl compiler command line.  Note that currently only typdef'd C structures are
supported.  That is, in the C header file, the \chpl{struct} must be supplied
with a type name through a \chpl{typedef} declaration.

\subsubsection{Referring to External Structs Through Pointers}
\label{Referring_to_External_Structs_Through_Pointers}
\index{interoperability!C Structs!external!pointers to}

An external type which is a pointer to a \chpl{struct} can be referred to from
Chapel using an external \chpl{class} declaration.  External class declarations
have the following syntax.
\begin{syntax}
external-class-declaration-statement:
  `extern' simple-class-declaration-statement
\end{syntax}
External class declarations are similar to external record declarations as
discussed above, but place additional requirements on the C code.

For example, given the declaration
\begin{chapel}
  extern class D {
    var x: real;
  }
\end{chapel}
\noindent
the requirements on the corresponding C code are:
\begin{enumerate}
\item There must be a struct type that is typedef'd to have the name \chpl{\_D}.
\item A pointer-to-\chpl{\_D} type must be typedef'd to have the name \chpl{D}.
\item The \chpl{\_D} struct type must contain a field named \chpl{x} of type \chpl{double}.
\end{enumerate}
\noindent
Like external records/structs, it may also contain other fields
that will simply be ignored by the Chapel compiler.

The following C typedef would fulfill the external Chapel class
declaration shown above:
\begin{chapel}
   typedef struct __D {
     double x;
     int y;
   } _D, *D;
\end{chapel}
where the Chapel compiler would not know about the 'y' field and
therefore could not refer to it or manipulate it.


\subsubsection{Opaque Types}
\label{Opaque_Types}
\index{interoperability!opaque types}

It is possible refer to external pointer-based C types that cannot be
described in Chapel by using the "opaque" keyword.  As the name implies,
these types are opaque as far as Chapel is concerned and cannot be
used for operations other than argument passing and assignment.

For example, Chapel could be used to call an external C function that
returns a pointer to a structure (that can't or won't be described as
an external class) as follows:
\begin{chapel}
    extern proc returnStructPtr(): opaque;

    var structPtr: opaque = returnStructPtr();
\end{chapel}

However, because the type of \chpl{structPtr} is opaque, it can be used only in
assignments and the arguments of functions expecting the same underlying type.
\begin{chapel}
    var copyOfStructPtr = structPtr;

    extern proc operateOnStructPtr(ptr: opaque);
    operateOnStructPtr(structPtr);
\end{chapel}
\noindent
Like a \chpl{void*} in C, Chapel's \chpl{opaque} carries no information
regarding the underlying type.  It therefore subverts type safety, and should be
used with caution.

\subsection{Shared Data}
\label{Shared_Data}
\index{interoperability!shared data}

This subsection discusses how to access external variables and constants.

A C variable or constant can be referred to within Chapel by prefixing
its declaration with the extern keyword.  For example:
\begin{chapel}
    extern var bar: foo;
\end{chapel}
\noindent
would tell the Chapel compiler about an external C variable named
\chpl{bar} of type \chpl{foo}.  Similarly, 
\begin{chapel}
   extern const baz: int(32);
\end{chapel}
would refer to an external 32-bit integer constant named \chpl{baz} in the
C code.  In practice, external consts can be used to provide Chapel
definitions for \#defines and enum symbols in addition to traditional C
constants.

\begin{craychapel}
Note that since params must be known to Chapel at compile-time (and
because the Chapel compiler doesn't have the ability to parse C code),
external params are not supported.
\end{craychapel}

\subsection{Shared Procedures}
\label{Shared_Procedures}
\index{interoperability!shared procedures}

This subsection provides additional detail and examples for calling external
procedures from Chapel and for exporting Chapel functions for external use.

\subsubsection{Calling External C Functions}
\label{Calling_External_C_Functions}
\index{interoperability!external functions!calling}

To call an external C function, a prototype of
the routine must appear in the Chapel code.  This is accomplished by providing
the Chapel signature of the function preceded by the \chpl{extern} keyword.  For
example, for a C function foo() that takes no arguments and returns
nothing, the prototype would be:
\begin{chapel}
       extern proc foo();
\end{chapel}

To refer to the return value of a C function, its type must be supplied through
a \sntx{return-type} clause in the prototype.\footnote{The return type cannot be
inferred, since an \chpl{extern} procedure declaration has no body.}

If the above function returns a C \chpl{double}, it would be declared as:
\begin{chapel}
       extern proc foo(): real;
\end{chapel}
Similarly, for external functions that expect arguments, the types of those
arguments types may be declared in Chapel using explicit argument type specifiers.

The types of function arguments may be omitted from the external procedure
declaration, in which case they are inferred based on the Chapel callsite.
For example, the Chapel code
\begin{chapel}
       extern proc foo(x: int, y): real;
       var a, b: int;
       foo(a, b);
\end{chapel}
\noindent
would imply that the external function foo takes two 64-bit integer values
and returns a 64-bit real.  External function declarations with omitted type
arguments can also be used call external C macros.

External function arguments can be declared using the \sntx{default-expression}
syntax.  In this case, the default argument will be supplied by the Chapel
compiler if the corresponding actual argument is omitted at the callsite.  For example:
\begin{chapel}
       extern proc foo(x: int, y = 1.2): real;
       foo(0);
\end{chapel}
Would cause external function foo() to be invoked with the arguments 0
and 1.2.

C varargs functions can be declared using
Chapel's \sntx{variable-argument-expression} syntax (\chpl{...}).  For example,
the C \chpl{printf} function can be declared in Chapel as
\begin{chapel}
       extern proc printf(fmt: c_string, vals...?numvals): int;
\end{chapel}

External C functions or macros that accept type arguments can also be
prototyped in Chapel by declaring the argument as a type.  For
example:
\begin{chapel}
       extern foo(type t);
\end{chapel}
Calling such a routine with a Chapel type will cause the type
identifier (e.g., 'int') to be passed to the routine.\footnote{In practice,
this will typically only be useful if the external function is a macro
or built-in that can handle type identifiers.}

\subsection{Calling Chapel Procedures Externally}
\label{Calling_Chapel_Procedures_Externally}
\index{interoperability!Chapel procedures!calling}

To call a Chapel procedure from external code, the procedure name must be
exported using the \chpl{export} keyword.  An exported procedure taking no
arguments and returning void can be declared as:
\begin{chapel}
export proc foo();
\end{chapel}
If the procedure body is omitted, the procedure declaration is a prototype; the
body of the procedure must be supplied elsewhere.  In a prototype, the return
type must be declared; otherwise, it is assumed to be \chpl{void}.  If the body
is supplied, the return type of the exported procedure is inferred from the
type of its return expression(s).  

If the optional \sntx{external-name} is supplied, that is the name used in
linking with external code.  For example, if we declare
\begin{chapel}
export "myModule_foo" proc foo();
\end{chapel}
\noindent
then the name \chpl{foo} is used to refer to the procedure within chapel code,
whereas a call to the same function from C code would appear
as \chpl{myModule_foo();}.  If the external name is omitted, then its internal
name is also used externally.

When a procedure is exported, all of the types and functions on which it depends
are also exported.  Iterators cannot be explicitly exported.  However, they are
inlined in Chapel code which uses them, so they are exported in effect.

\subsection{Argument Passing}
\label{Interop_Argument_Passing}
\index{interoperability!argument passing}

The manner in which arguments are passed to an external function can be
controlled using argument intents.  The following table shows the correspondence
between Chapel intents and C argument type declarations.  These correspondences
pertain to both imported and exported function signatures.

\begin{tabular}{rl}
Chapel & C \\
\hline
\tt T & \tt const T \\
\tt in T & \tt T \\
\tt inout T & \tt T* \\
\tt out T & \tt T* \\
\tt ref T & \tt T* \\
\tt param & \tt \\
\tt type & \tt char*\\
\end{tabular}

Currently, \chpl{param} arguments are not allowed in an extern function
declaration, and \chpl{type} args are passed as a string containing the name of
the actual type being passed.  Note that the level of indirection is changed
when passing arguments to a C function using \chpl{inout}, \chpl{out},
or \chpl{ref} intent.  The C code implementing that function must dereference
the argument to extract its value.
