\sekshun{Functions}
\label{Functions}
\index{functions}

This section defines functions.  Methods and iterators are functions
and most of this section applies to them as well.  They are defined
separately in~\rsec{Iterators} and~\rsec{Class_Methods}.

\subsection{Function Definitions}
\label{Function_Definitions}
\index{functions!syntax}

\index{def@\chpl{def}}
Functions are declared with the following syntax:
\begin{syntax}
function-declaration-statement:
  `def' function-name argument-list[OPT] var-param-clause[OPT]
    return-type[OPT] where-clause[OPT] function-body

function-name:
  identifier
  operator-name

operator-name: one of
  + - * / % ** ! == <= >= < > << >> & | ^ ~

argument-list:
  ( formals[OPT] )

formals:
  formal
  formal , formals

formal:
  formal-tag identifier formal-type[OPT] default-expression[OPT]
  formal-tag identifier formal-type[OPT] variable-argument-expression

formal-type:
  : type-specifier
  : ? identifier

default-expression:
  = expression

variable-argument-expression:
  ... expression
  ... ? identifier

formal-tag: one of
  `in' `out' `inout' `param' `type'

var-param-clause:
  `var'
  `const'
  `param'

return-type:
  : type-specifier

where-clause:
  `where' expression

function-body:
  block-statement
  return-statement
\end{syntax}

Operator overloading is supported in Chapel on the operators listed
above under operator name.  Operator and function overloading is
discussed in~\rsec{Function_Overloading}.

The intents \chpl{in}, \chpl{out}, and \chpl{inout} are discussed
in~\rsec{Intents}.  The formal tags \chpl{param} and \chpl{type} make
a function generic and are discussed in~\rsec{Generics}.  If the
formal argument's type is elided, generic, or prefixed with a question
mark, the function is also generic and is discussed
in~\rsec{Generics}.

Default expressions allow for the omission of actual arguments at the
call site, resulting in the implicit passing of a default value.
Default values are discussed in~\rsec{Default_Values}.

Functions do not require parentheses if they have no arguments.  Such
functions are described in~\rsec{Functions_without_Parentheses}.

Return types are optional and are discussed in~\rsec{Return_Types}.

Functions can take a variable number of arguments.  Such functions are
discussed in~\rsec{Variable_Length_Argument_Lists}.

The optional \sntx{var-param-clause} defines a variable function,
discussed in~\rsec{Variable_Functions}, or a parameter function,
discussed in~\rsec{Parameter_Functions}.  By default, a function call
cannot be treated as an lvalue and is constant.  This may be
explicitly specified via the keyword~\chpl{const}.

The optional where clause is only applicable if the function is
generic.  It is discussed in~\rsec{Where_Expressions}.

\subsection{The Return Statement}
\label{The_Return_Statement}
\index{return@\chpl{return}}

The return statement can only appear in a function.  It exits that
function, returning control to the point at which that function was
called.  It can optionally return a value.  The syntax of the return
statement is given by
\begin{syntax}
return-statement:
  `return' expression[OPT] ;
\end{syntax}

\begin{example}
The following code defines a function that returns the sum of three
integers:
\begin{chapel}
def sum(i1: int, i2: int, i3: int)
  return i1 + i2 + i3;
\end{chapel}
\end{example}

\subsection{Function Calls}
\label{Function_Calls}
\index{function calls}

Functions are called in call expressions described
in~\rsec{Call_Expressions}.  The function that is called is resolved
according to the algorithm described in~\rsec{Function_Resolution}.

\subsection{Formal Arguments}
\label{Formal_Arguments}
\index{formal arguments}

Chapel supports an intuitive formal argument passing mechanism.  An
argument is passed by value unless it is a class, array, or domain in
which case it is passed by reference.

Intents~(\rsec{Intents}) result in potential assignments to temporary
variables during a function call.  For example, passing an array by
intent \chpl{in}, a temporary array will be created.

\subsubsection{Named Arguments}
\label{Named_Arguments}
\index{named arguments}
\index{formal arguments!naming}

A formal argument can be named at the call site to explicitly map an
actual argument to a formal argument.

\begin{example}
In the code
\begin{chapel}
def foo(x: int, y: int) { ... }

foo(x=2, y=3);
foo(y=3, x=2);
\end{chapel}
named argument passing is used to map the actual arguments to the
formal arguments.  The two function calls are equivalent.
\end{example}

Named arguments are sometimes necessary to disambiguate calls or
ignore arguments with default values.  For a function that has many
arguments, it is sometimes good practice to name the arguments at the
call-site for compiler-checked documentation.

\subsubsection{Default Values}
\label{Default_Values}
\index{default values}
\index{formal arguments!defaults}

Default values can be specified for a formal argument by appending the
assignment operator and a default expression the declaration of the
formal argument.  If the actual argument is omitted from the function
call, the default expression is evaluated when the function call is
made and the evaluated result is passed to the formal argument as if
it were passed from the call site.

\begin{example}
In the code
\begin{chapel}
def foo(x: int = 5, y: int = 7) { ... }

foo();
foo(7);
foo(y=5);
\end{chapel}
default values are specified for the formal arguments \chpl{x}
and \chpl{y}.  The three calls to \chpl{foo} are equivalent to the
following three calls where the actual arguments are
explicit: \chpl{foo(5, 7)}, \chpl{foo(7, 7)}, and \chpl{foo(5, 5)}.
Note that named arguments are necessary to pass actual arguments to
formal arguments but use default values for arguments that are
specified earlier in the formal argument list.
\end{example}

\subsection{Intents}
\label{Intents}
\index{intents}

Intents allow the actual arguments to be copied to a formal argument
and also to be copied back.

\subsubsection{The Blank Intent}
\label{The_Blank_Intent}

If the intent is omitted, it is called a blank intent.  In such a
case, the value is copied in using the assignment operator.  Thus
classes are passed by reference and records are passed by value.
Arrays and domains are an exception because assignment does not apply
from the actual to the formal.  Instead, arrays and domains are passed
by reference.

With the exception of arrays, any argument that has blank intent
cannot be assigned within the function.

\subsubsection{The In Intent}
\label{The_In_Intent}
\index{in@\chpl{in}}
\index{intents!in@\chpl{in}}

If \chpl{in} is specified as the intent, the actual argument is copied
to the formal argument as usual, but it may also be assigned to within
the function.  This assignment is not reflected back at the call site.

If an array is passed to a formal argument that has \chpl{in} intent,
a copy of the array is made via assignment.  Changes to the elements
within the array are thus not reflected back at the call site.
Domains cannot be passed to a function via the \chpl{in} intent.

\subsubsection{The Out Intent}
\label{The_Out_Intent}
\index{out@\chpl{out}}
\index{intents!out@\chpl{out}}

If \chpl{out} is specified as the intent, the actual argument is
ignored when the call is made, but after the call, the formal argument
is assigned to the actual argument at the call site.  The actual
argument must be a valid lvalue.  The formal argument can be assigned
to and read from within the function.

The formal argument cannot not be generic and is treated as a variable
declaration.  Domains cannot be passed to a function via
the \chpl{out} intent.

\subsubsection{The Inout Intent}
\label{The_Inout_Intent}
\index{inout@\chpl{inout}}
\index{intents!inout@\chpl{inout}}

If \chpl{inout} is specified as the intent, the actual argument is
both passed to the formal argument as if the \chpl{in} intent applied
and then copied back as if the \chpl{out} intent applied.  The formal
argument can be generic and takes its type from the actual argument.
Domains cannot be passed to a function via the \chpl{inout} intent.
The formal argument can be assigned to and read from within the
function.

\subsection{Return Types}
\label{Return_Types}
\index{return@\chpl{return}!types}

A function can optionally return a value.  If the function does not
return a value, then no return type can be specified.  If the function
does return a value, the return type is optional.

\subsubsection{Explicit Return Types}
\label{Explicit_Return_Types}

If a return type is specified, the values that the function returns
via return statements must be assignable to a value of the return
type.  For variable functions~(\rsec{Variable_Functions}), the return
type must match the type returned in all of the return statements
exactly.

\subsubsection{Implicit Return Types}
\label{Implicit_Return_Types}
\index{type inference!of return types}

If a return type is not specified, it will be inferred from the return
statements.  Given the types that are returned by the different
statements, if exactly one of those types can be a target, via
implicit conversions, of every other type, then that is the inferred
return type.  Otherwise, it is an error.  For variable
functions~(\rsec{Variable_Functions}), every return statement must
return the same exact type and it becomes the inferred type.

\subsection{Variable Functions}
\label{Variable_Functions}
\index{functions!as lvalues}

A variable function is a function that can be assigned a value.  Note
that a variable function does not return a reference.  That is, the
reference cannot be captured.

A variable function is specified by following the argument list with
the \chpl{var} keyword.  A variable function must return an lvalue.

When a variable function is called on the left-hand side of an
assignment statement or in the context of a call to a formal argument
by out or inout intent, the lvalue that is returned by the function is
assigned a value.

Variable functions support an implicit argument \chpl{setter} of type
bool that is a compile-time constant (and can thus be folded).  If the
variable function is called in a context such that the returned lvalue
is assigned a value, the argument \chpl{setter} is \chpl{true};
otherwise it is \chpl{false}.  This argument is useful for controlling
different behavior depending on the call site.

\begin{example}
The following code creates a function that can be interpreted as a
simple two-element array where the elements are actually global
variables:
\begin{chapel}
var x, y = 0;

def A(i: int) var {
  if i < 0 || i > 1 then
    halt("array access out of bounds");
  if i == 0 then
    return x;
  else
    return y;
}
\end{chapel}
This function can be assigned to in order to write to the ``elements''
of the array as in
\begin{chapel}
A(0) = 1;
A(1) = 2;
\end{chapel}
It can be called as an expression to access the ``elements'' as in
\begin{chapel}
writeln(A(0) + A(1));
\end{chapel}
This code outputs the number \chpl{3}.

The implicit \chpl{setter} argument can be used to ensure, for
example, that the second element in the pseudo-array is only assigned
a value if the first argument is positive.  To do this, the line
\begin{chapel}
if setter && i == 1 && x <= 0 then
  halt("cannot assign value to A(1) if A(0) <= 0");
\end{chapel}
\end{example}

\subsection{Parameter Functions}
\label{Parameter_Functions}
\index{functions!as parameters}

A parameter function is a function that returns a parameter
expression.  It is specified by following the function's argument list
by the keyword \chpl{param}.  It is often, but not necessarily,
generic.

It is a compile-time error if a parameter function does not return a
parameter expression.  The result of a parameter function is computed
during compilation and the result is inlined at the call site.

\begin{example}
In the code
\begin{chapel}
def sumOfSquares(param a: int, param b: int) param
  return a**2 + b**2;

var x: sumOfSquares(2, 3)*int;
\end{chapel}
the function \chpl{sumOfSquares} is a parameter function that takes
two parameters as arguments.  Calls to this function can be used in
places where a parameter expression is required.  In this example, the
call is used in the declaration of a homogeneous and so is required to
be a parameter.
\end{example}.

\subsection{Function Overloading}
\label{Function_Overloading}
\index{functions!overloading}
\index{operators!overloading}

Functions that have the same name but different argument lists are
called overloaded functions.  Function calls to overloaded functions
are resolved according to the algorithm in~\rsec{Function_Resolution}.

Operator overloading is achieved by defining a function with a name
specified by that operator.  The operators that may be overloaded are
listed in the following table:

\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf arity} & {\bf operators} \\
\hline
unary & \verb@+ - ! ~@ \\
binary & \verb@+ - * / % ** ! == <= >= < > << >> & | ^ @ \\
\hline
\end{tabular}
\end{center}

The arity and precedence of the operator must be maintained when it is
overloaded.  Operator resolution follows the same algorithm as
function resolution.

\subsection{Function Resolution}
\label{Function_Resolution}

Given a function call, the function that the call resolves to is
determined according to the following algorithm:
\begin{itemize}
\item
Identify the set of visible functions.  A visible function is any
function with the same name that satisfies the criteria
in~\rsec{Identifying_Visible_Functions}.
\item
From the set of visible functions, determine the set of candidate
functions.  A function is a candidate if the function is a valid
application of the function call's actual arguments as determined
in~\rsec{Determining_Candidate_Functions}.  A compiler error occurs if
there are no candidate functions.
\item
From the set of candidate functions, the most specific function is
determined.  The most specific function is a candidate function that
is more specific than every other candidate function.  If there is no
function that is more specific than every other candidate function,
the function call is ambiguous and a compiler error occurs.  The term
{\em more specific function} is defined
in~\rsec{Determining_More_Specific_Functions}.
\end{itemize}.

\subsubsection{Identifying Visible Functions}
\label{Identifying_Visible_Functions}
\index{functions!visible}

A function is a visible function to a function call if the name of the
function is the same as the name of the function call and the function
is defined or used in a lexical outer scope.  Function visibility in
generic functions is discussed
in~\rsec{Function_Visibility_in_Generic_Functions}.

\subsubsection{Determining Candidate Functions}
\label{Determining_Candidate_Functions}
\index{functions!candidates}

A function is a candidate function if there is a {\em valid mapping}
from the function call to the function and each actual argument is
mapped to a formal argument that is a {\em legal argument mapping}.

\paragraph{Valid Mapping}

A function call is mapped to a function according to the following
steps:
\begin{itemize}
\item
Each actual argument that is passed by name is matched to the formal
argument with that name.  If there is no formal argument with that
name, there is no valid mapping.
\item
The remaining actual arguments are mapped in order to the remaining
formal arguments in order.  If there are more actual arguments then
formal arguments, there is no valid mapping.  If any formal argument
that is not mapped to by an actual argument does not have a default
value, there is no valid mapping.
\item
The valid mapping is the mapping of actual arguments to formal
arguments plus default values to formal arguments that are not mapped
to by actual arguments.
\end{itemize}

\paragraph{Legal Argument Mapping}

An actual argument of type $T_A$ can be mapped to a formal argument of
type $T_F$ if any of the following conditions hold:
\begin{itemize}
\item $T_A$ and $T_F$ are the same type.
\item There is an implicit coercion from $T_A$ to $T_F$.
\item $T_A$ is derived from $T_F$.
\item $T_A$ is scalar promotable to $T_F$.
\end{itemize}

\subsubsection{Determining More Specific Functions}
\label{Determining_More_Specific_Functions}
\index{functions!most specific}

Given two functions $F_1$ and $F_2$, $F_1$ is determined to be more
specific than $F_2$ by the following steps:
\begin{itemize}
\item
If at least one of the legal argument mappings to $F_1$ is a {\em more
specific argument mapping} than the corresponding legal argument
mapping to $F_2$ and none of the legal argument mappings to $F_2$ is a
more specific argument mapping than the corresponding legal argument
mapping to $F_1$, then $F_1$ is more specific.
\item If $F_1$ does not require promotion and $F_2$ does require promotion, then $F_1$ is more specific.
\item If $F_1$ shadows $F_2$, then $F_1$ is more specific.
\item Otherwise, $F_1$ is not more specific than $F_2$.
\end{itemize}

Given an argument mapping, $M_1$, from an actual argument, $A$, of
type $T_A$ to a formal argument, $F1$, of type $T_{F1}$ and an
argument mapping, $M_2$, from the same actual argument to a formal
argument, $F2$, of type $T_{F2}$, the more specific argument mapping
is determined by the following steps:
\begin{itemize}
\item
 If $T_{F1}$ and $T_{F2}$ are the same type and $F1$ is an
 instantiated parameter, $M_1$ is more specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type and $F2$ is an
 instantiated parameter, $M_2$ is more specific.
\item
 If $M_1$ requires scalar promotion and $M_2$ does not require scalar
 promotion, $M_2$ is more specific.
\item
 If $M_2$ requires scalar promotion and $M_1$ does not require scalar
 promotion, $M_1$ is more specific.
\item
 If $F1$ is generic over all types and $F2$ is not generic over all
 types, $M_2$ is more specific.
\item
 If $F2$ is generic over all types and $F1$ is not generic over all
 types, $M_1$ is more specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type, neither mapping is more
 specific.
\item
 If $T_A$ and $T_{F1}$ are the same type, $M_1$ is more specific.
\item
 If $T_A$ and $T_{F2}$ are the same type, $M_2$ is more specific.
\item
 If $T_{F1}$ is derived from $T_{F2}$, then $M_1$ is more specific.
\item
 If $T_{F2}$ is derived from $T_{F1}$, then $M_2$ is more specific.
\item
 If there is an implicit coercion from $T_{F1}$ to $T_{F2}$, then
 $M_1$ is more specific.
\item
 If there is an implicit coercion from $T_{F2}$ to $T_{F1}$, then
 $M_2$ is more specific.
\item
 If $T_{F1}$ is any \chpl{int} type and $T_{F2}$ is any \chpl{uint}
 type, $M_1$ is more specific.
\item
 If $T_{F2}$ is any \chpl{int} type and $T_{F1}$ is any \chpl{uint}
 type, $M_2$ is more specific.
\item
 Otherwise neither mapping is more specific.
\end{itemize}

\subsection{Functions without Parentheses}
\label{Functions_without_Parentheses}
\index{functions!functions without parentheses}

Functions do not require parentheses if they have empty argument
lists.  Functions declared without parentheses around empty argument
lists must be called without parentheses.

\begin{example}
Given the definitions
\begin{chapel}
def foo { }
def bar() { }
\end{chapel}
the function \chpl{foo} can be called by writing \chpl{foo} and the
function \chpl{bar} can be called by writing \chpl{bar()}.  It is an
error to apply parentheses to \chpl{foo} or omit them from \chpl{bar}.
\end{example}

\subsection{Nested Functions}
\label{Nested_Functions}
\index{functions!nested}

A function defined in another function is called a nested function.
Nesting of functions may be done to arbitrary degrees, i.e., a
function can be nested in a nested function.

Nested functions are only visible to function calls within the scope
in which they are defined.

\subsubsection{Accessing Outer Variables}
\label{Accessing_Outer_Variables}

Nested functions may refer to variables defined in the function in
which they are nested.

\subsection{Variable Length Argument Lists}
\label{Variable_Length_Argument_Lists}
\index{functions!variable number of arguments}

Functions can be defined to take a variable number of arguments where
those arguments can have any intent or can be types.  A variable
number of parameters is not supported.  This allows the call site to
pass a different number of actual arguments.

If the variable argument expression is an identifier prepended by a
question mark, the number of arguments is variable.  Alternatively,
the variable expression can evaluate to an integer parameter value
requiring the call site to pass that number of arguments to the
function.

In the function, the formal argument is a tuple of the actual
arguments.

\begin{example}
The code
\begin{chapel}
def mywriteln(x ...?k) {
  for param i in 1..k do
    writeln(x(i));
}
\end{chapel}
defines a generic function called \chpl{mywriteln} that takes a
variable number of arguments of any type and then writes them out on
separate lines.  The parameter for-loop~(\rsec{Parameter_For_Loops})
is unrolled by the compiler so that \chpl{i} is a parameter, rather
than a variable.  This needs to be a parameter for-loop because the
expression \chpl{x(i)} will have a different type on each iteration.
The type of \chpl{x} can be specified in the formal argument list to
ensure that the actuals all have the same type.
\end{example}

\begin{example}
The function
\begin{chapel}
def tuple(x ...?k) return x;
\end{chapel}
creates a generic function that returns tuples.  When passed two or
more actuals in a call, it is equivalent to building a tuple so the
expressions \chpl{tuple(1, 2)} and \chpl{(1, 2)} are equivalent.  When
passed one actual, it builds a 1-tuple which is different than the
evaluation of the parenthesized expression.  Thus the
expressions \chpl{tuple(1)} and \chpl{(1)} are not equivalent.
\end{example}

A tuple of variables arguments can be passed to a function that takes
variable arguments by destructuring the tuple in a tuple destructuring
expression.  The syntax of this expression is given by
\begin{syntax}
tuple-destructuring-expression:
  ( ... expression )
\end{syntax}
In this expression, the tuple defined by \sntx{expression} is expanded
in place to represent its components.  This allows for the forwarding
of variable arguments as variable arguments.
