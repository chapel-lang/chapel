\sekshun{Domains}
\label{Domains}
\index{domains}

A \emph{domain} is a first-class representation of an index set.
Domains are used to specify iteration spaces, to define the size and
shape of arrays (\rsec{Arrays}), and to specify aggregate operations
like slicing.
A domain can specify a single- or multi-dimensional
rectangular iteration space or represent a set of indices of
a given type.  Domains can also represent a subset of another domain's index set,
using either a dense or sparse representation.
A domain's
indices may potentially be distributed across multiple locales as
described in~\rsec{Domain_Maps}, thus supporting global-view data
structures.

In the next subsection, we introduce the key characteristics of
domains.  In~\rsec{Base_Domain_Types_and_Values}, we discuss the types
and values that can be associated with a base domain.
In~\rsec{Simple_Subdomain_Types_and_Values}, we discuss the types and
values of simple subdomains that can be created from those base
domains.  In~\rsec{Sparse_Subdomain_Types_and_Values}, we discuss the
types and values of sparse subdomains.  The remaining sections
describe the important manipulations that can be performed with
domains, as well as the predefined operators and functions defined for
domains.

\section{Domain Overview}
\index{domains!kinds}

There are three \emph{kinds} of domain, distinguished by their subset
dependencies: \emph{base domains}, \emph{subdomains} and \emph{sparse
subdomains}.  A base domain describes an index set spanning one or more
dimensions.  A subdomain creates an index set that is a subset of the indices in
a base domain or another subdomain.  Sparse subdomains are subdomains which can
represent sparse index subsets efficiently.  Simple subdomains are subdomains
that are not sparse.  These relationships can be represented as follows:

\begin{syntax}
domain-type:
  base-domain-type
  simple-subdomain-type
  sparse-subdomain-type
\end{syntax}

Domains can be further classified according to whether they are \emph{regular}
or \emph{irregular}.  A regular domain represents a rectangular iteration
space and can have a compact representation whose size is independent
of the number of indices. Rectangular domains, with the exception of
sparse subdomains, are regular.

An irregular domain can store an arbitrary set of indices of an arbitrary but
homogeneous index type.  Irregular domains typically require space proportional
to the number of indices being represented.  All \emph{associative} domain types
and their subdomains (including sparse subdomains) are irregular.  Sparse
subdomains of regular domains are also irregular.

An index set can be either \emph{ordered} or \emph{unordered} depending on
whether its members have a well-defined order relationship.  All regular and
enumerated domains are ordered.  All other associative domains are
unordered.

The type of a domain describes how a domain is represented and the operations
that can be performed upon it, while its value is the set of indices it represents.
In addition to storing a value, each domain variable has an identity that
distinguishes it from other domains that may have the same type and
value.  This identity is used to define the domain's relationship
with subdomains, index types~(\rsec{Index_Types}),
and arrays~(\rsec{Association_of_Arrays_to_Domains}).

\begin{openissue}
In the future, it is likely that we will support a means of creating
domain aliases, much as we support array aliases currently.
\end{openissue}

The runtime representation of a domain is controlled by its domain map.
Domain maps are presented in \rsec{Domain_Maps}.


\section{Base Domain Types and Values}
\label{Base_Domain_Types_and_Values}
\index{domains!types and values}

Base domain types can be classified as regular or irregular.  Dense and
strided rectangular domains are regular domains.
Irregular base domain types include all of the associative domain types.

\begin{syntax}
base-domain-type:
  rectangular-domain-type
  associative-domain-type
\end{syntax}

These base domain types are discussed in turn in the following
subsections.

\subsection{Rectangular Domains}
\index{rectangular domains (see also domains, rectangular)}
\index{domains!rectangular}

Rectangular domains describe multidimensional rectangular index sets.  They are
characterized by a tensor product of ranges and represent indices that are
tuples of an integral type.  Because their index sets can be represented using
ranges, regular domain values typically require only $O(1)$ space.

\subsubsection{Rectangular Domain Types}
\index{domains!rectangular!types}
\index{types!rectangular domains}

Rectangular domain types are parameterized by three things:
\begin{itemize}
\item \chpl{rank} a positive \chpl{int} value indicating the number
of dimensions that the domain represents;
\item \chpl{idxType} a type member representing the index type for
each dimension; and
% BLC: we should potentially rename idxType to idxDimType to make it
% more consistent with the irregular case
\item \chpl{stridable} a \chpl{bool} parameter indicating whether
any of the domain's dimensions will be characterized by a strided
range.
\end{itemize}
If \chpl{rank} is $1$, the index type represented by a rectangular
domain is \chpl{idxType}.  Otherwise, the index type is the homogenous
tuple type \chpl{rank*idxType}.
If unspecified, \chpl{idxType} defaults
to \chpl{int} and \chpl{stridable} defaults to \chpl{false}.

\begin{openissue}
We may represent a rectangular domain's index type as rank*idxType even if rank is 1.  This
would eliminate a lot of code currently used to support the special (rank == 1) case.
\end{openissue}

The syntax of a rectangular domain type is summarized as follows:
\begin{syntax}
rectangular-domain-type:
  `domain' ( named-expression-list )
\end{syntax}

\noindent where \sntx{named-expression-list} permits the values of
\chpl{rank}, \chpl{idxType}, and \chpl{stridable} to be specified
using standard type signature.

\begin{chapelexample}{typeFunctionDomain.chpl}
The following declarations both create an uninitialized rectangular domain with three dimensions, with \chpl{int} indices:
\begin{chapel}
var D1 : domain(rank=3, idxType=int, stridable=false);
var D2 : domain(3*int);
\end{chapel}
\begin{chapeloutput}
\end{chapeloutput}
\end{chapelexample}

\subsubsection{Rectangular Domain Values}
\label{Rectangular_Domain_Values}
\index{domains!values!rectangular}
\index{domains!rectangular!values}

Each dimension of a rectangular domain is a range of
type \chpl{range(idxType,} \chpl{BoundedRangeType.bounded,} \chpl{
stridable)}.  The index set for a rank~1 domain is the set of indices
described by its singleton range.  The index set for a rank~$n$
domain is the set of all \chpl{n*idxType} tuples described by the
tensor product of its ranges.  When expanded (as by an iterator), rectangular domain indices are ordered
according to the lexicographic order of their values.  That is, the index with
the highest rank is listed first and changes most slowly.\footnote{This is also
known as row-major ordering.}

%REVIEW: vass: we have not settled on the lexicographic order of the values.
% That needs to be reflected here.

%REVIEW: vass: rephrase the futures below to (a) be more formal
% and (b) motivate why we are considering them (or add some contents)?

\begin{future}
Domains defined using unbounded ranges may be supported.
\end{future}

\index{domains!rectangular!literals}

Literal rectangular domain values are represented by a comma-separated
list of range expressions of matching \chpl{idxType} enclosed in
curly braces:

%% \begin{future}
%% Will we support domains with heterogeneous index types?
%% \end{future}

\begin{syntax}
rectangular-domain-literal:
  { range-expression-list }

range-expression-list:
  range-expression
  range-expression, range-expression-list
\end{syntax}

\noindent The type of a rectangular domain literal is defined as follows:

\begin{itemize}
\item \chpl{rank} = the number of range expressions in the literal;
\item \chpl{idxType} = the type of the range expressions;
\item \chpl{stridable} = \chpl{true} if any of the range expressions
are stridable, otherwise \chpl{false}.
\end{itemize}
\noindent If the index types in the ranges differ and all of them can be
promoted to the same type, then that type is used as the \chpl{idxType}.
Otherwise, the domain literal is invalid.

\begin{example}
The expression \chpl{\{1..5, 1..5\}} defines a rectangular domain with
type \chpl{domain(rank=2,} \chpl{ idxType=int,} \chpl{ stridable=false)}.
It is a $5 \times 5$ domain with the indices:
\begin{equation}
(1, 1), (1, 2), \ldots, (1, 5), (2, 1), \ldots (5, 5).
\end{equation}
\end{example}

A domain expression may contain bounds which are evaluated at runtime.
\begin{example}
In the code
\begin{chapel}
var D: domain(2) = {1..n, 1..n};
\end{chapel}

\chpl{D} is defined as a two-dimensional, nonstridable rectangular
domain with an index type of \chpl{2*int} and is initialized to
contain the set of indices $(i,j)$ for all $i$ and $j$ such that
$i \in {1, 2, \ldots, n}$ and $j \in {1, 2, \ldots, n}$.
\end{example}

\index{domains!rectangular!default value}

The default value of a range type is the \chpl{rank} default range
values for type:
\begin{quote}
\chpl{range(idxType, BoundedRangeType.bounded, stridable)}
\end{quote}

\begin{chapelexample}{rectangularDomain.chpl}
The following creates a two-dimensional rectangular domain and then uses this to
declare an array.  The array indices are iterated over using the domain's
\chpl{dim()} method, and each element is filled with
some value.  Then the array is printed out.

Thus, the code
\begin{chapel}
var D : domain(2) = {1..2, 1..7};
var A : [D] int;
for i in D.dim(1) do
  for j in D.dim(2) do
    A[i,j] = 7 * i**2 + j;
writeln(A);
\end{chapel}
produces
\begin{chapelprintoutput}{}
8 9 10 11 12 13 14
29 30 31 32 33 34 35
\end{chapelprintoutput}
\end{chapelexample}

\subsection{Associative Domains}
\index{associative domains (see also domains, associative)}

Associative domains represent an arbitrary set of indices
of a given type and can be used to describe sets or to create
dictionary-style arrays (hash tables).
The type of indices of an associative domain, or its \chpl{idxType},
can be any primitive type except \chpl{void} or any class type.

\subsubsection{Associative Domain Types}

\label{Associative_Domain_Types}
\index{types!associative domains}
\index{domains!associative}

An associative domain type is parameterized by \chpl{idxType}, the
type of the indices that it stores.  The syntax is as follows:

\begin{syntax}
associative-domain-type:
  `domain' ( associative-index-type )
  `domain' ( enum-type )
  `domain' ( `opaque' )

associative-index-type:
  type-specifier
\end{syntax}

\index{types!enumerated domains}
\index{enumerated domains!types}
\index{domains!enumerated}
\index{types!opaque domains}
\index{opaque domains!types}
\index{domains!opaque}
The three expansions of \sntx{associative-domain-type} correspond to the three
kinds of associative domain listed below.
\begin{enumerate} 
\item In general, \sntx{associative-index-type} determines \chpl{idxType}
of the associative domain type.
\item Enumerated domains are a special case, in which \chpl{idxType}
is an enumerated type.  Enumerated domains are
handled specially during initialization and have a defined iteration
order, as described below.
\item Opaque domains are a special case, indicated by the type \chpl{opaque}.
Anonymous values of the type \chpl{opaque} are used as index values
in this case.
% TODO: need to define and explain the 'opaque' type elsewhere.
\end{enumerate}

When an associative domain is used as the index set of an array, the relation
between the indices and the array elements can be thought of as a map between
the values of the index set and the elements stored in the array.
Opaque domains can be used to build unstructured arrays that are similar to
pointer-based data structures in conventional languages.

\subsubsection{Associative Domain Values}
\label{Associative_Domain_Values}
\index{domains!values!associative}
\index{domains!associative!values}

An associative domain's value is simply the set of all index values
that the domain describes.  The iteration order over the indices of
an associative domain is undefined, except for enumerated domains.
The iteration order over the indices of an enumerated domain
is the declaration order of the corresponding enumeration constants.

\index{domains!associative!literals}
\index{domains!associative!initialization}

Specification of an assocative domain literal value follows a similar syntax as 
rectangular domain literal values.  What differentiates the two are the types 
of expressions specified in the comma separated list.  Use of values of a 
type other than ranges will result in the construction of an associative domain.  

\begin{syntax}
associative-domain-literal:
   { associative-expression-list }

associative-expression-list:
   non-range-expression
   non-range-expression, associative-expression-list

non-range-expression:
   expression
\end{syntax}

It is required that the types of the values used in constructing an associative
domain literal value be of the same type.  If the types of the indices does not
match a compiler error will be issued.

\begin{future}
Due to implementation of == over arrays it is currently not possible to use
arrays as indices within an associative domain. 
\end{future}

\begin{openissue}
Assignment of an associative domain literal results in the a warning message
being printed altering the user that whole-domain assignment has been
serialized. This results from the resize operation over assocative arrays not 
being parsafe. 
\end{openissue}

\begin{chapelexample}{associativeDomain.chpl}
The following example illusrates construction of an associative domain
containing string indices "bar" and "foo".  Note that due to internal hashing 
of indices the order in which the values of the associative domain are iterated
is not the same as their specification order.

This code
\begin{chapel}
var D : domain(string) = {"bar", "foo"};
writeln(D);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
produces the output
\begin{chapelprintoutput}{}
{foo, bar}
\end{chapelprintoutput}
\end{chapelexample}

\index{domains!associative!default values}

If unspecified the default value of an associative domain type is the empty 
index set, except for enumerated domains.
The default value of an enumerated domain type is the set of all constants
of the corresponding enumerated type.

\begin{rationale}
The decision to have enumerated domains start fully populated was
based on the observation that enumerations have a finite, typically
small number of values and that it would be common to declare arrays
with elements corresponding to each identifier in the enumeration.
Further, in terms of usability it is simpler to clear a fully-populated
domain than to fully populate an empty one.

In addition, fully-populated constant enumerated
domains are an important case for compiler optimizations, particularly
if the numeric values of the enumeration are consecutive.
\end{rationale}

\begin{future}
We may generally support a \chpl{startPopulated} parameter on associative
domains, to unify this capability with other values.
\end{future}

Indices can be added to or removed from an associative domain
as described in \rsec{Adding_and_Removing_Domain_Indices}.


\section{Simple Subdomain Types and Values}
\label{Simple_Subdomain_Types_and_Values}
\index{subdomains}
\index{subdomains!simple}

A subdomain is a domain whose indices are guaranteed to be a subset of
those described by another domain known as its \emph{parent domain}.
A subdomain has the same type as its parent domain, and by default
it inherits the domain map of its parent domain.  All domain types
support subdomains.

Simple subdomains are subdomains which are not sparse.  Sparse
subdomains are discussed in the following section
(\rsec{Sparse_Subdomain_Types_and_Values}).  A simple subdomain
inherits its representation (regular or irregular) from its base
domain (or base subdomain).  A sparse subdomain is always irregular,
even if its base domain is regular.

In all other respects, the two kinds of subdomain behave identically.  In this
specification, ``subdomain'' refers to both simple and sparse subdomains, unless
it is specifically distinguished as one or the other.

\begin{rationale}
Subdomains are provided in Chapel for a number of reasons: to
facilitate the ability of the compiler or a reader to reason about the
inter-relationship of distinct domain variables; to support the
author's ability to omit redundant domain mapping specifications; to
support the compiler's ability to reason about the relative alignment
of multiple domains; and to improve the compiler's ability to prove
away bounds checks for array accesses.
\end{rationale}

\subsection{Simple Subdomain Types}
\label{Simple_Subdomain_Types}
\index{subdomains!simple!types}
\index{subdomains!types!simple}
\index{types!subdomains!simple}

A simple subdomain type is specified using the following syntax:
\begin{syntax}
simple-subdomain-type:
  `subdomain' ( domain-expression )
\end{syntax}

This declares that \sntx{domain-expression} is the parent domain of
this subdomain type.  A simple subdomain specifies a subdomain
with the same underlying representation as its base domain.  

\begin{openissue}

An open semantic issue for subdomains is when a subdomain's subset
property should be re-verified once its parent domain is reassigned
and whether this should be done aggressively or lazily.

\end{openissue}

\subsection{Simple Subdomain Values}
\index{subdomains!simple!values}
\index{values!subdomains!simple}

The value of a simple subdomain is the set of all index values
that the subdomain describes.

\index{subdomains!simple!default values}

The default value of a simple subdomain type is the same as the default value
of its parent's type
(\rsec{Rectangular_Domain_Values}, \rsec{Associative_Domain_Values}).

A simple subdomain variable can be initialized or assigned to
with a tuple of values of the parent's \chpl{idxType}.
Indices can also be added to or removed from a simple subdomain
as described in \rsec{Adding_and_Removing_Domain_Indices}.
It is an error to attempt to add an index to a subdomain that is not also
a member of the parent domain.


\section{Sparse Subdomain Types and Values}
\label{Sparse_Subdomain_Types_and_Values}
\index{domains!sparse}
\index{subdomains!sparse}

\begin{syntax}
sparse-subdomain-type:
  `sparse' `subdomain'[OPT] ( domain-expression )
\end{syntax}

This declaration creates a sparse subdomain.
 \emph{Sparse subdomains} are irregular domains that describe an
arbitrary subset of a domain, even if the parent domain is a regular
domain.  Sparse subdomains are useful in Chapel for
defining \emph{sparse arrays} in which a single element value (usually ``zero'')
 occurs
frequently enough that it is worthwhile to avoid storing it
redundantly.  The set difference between a sparse subdomain's index set
and that of parent domain is the set of indices for which the
sparse array will store this replicated value.
%%NB: This is a nice mathematical definition, but do we really want to torque
%%the reader's brain with the notion of redundant values?
%REVIEW:hilde -- I would suggest "uninteresting values" or values that can be omitted.
See~\rsec{Sparse_Arrays} for details about sparse arrays.

\subsection{Sparse Subdomain Types}
\index{domains!sparse!types}
\index{subdomains!sparse!types}
\index{types!domains!sparse}
\index{types!subdomains!sparse}

Each root domain type has a unique corresponding sparse subdomain
type.  Sparse subdomains whose parent domains are also sparse
subdomains share the same type.

\subsection{Sparse Subdomain Values}
\label{Sparse_Domain_Values}
\index{domains!sparse!values}
\index{subdomains!sparse!values}
\index{values!domains!sparse}
\index{values!subdomains!sparse}

A sparse subdomain's value is simply the set of all index values that
the domain describes.  If the parent domain defines an iteration order
over its indices, the sparse subdomain inherits that order.

\index{sparse domains!literals!lack thereof}
\index{sparse domains!initialization}
\index{domains!sparse!initialization}
\index{initializations!sparse domains}
There is no literal syntax for an sparse subdomain.  However, a variable of a
sparse subdomain type can be initialized using a tuple of values
of the parent domain's index type.

\index{sparse domains!default value}
\index{domains!sparse!default value}
The default value for a sparse subdomain value is the empty set.  This is true
even if the parent domain is an enumerated domain.

\begin{example}
The following code declares a two-dimensional dense domain \chpl{D},
followed by a two dimensional sparse subdomain of \chpl{D}
named \chpl{SpsD}.  Since \chpl{SpsD} is uninitialized, it will
initially describe an empty set of indices from \chpl{D}.
\begin{chapel}
const D: domain(2) = {1..n, 1..n};
var SpsD: sparse subdomain(D);
\end{chapel}
\end{example}

\section{Domain Index Types}
\label{Index_Types}
\index{domains!index types}

Each domain value has a corresponding compiler-provided \emph{index
type} which can be used to represent values belonging to that domain's
index set.  Index types are described using the following syntax:

\begin{syntax}
index-type:
  `index' ( domain-expression )
\end{syntax}

A variable with a given index type is constrained to take on only values
available within the domain on which it is defined.  This restriction allows the
compiler to prove away the bound checking that code safety considerations might
otherwise require.  Due to the subset relationship between a base domain and its
subdomains, a variable of an index type defined with respect to a subdomain is
also necessarily a valid index into the base domain.

Since an index types are known to be legal for a given domain, it may
also afford the opportunity to represent that index using an optimized
format that doesn't simply store the index variable's value.  This fact could be
used to support accelerated access to arrays declared over that domain.  For
example, iteration over an index type could be implemented using memory pointers
and strides, rather than explicitly calculating the offset of each index
within the domain.

These potential optimizations may make it less expensive to
index into arrays using index type variables of their domains or
subdomains.

In addition, since an index type is associated with a specific domain or subdomain, it
carries more semantic weight than a generic index.  For example, one could
iterate over a rectangular domain with integer bounds using an \chpl{int(n)} as
the index variable.  However, it would be more precise to use a variable of the
domain's index type.

\begin{openissue}

An open issue for index types is what the semantics should be for an
index type value that is live across a modification to its domain's
index set---particularly one that shrinks the index set.  Our
hypothesis is that most stored indices will either have short
lifespans or belong to constant or monotonically growing domains.  But
these semantics need to be defined nevertheless.

\end{openissue}

\section{Iteration Over Domains}
\label{Iteration_over_Domains}
\index{domains!iteration}
\index{iteration!domain}

All domains support iteration via standard \chpl{for}, \chpl{forall}, and \chpl{coforall}
loops.  These loops iterate over all of the indices that the domain
describes.  If the domain defines an iteration order of its indices,
then the indices are visited in that order.  

The type of the iterator variable for an iteration over a
domain named \chpl{D} is that domain's index type, \chpl{index(D)}.


\section{Domains as Arguments}
\label{Domain_Arguments}
\index{domains!as arguments}
\index{argument passing!domains}

This section describes the semantics of passing domains as arguments
to functions.

\subsection{Formal Arguments of Domain Type}

When a domain value is passed to a formal argument of compatible
domain type by default intent, it is passed by reference in order to
preserve the domain's identity.

\subsection{Domain Promotion of Scalar Functions}
\label{Domain_Promotion_of_Scalar_Functions}
\index{domains!promotion}
\index{promotion!domain}

Domain values may be passed to a scalar function argument whose type
matches the domain's index type.  This results in a promotion of the
scalar function as defined in~\rsec{Promotion}.

\begin{example}
Given a function \chpl{foo()} that accepts real floating point values
and an associative domain \chpl{D} of
type \chpl{domain(real)}, \chpl{foo} can be called with \chpl{D} as
its actual argument which will result in the function being invoked
for each value in the index set of \chpl{D}.
\end{example}

\begin{example}
Given an array \chpl{A} with element type \chpl{int} declared over a
one-dimensional domain \chpl{D} with \chpl{idxType} \chpl{int}, the
array elements can be assigned their corresponding index values by
writing:
\begin{chapel}
A = D;
\end{chapel}
This is equivalent to:
\begin{chapel}
forall (a,i) in zip(A,D) do
  a = i;
\end{chapel}
\end{example}


\section{Domain Operations}

Chapel supplies predefined operators and functions that can be used to manipulate
domains.  Unless otherwise noted, these operations are applicable to a domain of
any type, whether a base domain or a subdomain.

\subsection{Domain Assignment}
\label{Domain_Assignment}
\index{domains!assignment}
\index{assignment!domain}

All domain types support domain assignment.  

\begin{syntax}
domain-expression:
  domain-literal
  domain-name
  domain-assignment-expression
  domain-striding-expression
  domain-slice-expression

domain-literal:
  rectangular-domain-literal
  associative-domain-literal

domain-assignment-expression:
  domain-name = domain-expression

domain-name:
  identifier
\end{syntax}

Domain assignment is by
value and causes the target domain variable to take on the index set
of the right-hand side expression.  In practice, the right-hand side
expression is often another domain value; a tuple of ranges (for
regular domains); or a tuple of indices or a loop that enumerates
indices (for irregular domains).  If the domain variable being
assigned was used to declare arrays, these arrays are reallocated as
discussed in~\rsec{Association_of_Arrays_to_Domains}.

\begin{example}
The following three assignments show ways of assigning indices to a
sparse domain, \chpl{SpsD}.  The first assigns the domain two index
values, \chpl{(1,1)} and \chpl{(n,n)}.  The second assigns the domain
all of the indices along the diagonal from
\chpl{(1,1)}$\ldots$\chpl{(n,n)}.  The third invokes an iterator that
is written to \chpl{yield} indices read from a file named
``inds.dat''.  Each of these assignments has the effect of replacing
the previous index set with a completely new set of values.
\begin{chapel}
SpsD = ((1,1), (n,n));
SpsD = [i in 1..n] (i,i);
SpsD = readIndicesFromFile("inds.dat");
\end{chapel}
\end{example}

\subsection{Domain Striding}
\label{Domain_Striding}
\index{domains!striding}
\index{by@\chpl{by}!on rectangular domains}
\index{operators!by (domain)@\chpl{by} (domain)}

The \chpl{by} operator can be applied to a rectangular domain value in
order to create a strided rectangular domain value.  The right-hand
operand to the \chpl{by} operator can either be an integral value or
an integral tuple whose size matches the domain's rank.

\begin{syntax}
domain-striding-expression:
  domain-expression `by' expression
\end{syntax}

The type of the resulting domain is the same as the original domain
but with \chpl{stridable} set to true.  In the case of an integer
stride value, the value of the resulting domain is computed by
applying the integer value to each range in the value using the
\chpl{by} operator.  In the case of a tuple stride value, the resulting
domain's value is computed by applying each tuple component to the
corresponding range using the \chpl{by} operator.


\subsection{Domain Slicing}
\label{Domain_Slicing}
\index{slicing!domains}
\index{domains!slicing}

Slicing is the application of an index set to a domain.
It can be written using either parentheses or square brackets.
The index set can be defined with either a domain or a list of ranges.

\begin{syntax}
domain-slice-expression:
  domain-expression [ slicing-index-set ]
  domain-expression ( slicing-index-set )

slicing-index-set:
  domain-expression
  range-expression-list
\end{syntax}

The result of slicing, or a \emph{slice}, is a new domain value
that represents the intersection of
the index set of the domain being sliced and
the index set being applied.
The type and domain map of the slice match the domain being sliced.

Slicing can also be performed on an array,
resulting in aliasing a subset of the array's elements
(\rsec{Array_Slicing}).

\subsubsection{Domain-based Slicing}
\index{domain-based slicing}
\index{slicing!domain-based}

If the brackets or parentheses contain a domain value,
its index set is applied for slicing.

\begin{openissue}
Can we say that it is an alias in the case of sparse/associative?
% If so, need to reconcile getting an "alias" with getting
% a "new domain value", as claimed earlier.
\end{openissue}

\subsubsection{Range-based Slicing}
\label{Range_Based_Slicing}
\index{slicing!range-based}
\index{range-based slicing}
When slicing rectangular domains or arrays, the brackets or parentheses
can contain a list of \chpl{rank} ranges.  These ranges can either be bounded
or unbounded.
%
%REVIEW: vass: no, they don't inherit. We should either drop
% the following sentence or rephrase it to make it correct.
When unbounded, they inherit their bounds from the
domain or array being sliced.
%
The Cartesian product of the ranges' index sets is applied for slicing.

\begin{example}
The following code declares a two dimensional rectangular
domain \chpl{D}, and then a number of subdomains of \chpl{D} by
slicing into \chpl{D} using bounded and unbounded ranges.
The \chpl{InnerD} domain describes the inner indices of
D, \chpl{Col2OfD} describes the 2nd column of
\chpl{D}, and \chpl{AllButLastRow} describes all of \chpl{D} except
for the last row.

\begin{chapel}
const D: domain(2) = {1..n, 1..n},
      InnerD = D[2..n-1, 2..n-1],
      Col2OfD = D[.., 2..2],
      AllButLastRow = D[..n-1, ..];
\end{chapel}
\end{example}

\subsubsection{Rank-Change Slicing}
\label{Rank_Change_Slicing}
\index{slicing!rank-change}
\index{rank-change slicing}

For multidimensional rectangular domains and arrays, substituting
integral values for one or more of the ranges in a range-based slice
will result in a domain or array of lower rank.

The result of a rank-change slice on an array is an alias to a subset
of the array's elements as described
in~\rsec{Rectangular_Array_Slicing}.

The result of rank-change slice on a domain is a subdomain of the
domain being sliced.  The resulting
subdomain's type will be the same as the original domain, but with
a \chpl{rank} equal to the number of dimensions that were sliced by
ranges rather than integers.


\subsection{Count Operator}
\label{Count_Operator_Domains}
\index{domains!count operator}
\index{domains!#@\chpl{#}}
\index{# (domain)@\chpl{#} (domain)}
\index{operators!# (domain)@\chpl{#} (domain)}
The \chpl{#} operator can be applied to dense rectangular domains with
a tuple argument whose size matches the rank of the domain (or
optionally an integer in the case of a 1D domain).  The operator is
equivalent to applying the \chpl{#} operator to the component ranges
of the domain and then using them to slice the domain as in
Section~\ref{Range_Based_Slicing}.


\subsection{Adding and Removing Domain Indices}
\label{Adding_and_Removing_Domain_Indices}
\index{domains!adding indices}
\index{domains!removing indices}

All irregular domain types support the ability to incrementally add
and remove indices from their index sets.  This can either be done
using \chpl{add(i:idxType)} and \chpl{remove(i:idxType)} methods on a
domain variable or by using the \chpl{+=} and \chpl{-=} assignment
operators.  It is legal to add the same index to an irregular domain's
index set twice, but illegal to remove an index that does not belong
to the domain's index set.

\begin{openissue}
These remove semantics seem dangerous in a parallel context; maybe
add flags to both the method versions of the call that say whether
they should balk or not?  Or add exceptions...
\end{openissue}

As with normal domain assignments, arrays declared in terms of a
domain being modified in this way will be reallocated as discussed
in~\rsec{Association_of_Arrays_to_Domains}.

% TODO: describe operations on opaque domains, esp. domain.create().
% Note that domain.add() (should) work as defined above on
% opaque domains, taking values of the opaque type for its argument.


\section{Predefined Methods on Domains}
\index{domains!predefined functions}

This section gives a brief description of the library functions provided for
Domains.  These are categorized by the type of domain to which they apply: all,
regular or irregular.  Within each subsection, entries are listed in
alphabetical order.

\subsection{Methods on All Domain Types}
\index{domains!methods!common}
\index{domains!common methods}

The methods in this subsection can be applied to any domain.

\index{domains!clear@\chpl{clear}}
\index{predefined functions!clear@\chpl{clear}}
\begin{protohead}
proc $Domain$.clear()
\end{protohead}
\begin{protobody}
Resets this domain's index set to the empty set.
\end{protobody}

\begin{chapelexample}{emptyEnumeratedDomain}
In the case of an enumerated domain, this function provides a way to produce an
empty index set.

When run, the code
\begin{chapel}
enum Counter { one, two, three };
var D : domain ( Counter );
writeln("D has ", D.numIndices, " indices.");
D.clear();
writeln("D has ", D.numIndices, " indices.");
\end{chapel}
prints out
\begin{chapelprintoutput}{}
D has 3 indices.
D has 0 indices.
\end{chapelprintoutput}
\end{chapelexample}

\index{domains!idxType@\chpl{idxType}}
\index{predefined functions!idxType@\chpl{idxType}}
\begin{protohead}
proc $Domain$.idxType type
\end{protohead}
\begin{protobody}
Returns the domain type's \chpl{idxType}.
This function is not available on opaque domains.
\end{protobody}

\begin{protohead}
proc $Domain$.indexOrder(i: index($Domain$)): idxType
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the domain, returns the ordinal value of
\chpl{i} using a total ordering of the domain's indices using 0-based
indexing.  Otherwise, it returns \chpl{(-1):idxType}.  For rectangular
domains, this ordering will be based on a row-major ordering of the
indices; for other domains, the ordering may be
implementation-defined and unstable as indices are added and
removed from the domain.
\end{protobody}

\index{domains!isEnumDom@\chpl{isEnumDom}}
\index{predefined functions!isEnumDom@\chpl{isEnumDom}}
\begin{protohead}
proc isEnumDom(d: domain) param
\end{protohead}
\begin{protobody}
Returns a param \chpl{true} if the given domain is enumerated, false otherwise.
\end{protobody}

\index{domains!isIrregularDom@\chpl{isIrregularDom}}
\index{predefined functions!isIrregularDom@\chpl{isIrregularDom}}
\begin{protohead}
proc isIrregularDom(d: domain) param
\end{protohead}
\begin{protobody}
Returns a param \chpl{true} if the given domain is irregular, false otherwise.
\end{protobody}

\index{domains!isOpaqueDom@\chpl{isOpaqueDom}}
\index{predefined functions!isOpaqueDom@\chpl{isOpaqueDom}}
\begin{protohead}
proc isOpaqueDom(d: domain) param
\end{protohead}
\begin{protobody}
Returns a param \chpl{true} if the given domain is opaque, false otherwise.
\end{protobody}

\index{domains!isRectangularDom@\chpl{isRectangularDom}}
\index{predefined functions!isRectangularDom@\chpl{isRectangularDom}}
\begin{protohead}
proc isRectangularDom(d: domain) param
\end{protohead}
\begin{protobody}
Returns a param \chpl{true} if the given domain is rectangular, false otherwise.
\end{protobody}

\index{domains!isSparseDom@\chpl{isSparseDom}}
\index{predefined functions!isSparseDom@\chpl{isSparseDom}}
\begin{protohead}
proc isSparseDom(d: domain) param
\end{protohead}
\begin{protobody}
Returns a param \chpl{true} if the given domain is sparse, false otherwise.
\end{protobody}

\index{domains!member@\chpl{member}}
\index{predefined functions!member (domain)@\chpl{member} (domain)}
\begin{protohead}
proc $Domain$.member(i)
\end{protohead}
\begin{protobody}
Returns true if the given index \chpl{i} is a member of this domain's index set,
and false otherwise.
\end{protobody}

\begin{openissue}
We would like to call the type of i above idxType, but it's not true
for rectangular domains.  That observation provides some motivation to normalize
the behavior.
\end{openissue}

%REVIEW: vass: need to define 'capType' or replace with something that is defined
\index{domains!numIndices@\chpl{numIndices}}
\index{predefined functions!numIndices (domain)@\chpl{numIndices} (domain)}
\begin{protohead}
proc $Domain$.numIndices: capType
\end{protohead}
\begin{protobody}
Returns the number of indices in the domain as a value of the capacity type.
\end{protobody}

\subsection{Methods on Regular Domains}
\index{domains!methods!regular}
\index{regular domains!methods}

The methods described in this subsection can be applied to regular domains only.

\index{domains!dim@\chpl{dim}}
\index{predefined functions!dim (domain)@\chpl{dim} (domain)}
\begin{protohead}
proc $Domain$.dim(d: int): range
\end{protohead}
\begin{protobody}
Returns the range of indices described by dimension \chpl{d} of the
domain.
\end{protobody}

\begin{example}
In the code
\begin{chapel}
for i in D.dim(1) do
  for j in D.dim(2) do
    writeln(A(i,j));
\end{chapel}
domain \chpl{D} is iterated over by two nested loops.  The first
dimension of \chpl{D} is iterated over in the outer loop.  The second
dimension is iterated over in the inner loop.
\end{example}

\index{domains!dims@\chpl{dims}}
\index{predefined functions!dims (domain)@\chpl{dims} (domain)}
\begin{protohead}
proc $Domain$.dims(): rank*range
\end{protohead}
\begin{protobody}
Returns a tuple of ranges describing the dimensions of the domain.
\end{protobody}

% BLC: ``integral'' isn't really correct in the two 1D cases below,
% however, we don't really seem to have a user-level name for the
% per-dimension index type in the language that I can see.

\index{domains!expand@\chpl{expand}}
\index{predefined functions!expand (domain)@\chpl{expand} (domain)}
\begin{protohead}
proc $Domain$.expand(off: integral): domain
proc $Domain$.expand(off: rank*integral): domain
\end{protohead}
\begin{protobody}
Returns a new domain that is the current domain expanded in
dimension \chpl{d} if \chpl{off} or \chpl{off(d)} is positive or
contracted in dimension \chpl{d} if \chpl{off} or \chpl{off(d)} is
negative.
\end{protobody}

\index{domains!exterior@\chpl{exterior}}
\index{predefined functions!exterior (domain)@\chpl{exterior} (domain)}
\begin{protohead}
proc $Domain$.exterior(off: integral): domain
proc $Domain$.exterior(off: rank*integral): domain
\end{protohead}
\begin{protobody}
Returns a new domain that is the exterior portion of the current
domain with \chpl{off} or \chpl{off(d)} indices for each
dimension \chpl{d}.  If \chpl{off} or \chpl{off(d)} is negative,
compute the exterior from the low bound of the dimension; if positive,
compute the exterior from the high bound.
\end{protobody}

\index{domains!high@\chpl{high}}
\index{predefined functions!high (domain)@\chpl{high} (domain)}
\begin{protohead}
proc $Domain$.high: index($Domain$)
\end{protohead}
\begin{protobody}
Returns the high index of the domain as a value of the domain's index
type.
\end{protobody}

\index{domains!interior@\chpl{interior}}
\index{predefined functions!interior (domain)@\chpl{interior} (domain)}
\begin{protohead}
proc $Domain$.interior(off: integral): domain
proc $Domain$.interior(off: rank*integral): domain
\end{protohead}
\begin{protobody}
Returns a new domain that is the interior portion of the current
domain with \chpl{off} or \chpl{off(d)} indices for each
dimension \chpl{d}.  If \chpl{off} or \chpl{off(d)} is negative,
compute the interior from the low bound of the dimension; if positive,
compute the interior from the high bound.
\end{protobody}

\index{domains!low@\chpl{low}}
\index{predefined functions!low (domain)@\chpl{low} (domain)}
\begin{protohead}
proc $Domain$.low: index($Domain$)
\end{protohead}
\begin{protobody}
Returns the low index of the domain as a value of the domain's index
type.
\end{protobody}

\index{domains!rank@\chpl{rank}}
\index{predefined functions!rank (domain)@\chpl{rank} (domain)}
\begin{protohead}
proc $Domain$.rank param : int
\end{protohead}
\begin{protobody}
Returns the rank of the domain.
\end{protobody}

\index{domains!size@\chpl{size}}
\index{predefined functions!size (domain)@\chpl{size} (domain)}
\begin{protohead}
proc $Domain$.size: capType
\end{protohead}
\begin{protobody}
Same as $Domain$.numIndices.
\end{protobody}

\index{domains!stridable@\chpl{stridable}}
\index{predefined functions!stridable (domain)@\chpl{stridable} (domain)}
\begin{protohead}
proc $Domain$.stridable param : bool
\end{protohead}
\begin{protobody}
Returns whether or not the domain is stridable.
\end{protobody}

\index{domains!stride@\chpl{stride}}
\index{predefined functions!stride (domain)@\chpl{stride} (domain)}
\begin{protohead}
proc $Domain$.stride: int(numBits(idxType)) where rank == 1
proc $Domain$.stride: rank*int(numBits(idxType))
\end{protohead}
\begin{protobody}
Returns the stride of the domain as the domain's stride type (for 1D
domains) or a tuple of the domain's stride type (for multidimensional
domains).
\end{protobody}

\index{domains!translate@\chpl{translate}}
\index{predefined functions!translate (domain)@\chpl{translate} (domain)}
\begin{protohead}
proc $Domain$.translate(off: integral): domain
proc $Domain$.translate(off: rank*integral): domain
\end{protohead}
\begin{protobody}
Returns a new domain that is the current domain translated
by \chpl{off} or \chpl{off(d)} for each dimension \chpl{d}.
\end{protobody}

%% \begin{protohead} **/
%% proc $Domain$.position(i: index($Domain$)): rank*idxType **/
%% \end{protohead} **/
%% \begin{protobody} **/
%% Returns a tuple holding the order of index i in each range defining **/
%% the domain. **/
%% \end{protobody} **/

\subsection{Methods on Irregular Domains}
\index{domains!methods!irregular}
\index{irregular domains!methods}

The following methods are available only on irregular domain types.

\index{domains!+@\chpl{+}}
\index{predefined functions!+ (domain)@\chpl{+} (domain)}
\begin{protohead}
proc +(d: domain, i: index(d))
proc +(i, d: domain) where i: index(d)
\end{protohead}
\begin{protobody}
Adds the given index to the given domain.  If the given index is already a
member of that domain, it is ignored.
\end{protobody}

\index{domains!+@\chpl{+}}
\index{predefined functions!+ (domain)@\chpl{+} (domain)}
\begin{protohead}
proc +(d1: domain, d2: domain)
\end{protohead}
\begin{protobody}
Merges the index sets of the two domain arguments.
\end{protobody}

\index{domains!-@\chpl{-}}
\index{predefined functions!- (domain)@\chpl{-} (domain)}
\begin{protohead}
proc -(d: domain, i: index(d))
\end{protohead}
\begin{protobody}
Removes the given index from the given domain.  It is an error if the domain
does not contain the given index.
\end{protobody}

\index{domains!-@\chpl{-}}
\index{predefined functions!- (domain)@\chpl{-} (domain)}
\begin{protohead}
proc -(d1: domain, d2: domain)
\end{protohead}
\begin{protobody}
Removes the indices in domain \chpl{d2} from those in \chpl{d1}.  It is an error
if \chpl{d2} contains indices which are not also in \chpl{d1}.
\end{protobody}

\index{domains!requestCapacity@\chpl{requestCapacity}}
\index{predefined functions!requestCapacity@\chpl{requestCapacity}}
\begin{protohead}
proc requestCapacity(s: int)
\end{protohead}
\begin{protobody}
Resizes the domain internal storage to hold at least \chpl{s} indicies.
\end{protobody}
