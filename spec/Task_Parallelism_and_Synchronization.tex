\sekshun{Task Parallelism and Synchronization}
\label{Task_Parallelism_and_Synchronization}
\index{synchronization}

Chapel supports both task parallelism and data parallelism.  This
chapter details task parallelism as follows:
\begin{itemize}
\item \rsec{Task_parallelism} introduces tasks and task parallelism.
\item \rsec{Begin} describes the begin statement, an unstructured way
to introduce concurrency into a program.
\item \rsec{Synchronization_Variables} describes synchronization
variables, an unstructured mechanism for synchronizing tasks.
\item \rsec{Atomic_Variables} describes atomic variables, a mechanism
for supporting atomic operations. 
\item \rsec{Cobegin} describes the cobegin statement, a structured way to
introduce concurrency into a program.
\item \rsec{Coforall} describes the coforall loop, another structured way to
introduce concurrency into a program.
\item \rsec{Task_Intents} specifies how variables from outer scopes
are handled within \chpl{begin}, \chpl{cobegin} and \chpl{coforall}
statements.
\item \rsec{Sync_Statement} describes the sync statement, a structured
way to control parallelism.
\item \rsec{Serial} describes the serial statement, a structured way to suppress
parallelism.
\item \rsec{Atomic_Statement} describes the atomic statement, a construct to
support atomic transactions.
\end{itemize}

\section{Tasks and Task Parallelism}
\label{Task_parallelism}
\index{task parallelism}
\index{parallelism!task}

A Chapel \emph{task} is a distinct context of execution that may be
running concurrently with other tasks.  Chapel provides a simple
construct, the \chpl{begin} statement, to create tasks, introducing
concurrency into a program in an unstructured way.  In addition,
Chapel introduces two type qualifiers, \chpl{sync} and \chpl{single},
for synchronization between tasks.

Chapel provides two constructs, the \chpl{cobegin} and \chpl{coforall} statements,
to introduce concurrency in a more structured way.  These constructs
create multiple tasks but do not continue until these tasks have
completed.  In addition, Chapel provides two constructs, the \chpl{sync} and
\chpl{serial} statements, to insert synchronization and suppress parallelism.
All four of these constructs can be implemented through judicious uses
of the unstructured task-parallel constructs described in the previous
paragraph.

\index{task parallelism!task creation}
\index{task creation}
Tasks are considered to be created when execution reaches the start
of a \chpl{begin}, \chpl{cobegin}, or \chpl{coforall} statement.
When the tasks are actually executed depends on the Chapel
implementation and run-time execution state.

\index{task function}
\index{task parallelism!task function}
A task is represented as a call to a \emph{task function}, whose body
contains the Chapel code for the task. Variables defined in outer
scopes are considered to be passed into a task function by blank intent,
unless a different \emph{task intent} is specified explicitly
by a \sntx{task-intent-clause}.


\section{The Begin Statement}
\label{Begin}
\index{begin@\chpl{begin}}
\index{statements!begin}

The begin statement creates a task to execute a statement.  The syntax
for the begin statement is given by
\begin{syntax}
begin-statement:
  `begin' task-intent-clause[OPT] statement
\end{syntax}
Control continues concurrently with the statement following the
begin statement.

\begin{chapelexample}{beginUnordered.chpl}
The code
\begin{chapel}
begin writeln("output from spawned task");
writeln("output from main task");
\end{chapel}
\begin{chapelprediff}
\#!/usr/bin/env sh
testname=$1
outfile=$2
sort $outfile > $outfile.2
mv $outfile.2 $outfile
\end{chapelprediff}
\begin{chapeloutput}
output from main task
output from spawned task
\end{chapeloutput}
executes two \chpl{writeln} statements that output the strings to the
terminal, but the ordering is purposely unspecified.  There is no
guarantee as to which statement will execute first.  When the
begin statement is executed, a new task is created that will execute
the \chpl{writeln} statement within it.  However, execution will
continue immediately after task creation with the next statement.
\end{chapelexample}

A begin statement creates a single task function,
whose body is the body of the begin statement.
The handling of the outer variables within the task function and
the role of \sntx{task-intent-clause} are defined in \rsec{Task_Intents}.

Yield and return statements are not allowed in begin blocks.  Break
and continue statements may not be used to exit a begin block.

%
% TODO: Future environment about task teams.
%

\section{Synchronization Variables}
\label{Synchronization_Variables}
\index{synchronization variables!sync@\chpl{sync}}
\index{synchronization variables!sync@\chpl{single}}
\index{sync@\chpl{sync}}
\index{single@\chpl{single}}

Synchronization variables have a logical state associated with the
value.  The state of the variable is either {\em full} or {\em empty}.
Normal reads of a synchronization variable cannot proceed until the
variable's state is full.  Normal writes of a synchronization variable
cannot proceed until the variable's state is empty.

Chapel supports two types of synchronization variables: sync and
single.  Both types behave similarly, except that a single variable
may only be written once.  Consequently, when a sync variable is read,
its state transitions to empty, whereas when a single variable is
read, its state does not change.  When either type of synchronization
variable is written, its state transitions to full.

\chpl{sync} and \chpl{single} are type qualifiers and precede
the type of the variable's value in
the declaration.  Sync and single are supported for all Chapel
primitive types (~\rsec{Primitive_Types}) except strings and complex.

If a task attempts to read or write a synchronization variable that is
not in the correct state, the task is suspended.  When the variable
transitions to the correct state, the task is resumed.  If there are
multiple tasks blocked waiting for the state transition, one is
non-deterministically selected to proceed and the others continue to
wait if it is a sync variable; all tasks are selected to proceed
if it is a single variable.

A synchronization variable is specified with a sync or single type
given by the following syntax:
\begin{syntax}
sync-type:
  `sync' type-specifier

single-type:
  `single' type-specifier
\end{syntax}

If a synchronization variable declaration has an initialization
expression, then the variable is initially full, otherwise it is
initially empty.

\begin{chapelexample}{beginWithSyncVar.chpl}
The code
\begin{chapel}
class Tree {
  var isLeaf: bool;
  var left, right: Tree;
  var value: int;

  proc sum():int {
    if (isLeaf) then 
       return value;

    var x(*\texttt{\$}*): sync int;
    begin x(*\texttt{\$}*) = left.sum();
    var y = right.sum();
    return x(*\texttt{\$}*) + y;
  }
}
\end{chapel}
\begin{chapelpost}
var tree: Tree = new Tree(false, new Tree(false, new Tree(true, nil, nil, 1),
                                                 new Tree(true, nil, nil, 1), 1),
                                 new Tree(false, new Tree(true, nil, nil, 1),
                                                 new Tree(true, nil, nil, 1), 1), 1);
writeln(tree.sum());
proc Tree.~Tree() {
  if isLeaf then return;
  delete left;
  delete right;
}
delete tree;
\end{chapelpost}
\begin{chapeloutput}
4
\end{chapeloutput}
the sync variable \chpl{x$\mbox{\texttt{\$}}$} is assigned by an
asynchronous task created with the begin statement.  The task
returning the sum waits on the reading of \chpl{x$\mbox{\texttt{\$}}$}
until it has been assigned.  By convention, synchronization variables
end in \texttt{\$} to provide a visual cue to the programmer
indicating that the task may block.
\end{chapelexample}

\begin{chapelexample}{syncCounter.chpl}
Sync variables are useful for tallying data from multiple tasks as
well.  If all updates to an initialized sync variable are via compound
assignment operators (or equivalently, traditional assignments that
read and write the variable once), the full/empty state of the sync
variable guarantees that the reads and writes will be interleaved
in a manner that makes the updates atomic.  For example, the code:
\begin{chapel}
var count(*\texttt{\$}*): sync int = 0;
cobegin {
  count(*\texttt{\$}*) += 1;
  count(*\texttt{\$}*) += 1;
  count(*\texttt{\$}*) += 1;
}
\end{chapel}
\begin{chapelpost}
writeln("count is: ", count(*\texttt{\$}*).readFF());
\end{chapelpost}
\begin{chapeloutput}
count is: 3
\end{chapeloutput}
creates three tasks that increment \chpl{count$\mbox{\texttt{\$}}$}.
If \chpl{count$\mbox{\texttt{\$}}$} were not a sync variable, this code
would be unsafe because two tasks could then read the same value
before either had written its updated value, causing one of the
increments to be lost.
\end{chapelexample}

\begin{chapelexample}{singleVar.chpl}
The following code implements a simple split-phase barrier using a
single variable.
\begin{chapelpre}
config const n = 44;
proc work(i) {
  // do nothing
}
\end{chapelpre}
\begin{chapel}
var count(*\texttt{\$}*): sync int = n;  // counter which also serves as a lock
var release(*\texttt{\$}*): single bool; // barrier release

forall t in 1..n do begin {
  work(t);
  var myc = count(*\texttt{\$}*);  // read the count, set state to empty
  if myc!=1 {
    write(".");
    count(*\texttt{\$}*) = myc-1;  // update the count, set state to full
    // we could also do some work here before blocking
    release(*\texttt{\$}*);
  } else {
    release(*\texttt{\$}*) = true;  // last one here, release everyone
    writeln("done");
  }
}
\end{chapel}
\begin{chapeloutput}
...........................................done
\end{chapeloutput}
In each iteration of the forall loop after the work is completed, the
task reads the \chpl{count$\mbox{\texttt{\$}}$} variable, which is
used to tally the number of tasks that have arrived.  All tasks except
the last task to arrive will block while trying to read the
variable \chpl{release$\mbox{\texttt{\$}}$}.  The last task to arrive
will write to \chpl{release$\mbox{\texttt{\$}}$}, setting its state to
full at which time all the other tasks can be unblocked and run.
\end{chapelexample}

\index{synchronization types!formal arguments}
If a formal argument with a blank intent either has a synchronization
type or the formal is generic (\rsec{Formal_Arguments_of_Generic_Type})
and the actual has a synchronization type, the actual must be an
lvalue and is passed by reference. In these cases the formal itself
is an lvalue, too. The actual argument is not read or written during
argument passing; its state is not changed or waited on. The qualifier
\chpl{sync} or \chpl{single} without the value type can be used to
specify a generic formal argument that requires a \chpl{sync}
or \chpl{single} actual.

\index{synchronization types!actual arguments}
When the actual argument is a \chpl{sync} or \chpl{single} and the
corresponding formal has the actual's base type or is implicitly
converted from that type, a normal read of the actual is performed
when the call is made, and the read value is passed to the formal.


\subsection{Predefined Single and Sync Methods}
\label{Functions_on_Synchronization_Variables}
\index{synchronization variables!predefined methods on}

The following methods are defined for variables of sync and single
type.

\index{readFE (sync var)@\chpl{readFE} (sync var)}
\index{predefined functions!readFE (sync var)@\chpl{readFE} (sync var)}
\begin{protohead}
proc (sync t).readFE(): t
\end{protohead}
\begin{protobody}
Returns the value of the sync variable.  This method blocks until the
sync variable is full.  The state of the sync variable is set to empty
when this method completes.
This method implements the normal read of a \chpl{sync} variable.
\end{protobody}

\index{readFF (sync var)@\chpl{readFF} (sync var)}
\index{predefined functions!readFF (sync var)@\chpl{readFF} (sync var)}
\begin{protohead}
proc (sync t).readFF(): t
proc (single t).readFF(): t
\end{protohead}
\begin{protobody}
Returns the value of the sync or single variable.  This method blocks
until the sync or single variable is full.  The state of the sync or
single variable remains full when this method completes.
This method implements the normal read of a \chpl{single} variable.
\end{protobody}

\index{readXX (sync var)@\chpl{readXX} (sync var)}
\index{predefined functions!readXX (sync var)@\chpl{readXX} (sync var)}
\begin{protohead}
proc (sync t).readXX(): t
proc (single t).readXX(): t
\end{protohead}
\begin{protobody}
Returns the value of the sync or single variable.  This method is non-blocking
and the state of the sync or single variable is unchanged when this method
completes.
\end{protobody}

\index{writeEF (sync var)@\chpl{writeEF} (sync var)}
\index{predefined functions!writeEF (sync var)@\chpl{writeEF} (sync var)}
\begin{protohead}
proc (sync t).writeEF(v: t)
proc (single t).writeEF(v: t)
\end{protohead}
\begin{protobody}
Assigns \chpl{v} to the value of the sync or single variable.  This
method blocks until the sync or single variable is empty.  The state
of the sync or single variable is set to full when this method
completes.
This method implements the normal write of a \chpl{sync} or \chpl{single}
variable.
\end{protobody}

\index{writeFF (sync var)@\chpl{writeFF} (sync var)}
\index{predefined functions!writeFF (sync var)@\chpl{writeFF} (sync var)}
\begin{protohead}
proc (sync t).writeFF(v: t)
\end{protohead}
\begin{protobody}
Assigns \chpl{v} to the value of the sync variable.  This method
blocks until the sync variable is full.  The state of the sync
variable remains full when this method completes.
\end{protobody}

\index{writeXF (sync var)@\chpl{writeXF} (sync var)}
\index{predefined functions!writeXF (sync var)@\chpl{writeXF} (sync var)}
\begin{protohead}
proc (sync t).writeXF(v: t)
\end{protohead}
\begin{protobody}
Assigns \chpl{v} to the value of the sync variable.  This method is
non-blocking and the state of the sync variable is set to full when
this method completes.
\end{protobody}

\index{reset (sync var)@\chpl{reset} (sync var)}
\index{predefined functions!reset (sync var)@\chpl{reset} (sync var)}
\begin{protohead}
proc (sync t).reset()
\end{protohead}
\begin{protobody}
Assigns the default value of type \chpl{t} to the value of the sync
variable.  This method is non-blocking and the state of the sync
variable is set to empty when this method completes.
\end{protobody}

\index{isFull (sync var)@\chpl{isFull} (sync var)}
\index{predefined functions!isFull (sync var)@\chpl{isFull} (sync var)}
\begin{protohead}
proc (sync t).isFull: bool
proc (single t).isFull: bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the sync or single variable is full and \chpl{false}
otherwise.  This method is non-blocking and the state of the sync or single
variable is unchanged when this method completes.
\end{protobody}

Note that \chpl{writeEF} and \chpl{readFE}/\chpl{readFF} methods
(for \chpl{sync} and \chpl{single} variables, respectively) are
implicitly invoked for normal writes and reads of synchronization variables.


\begin{chapelexample}{syncMethods.chpl}
Given the following declarations
\begin{chapelpre}
{ // }
\end{chapelpre}
\begin{chapel}
var x(*\texttt{\$}*): sync int;
var y(*\texttt{\$}*): single int;
var z: int;
\end{chapel}
the code
\begin{chapel}
x(*\texttt{\$}*) = 5;
y(*\texttt{\$}*) = 6;
z = x(*\texttt{\$}*) + y(*\texttt{\$}*);
\end{chapel}
\begin{chapelnoprint}
writeln((x(*\texttt{\$}*).readXX(), y(*\texttt{\$}*).readFF(), z));
// {
}
{ // }
var x(*\texttt{\$}*): sync int;
var y(*\texttt{\$}*): single int;
var z: int;
\end{chapelnoprint}
is equivalent to
\begin{chapel}
x(*\texttt{\$}*).writeEF(5);
y(*\texttt{\$}*).writeEF(6);
z = x(*\texttt{\$}*).readFE() + y(*\texttt{\$}*).readFF();
\end{chapel}
\begin{chapelpost}
writeln((x(*\texttt{\$}*).readXX(), y(*\texttt{\$}*).readFF(), z));
// {
}
\end{chapelpost}
\begin{chapeloutput}
(5, 6, 11)
(5, 6, 11)
\end{chapeloutput}
\end{chapelexample}



\section{Atomic Variables}
\label{Atomic_Variables}
\index{atomic variables!atomic@\chpl{atomic}}
\index{atomic@\chpl{atomic}}

Atomic variables are variables that support atomic operations. Chapel
currently supports atomic operations for bools, all supported sizes of
signed and unsigned integers, as well as all supported sizes of reals. 

\begin{rationale}
The choice of supported atomic variable types as well as the atomic
operations was strongly influenced by the C11 standard.
\end{rationale}

Atomic is a type qualifier that precedes the variable's type in
the declaration. Atomic operations are supported for bools, and all
sizes of ints, uints, and reals.  

An atomic variable is specified with an atomic type given by the 
following syntax:

\begin{syntax}
atomic-type:
  `atomic' type-specifier
\end{syntax}

\subsection{Predefined Atomic Methods}
\label{Functions_on_Atomic_Variables}
\index{atomic variables!predefined methods on}

The following methods are defined for variables of atomic type. Note
that not all operations are supported for all atomic types. The
supported types are listed for each method.  

\index{atomic types!memory order}
Most of the predefined atomic methods accept an optional argument
named \chpl{order} of type memory\_order. The \chpl{order} argument is
used to specify the ordering constraints of atomic operations. The
supported memory\_order values are:
\begin{itemize}
\item{memory\_order\_relaxed}
\item{memory\_order\_consume}
\item{memory\_order\_acquire}
\item{memory\_order\_release}
\item{memory\_order\_acq\_rel}
\item{memory\_order\_seq\_cst}
\end{itemize}

\begin{openissue}
  The memory\_order values were taken directly from the C11
  specification.  We expect to review and better define the supported
  values with work on Chapel's memory consistency model
  (see~\ref{Memory_Consistency_Model}).
\end{openissue}

Unless specified, the default for the memory\_order parameter is
memory\_order\_seq\_cst.

\begin{note}
Not all architectures or implementations may support all memory\_order
values.  In these cases, the implementation should default to a more
conservative ordering than specified.
\end{note}

\index{read (atomic var)@\chpl{read} (atomic var)}
\index{predefined functions!read (atomic var)@\chpl{read} (atomic var)}
\begin{protohead}
proc (atomic t).read(memory_order order): t
\end{protohead}
\begin{protobody}
Reads and returns the stored value. Defined for all atomic types.  
\end{protobody}

\index{peek (atomic var)@\chpl{peek} (atomic var)}
\index{predefined functions!peek (atomic var)@\chpl{peek} (atomic var)}
\begin{protohead}
proc (atomic t).peek(): t
\end{protohead}
\begin{protobody}
Reads and returns the stored value using memory\_order\_relaxed.
Defined for all atomic types.
\end{protobody}

\index{write (atomic var)@\chpl{write} (atomic var)}
\index{predefined functions!write (atomic var)@\chpl{write} (atomic var)}
\begin{protohead}
proc (atomic t).write(v: t, memory_order order)
\end{protohead}
\begin{protobody}
Stores \chpl{v} as the new value. Defined for all atomic types.  
\end{protobody}

\index{poke (atomic var)@\chpl{poke} (atomic var)}
\index{predefined functions!poke (atomic var)@\chpl{poke} (atomic var)}
\begin{protohead}
proc (atomic t).poke(v: t)
\end{protohead}
\begin{protobody}
Stores \chpl{v} as the new value using memory\_order\_relaxed.
Defined for all atomic types.
\end{protobody}

\index{exchange (atomic var)@\chpl{exchange} (atomic var)}
\index{predefined functions!exchange (atomic var)@\chpl{exchange} (atomic var)}
\begin{protohead}
proc (atomic t).exchange(v: t, memory_order order): t
\end{protohead}
\begin{protobody}
Stores \chpl{v} as the new value and returns the original
value. Defined for all atomic types. 
\end{protobody}

\index{compareExchangWeak (atomic var)@\chpl{compareExchangeWeak} (atomic var)}
\index{predefined functions!compareExchangeWeak (atomic var)@\chpl{compareExchangeWeak} (atomic var)}
\index{compareExchangStrong (atomic var)@\chpl{compareExchangeStrong} (atomic var)}
\index{predefined functions!compareExchangeStrong (atomic var)@\chpl{compareExchangeStrong} (atomic var)}
\index{compareExchange (atomic var)@\chpl{compareExchange} (atomic var)}
\index{predefined functions!compareExchange (atomic var)@\chpl{compareExchange} (atomic var)}
\begin{protohead}
proc (atomic t).compareExchangeWeak(e: t, v: t, memory_order order): bool
proc (atomic t).compareExchangeStrong(e: t, v: t, memory_order order): bool
proc (atomic t).compareExchange(e: t, v: t, memory_order order): bool
\end{protohead}
\begin{protobody}
Stores \chpl{v} as the new value, if and only if the original value is
equal to \chpl{e}. Returns \chpl{true} if \chpl{v} was
stored, \chpl{false} otherwise. The 'weak' variation may
return \chpl{false} even if the original value was equal to \chpl{e},
if, for example, the value could not be updated
atomically. \chpl{compareExchange} is equivalent to
\chpl{compareExchangeStrong}.  Defined for all atomic types.
\end{protobody}

\index{add (atomic var)@\chpl{add} (atomic var)}
\index{predefined functions!add (atomic var)@\chpl{add} (atomic var)}
\index{sub (atomic var)@\chpl{sub} (atomic var)}
\index{predefined functions!sub (atomic var)@\chpl{sub} (atomic var)}
\index{or (atomic var)@\chpl{or} (atomic var)}
\index{predefined functions!or (atomic var)@\chpl{or} (atomic var)}
\index{and (atomic var)@\chpl{and} (atomic var)}
\index{predefined functions!and (atomic var)@\chpl{and} (atomic var)}
\index{xor (atomic var)@\chpl{xor} (atomic var)}
\index{predefined functions!xor (atomic var)@\chpl{xor} (atomic var)}
\begin{protohead}
proc (atomic t).add(v: t, memory_order order)
proc (atomic t).sub(v: t, memory_order order)
proc (atomic t).or(v: t, memory_order order)
proc (atomic t).and(v: t, memory_order order)
proc (atomic t).xor(v: t, memory_order order)
\end{protohead}
\begin{protobody}
Applies the appropriate operator (\verb@+@, \verb@-@, \verb@|@,
\verb@&@, \verb@^@) to the original value and \chpl{v} and stores the result.
All of the methods are defined for integral atomic types. Only add and
sub (\verb@+@, \verb@-@) are defined for \chpl{real} atomic types.
None of the methods are defined for the \chpl{bool} atomic type.
\end{protobody}

\begin{future}
In the future we may overload certain operations such as \verb@+=@ to
call the above methods automatically for atomic variables.
\end{future}

\index{fetchAdd (atomic var)@\chpl{fetchAdd} (atomic var)}
\index{predefined functions!fetchAdd (atomic var)@\chpl{fetchAdd} (atomic var)}
\index{fetchSub (atomic var)@\chpl{fetchSub} (atomic var)}
\index{predefined functions!fetchSub (atomic var)@\chpl{fetchSub} (atomic var)}
\index{fetchOr (atomic var)@\chpl{fetchOr} (atomic var)}
\index{predefined functions!fetchOr (atomic var)@\chpl{fetchOr} (atomic var)}
\index{fetchAnd (atomic var)@\chpl{fetchAnd} (atomic var)}
\index{predefined functions!fetchAnd (atomic var)@\chpl{fetchAnd} (atomic var)}
\index{fetchXor (atomic var)@\chpl{fetchXor} (atomic var)}
\index{predefined functions!fetchXor (atomic var)@\chpl{fetchXor} (atomic var)}
\begin{protohead}
proc (atomic t).fetchAdd(v: t, memory_order order): t
proc (atomic t).fetchSub(v: t, memory_order order): t
proc (atomic t).fetchOr(v: t, memory_order order): t
proc (atomic t).fetchAnd(v: t, memory_order order): t
proc (atomic t).fetchXor(v: t, memory_order order): t
\end{protohead}
\begin{protobody}
Applies the appropriate operator (\verb@+@, \verb@-@, \verb@|@,
\verb@&@, \verb@^@) to the original value and \chpl{v}, stores the result, and
returns the original value. All of the methods are defined for
integral atomic types. Only add and sub (\verb@+@, \verb@-@) are
defined for \chpl{real} atomic types.  None of the methods are defined
for the \chpl{bool} atomic type.
\end{protobody}


\index{testAndSet (atomic bool)@\chpl{testAndSet} (atomic bool)}
\index{predefined functions!testAndSet (atomic bool)@\chpl{testAndSet}
(atomic bool)}
\begin{protohead}
proc (atomic bool).testAndSet(memory_order order): bool
\end{protohead}
\begin{protobody}
Stores \chpl{true} as the new value and returns the old
value. Equivalent to \chpl{exchange(true)}. Only defined for
the \chpl{bool} atomic type.
\end{protobody}

\index{clear (atomic bool)@\chpl{clear} (atomic bool)}
\index{predefined functions!clear (atomic bool)@\chpl{clear} (atomic bool)}
\begin{protohead}
proc (atomic bool).clear(memory_order order)
\end{protohead}
\begin{protobody}
Stores \chpl{false} as the new value. Equivalent
to \chpl{write(false)}. Only defined for the \chpl{bool} atomic type.
\end{protobody}

\index{waitFor (atomic var)@\chpl{waitFor} (atomic var)}
\index{predefined functions!waitFor (atomic var)@\chpl{waitFor} (atomic var)}
\begin{protohead}
proc (atomic t).waitFor(v: t)
\end{protohead}
\begin{protobody}
Waits until the stored value is equal to \chpl{v}. The implementation
may yield the running task while waiting.  Defined for all atomic types.
\end{protobody}



\section{The Cobegin Statement}
\label{Cobegin}
\index{cobegin@\chpl{cobegin}}
\index{statements!cobegin@\chpl{cobegin}}

The cobegin statement is used to introduce concurrency within a
block.  The \chpl{cobegin} statement syntax is
\begin{syntax}
cobegin-statement:
  `cobegin' task-intent-clause[OPT] block-statement
\end{syntax}

A new task and a corresponding task function are created for each statement
in the \sntx{block-statement}.  Control
continues when all of the tasks have finished.
The handling of the outer variables within each task function and
the role of \sntx{task-intent-clause} are defined in \rsec{Task_Intents}.

Return statements are not allowed in cobegin blocks.  Yield statement
may only be lexically enclosed in cobegin blocks in parallel
iterators~(\rsec{Parallel_Iterators}).  Break and continue statements
may not be used to exit a cobegin block.


\begin{chapelexample}{cobeginAndEquivalent.chpl}
The cobegin statement
\begin{chapelpre}
var s1, s2: sync int;
proc stmt1() { s1; }
proc stmt2() { s2; s1 = 1; }
proc stmt3() { s2 = 1; }
\end{chapelpre}
\begin{chapel}
cobegin {
  stmt1();
  stmt2();
  stmt3();
}
\end{chapel}
is equivalent to the following code that uses only begin statements
and single variables to introduce concurrency and synchronize:
\begin{chapel}
var s1(*\texttt{\$}*), s2(*\texttt{\$}*), s3(*\texttt{\$}*): single bool;
begin { stmt1(); s1(*\texttt{\$}*) = true; }
begin { stmt2(); s2(*\texttt{\$}*) = true; }
begin { stmt3(); s3(*\texttt{\$}*) = true; }
s1(*\texttt{\$}*); s2(*\texttt{\$}*); s3(*\texttt{\$}*);
\end{chapel}
\begin{chapeloutput}
\end{chapeloutput}
Each begin statement is executed concurrently but control does not
continue past the final line above until each of the single variables
is written, thereby ensuring that each of the functions has finished.
\end{chapelexample}

\section{The Coforall Loop}
\label{Coforall}
\index{coforall@\chpl{coforall}}
\index{statements!coforall@\chpl{coforall}}

The coforall loop is a variant of the cobegin statement in loop form.
The syntax for the coforall loop is given by
\begin{syntax}
coforall-statement:
  `coforall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' statement
  `coforall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] block-statement
  `coforall' iteratable-expression task-intent-clause[OPT] `do' statement
  `coforall' iteratable-expression task-intent-clause[OPT] block-statement
\end{syntax}

The \chpl{coforall} loop creates a separate task for each iteration of
the loop.  Control continues with the statement following
the \chpl{coforall} loop after all tasks corresponding to the
iterations of the loop have completed.

The single task function created for a \chpl{coforall} and invoked by
each task contains the loop body.
The handling of the outer variables within the task function and
the role of \sntx{task-intent-clause} are defined in \rsec{Task_Intents}.

Return statements are not allowed in coforall blocks.  Yield statement
may only be lexically enclosed in coforall blocks in parallel
iterators~(\rsec{Parallel_Iterators}).  Break and continue statements
may not be used to exit a coforall block.

\begin{chapelexample}{coforallAndEquivalent.chpl}
The coforall statement
\begin{chapelpre}
iter iterator() { for i in 1..3 do yield i; }
proc body() { }
\end{chapelpre}
\begin{chapel}
coforall i in iterator() {
  body();
}
\end{chapel}
is equivalent to the following code that uses only begin statements
and sync and single variables to introduce concurrency and
synchronize:
\begin{chapel}
var runningCount(*\texttt{\$}*): sync int = 1;
var finished(*\texttt{\$}*): single bool;
for i in iterator() {
  runningCount(*\texttt{\$}*) += 1;
  begin {
    body();
    var tmp = runningCount(*\texttt{\$}*);
    runningCount(*\texttt{\$}*) = tmp-1;
    if tmp == 1 then finished(*\texttt{\$}*) = true;
  }
}
var tmp = runningCount(*\texttt{\$}*);
runningCount(*\texttt{\$}*) = tmp-1;
if tmp == 1 then finished(*\texttt{\$}*) = true;
finished(*\texttt{\$}*);
\end{chapel}
\begin{chapeloutput}
\end{chapeloutput}
Each call to \chpl{body()} executes concurrently because it is in a
begin statement.  The sync
variable \chpl{runningCount$\mbox{\texttt{\$}}$} is used to keep track
of the number of executing tasks plus one for the main task.  When
this variable reaches zero, the single
variable \chpl{finished$\mbox{\texttt{\$}}$} is used to signal that
all of the tasks have completed.  Thus control does not continue past
the last line until all of the tasks have completed.
\end{chapelexample}


\section{Task Intents}
\label{Task_Intents}
\index{task intents}
\index{task parallelism!task functions}
\index{task parallelism!task intents}

% Would be nice to give this arrangement a name. Could say
% "the task intent rule", although that sounds a bit like
% a colloquialism.
If a variable is referenced within the lexical scope of a
\chpl{begin}, \chpl{cobegin}, or \chpl{coforall} statement
and is declared outside that statement, it is considered
to be passed as an actual argument to the corresponding task function 
at task creation time. All references to the variable
within the task function implicitly refer to the task function's
corresponding formal argument.

Each formal argument of a task function has the blank intent by default.
For variables of primitive and class types, this has the effect
of capturing the value of the variable at task creation time
and referencing that value instead of the original variable
within the lexical scope of the task construct.

A formal can be given another intent explicitly by listing it
with that intent in the optional \sntx{task-intent-clause}.
For example, for variables of most types, the \chpl{ref} intent allows
the task construct to modify the corresponding original variable
or to read its updated value after concurrent modifications.

The syntax of the task intent clause is:

\begin{syntax}
task-intent-clause:
  `with' ( task-intent-list )

task-intent-list:
  formal-intent identifier
  formal-intent identifier, task-intent-list
\end{syntax}

The implicit treatment of outer scope variables as the task function's
formal arguments applies to both module level and local variables.
It applies to variable references within the lexical scope
of a task construct, but does not extend to its dynamic scope, i.e.,
to the functions called from the task(s) but declared outside of
the lexical scope.
The loop index variables of a \chpl{coforall} statement are not
subject to such treatment within that statement; however, they are
subject to such treatment within nested task constructs, if any.


\begin{rationale}
% Ideally, replace "task intents" throughout the foregoing
% with a more appropriate name for this feature.
The primary motivation for task intents is to avoid some races on
scalar/record variables, which are possible when one task modifies a
variable and another task reads it. Without task intents,
for example, it would be easy to introduce and overlook a bug
illustrated by this simplified example:

  \begin{chapel}
  {
    var i = 0;
    while i < 10 {
      begin {
        f(i);
      }
      i += 1;
    }
  }
  \end{chapel}

If all the tasks created by the \chpl{begin} statement start executing
only after the \chpl{while} loop completes, and \chpl{i} within the
\chpl{begin} is treated as a reference to the original \chpl{i},
there will be ten tasks executing \chpl{f(10)}. However, the user most
likely intended to generate ten tasks executing
\chpl{f(0)}, \chpl{f(1)}, ..., \chpl{f(9)}.
Task intents ensure that, regardless of the timing of task execution.

Another motivation for task intents is that referring to a captured
copy in a task is often more efficient than referring to the original
variable. That's because the copy is a local constant, e.g. it could
be placed in a register when it fits.  Without task intents,
references to the original variable would need to be implemented using
a pointer dereference. This is less efficient and can hinder optimizations
in the surrounding code, for example loop-invariant code motion.

Furthermore, in the above example the scope where \chpl{i} is declared
may exit before all the ten tasks complete.  Without task intents,
the implementation needs to ensure that \chpl{i} can still be
referenced by the tasks after its scope ends.

We decided to treat \chpl{cobegin} and \chpl{coforall} statements the
same way as \chpl{begin}. This is for consistency and to make the
race-avoidance benefit available to more code.

We decided to apply task intents to module level variables, in addition
to local variables. Again, this is for consistency. One could view module
level variables differently than local variables (e.g. a module level 
variable is ``always available''), but we favored consistency over such
an approach.

We decided not to apply task intents to ``closure'' variables, i.e.,
the variables in the dynamic scope of a task construct. This is to
keep this feature manageable, so that all variables subject to task
intents can be obtained by examining just the lexical scope of the
task construct. In general, the set of closure variables can be hard
to determine, unweildy to implement and reason about, it is unclear
what to do with extern functions, etc.
\end{rationale}


\begin{future}
For a given intent, we would also like to provide a blanket clause,
which would apply the intent to all variables.
An example of syntax for a blanket \chpl{ref} intent would be \chpl{ref *}.
\end{future}

\begin{future}
We may want to disallow some intents because they do not make sense
in this context. For example, an \chpl{inout} or \chpl{out} intent
will necessarily create a data race in a \chpl{cobegin} or \chpl{coforall}.
Also, \chpl{type} and \chpl{param} intents do not seem useful.
\end{future}

\begin{craychapel}
At present, only the \chpl{ref} task intent is implemented.
\end{craychapel}


\section{The Sync Statement}
\label{Sync_Statement}
\index{sync@\chpl{sync}}
\index{statements!sync@\chpl{sync}}

The sync statement acts as a join of all dynamically encountered
begins from within a statement.  The syntax for the sync statement is
given by
\begin{syntax}
sync-statement:
  `sync' statement
  `sync' block-statement
\end{syntax}

Return statements are not allowed in sync statement blocks.  Yield
statement may only be lexically enclosed in sync statement blocks in
parallel iterators~(\rsec{Parallel_Iterators}).  Break and continue
statements may not be used to exit a sync statement block.

\begin{chapelexample}{syncStmt1.chpl}
The sync statement can be used to wait for many dynamically created
tasks.
\begin{chapelpre}
config const n = 9;
proc work() {
  write(".");
}
\end{chapelpre}
\begin{chapel}
sync for i in 1..n do begin work();
\end{chapel}
\begin{chapelpost}
writeln("done");
\end{chapelpost}
\begin{chapeloutput}
.........done
\end{chapeloutput}
The for loop is within a sync statement and thus the tasks created
in each iteration of the loop must complete before the continuing past
the sync statement.
\end{chapelexample}

\begin{chapelexample}{syncStmt2.chpl}
The sync statement
\begin{chapelpre}
proc stmt1() { }
proc stmt2() { }
\end{chapelpre}
\begin{chapel}
sync {
  begin stmt1();
  begin stmt2();
}
\end{chapel}
is similar to the following cobegin statement
\begin{chapel}
cobegin {
  stmt1();
  stmt2();
}
\end{chapel}
\begin{chapeloutput}
\end{chapeloutput}
except that if begin statements are dynamically encountered
when \chpl{stmt1()} or \chpl{stmt2()} are executed, then the former
code will wait for these begin statements to complete whereas the
latter code will not.
\end{chapelexample}

\section{The Serial Statement}
\label{Serial}
\index{serial@\chpl{serial}}
\index{statements!serial@\chpl{serial}}

The \chpl{serial} statement can be used to dynamically disable
parallelism.  The syntax is:
\begin{syntax}
serial-statement:
  `serial' expression[OPT] `do' statement
  `serial' expression[OPT] block-statement
\end{syntax}
where the optional \sntx{expression} evaluates to a boolean value.  If
the expression is omitted, it is as though 'true' were specified.
Whatever the expression's value, the statement following it is
evaluated. If the expression is true, any dynamically encountered code
that would normally create new tasks within the statement is instead
executed by the original task without creating any new ones.  In
effect, execution is serialized.  If the expression is false, code
within the statement will generates task according to normal Chapel
rules.

\begin{chapelexample}{serialStmt1.chpl}
In the code
\begin{chapelpre}
config const lo = 9;
config const hi = 23;
proc work(i) {
  if \_\_primitive("task\_get\_serial") then
    writeln("serial ", i);
}
\end{chapelpre}
\begin{chapel}
proc f(i) {
  serial i<13 {
    cobegin {
      work(i);
      work(i);
    }
  }
}

for i in lo..hi {
  f(i);
}
\end{chapel}
\begin{chapelpost}
\end{chapelpost}
\begin{chapeloutput}
serial 9
serial 9
serial 10
serial 10
serial 11
serial 11
serial 12
serial 12
\end{chapeloutput}
the serial statement in procedure f() inhibits concurrent execution of
work() if the variable i is less than 13.
\end{chapelexample}

\begin{chapelexample}{serialStmt2.chpl}
The code
\begin{chapelpre}
proc stmt1() { write(1); }
proc stmt2() { write(2); }
proc stmt3() { write(3); }
proc stmt4() { write(4); }
var n = 3;
\end{chapelpre}
\begin{chapel}
serial {
  begin stmt1();
  cobegin {
    stmt2();
    stmt3();
  }
  coforall i in 1..n do stmt4();
}
\end{chapel}
is equivalent to
\begin{chapel}
stmt1();
{
  stmt2();
  stmt3();
}
for i in 1..n do stmt4();
\end{chapel}
\begin{chapelpost}
writeln();
\end{chapelpost}
\begin{chapeloutput}
123444123444
\end{chapeloutput}
because the expression evaluated to determine whether to serialize
always evaluates to true.
\end{chapelexample}

\section{Atomic Statements}
\label{Atomic_Statement}
\index{atomic transactions}
\index{atomic statement}
\index{atomic@\chpl{atomic}}
\index{statements!atomic@\chpl{atomic}}

\begin{openissue}
  This section describes a feature that is a work-in-progress.  We seek feedback
  and collaboration in this area from the broader community.
\end{openissue}

The \emph{atomic statement} is used to specify that a statement should appear
to execute atomically from other tasks' point of view.
In particular, no task will see memory in a state that would reflect that
the atomic statement had begun executing but had not yet completed.

\begin{openissue}
  This definition of the atomic statement provides a notion of {\em
    strong atomicity} since the action will appear atomic to any task
  at any point in its execution.  For performance reasons, it could be
  more practical to support {\em weak atomicity} in which the
  statement's atomicity is only guaranteed with respect to other
  atomic statements.  We may also pursue using atomic type qualifiers
  as a means of marking data that should be accessed atomically inside
  or outside an atomic section.
\end{openissue}

The syntax for the atomic statement is given by:
\begin{syntax}
atomic-statement:
  `atomic' statement
\end{syntax}

%\begin{chapelexample}{atomicStmt}
\begin{example}
The following code illustrates the use of an atomic statement
to perform an insertion into a doubly-linked list:

\begin{chapelpre}
class Node {
  var data: int;
  var next: Node;
  var prev: Node;
}
var head = new Node(1);
head.insertAfter(new Node(4));
head.insertAfter(new Node(2));

var obj = new Node(3);
head.next.insertAfter(obj);
\end{chapelpre}
\begin{chapel}
proc Node.insertAfter(newNode: Node) {
  atomic {
    newNode.prev = this;
    newNode.next = this.next;
    if this.next then this.next.prev = newNode;
    this.next = newNode;
  }
}
\end{chapel}
\begin{chapelpost}
writeln(head.data, head.next.data, head.next.next.data, head.next.next.next.data);
proc Node.remove() {
  if this.prev then this.prev = this.next;
  if this.next then this.next = this.prev;
  return this;
}
while (head) {
  next = head.next;
  delete head;
  head = next;
} 
\end{chapelpost}
\begin{chapeloutput}
atomic.chpl:13: warning: atomic keyword is ignored (not implemented)
1234
\end{chapeloutput}
The use of the atomic statement in this routine prevents other tasks
from viewing the list in a partially-updated state in which the
pointers might not be self-consistent.
\end{example}
%\end{chapelexample}
