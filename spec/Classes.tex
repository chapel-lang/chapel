\sekshun{Classes}
\label{Classes}
\index{classes}

\index{classes!instances}
\index{objects}

Classes are data structures with associated state and functions.  A
variable of class type either refers to a class instance, or contains a
special \chpl{nil} value. Note that \emph{object} is another name for a
class instance.  Storage for a class instance is not necessarily tied to
the scope of the variable(s) referring to that class instance. It is
possible for multiple variables to refer to the same class instance.

The \sntx{new-expression} can be used to create an instance of a class
(\rsec{Class_New}). Depending on the memory management strategy, a class
instance is either deleted automatically or can be deleted using the
\sntx{delete-statement} (\rsec{Class_Delete}).

A class declaration (\rsec{Class_Declarations}) generates a class
type (\rsec{Class_Types}).  A variable of a class type can refer to an
instance of that class or any of its derived classes.

A class is generic if it has generic fields. A class can also
be generic if it inherits from a generic class. Generic classes and fields
are discussed in~\rsec{Generic_Types}.

\section{Class Declarations}
\label{Class_Declarations}
\index{classes!declarations}
\index{class@\chpl{class}}

A class is defined with the following syntax:
\begin{syntax}
class-declaration-statement:
  simple-class-declaration-statement

simple-class-declaration-statement:
  `class' identifier class-inherit[OPT] { class-statement-list[OPT] }

class-inherit:
  : basic-class-type

class-statement-list:
  class-statement
  class-statement class-statement-list

class-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
\end{syntax}

A \sntx{class-declaration-statement} defines a new type symbol
specified by the identifier.  Classes inherit data and functionality
from other classes %and/or records
if the \sntx{inherit-type-list} is specified.
Inheritance is described in~\rsec{Inheritance}.

The body of a class declaration consists of a sequence of statements
where each of the statements either defines a variable (called a
field), a procedure or iterator (called a method), or a type alias.  In addition, empty
statements are allowed in class declarations, and they have no effect.

If a class declaration contains a type alias or a parameter field, or it contains a variable or
constant without a specified type and without an initialization
expression, then it declares a generic class type.  Generic classes are described
in~\rsec{Generic_Types}.

\begin{future}
Privacy controls for classes and records are currently not specified,
as discussion is needed regarding its impact on inheritance, for
instance.
\end{future}

\subsection{Class Lifetime and Borrows}
\label{Class_Lifetime_and_Borrows}
\index{classes!lifetime}
\index{classes!borrows}
\index{class lifetime}
\index{borrow}

The lifetime of a class instance is the time between its creation and its
deletion. It is legal to access the class fields or methods only during
its lifetime.

Each allocation of a class instance specifies a \emph{memory management
strategy} . Four memory management strategies are available:
\chpl{owned}, \chpl{shared}, \chpl{borrowed}, and \chpl{unmanaged}.

\chpl{owned} and \chpl{shared} class instances always have their lifetime
managed by the compiler. In other words, the compiler automatically
calls \chpl{delete} on these instances to reclaim their memory. For these
instances, \chpl{=} and copy initialization can result in the transfer or
sharing of ownership. See
\\ %formatting
\mbox{$$ $$ $$ $$ $$} %indent
\url{https://chapel-lang.org/docs/builtins/OwnedObject.html}
\\
and
\\ %formatting
\mbox{$$ $$ $$ $$ $$} %indent
\url{https://chapel-lang.org/docs/builtins/SharedObject.html}
\\

When \chpl{borrowed} is used as a memory management strategy in a
\sntx{new-expression}, it also creates an instance that has its lifetime
managed by the compiler (\rsec{Class_New}).

Class instances that are \chpl{unmanaged} have their lifetime managed
explicitly and \chpl{delete} must be used to reclaim their memory.

No matter the memory management strategy used, class types support
\emph{borrowing}.
A \chpl{borrowed} class instance refers to the same class instance as
another variable but has no impact on the lifetime of that instance. The
process of getting such a reference to an instance is called
\emph{borrowing}.

There are several ways to borrow an instance. To borrow explicitly the
instance managed by another variable, call the \chpl{.borrow()} method.
Additionally, coercions are available that are equivalent to calling the
\chpl{.borrow()} method.  For example:

\begin{chapelexample}{borrowing.chpl}
\begin{chapel}
class C { }
proc test() {
  var own = new owned C();   // 'own' manages the memory of the instance
  var b = own.borrow();      // 'b' refers to the same instance but has no
                             // impact on the lifetime.

  var bc: borrowed C = own;  // 'bc' stores the result of own.borrow()
                             // due to coercion from owned C to C

  var c: C = own;            // same as above
                             // since 'C' is equivalent to 'borrowed C'

                             // Note that these coercions can also apply
                             // in the context of procedure calls.

                             // the instance referred to by 'own' is
                             // deleted here, at the end of the containing
                             // block.
}
\end{chapel}
\begin{chapelpost}
test();
\end{chapelpost}
\begin{chapeloutput}
\end{chapeloutput}
\end{chapelexample}

The \chpl{.borrow()} method is available on all class types (including
\chpl{unmanaged} and \chpl{borrowed}) in order to support generic
programming.

Errors due to accessing an instance after the end of its lifetime are
particularly difficult to debug. For this reason, the compiler includes a
component called the lifetime checker. It identifies some cases where a
borrowing variable can be accessed beyond the lifetime of an instance it
refers to.

\begin{future}
  The details of lifetime checking are not yet finalized or specified.
  Additional syntax to specify the lifetimes of function returns will
  probably be needed.
\end{future}

\subsection{Class Types}
\label{Class_Types}
\index{classes!types}
\index{class type}

A class type is formed by the combination of a basic class type and a
memory management strategy.

\begin{syntax}
class-type:
  basic-class-type
  `owned' basic-class-type
  `shared' basic-class-type
  `borrowed' basic-class-type
  `unmanaged' basic-class-type
\end{syntax}

A basic class type is given simply by the class name for non-generic classes.
Generic classes must be instantiated to serve as a fully-specified
type, for example to declare a variable.  This is done with
type constructors, which are defined in Section~\ref{Type_Constructors}.

\begin{syntax}
basic-class-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}

A basic class type, including a generic class type that is not
fully specified, may appear in the inheritance lists
of other class declarations.

If no memory management strategy is indicated, \chpl{borrowed} will be
used.

\begin{rationale}
  \chpl{borrowed} is the default memory management strategy for a class
  type because there are likely to be more variables referring to a class
  instance than managing its memory. A further advantage of this default
  is that \chpl{borrowed}, along with \chpl{unmanaged}, has minimal
  performance overhead.
\end{rationale}

The memory management strategies have the following meaning:

\begin{itemize}
  \item \chpl{owned} the instance will be deleted
    automatically when the \chpl{owned} variable goes out of scope, but
    only one \chpl{owned} variable can refer to the instance at a time.
    See
    \\ %formatting
    \mbox{$$ $$ $$ $$ $$} %indent
    \url{https://chapel-lang.org/docs/builtins/OwnedObject.html}

  \item \chpl{shared} will be deleted when all of the \chpl{shared}
    variables referring to the instance go out of scope.
    See
    \\ %formatting
    \mbox{$$ $$ $$ $$ $$} %indent
    \url{https://chapel-lang.org/docs/builtins/SharedObject.html}.

  \item \chpl{borrowed} refers to a class instance that has a lifetime
    managed by another variable.

  \item \chpl{unmanaged} the instance must have \chpl{delete} called on
    it explicitly to reclaim its memory.

\end{itemize}


\subsection{Class Values}
\label{Class_Values}
\index{classes!values}
\index{class value}

A class value is either a reference to an instance of a class
or \chpl{nil} (\rsec{Class_nil_value}). Class instances can be created
using a \chpl{new} expression (\rsec{Class_New}).

For a given class type, a legal value of that type is a reference to
an instance of either that class or a class inheriting, directly or
indirectly, from that class.
\chpl{nil} is a legal value of any class type.

The default value of a class type is \chpl{nil}.

\begin{chapelexample}{declaration.chpl}
\begin{chapel}
class C { }
var c : owned C?;    // c has class type owned C?, meaning
                     // the instance can be nil and is deleted automatically.
c = new C();         // Now c refers to an initialized instance of type C.
var c2 = c.borrow(); // The type of c2 is borrowed C.
                     // c2 refers to the same object as c.
class D : C {}    // Class D is derived from C.
c = new D();      // Now c refers to an object of type D.
                  // Since c is owned, the previous is deleted.
// the C and D instances allocated above will be reclaimed
// at the end of this block.
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
\end{chapeloutput}
When the variable \chpl{c} is declared, it initially has the value
of \chpl{nil}.  The next statement assigned to it an instance of the
class \chpl{C}.  The declaration of variable \chpl{c2} shows that these steps can
be combined.  The type of \chpl{c2} is also \chpl{C}, determined implicitly from
the the initialization expression.  Finally, an object of type \chpl{D} is created and
assigned to \chpl{c}.
\end{chapelexample}

\subsection{Class Fields}
\label{Class_Fields}
\index{classes!fields}
\index{fields!class}

A variable declaration within a class declaration defines
a \emph{field} within that class.
Each class instance consists of one variable per each
\chpl{var} or \chpl{const} field in the class.

\begin{chapelexample}{defineActor.chpl}
The code
\begin{chapelpre}
config param cleanUp = false;
\end{chapelpre}
\begin{chapel}
class Actor {
  var name: string;
  var age: uint;
}
\end{chapel}
\begin{chapeloutput}
\end{chapeloutput}
defines a new class type called \chpl{Actor} that has two fields: the
string field \chpl{name} and the unsigned integer field \chpl{age}.
\end{chapelexample}

Field access is described in \rsec{Class_Field_Accesses}.

\begin{future}
\chpl{ref} fields, which are fields corresponding to variable declarations
with \chpl{ref} or \chpl{const ref} keywords, are an area of future work.
\end{future}

\subsection{Class Methods}
\label{Class_Methods}
\index{classes!methods}
\index{methods!classes}
\index{methods!primary}
\index{methods!secondary}
\index{primary methods}
\index{secondary methods}

Methods on classes are referred to as to as \emph{class methods}.
See the methods section~\rsec{Methods}.

\subsection{Nested Classes}
\label{Nested_Classes}
\index{classes!nested classes}
\index{nested classes}

A class defined within another class or record is a nested class. A nested
class can be referenced only within its immediately enclosing class or record.

\section{Inheritance}
\label{Inheritance}
\index{inheritance}
\index{classes!inheritance}
\index{derived class}
\index{classes!derived}

A \emph{derived} class can inherit from one or more other classes by
listing those classes in the derived class declaration.

%When inheriting from multiple base classes, only one of the base classes
%may contain fields.  The other classes can only define methods.  Note
%that a class can still be derived from a class that contains fields
%which is itself derived from a class that contains fields.

%REVIEW: vass: the below ("tree") does not match the above ("multiple base classes")

%These restrictions on inheritance induce a class hierarchy which has the form of
%a tree.  A variable referring to an instance of class \chpl{C} can be
%cast to any type that is an ancestor of \chpl{C}.  Note that casts to more- and
%less-derived classes are both permitted.

It is possible for a class to inherit from a generic class. Suppose for
example that a class \chpl{C} inherits from class \chpl{ParentC}. In this
situation, \chpl{C} will have type constructor arguments based upon
generic fields in the \chpl{ParentC} as described in
~\ref{Type_Constructors}. Furthermore, a fully specified \chpl{C} will be
a subclass of a corresponding fully specified \chpl{ParentC}.

\begin{future}
Multiple inheritance is not currently specified or implemented.
It is unclear if it will ever be included in the language.
\end{future}

\subsection{The object Class}
\label{The_object_Class}
\index{object@\chpl{object}}
\index{classes!object@\chpl{object}}

All classes are derived from the \chpl{object} class, either directly or
indirectly.  If no class name appears in the inheritance list, the class derives
implicitly from \chpl{object}.  Otherwise, a class derives from \chpl{object}
indirectly through the class it inherits.  A variable of type \chpl{object}
can hold a reference to an object of any class type.

\subsection{Accessing Base Class Fields}
\label{Accessing_Base_Class_Fields}
\index{classes!base!field access}
\index{classes!field access!base class}

A derived class contains data associated with the fields in its base
classes.  The fields can be accessed in the same way that they are
accessed in their base class unless a getter method is
overridden in the derived class, as discussed
in~\rsec{Overriding_Base_Class_Methods}.

\subsection{Shadowing Base Class Fields}
\label{Shadowing_Base_Class_Fields}
\index{shadowing!base class fields}
A field in the derived class can be declared with the same name as a
field in the base class.  Such a field shadows the field in the base
class in that it is always referenced when it is accessed in the
context of the derived class.

\begin{openissue}
There is an expectation that there will
be a way to reference the field in the base class but this is not
defined at this time.
\end{openissue}

\subsection{Overriding Base Class Methods}
\label{Overriding_Base_Class_Methods}
\index{dynamic dispatch}
\index{methods!base class!overriding}

If a method in a derived class is declared with a signature identical to
that of a method in a base class, then it is said to override the base
class's method. Such methods are considered for dynamic dispatch.  In
particular, dynamic dispatch will be used when the method receiver has a
static type of the base class but refers to an instance of a derived
class type.

In order to have identical signatures, two methods must have the same the
names, intents, types, and order of formal arguments. The return type of
the overriding method must either be the same as the return type of the base
class's method or be a subclass of the base class method's return
type.

Methods that override a base class method must be marked with the
\chpl{override} keyword in the \sntx{procedure-kind}. Additionally,
methods marked with \chpl{override} but for which there is no parent class
method with an identical signature will result in a compiler error.

\begin{rationale}
  This feature is designed to help avoid cases where class authors
  accidentally override a method without knowing it; or fail to override
  a method that they intended to due to not meeting the identical
  signature condition.
\end{rationale}


Methods without parentheses are not candidates for dynamic dispatch.
\begin{rationale}
Methods without parentheses are primarily used for field accessors.
A default is created if none is specified.  The field accessor
should not dispatch dynamically since that would make it
impossible to access a base field within a base method should that
field be shadowed by a subclass.
\end{rationale}

\subsection{The {\em nil} Value}
\label{Class_nil_value}
\index{classes!nil}
\index{nil@\chpl{nil}}

Chapel provides \chpl{nil} to indicate the absence of a reference to
any object.  \chpl{nil} can be assigned to a variable of any class
type.  Invoking a class method or accessing a field of the \chpl{nil}
value results in a run-time error.

\begin{syntax}
nil-expression:
  `nil'
\end{syntax}

\section{Class New}
\label{Class_New}
\index{new!classes}
\index{new@\chpl{new}}
\index{classes!new@\chpl{new}}

To create an instance of a class, use a \chpl{new} expression. For
example:

\begin{chapelexample}{class-new.chpl}
\begin{chapel}
class C {
  var x: int;
}
var instance = new C(1);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\end{chapelexample}

The new expression can be defined by the following syntax:

\begin{syntax}
new-expression:
  `new' type-expression ( argument-list )
\end{syntax}

An initializer for a given class is called by placing the \chpl{new}
operator in front of a type expression. Any initializer arguments follow
the class name in a parenthesized list.

Syntactically, the \sntx{type-expression} includes \chpl{owned},
\chpl{shared}, \chpl{borrowed}, and \chpl{unmanaged}. However these have
important consequences for class new expressions. In particular, suppose
\chpl{C} is a \sntx{type-expression} that results in a class type. Then:

\begin{itemize}

  \item \chpl{new C()} is the same as \chpl{new owned C()}

  \item \chpl{new owned C()} allocates and initializes an instance that
    will be deleted at the end of the current block unless it is
    transferred to another \chpl{owned} variable. It results in something
    of type \chpl{owned C}.

  \item \chpl{new shared C()} allocates and initializes the instance that
    will be deleted when the last \chpl{shared} variable referring to it
    goes out of scope. Results in something of type \chpl{shared C}.

  \item \chpl{new borrowed C()} allocates and initializes an instance
    that will be automatically deleted at the end of the current block.
    This process is managed by an \chpl{owned} temporary.  Unlike
    \chpl{new owned C()}, this results in a value of type \chpl{borrowed
    C} and ownership of the instance cannot be transferred out of the
    block. In other words, \chpl{new borrowed C()} is equivalent to
    \begin{chapel}
      (new owned C()).borrow()
    \end{chapel}

  \item \chpl{new unmanaged C()} allocates and initializes an instance
    that must have \chpl{delete} called on it explicitly to avoid a
    memory leak. It results in something of type \chpl{unmanaged C}.

\end{itemize}

See also \rsec{Class_Lifetime_and_Borrows} and \rsec{Class_Types}.

\section{Class Initializers}
\label{Class_Initializers}
\index{classes!initializers}
\index{initializers}

A \chpl{new} expression allocates memory for the desired class and invokes
an {\em initializer} method on the uninitialized memory, passing any arguments
following the class name. An initializer is implemented by a method named
\chpl{init} and is responsible for initializing the fields of the class.

Any initializers declared in a program are \emph{user-defined} initializers. If
the program declares no initializers for a class, the compiler must generate an
initializer for that class based on the types and initialization expressions of
fields defined by that class.

\subsection{User-Defined Initializers}
\label{User_Defined_Initializers}
\index{classes!initializers!user-defined}
\index{user-defined initializers}
\index{initializers!user-defined}

A user-defined initializer is an initializer method explicitly declared in the
program.  An initializer declaration has the same syntax as a method
declaration, with the restrictions that the name of the method must be
\chpl{init} and there must not be a return type specifier. When an initializer
is called, the usual function resolution mechanism (\rsec{Function_Resolution})
is applied with the exception that an initializer may not be virtually
dispatched.

A user-defined initializer is responsible for initializing all fields. An
initializer may omit initialization of fields, but all fields that are
initialized must be initialized in declaration order.

Initializers for generic classes (\rsec{Generic_Types}) handle generic fields
without default values differently and may need to satisfy additional
requirements.  See Section~\ref{Generic_User_Initializers} for details.

\begin{chapelexample}{simpleInitializers.chpl}
The following example shows a class with two initializers:
\begin{chapel}
class MessagePoint {
  var x, y: real;
  var message: string;

  proc init(x: real, y: real) {
    this.x = x;
    this.y = y;
    this.message = "a point";
  }

  proc init(message: string) {
    this.x = 0;
    this.y = 0;
    this.message = message;
  }
}  // class MessagePoint

// create two objects
var mp1 = new MessagePoint(1.0, 2.0);
var mp2 = new MessagePoint("point mp2");
\end{chapel}
\begin{chapelpost}
writeln(mp1);
writeln(mp2);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 1.0, y = 2.0, message = a point}
{x = 0.0, y = 0.0, message = point mp2}
\end{chapeloutput}
The first initializer lets the user specify the initial coordinates
and the second initializer lets the user specify the initial message
when creating a MessagePoint.
\end{chapelexample}

\subsubsection{Field Initialization Versus Assignment}
\label{Field_Initialization_Versus_Assignment}
\index{classes!initializers!user-defined!init-vs-assign}

Within the body of an initializer, the first use of a field as the left-hand
side of an assignment statement will be considered initialization. Subsequent
uses of the assignment operator on the field will invoke regular assignment as
defined by the language.

\begin{chapelexample}{fieldInitAssignment.chpl}
The following example documents the difference between field initialization
and field assignment.
\begin{chapel}
class PointDoubleX {
  var x, y : real;

  proc init(x: real, y: real) {
    this.x = x;              // initialization
    writeln("x = ", this.x); // use of initialized field
    this.x = this.x * 2;     // assignment, use of initialized field

    this.y = y;              // initialization
  }
}

var p = new PointDoubleX(1.0, 2.0);
\end{chapel}
\begin{chapelpost}
writeln(p);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
x = 1.0
{x = 2.0, y = 2.0}
\end{chapeloutput}
The first statement in the initializer initializes field \chpl{x} to the value
of the formal \chpl{x}. The second statement simply reads the value of the
initialized field. The third statement reads the value of the field, doubles
it, and {\em assigns} the result to the field \chpl{x}.
\end{chapelexample}

If a field is used before it is initialized, an compile-time error will be
issued.

\begin{chapelexample}{usedBeforeInitialized.chpl}
In the following code:
\begin{chapel}
class Point {
  var x, y : real;

  proc init(x: real, y: real) {
    writeln(this.x); // Error: use of uninitialized field!
    this.x = x;
    this.y = y;
    writeln(this.y);
  }
}
var p = new Point(1.0, 2.0);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}

The first statement in the initializer reads the value of uninitialized field
\chpl{x}, so the compiler will issue an error:

\begin{chapelprintoutput}{}
usedBeforeInitialized.chpl:4: In initializer:
usedBeforeInitialized.chpl:5: error: field "x" used before it is initialized
\end{chapelprintoutput}

\end{chapelexample}

\subsubsection{Omitting Field Initializations}
\label{Omitting_Field_Initializations}
\index{classes!initializers!user-defined!omitting}

In order to support productive and elegant initializers, the language allows
field initializations to be omitted if the field has a type or if the field has
an initialization expression. The compiler will insert initialization
statements for such fields based on their types and default values.

\begin{chapelexample}{fieldInitOmitted.chpl}
In the following code:
\begin{chapel}
class LabeledPoint {
  var x : real;
  var y : real;
  var msg : string = 'Unlabeled';

  proc init(x: real, y: real) {
    this.x = x;
    this.y = y;
    // compiler inserts "this.msg = 'Unlabeled'";
  }

  proc init(msg : string) {
    // compiler inserts "this.x = 0.0;"
    // compiler inserts "this.y = 0.0;"
    this.msg = msg;
  }
}

var A = new LabeledPoint(2.0, 3.0);
var B = new LabeledPoint("Origin");
\end{chapel}
\begin{chapelpost}
writeln(A);
writeln(B);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 2.0, y = 3.0, msg = Unlabeled}
{x = 0.0, y = 0.0, msg = Origin}
\end{chapeloutput}
The first initializer initializes the values of fields \chpl{x} and \chpl{y},
and the compiler inserts initialization for the \chpl{msg} field by using
its default value. The second initializer initializes the \chpl{msg} field,
and the compiler inserts initialization for fields \chpl{x} and \chpl{y}
based on the type of those fields (\rsec{Default_Values_For_Types}).
\end{chapelexample}

In order to reduce ambiguity and to ensure a well-defined order for
side-effects, the language requires that all fields be initialized in field
declaration order. This applies regardless of whether field initializations are
omitted from the initializer body. If fields are initialized out of order, a
compile-time error will be issued.

\begin{chapelexample}{fieldsOutOfOrder.chpl}
In the following code:
\begin{chapel}
class Point3D {
  var x = 1.0;
  var y = 1.0;
  var z = 1.0;

  proc init(x: real) {
    this.x = x;
    // compiler inserts "this.y = 1.0;"
    this.z = y * 2.0;
  }

  proc init(x: real, y: real, z: real) {
    this.x = x;
    this.z = z;
    this.y = y; // Error!
  }
}

var A = new Point3D(1.0);
var B = new Point3D(1.0, 2.0, 3.0);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
fieldsOutOfOrder.chpl:12: In initializer:
fieldsOutOfOrder.chpl:15: error: Field "y" initialized out of order
fieldsOutOfOrder.chpl:15: note: initialization of fields before .init() call must be in field declaration order
\end{chapeloutput}

The first initializer leverages the well-defined order of omitted field
initialization to use the default value of field \chpl{y} in order to
explicitly initialize field \chpl{z}.

The second initializer initializes field \chpl{z} before field \chpl{y},
causing a compile-time error to be issued.

\end{chapelexample}

\begin{rationale}
Without this rule the compiler could insert default initialization for field
\chpl{y} before \chpl{z} is explicitly initialized. The following statement
would then be {\em assignment} to field \chpl{y}, despite appearing to be
initialization. This subtle difference may be confusing and surprising, and
is avoided by requiring fields to be initialized in field declaration order.
\end{rationale}

\subsubsection{Limitations on Instance Usage in Initializers}
\label{Limitations_on_Instance_Usage_in_Initializers}
\index{classes!initializers!user-defined!complete}

As the initializer makes progress, the class instance is incrementally
initialized. In order to prevent usage of uninitialized memory, there are
restrictions on usage of the class instance before it is fully initialized:

\begin{itemize}
\item Methods may not be invoked on partially-initialized instances
\item \chpl{this} may not be passed to functions while partially-initialized
\end{itemize}

These rules allow all methods and functions to assume that class instances
have been initialized, provided their value is not \chpl{nil}.

\begin{rationale}
  The compiler could conceivably attempt to analyze methods and functions to
  determine which fields are used, and selectively allow method calls on
  partially-initialized class instances. Instead, it is simpler for the
  language to forbid method calls on partially-initialized instances.
\end{rationale}

Methods may be called and \chpl{this} may be passed to functions only after the
built-in \chpl{complete} method is invoked. This method may not be overridden.
If any fields have not been initialized by the time the \chpl{complete} method
is invoked, they will be considered omitted and the compiler will insert
initialization statements as described earlier. If the user does not invoke the
\chpl{complete} method explicitly, the compiler will insert a call to
\chpl{complete} at the end of the initializer.

\begin{rationale}
Due to support for omitted field initialization, there is potential for
confusion regarding the overall status of initialization. This confusion is
addressed in the design by requiring \chpl{complete} to explicitly mark the
transition between partially and fully initialized instances.
\end{rationale}

\begin{note}
Even if the user explicitly initializes every field, the \chpl{complete} method
is still required to invoke other methods.
\end{note}

\begin{chapelexample}{thisDotComplete.chpl}
In the following code:
\begin{chapel}
class LabeledPoint {
  var x, y : real;
  var max = 10.0;
  var msg : string = 'Unlabeled';

  proc init(x: real, y: real) {
    this.x = x;
    this.y = y;
    // compiler inserts initialization for 'max' and 'msg'

    this.complete(); // 'this' is now considered to be fully initialized

    this.verify();
    writeln(this);
  }

  proc init(msg : string) {
    // compiler inserts initialization for fields 'x', 'y', and 'max'
    this.msg = msg;

    // Illegal: this.verify();
    // Implicit 'this.complete();'
  }

  proc verify() {
    if x > max || y > max then
      halt("LabeledPoint out of bounds!");
  }
}

var A = new LabeledPoint(1.0, 2.0);
var B = new LabeledPoint("Origin");
\end{chapel}
\begin{chapelpost}
writeln(B);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 1.0, y = 2.0, max = 10.0, msg = Unlabeled}
{x = 0.0, y = 0.0, max = 10.0, msg = Origin}
\end{chapeloutput}

The first initializer leverages the \chpl{complete} method to initialize the
remaining fields and to allow for the usage of the \chpl{verify} method.
Calling the \chpl{verify} method or passing \chpl{this} to \chpl{writeln}
before the \chpl{complete} method is called would result in a compile-time
error.

The second initializer exists to emphasize the rule that even though all
fields are initialized after the initialization of the \chpl{msg} field, the
compiler does not consider the type initialized until the \chpl{complete}
method is called. If the second initializer tried to invoke the \chpl{verify}
method, a compile-time error would be issued.
\end{chapelexample}

\subsubsection{Invoking Other Initializers}
\label{Invoking_Other_Initializers}
\index{classes!initializers!user-defined!other-initializers}

In order to allow for code-reuse, an initializer may invoke another initializer
implemented for the same type. Because the invoked initializer must operate on
completely uninitialized memory, a compile-time error will be issued for field
initialization before a call to \chpl{init}. Because each initializer
either explicitly or implicitly invokes the \chpl{complete} method, all fields
and methods may be used after such a call to \chpl{init}.

\begin{chapelexample}{thisDotInit.chpl}
In the following code:
\begin{chapel}
class Point3D {
  var x, y, z : real;

  proc init(x: real, y: real, z: real) {
    this.x = x;
    this.y = y;
    this.z = z;
    // implicit 'this.complete();'
  }

  proc init(u: real) {
    this.init(u, u, u);
    writeln(this);
  }
}

var A = new Point3D(1.0);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 1.0, y = 1.0, z = 1.0}
\end{chapeloutput}
The second initializer leverages the first initializer to initialize all fields
with the same value. After the \chpl{init} call the type is fully initialized,
the \chpl{complete} method has been invoked, and so \chpl{this} can be passed
to the \chpl{writeln} function.
\end{chapelexample}

\subsubsection{Initializing Fields in Conditional Statements}
\label{Initializing_Fields_in_Conditional_Statements}
\index{classes!initializers!user-defined!conditionals}

Fields may be initialized inside of conditional statements, with the
restriction that the same set of fields must be initialized in every branch.
If the user omits any field initializations, the compiler will insert field
initializations up to and including the field furthest in field declaration
order between the conditional branches. If the else branch of a conditional
statement is omitted, the compiler will generate an empty else branch and
insert field initialization statements as needed.

\begin{chapelexample}{initFieldConditional.chpl}
In the following code:
\begin{chapel}
class Point {
  var x, y : real;
  var r, theta : real;

  proc init(polar : bool, val : real) {
    if polar {
      // compiler inserts initialization for fields 'x' and 'y'
      this.r = val;
    } else {
      this.x = val;
      this.y = val;
      // compiler inserts initialization for field 'r'
    }
    // compiler inserts initialization for field 'theta'
  }
}

var A = new Point(true, 5.0);
var B = new Point(false, 1.0);
\end{chapel}
\begin{chapelpost}
writeln(A);
writeln(B);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 0.0, y = 0.0, r = 5.0, theta = 0.0}
{x = 1.0, y = 1.0, r = 0.0, theta = 0.0}
\end{chapeloutput}

The compiler identifies field \chpl{r} as the latest field in both branches,
and inserts omitted field initialization statements as needed to ensure that
fields \chpl{x}, \chpl{y}, and \chpl{r} are all initialized by the end of the
conditional.
\end{chapelexample}

Conditionals may also contain calls to parent initializers
(\rsec{Initializing_Inherited}) and other initializers defined for the current
type, provided that the initialization state is the same at the end of the
conditional statement.

\begin{chapelexample}{thisDotInitConditional.chpl}
In the following code:
\begin{chapel}
class Parent {
  var x, y : real;
}

class Child : Parent {
  var z : real;

  proc init(cond : bool, val : real) {
    if cond {
      super.init(val, val);
      this.z = val;
      this.complete();
    } else {
      this.init(val, val, val);
    }
  }

  proc init(x: real, y: real, z: real) {
    super.init(x, y);
    this.z = z;
  }
}

var c = new Child(true, 5.0);
\end{chapel}
\begin{chapelpost}
writeln(c);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 5.0, y = 5.0, z = 5.0}
\end{chapeloutput}
The first initializer must invoke the \chpl{complete} method at the end of
the if-branch in order to match the state at the end of the else-branch.
\end{chapelexample}

\subsubsection{Miscellaneous Field Initialization Rules}

Fields may not be initialized within loop statements or parallel statements.

\subsection{The Compiler-Generated Initializer}
\label{The_Compiler_Generated_Initializer}
\index{classes!initializers!compiler-generated}
\index{initializers!compiler-generated}
\index{compiler-generated initializers}

A compiler-generated initializer for a class is created automatically if there
are no initializers for that class in the program. The compiler-generated
initializer has one argument for every field in the class, each of which has a
default value equal to the field's default value (if present) or the default
value of the field's type (if not). The order and names of arguments matches
the order and names of field declarations within the class.

Generic fields are discussed in Section~\rsec{Generic_Compiler_Generated_Initializers}.

The compiler-generated initializer will initialize each field to the value of
the corresponding actual argument.

\begin{chapelexample}{defaultInitializer.chpl}
Given the class
\begin{chapel}
class C {
  var x: int;
  var y: real = 3.14;
  var z: string = "Hello, World!";
}
\end{chapel}
\begin{chapelpost}
var c1 = new C();
var c2 = new C(2);
var c3 = new C(z="");
var c4 = new C(2, z="");
var c5 = new C(0, 0.0, "");
writeln((c1, c2, c3, c4, c5));
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
({x = 0, y = 3.14, z = Hello, World!}, {x = 2, y = 3.14, z = Hello, World!}, {x = 0, y = 3.14, z = }, {x = 2, y = 3.14, z = }, {x = 0, y = 0.0, z = })
\end{chapeloutput}
there are no user-defined initializers for \chpl{C}, so \chpl{new} expressions
will invoke \chpl{C}'s compiler-generated initializer. The \chpl{x} argument
of the compiler-generated initializer has the default value \chpl{0}.
The \chpl{y} and \chpl{z} arguments have the default values \chpl{3.14} and
\chpl{"Hello, World\!"}, respectively.

\chpl{C} instances can be created by calling the compiler-generated initializer as follows:
\begin{itemize}
\item The call \chpl{new C()} is equivalent to \chpl{new C(0,3.14,"Hello, World\!")}.
\item The call \chpl{new C(2)} is equivalent to \chpl{new C(2,3.14,"Hello, World\!")}.
\item The call \chpl{new C(z="")} is equivalent to \chpl{new C(0,3.14,"")}.
\item The call \chpl{new C(2, z="")} is equivalent to \chpl{new C(2,3.14,"")}.
\item The call \chpl{new C(0,0.0,"")} specifies the initial values for all fields explicitly.
\end{itemize}
\end{chapelexample}

\subsection{The postinit Method}
\label{The_postinit_Method}
\index{classes!initializers!postinit}

The compiler-generated initializer is powerful and flexible, but cannot satisfy
all initialization patterns desired by users. One way for users to leverage
the compiler-generated initializer while adding their own functionality is to
implement a method named \chpl{postinit}. The \chpl{postinit} method may also
be implemented for types with user-defined initializers.

The compiler will insert a call to the \chpl{postinit} method after the
initializer invoked by the \chpl{new} expression finishes, if the method
exists. The \chpl{postinit} method accepts zero arguments and may not return
anything. Otherwise, this method behaves like any other method.

\begin{chapelexample}{postinit.chpl}
In the following code:
\begin{chapel}
class Point3D {
  var x, y : real;
  var max = 10.0;

  proc postinit() {
    verify();
  }

  proc verify() {
    writeln("(", x, ", ", y, ")");
    if x > max || y > max then
      writeln("  Point out of bounds!");
  }
}

var A = new Point3D();
var B = new Point3D(1.0, 2.0);
var C = new Point3D(y=5.0);
var D = new Point3D(50.0, 50.0);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
Each of the \chpl{new} expressions invokes the compiler-generated initializer,
then invokes the \chpl{verify} method via the \chpl{postinit} method:
\begin{chapelprintoutput}{}
(0.0, 0.0)
(1.0, 2.0)
(0.0, 5.0)
(50.0, 50.0)
  Point out of bounds!
\end{chapelprintoutput}
\end{chapelexample}

For classes that inherit, the user may invoke the parent's \chpl{postinit}
method or let the compiler insert a call automatically
(\rsec{The_postinit_Method_for_Inheriting_Classes}).

\subsection{Initializing Inherited Classes}
\label{Initializing_Inherited}
\index{classes!initializers!initializer-inheritance}
\index{initializers!initializer-inheritance}
\index{initializer-inheritance}

User-defined initializers also allow for control over initialization of parent
classes. All the fields of the parent type must be initialized before any
fields of the child type, otherwise a compile-time error is issued. This allows
for parent fields to be used in the definition of child fields. An initializer
may invoke a parent's initializer using the \chpl{super} keyword.

If the user does not explicitly call the parent's initializer, the compiler
will insert a call to the parent initializer with zero arguments at the start
of the initializer.

\begin{chapelexample}{simpleSuperInit.chpl}
In the following code:
\begin{chapel}
class A {
  var a, b : real;

  proc init() {
    this.init(1.0);
  }

  proc init(val : real) {
    this.a = val;
    this.b = val * 2;
  }
}

class B : A {
  var x, y : real;

  proc init(val: real, x: real, y: real) {
    super.init(val);
    this.x = x;
    this.y = y;
  }

  proc init() {
    // implicit super.init();
    this.x = a*2;
    this.y = b*2;
  }
}

var b1 = new B(4.0, 1.0, 2.0);
var b2 = new B();
\end{chapel}
\begin{chapelpost}
writeln(b1);
writeln(b2);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{a = 4.0, b = 8.0, x = 1.0, y = 2.0}
{a = 1.0, b = 2.0, x = 2.0, y = 4.0}
\end{chapeloutput}
The first initializer explicitly calls an initializer for class \chpl{A}. Once
the parent's initializer is complete, fields of class \chpl{B} may be
initialized.

The second initializer implicitly invokes the parent's initializer with zero
arguments, and then uses the parent's fields to initialize its own fields.
\end{chapelexample}

As stated earlier, the compiler will insert a zero-argument call to the
parent's initializer if the user has not explicitly written one themselves.
The exception to this rule is if the initializer body invokes another
initializer on the current type (\rsec{Invoking_Other_Initializers}). This
other initializer will either contain an implicit or explicit call to the
parent initializer, and so the calling initializer should not attempt to
initialize the parent itself. This also means that parent fields may not be
accessed before explicit calls to \chpl{init}.

\begin{chapelexample}{superInitThisInit.chpl}
In the following code:
\begin{chapel}
class Parent {
  var x, y: real;
}

class Child : Parent {
  var z : real;

  proc init(x: real, y: real, z: real) {
    super.init(x, y);
    this.z = z;
  }

  proc init(z: real) {
    this.init(0.0, 0.0, z);
  }
}

var c = new Child(5.0);
\end{chapel}
\begin{chapelpost}
writeln(c);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 0.0, y = 0.0, z = 5.0}
\end{chapeloutput}
The second initializer does not contain an implicit call to the parent's
initializer because it explicitly invokes another initializer.
\end{chapelexample}

\subsubsection{Calling Methods on Parent Classes}
\label{Calling_Methods_on_Parent_Classes}
\index{classes!initializers!initializer-inheritance!dynamic-this}

Once \chpl{super.init()} returns, the dynamic type of \chpl{this} is the
parent's type until the \chpl{complete} method
(\rsec{Limitations_on_Instance_Usage_in_Initializers}) is invoked (except when
the child's fields are initialized and used). As a result, the parent's methods
may be called and \chpl{this} may be passed to functions as though it were of
the parent type.

\begin{rationale}
After \chpl{super.init()} returns the instance is in some
partially-initialized, but valid, state. Allowing \chpl{this} to be treated as
the parent allows for additional functionality and flexibility for users.
\end{rationale}

\begin{chapelexample}{dynamicThisInit.chpl}
In the following code:
\begin{chapel}
class Parent {
  var x, y : real;

  proc foo() {
    writeln("Parent.foo");
  }
}

class Child : Parent {
  var z : real;

  proc init(x: real, y: real, z: real) {
    super.init(x, y); // parent's compiler-generated initializer
    foo(); // Parent.foo()
    this.z = z;
    this.complete();
    foo(); // Child.foo()
  }

  override proc foo() {
    writeln("Child.foo");
  }
}

var c = new Child(1.0, 2.0, 3.0);
\end{chapel}
\begin{chapelpost}
writeln(c);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
Once the parent's initializer is finished, the parent method \chpl{foo} may be
called. After the \chpl{complete} method is invoked, a call to \chpl{foo}
resolves to the child's overridden (\rsec{Overriding_Base_Class_Methods})
implementation:
\begin{chapelprintoutput}{}
Parent.foo
Child.foo
{x = 1.0, y = 2.0, z = 3.0}
\end{chapelprintoutput}
\end{chapelexample}

\subsubsection{The Compiler Generated Initializer for Inheriting Classes}
\label{The_Compiler_Generated_Initializer_for_Inheriting_Classes}
\index{classes!initializers!initializer-inheritance!compiler-generated}

The compiler-generated initializer for inheriting classes will have arguments
with default values and names based on the field declarations in the parent
class. Formals for the parent type will be listed before formals for the
child type.

\begin{chapelexample}{compilerGeneratedInheritanceInit.chpl}
In the following code:
\begin{chapel}
class Parent {
  var x, y: real;
}

class Child : Parent {
  var z : real;
}

var A = new Child();
var B = new Child(1.0, 2.0, 3.0); // x=1.0, y=2.0, z=3.0
var C = new Child(y=10.0);
\end{chapel}
\begin{chapelpost}
writeln(A);
writeln(B);
writeln(C);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
{x = 0.0, y = 0.0, z = 0.0}
{x = 1.0, y = 2.0, z = 3.0}
{x = 0.0, y = 10.0, z = 0.0}
\end{chapeloutput}
Any \chpl{new} expressions using the \chpl{Child} type can invoke an
initializer with three formals named \chpl{x}, \chpl{y}, and \chpl{z} that all
have default values based on their types.
\end{chapelexample}

\subsubsection{The postinit Method for Inheriting Classes}
\label{The_postinit_Method_for_Inheriting_Classes}
\index{classes!initializers!initializer-inheritance!postinit}

The \chpl{postinit} method on inheriting classes allows users to invoke
the parent's \chpl{postinit} method using the \chpl{super} keyword. If the
user does not explicitly invoke the parent's \chpl{postinit}, the compiler
will insert the call at the top of the user's \chpl{postinit} method. If the
parent type has a \chpl{postinit} method but the inheriting class does not,
the compiler will generate a \chpl{postinit} method that simply invokes the
parent's \chpl{postinit} method.

\begin{chapelexample}{inheritancePostinit.chpl}
In the following code:
\begin{chapel}
class Parent {
  var a, b : real;
  proc postinit() {
    writeln("Parent.postinit: ", a, ", ", b);
  }
}

class Child : Parent {
  var x, y : real;
  proc postinit() {
    // compiler inserts "super.postinit();"
    writeln("Child.postinit: ", x, ", ", y);
  }
}

var c = new Child(1.0, 2.0, 3.0, 4.0);
\end{chapel}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
The compiler inserts a call to the parent's \chpl{postinit} method in the
child's \chpl{postinit} method, and invokes the child's \chpl{postinit} method
after the compiler-generated initializer finishes:
\begin{chapelprintoutput}{}
Parent.postinit: 1.0, 2.0
Child.postinit: 3.0, 4.0
\end{chapelprintoutput}
\end{chapelexample}

\section{Field Accesses}
\label{Class_Field_Accesses}
\index{classes!field access}
\index{field access!class}

The field in a class is accessed via a field access expression.

\begin{syntax}
field-access-expression:
  receiver-clause[OPT] identifier

receiver-clause:
  expression .
\end{syntax}

\index{classes!receiver}
\index{receiver!class}
% TODO: these are the rules to determine the receiver - move them
% to a separate section so they can be uniformly referenced from everywhere.
The receiver-clause specifies the \emph{receiver}, which is the class
instance whose field is being accessed.
The receiver clause can be omitted when the field access is within a method.
In this case the receiver is the method's receiver.
The receiver clause can also be omitted when the field access is within
a class declaration. In this case the receiver is the instance
being implicitly defined or referenced.

The identifier in the field access expression indicates which field is accessed.

% TODO: rephrase all this in terms of the getter methods

A field can
be modified via an assignment statement where the left-hand side of
the assignment is a field access expression.

Accessing a parameter or type field returns a parameter or type,
respectively. In addition to being available for access with a class
instance receiver, parameter and type fields can be accessed from the
instantiated class type itself.

\begin{chapelexample}{useActor1.chpl}
Given a variable \chpl{anActor} of type \chpl{Actor} as defined above,
the code
\begin{chapelpre}
use defineActor;
var anActor = new unmanaged Actor(name="Tommy", age=26);
\end{chapelpre}
\begin{chapel}
var s: string = anActor.name;
anActor.age = 27;
\end{chapel}
\begin{chapelpost}
writeln((s, anActor));
if (cleanUp) then delete anActor;
\end{chapelpost}
\begin{chapelcompopts}
-scleanUp=true
\end{chapelcompopts}
\begin{chapeloutput}
(Tommy, {name = Tommy, age = 27})
\end{chapeloutput}
reads the field \chpl{name} and assigns the value to the variable
\chpl{s}, and assigns the field \chpl{age} in the object
\chpl{anActor} the value \chpl{27}.
\end{chapelexample}

\subsection{Variable Getter Methods}
\label{Getter_Methods}
\index{classes!getter method}
\index{getter method!class}
\index{methods!class!getter}

All field accesses are performed via getters.  A getter is a method without
parentheses with the same name as the field. It is defined in the field's class
and has a \chpl{ref} return intent (\rsec{Ref_Return_Intent}).  If the program
does not define it, the default getter, which simply returns the field, is
provided.

\begin{chapelexample}{getterSetter.chpl}
In the code
\begin{chapel}
class C {
  var setCount: int;
  var x: int;
  proc x ref {
    setCount += 1;
    return x;
  }
  proc x {
    return x;
  }

}
\end{chapel}
\begin{chapelpost}
var c = new C();
c.x = 1;
writeln(c.x);
c.x = 2;
writeln(c.x);
c.x = 3;
writeln(c.x);
writeln(c.setCount);
\end{chapelpost}
\begin{chapelcompopts}
--no-warnings
\end{chapelcompopts}
\begin{chapeloutput}
1
2
3
3
\end{chapeloutput}
an explicit variable getter method is defined for field \chpl{x}.  It
returns the field \chpl{x} and increments another field that records
the number of times x was assigned a value.
\end{chapelexample}

\section{Class Method Calls}
\label{Class_Method_Calls}
\index{classes!method calls}
\index{methods!calling}

Class method calls are similar to other method calls which are described
in \rsec{Method_Calls}. However, class method calls are subject to
dynamic dispatch.

The receiver-clause (or its absence) specifies the method's receiver in
the same way it does for field accesses \rsec{Class_Field_Accesses}.

See (\rsec{Method_receiver_and_this}) for more details of about method
receivers.

\section{Common Operations}

\subsection{Class Assignment}
\label{Class_Assignment}
\index{classes!assignment}
\index{assignment!class}

Classes are assigned by reference.  After an assignment from one
variable of a class type to another, both variables reference the same
class instance.

Assignment for an \chpl{owned} variable transfers ownership and leaves the
source variable empty. For example:

\begin{chapelexample}{owned-assignment.chpl}
\begin{chapelpre}
class C { }
\end{chapelpre}
\begin{chapel}
// assume that C is a class
var a = new owned C();
var b:owned C; // default initialized to store `nil`
b = a; // transfers ownership from a to b
writeln(a); // a is left storing `nil`
\end{chapel}
\begin{chapeloutput}
nil
\end{chapeloutput}
\end{chapelexample}

In contrast, assignment for \chpl{shared} variables allows both
variables to refer to the same class instance.

\subsection{Implicit Class Conversions}
\label{Implicit_Class_Conversions}
\index{conversions!class}
\index{conversions!implicit!class}
\index{classes!implicit conversion}

An implicit conversion from class type \chpl{D} to
another class type \chpl{C} is allowed when \chpl{D} is a subclass
of \chpl{C}.
The value \chpl{nil} can be implicitly converted to any class type.
These conversions do not change the value.

Class types other than \chpl{borrowed C}, for example \chpl{owned C}, can
be implicitly converted to \chpl{borrowed C}. Note that \chpl{C} is
equivalent to \chpl{borrowed C}.  This coercion is equivalent to calling
the \chpl{.borrow()} method.  See~\rsec{Class_Lifetime_and_Borrows}.

%TODO: Move memory management explanation up, closer to class initializers.
% Perhaps make the memory management part of the introduction, and then let the
% description of deinitializers appear naturally at the same indentation level as
% initializers.
\section{Deleting Unmanaged Class Instances}
\label{Class_Delete}
\index{classes!delete}
\index{delete!class unmanaged instances}
\index{deallocation!unmanaged class instances}

Memory associated with \chpl{unmanaged} class instances can be reclaimed
with the \chpl{delete} statement:

\begin{syntax}
delete-statement:
  `delete' expression-list ;
\end{syntax}

where the expression-list specifies the class objects whose memory
will be reclaimed.  Prior to releasing their memory, the
deinitialization routines for these objects will be executed
(\rsec{Class_Deinitializer}).  The expression-list can contain array
expressions, in which case each element of that array will be deleted
in parallel using a \chpl{forall} loop over the array.  It is legal to
delete a class variable whose value is \chpl{nil}, though this has no
effect.  If a class instance is referenced after it has been deleted,
the behavior is undefined.

\begin{chapelexample}{delete.chpl}
The following example allocates a new object \chpl{c} of class type \chpl{C}
and then deletes it.
\begin{chapelpre}
class C {
  var i,j,k: int;
}
\end{chapelpre}
\begin{chapel}
var c : unmanaged C = nil;
delete c;              // Does nothing: c is nil.

c = new unmanaged C(); // Creates a new object.
delete c;              // Deletes that object.

// The following statements reference an object after it has been deleted, so
// the behavior of each is "undefined":
// writeln(c.i); // May read from freed memory.
// c.i = 3;      // May overwrite freed memory.
// delete c;     // May confuse some allocators.
\end{chapel}
\begin{chapelpost}
\end{chapelpost}
\begin{chapelexecopts}
--memLeaksByType
\end{chapelexecopts}
\begin{chapeloutput}

====================
Leaked Memory Report
==============================================================
Number of leaked allocations
           Total leaked memory (bytes)
                      Description of allocation
==============================================================
==============================================================
\end{chapeloutput}
\end{chapelexample}

\subsection{Class Deinitializer}
\label{Class_Deinitializer}
\index{classes!deinitializer}
\index{deinitializer!classes}

A class author may create a deinitializer to specify additional actions
to be performed when a class instance is deleted.
A class deinitializer is a method named \chpl{deinit()}.  It must take no
arguments (aside from the implicit \chpl{this} argument).  If defined,
the deinitializer is called each time a \chpl{delete} statement is
invoked with a valid instance of that class type. The deinitializer is
not called if the argument of \chpl{delete} evaluates to \chpl{nil}.
Note that when an \chpl{owned} or \chpl{shared} variable goes out of
scope, it may call \chpl{delete} on a class instance which in turn will
run the deinitializer and then reclaim the memory.

\begin{chapelexample}{classDeinitializer.chpl}
\begin{chapel}
class C {
  var i: int;
  proc deinit() { writeln("Bye, bye ", i); }
}

var c : unmanaged C = nil;
delete c;              // Does nothing: c is nil.

c = new unmanaged C(1); // Creates a new instance.
delete c;               // Deletes that instance: Writes out "Bye, bye 1"
                        // and reclaims the memory that was held by c.
{
  var own = new owned C(2); // Creates a new owned instance
                            // The instance is automatically deleted at
                            // the end of this block, so "Bye, bye 2" is
                            // output and then the memory is reclaimed.
}
\end{chapel}
\begin{chapeloutput}
Bye, bye 1
Bye, bye 2
\end{chapeloutput}
\end{chapelexample}
