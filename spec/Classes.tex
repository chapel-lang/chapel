\sekshun{Classes}
\label{Classes}
\index{class@\chpl{class}}
\index{classes}

Classes are an abstraction of a data structure. Storage for
\index{classes!instances}
\index{objects}
a class instance, or an object, is allocated independently of the scope of
the variable that refers to it.
An object is created by calling a class constructor
(\rsec{Class_Constructors}), which allocates storage, initializes it,
and returns a reference to the newly-created object.
Storage can be reclaimed by deleting the object (\rsec{Class_Delete}).

A class declaration (\rsec{Class_Declarations}) also generates a class
type (\rsec{Class_Types}), which is the type of variables referring to
instances of that class or any of its derived classes.

A class is generic if it has generic fields. Generic classes and fields
are discussed in~\rsec{Generic_Types}.

\subsection{Class Types}
\label{Class_Types}
\index{classes!class types}

The syntax of a class type is summarized as follows:
\begin{syntax}
class-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}
For non-generic classes, the class name is sufficient to specify the
type.  Generic classes must be instantiated to be used as types
of variables and in most other contexts.  This is done with
type constructors, which are defined in Section~\ref{Type_Constructors}.

\subsection{Class Declarations}
\label{Class_Declarations}
\index{classes!declarations}

A class is defined with the following syntax:
\begin{syntax}
class-declaration-statement:
  `class' identifier class-inherit-list[OPT] {
    class-statement-list[OPT] }

class-inherit-list:
  : class-type-list

class-type-list:
  class-type
  class-type , class-type-list

class-statement-list:
  class-statement
  class-statement class-statement-list

class-statement:
  type-declaration-statement
  function-declaration-statement
  variable-declaration-statement
  empty-statement
\end{syntax}
A \sntx{class-declaration-statement} defines a new type symbol
specified by the identifier.  Classes inherit data and functionality
from other classes if the \sntx{inherit-type-list} is specified.
Inheritance is described in~\rsec{Inheritance}.

The body of a class declaration consists of a sequence of statements
where each of the statements either defines a variable (called a
field), a function (called a method), or a type alias.  In addition, empty
statements are allowed in class declarations, and they have no effect.

If a class contains a variable or constant without a specified type or
initialization expression, a type alias or a parameter field, the class is
generic.  Generic classes are described in~\rsec{Generic_Types}.

\subsection{Class Assignment}
\label{Class_Assignment}
\index{classes!assignment}

Classes are assigned by reference.  After an assignment from one
variable of class type to another, the variables reference the same
class instance, i.e. the same storage location.

\subsection{Class Fields}
\label{Class_Fields}
\index{classes!fields}
\index{fields}

Variable declarations within a class define
fields within that class.  Parameter fields make a class generic.
Variable and constant fields define the storage associated with a class.

\begin{example}
The code
\begin{chapelpre}
% defineActor.chpl
\end{chapelpre}
\begin{chapel}
class Actor {
  var name: string;
  var age: uint;
}
\end{chapel}
\begin{chapeloutput}
\end{chapeloutput}
defines a new class type called \chpl{Actor} that has two fields: the
string field \chpl{name} and the unsigned integer field \chpl{age}.
\end{example}

\subsubsection{Class Field Accesses}
\label{Class_Field_Accesses}
\index{member access}

The field in a class is accessed via a member access expression as
described in~\rsec{Member_Access_Expressions}.  Fields in a class can
be modified via an assignment statement where the left-hand side of
the assignment is a member access expression.
Accessing a parameter field returns a parameter.
\begin{example}
Given a variable \chpl{anActor} of type \chpl{Actor}, defined above,
the code
\begin{chapelpre}
% useActor1.chpl
use defineActor;
var anActor = new Actor(name="Tommy", age=26);
\end{chapelpre}
\begin{chapel}
var s: string = anActor.name;
anActor.age = 27;
\end{chapel}
\begin{chapelpost}
writeln((s, anActor));
\end{chapelpost}
\begin{chapeloutput}
(Tommy, {name = Tommy, age = 27})
\end{chapeloutput}
reads the field \chpl{name} and assigns the value to the variable
\chpl{s}, and assigns the storage location in the object
\chpl{anActor} associated with the field \chpl{age} the value
\chpl{27}.
\end{example}

\subsection{Class Methods}
\label{Class_Methods}
\index{classes!methods}

A method is a function or iterator that is bound to a class.  A method
is called by passing an instance of the class to the method via a
special syntax that is similar to a field access.

\subsubsection{Class Method Declarations}
\label{Class_Method_Declarations}

Methods are declared with the following syntax:
\begin{syntax}
method-declaration-statement:
  `def' param-clause[OPT] type-binding function-name argument-list[OPT] var-param-type-clause[OPT]
    return-type[OPT] where-clause[OPT] function-body

param-clause:
  `param'

type-binding:
  identifier .
\end{syntax}
If a method is declared within the lexical scope of a class, record,
or union, the type binding can be omitted and is taken to be the
innermost class, record, or union that the method is defined in.  If a
method declaration contains the optional \sntx{param-clause}, it
implies that it can only be applied to param objects of the given type
binding.

\subsubsection{Class Method Calls}
\label{Class_Method_Calls}

A method is called by using the member access syntax as described
in~\rsec{Member_Access_Expressions} where the accessed expression is
the name of the method.

\begin{example}
A method to output information about an instance of the \chpl{Actor}
class can be defined as follows:
\begin{chapelpre}
% defineMethod.chpl
use useActor1;
\end{chapelpre}
\begin{chapel}
def Actor.print() {
  writeln("Actor ", name, " is ", age, " years old");
}
\end{chapel}
\begin{chapelpost}
anActor.print();
\end{chapelpost}
\begin{chapeloutput}
(Tommy, {name = Tommy, age = 27})
Actor Tommy is 27 years old
\end{chapeloutput}
This method can be called on an instance of the \chpl{Actor}
class, \chpl{anActor}, by writing \chpl{anActor.print()}.
\end{example}

\subsubsection{The {\em this} Reference}
\label{The_em_this_Reference}
\index{this@\chpl{this}}

The instance of a class is passed to a method using special syntax.
It does not appear in the argument list to the method.  The
reference \chpl{this} is an alias to the instance of the class on
which the method is called.

\begin{example}
Let class \chpl{C}, method \chpl{foo}, and function \chpl{bar} be
defined as
\begin{chapelpre}
% implicitThis.chpl
\end{chapelpre}
\begin{chapel}
class C {
  def foo() {
    bar(this);
  }
}
def bar(c: C) { writeln(c); }
\end{chapel}
\begin{chapelpost}
var c: C = new C();
c.foo();
\end{chapelpost}
\begin{chapeloutput}
{}
\end{chapeloutput}
Then given an instance of \chpl{C} called \chpl{c}, the method
call \chpl{c.foo()} results in a call to \chpl{bar} where the argument
is \chpl{c}.
\end{example}

\subsubsection{The {\em this} Method}
\label{The_em_this_Method}
\index{this@\chpl{this}}
\index{classes!indexing}

A method declared with the name \chpl{this} allows a class to be
``indexed'' similarly to how an array is indexed.  Indexing into a
class has the semantics of calling a method on the class
named \chpl{this}.  There is no other way to call a method
called \chpl{this}.  The \chpl{this} method must be declared with
parentheses even if the argument list is empty.

\begin{example}
In the following code, the \chpl{this} method is used to create a
class that acts like a simple array that contains three integers
indexed by 1, 2, and 3.
\begin{chapelpre}
% thisMethod.chpl
\end{chapelpre}
\begin{chapel}
class ThreeArray {
  var x1, x2, x3: int;
  def this(i: int) var {
    select i {
      when 1 do return x1;
      when 2 do return x2;
      when 3 do return x3;
    }
    halt("ThreeArray index out of bounds: ", i);
  }
}
\end{chapel}
\begin{chapelpost}
var ta = new ThreeArray();
ta(1) = 1;
ta(2) = 2;
ta(3) = 3;
for i in 1..3 do
  writeln(ta(i));
ta(4) = 4;
\end{chapelpost}
\begin{chapeloutput}
1
2
3
thisMethod.chpl:9: error: halt reached - ThreeArray index out of bounds: 4
\end{chapeloutput}
\end{example}

\subsubsection{The {\em these} Method}
\label{The_these_Method}
\index{these@\chpl{these}}
\index{classes!iterating}

A method declared with the name \chpl{these} allows a class to be
``iterated over'' similarly to how a domain or array is iterated over.
Using a class in the context of a loop where
an \sntx{iterator-expression} is expected has the semantics of calling
a method on the class named \chpl{these}.

\begin{example}
In the following code, the \chpl{these} method is used to create a
class that acts like a simple array that can be iterated over and
contains three integers.
\begin{chapelpre}
% theseIterator.chpl
\end{chapelpre}
\begin{chapel}
class ThreeArray {
  var x1, x2, x3: int;
  def these() var {
    yield x1;
    yield x2;
    yield x3;
  }
}
\end{chapel}
\begin{chapelpost}
var ta = new ThreeArray();
for (i, j) in (ta, 1..) do
  i = j;

for i in ta do
  writeln(i);
\end{chapelpost}
\begin{chapeloutput}
1
2
3
\end{chapeloutput}

\end{example}

\subsection{Class Constructors}
\label{Class_Constructors}
\index{classes!constructors}
\index{classes!new}
\index{new!classes}

A class constructor is defined by declaring a method with the same
name as the class.  The constructor is used to create instances of the
class. It is invoked by preceding a call to it with the \chpl{new}
keyword.  When the constructor is called, memory is allocated to store
a class instance, its fields are initialized to default values
(field defaults when specified in the class declaration, type defaults
otherwise), then the constructor method is invoked on this newly-created
instance.

\begin{example}
The following example shows a class with two constructors:
\begin{chapelpre}
% simpleConstructors.chpl
\end{chapelpre}
\begin{chapel}
class MessagePoint {
  var x, y: real;
  var message: string;

  def MessagePoint(x: real, y: real) {
    this.x = x;
    this.y = y;
    this.message = "a point";
  }

  def MessagePoint(message: string) {
    this.x = 0;
    this.y = 0;
    this.message = message;
  }
}  // class MessagePoint

// create two objects
var mp1 = new MessagePoint(1.0,2.0);
var mp2 = new MessagePoint("point mp2");
\end{chapel}
\begin{chapelpost}
writeln(mp1);
writeln(mp2);
\end{chapelpost}
\begin{chapeloutput}
{x = 1.0, y = 2.0, message = a point}
{x = 0.0, y = 0.0, message = point mp2}
\end{chapeloutput}
The first constructor lets the user specify the initial coordinates
and the second constructor lets the user specify the initial message
when creating a MessagePoint.
\end{example}

Constructors for generic classes (\rsec{Generic_Types}) handle certain
arguments differently and may need to satisfy additional
requirements. See Section~\ref{Generic_User_Constructors} for details.

\subsubsection{The Default Constructor}
\label{The_Default_Constructor}
\index{classes!default constructors}

The default constructor is automatically created for every class in
the Chapel program. It has one argument for every field in the class
(including the fields inherited from superclasses, if any, and including
type alias and parameter fields, if any)
with the argument name matching the field's name.
The order of the arguments matches the order of the field declarations
in the class, with the arguments for a superclass's fields occurring
before the arguments for a subclass's fields.
The default constructor for a class can be invoked via a \chpl{new}
operator only when the class does not have any user-defined constructors,
i.e. the program does not define any constructors for
that class explicitly.

The default constructor provides default values for its arguments as follows.
For a field that has an initializer expression (like the
fields \chpl{y} and \chpl{z} in the example below), that initializer
expression is the corresponding argument's default value.
Otherwise, for non-generic fields it is the default value for that
field's type.
For generic fields declared without an initializer expression the
default constructor provides no default value.
Therefore, when the default constructor is invoked via a \chpl{new}
expression and no actual is passed to its argument \chpl{x}, the
field \chpl{x} of the newly-created object will be initialized if it
is declared with an initializer or is not generic, otherwise it is a
compile-time error.

The default constructor initializes each field in the class to the
value of the corresponding actual. (For example, a field \chpl{x} is
initialized to the actual passed to the argument named \chpl{x}.)
This ensures that upon return from the constructor it is safe to use
the object being created -- each field contains a legal value for its type.
The initialization is done in the order the fields are declared, with
a superclass's fields initialized before a subclass's fields.
(This is the same as the order of the default constructor's arguments.)

The program may define a constructor with the same arguments and types
as the default constructor for that class. If there is such a
user-defined constructor, it is distinct from the default
constructor and, as discussed above, makes the default constructor
unavailable for \chpl{new} expressions.

Any user-defined constructor begins with an implicit call to the
default constructor for that class. No arguments are passed in this
call, so the default values discussed above are used to initialize all
fields. Correspondingly, it is illegal for a program to define a
constructor for a class that has a generic field with no default.

\begin{example}
Given the class
\begin{chapelpre}
% defaultConstructor.chpl
\end{chapelpre}
\begin{chapel}
class C {
  var x: int;
  var y: real = 3.14;
  var z: string = "Hello, World!";
}
\end{chapel}
\begin{chapelpost}
var c1 = new C();
var c2 = new C(2);
var c3 = new C(z="");
var c4 = new C(2, z="");
var c5 = new C(0, 0.0, "");
writeln((c1, c2, c3, c4, c5));
\end{chapelpost}
\begin{chapeloutput}
({x = 0, y = 3.14, z = Hello, World!}, {x = 2, y = 3.14, z = Hello, World!}, {x = 0, y = 3.14, z = }, {x = 2, y = 3.14, z = }, {x = 0, y = 0.0, z = })
\end{chapeloutput}
there are no user-defined constructors for \chpl{C}, so \chpl{new} expressions
will invoke \chpl{C}'s default constructor. The \chpl{x} argument
of the default constructor has the default value \chpl{0}.
The \chpl{y} and \chpl{z} arguments have the default values \chpl{3.14} and
\chpl{"Hello, World!"}, respectively.

\chpl{C} instances can be created by calling the default constructor as follows:
\begin{itemize}
\item The call \chpl{new C()} is equivalent to \chpl{C(0,3.14,"Hello, World!")}.
\item The call \chpl{new C(2)} is equivalent to \chpl{C(2,3.14,"Hello, World!")}.
\item The call \chpl{new C(z="")} is equivalent to \chpl{C(0,3.14,"")}.
\item The call \chpl{new C(2, z="")} is equivalent to \chpl{C(2,3.14,"")}.
\item The call \chpl{new C(0,0.0,"")} specifies the initial values for all fields explicitly.
\end{itemize}
\end{example}

\subsection{Variable Getter Methods}
\label{Getter_Methods}
\index{classes!getters}
\index{classes!setters}

All field accesses are resolved via getters that are variable
methods~(\rsec{Variable_Functions}) defined in the class with the same
name as the field.  The default getter is defined to simply return the
field if the user does not define their own.

\begin{example}
In the code
\begin{chapelpre}
% getterSetter.chpl
\end{chapelpre}
\begin{chapel}
class C {
  var setCount: int;
  var x: int;
  def x var {
    if setter then
      setCount += 1;
    return x;
  }
}
\end{chapel}
\begin{chapelpost}
var c = new C();
c.x = 1;
writeln(c.x);
c.x = 2;
writeln(c.x);
c.x = 3;
writeln(c.x);
writeln(c.setCount);
\end{chapelpost}
\begin{chapeloutput}
1
2
3
3
\end{chapeloutput}
an explicit variable getter method is defined for field \chpl{x}.  It
returns the field \chpl{x} and increments another field that records
the number of times x was assigned a value.
\end{example}

\subsection{Inheritance}
\label{Inheritance}
\index{inheritance}
\index{classes!inheritance}

A ``derived'' class can inherit from one or more other classes by
specifying those classes, the base classes, following the name of the
derived class in the declaration of the derived class.  When
inheriting from multiple base classes, only one of the base classes
may contain fields.  The other classes can only define methods.  Note
that a class can still be derived from a class that contains fields
which is itself derived from a class that contains fields.
\subsubsection{The object Class}
\label{The_object_Class}

All classes are derived from the \chpl{object} class either directly, or
through the classes they are derived from. A variable of type \chpl{object}
can hold a reference to an object of any class type. 

\subsubsection{Accessing Base Class Fields}
\label{Accessing_Base_Class_Fields}

A derived class contains data associated with the fields in its base
classes.  The fields can be accessed in the same way that they are
accessed in their base class unless the getter or setter method is
overridden in the derived class, as discussed
in~\rsec{Overriding_Base_Class_Methods}.

\subsubsection{Derived Class Constructors}
\label{Derived_Class_Constructors}

Derived class constructors automatically call the default constructor
of the base class.  There is an expectation that a more standard way
of chaining constructor calls will be supported.

\subsubsection{Shadowing Base Class Fields}
\label{Shadowing_Base_Class_Fields}

A field in the derived class can be declared with the same name as a
field in the base class.  Such a field shadows the field in the base
class in that it is always referenced when it is accessed in the
context of the derived class.  There is an expectation that there will
be a way to reference the field in the base class but this is not
defined at this time.

\subsubsection{Overriding Base Class Methods}
\label{Overriding_Base_Class_Methods}
\index{dynamic dispatch}

If a method in a derived class is declared with the identical
signature as a method in a base class, then it is said to override the
base class's method.  Such a method is a candidate for dynamic
dispatch in the event that a variable that has the base class type
references a variable that has the derived class type.

The identical signature requires that the names, types, and order of
the formal arguments be identical. The return type of the overriding
method must be the same as the return type of the base class's method,
or must be a subclass of the base class method's return type.

Methods without parentheses are not candidates for dynamic dispatch.
\begin{rationale}
Methods without parentheses are primarily used for field accessors of
which a default is created if none is specified.  The field accessor
should not dynamically dispatch in general since that would make it
impossible to access a base field within a base method should that
field be shadowed by a subclass.
\end{rationale}

\subsubsection{Inheriting from Multiple Classes}
\label{Inheriting_from_Multiple_Classes}
\index{multiple inheritance}

A class can be derived from multiple base classes provided that only
one of the base classes contains fields either directly or from base
classes that it is derived from.  The methods defined by the other
base classes can be overridden.

\subsection{Nested Classes}
\label{Nested_Classes}
\index{classes!nested}

A class defined within another class is a nested class.

Nested classes can refer to fields and methods in the outer class
implicitly or explicitly with an \chpl{outer} reference.

\subsection{The \chpl{nil} Value}
\index{classes!nil}
\index{nil@\chpl{nil}}

Chapel provides \chpl{nil} to indicate the absence of a reference to
any object.  \chpl{nil} can be assigned to a variable of any class
type.  Invoking a class method or accessing a field of the \chpl{nil}
value results in a run-time error.

\subsection{Dynamic Memory Management}
\label{Dynamic_Memory_Management}
\label{Class_Delete}
\index{memory management}
\index{classes!delete}
\index{delete!classes}

Memory associated with class instances can be reclaimed with the \chpl{delete}
keyword.

\begin{example}
The following example allocates a new object \chpl{c} of class type \chpl{C}
and then deletes it.
\begin{chapelpre}
% delete.chpl
class C {
  var i,j,k: int;
}
\end{chapelpre}
\begin{chapel}
var c = new C();
delete c;
\end{chapel}
\begin{chapelpost}
\end{chapelpost}
\begin{chapelexecopts}
--memLeaks
\end{chapelexecopts}
\begin{chapeloutput}

====================
Leaked Memory Report
==============================================================
Number of leaked allocations
           Total leaked memory (bytes)
                      Description of allocation
==============================================================
==============================================================
\end{chapeloutput}
\end{example}

\begin{openissue}
Chapel was originally specified without a \chpl{delete} keyword.  The intention
was that Chapel would be implemented with a distributed-memory garbage
collector.  This is a research challenge.  In order to focus elsewhere, the
design has been scaled back.  There is an expectation that Chapel will
eventually support an optional distributed-memory garbage collector as well as
a region-based memory management scheme similar to that used in the Titanium
language.  Support of \chpl{delete} will likely continue even as these optional
features become supported.
\end{openissue}
