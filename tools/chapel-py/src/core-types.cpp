/*
 * Copyright 2023-2026 Hewlett Packard Enterprise Development LP
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "core-types.h"
#include "core-types-gen.h"
#include "chpl/uast/all-uast.h"
#include "chpl/types/all-types.h"
#include "chpl/parsing/parsing-queries.h"
#include "chpl/resolution/scope-queries.h"
#include "python-types.h"
#include "error-tracker.h"
#include "resolution.h"
#include "python-type-helper.h"

using namespace chpl;
using namespace uast;

int ContextObject::init(ContextObject* self, PyObject* args, PyObject* kwargs) {
  Context::Configuration config;

  std::string chplHome;
  bool installed = false;
  bool fromEnv = false;
  std::string diagnosticMsg;
  auto error = findChplHome(nullptr, nullptr, chplHome, installed, fromEnv, diagnosticMsg);
  if (!diagnosticMsg.empty()) {
    if (error) {
      PyErr_SetString(PyExc_RuntimeError, diagnosticMsg.c_str());
      return -1;
    } else {
      PyErr_WarnEx(PyExc_RuntimeWarning, diagnosticMsg.c_str(), 1);
    }
  } else if (error) {
    PyErr_SetString(PyExc_RuntimeError, "Unknown error while finding CHPL_HOME");
    return -1;
  }

  config.chplHome = chplHome;
  new (&self->value_) Context(std::move(config));
  self->value_.installErrorHandler(owned<PythonErrorHandler>(new PythonErrorHandler((PyObject*) self)));

  return 0;
}

template <typename Tuple, size_t ... Indices>
static void printTypedPythonFunctionArgs(std::ostringstream& ss, std::index_sequence<Indices...>) {
  // std::index_sequence is an empty object that only serves to contain a list
  // of size_ts in a parameter back. By writing template functions with
  // template <size_t ... Indices>, and accepting a std::index_sequence argument,
  // we are able to get a compile-time handle on a variadic list of indices --
  // in this case, a variadic list of tuple indices. That's what this
  // function does.
  //
  // From there, we can use variadic template expansion to print the typeString
  // corresponding to each element / index of the tuple. If we just wanted to
  // print the typeStrings without spaces or punctuation, we could have used
  // (<<) with a fold expression[1]. However, we want to print a comma and
  // more, so it's more convenient to use a wrapper function printArg to handle
  // the formatting.
  //
  // [1]: https://en.cppreference.com/w/cpp/language/fold

  int counter = 0;
  auto printArg = [&](const std::string& arg) {
    ss << ", arg" << counter++ << ": " << arg;
  };

  (printArg(std::tuple_element<Indices, Tuple>::type::typeString()), ...);
}

template <typename T>
struct ParentTypeInfo {
  static PyTypeObject* parentTypeObject() { return nullptr; }
};

#define GENERATED_TYPE(ROOT, ROOT_TYPE, NAME, TYPE, TAG, FLAGS) \
  template <> \
  struct ParentTypeInfo<NAME##Object> { \
    static PyTypeObject* parentTypeObject() { \
      return parentTypeFor(TAG); \
    } \
  };
#include "generated-types-list.h"

std::string generatePyiFile() {
  std::ostringstream ss;

  ss << "\"\"\"" << std::endl;
  ss << "AUTOGENERATED FILE - DO NOT EDIT" << std::endl;
  ss << "\"\"\"" << std::endl << std::endl;

  ss << "import typing" << std::endl << std::endl;

  // Here, use X-macros with the method-tables.h header file to generate
  // printing code for each AST node class. This uses the helper function
  // printTypedPythonFunctionArgs (explained in its body) for the arguments.
  //
  // We get a tuple of type information structs from the PythonFnHelper template
  // and each method's TYPEFN (a C++ type in the form R(Args...)). The documentation
  // for PythonFnHelper has some more information on this.

  std::unordered_set<std::string> generated;

  bool printedAnything = false;

  #define CLASS_BEGIN(NODE) \
    ss << "class " << NODE##Object::Name; \
    printedAnything = false; \
    generated.insert(NODE##Object::Name); \
    if (auto parentType = ParentTypeInfo<NODE##Object>::parentTypeObject()) { \
      ss << "(" << getTypeName(parentType) << ")"; \
    } \
    ss << ":" << std::endl;
  #define METHOD(NODE, NAME, DOCSTR, TYPEFN, BODY) \
    printedAnything = true; \
    ss << "    def " << #NAME << "(self"; \
    printTypedPythonFunctionArgs<PythonFnHelper<TYPEFN>::ArgTypeInfo>(ss, std::make_index_sequence<std::tuple_size<PythonFnHelper<TYPEFN>::ArgTypeInfo>::value>()); \
    ss << ") -> " << PythonFnHelper<TYPEFN>::ReturnTypeInfo::typeString() << ":" << std::endl;\
    ss << "        \"\"\"" << std::endl; \
    ss << "        " << DOCSTR << std::endl; \
    ss << "        \"\"\"" << std::endl; \
    ss << "        ..." << std::endl << std::endl;
  #define METHOD_PROTOTYPE(NODE, NAME, DOCSTR) \
    printedAnything = true; \
    ss << "    def " << #NAME << "(self):" << std::endl; \
    ss << "        \"\"\"" << std::endl; \
    ss << "        " << DOCSTR << std::endl; \
    ss << "        \"\"\"" << std::endl; \
    ss << "        ..." << std::endl << std::endl;
  #define ITER_PROTOTYPE(NODE, TYPE) \
    printedAnything = true; \
    ss << "    def __iter__(self) -> typing.Iterator[" << PythonReturnTypeInfo<TYPE>::typeString() << "]:" << std::endl; \
    ss << "        ..." << std::endl << std::endl;
  #define OPERATOR_PROTOTYPE(NODE, NAME, DOCSTR, TYPEFN) METHOD(NODE, NAME, DOCSTR, TYPEFN, /*BODY*/)
  #define CLASS_END(NODE) \
    if (!printedAnything) { \
      ss << "    pass" << std::endl; \
    } \
    ss << std::endl;
  #include "method-tables.h"

  #define ENSURE_ALL_CLASSES(NODE, TAG) \
    if(generated.find(NODE##Object::Name) == generated.end()) { \
      ss << "class " << NODE##Object::Name; \
      if (auto parentType = ParentTypeInfo<NODE##Object>::parentTypeObject()) { \
        ss << "(" << getTypeName(parentType) << ")"; \
      } \
      ss << ":" << std::endl; \
      ss << "    pass" << std::endl; \
    } \

  #define GENERATED_TYPE(ROOT, ROOT_TYPE, NAME, TYPE, TAG, FLAGS) ENSURE_ALL_CLASSES(NAME, TAG)
  #include "generated-types-list.h"
  #undef ENSURE_ALL_CLASSES

  return ss.str();
}

PyObject* AstNodeObject::iter(AstNodeObject *self) {
  if (!self->value_) {
    raiseExceptionForIncorrectlyConstructedType("AstNode");
    return nullptr;
  }
  return wrapIterPair((ContextObject*) self->contextObject, self->value_->children());
}

PyObject* AstNodeObject::str(AstNodeObject *self) {
  if (!self->value_) {
    raiseExceptionForIncorrectlyConstructedType("AstNode");
    return nullptr;
  }

  std::stringstream ss;
  self->value_->stringify(ss, CHPL_SYNTAX);
  auto typeString = ss.str();
  return Py_BuildValue("s", typeString.c_str());
}

PyObject* AstNodeObject::repr(AstNodeObject *self) {
  if (!self->value_) {
    raiseExceptionForIncorrectlyConstructedType("AstNode");
    return nullptr;
  }

  std::stringstream ss;
  self->value_->stringify(ss, DEBUG_DETAIL);
  auto typeString = ss.str();
  return Py_BuildValue("s", typeString.c_str());
}

Py_hash_t AstNodeObject::hash(AstNodeObject *self) {
  return self->value_->id().hash();
}

PyObject* AstNodeObject::richcompare(AstNodeObject *self, PyObject *other, int op) {
  if (!PyObject_TypeCheck(other, AstNodeObject::PythonType)) {
    Py_RETURN_NOTIMPLEMENTED;
  }
  auto otherCast = (AstNodeObject*) other;
  auto& selfId = self->value_->id();
  auto& otherId = otherCast->value_->id();

  Py_RETURN_RICHCOMPARE(selfId, otherId, op);
}

PyObject* ChapelTypeObject::str(ChapelTypeObject* self) {
  if (!self->value_) {
    raiseExceptionForIncorrectlyConstructedType("Type");
    return nullptr;
  }
  std::stringstream ss;
  self->value_->stringify(ss, CHPL_SYNTAX);
  auto typeString = ss.str();
  return Py_BuildValue("s", typeString.c_str());
}

PyObject* ParamObject::str(ParamObject* self) {
  if (!self->value_) {
    raiseExceptionForIncorrectlyConstructedType("Param");
    return nullptr;
  }
  std::stringstream ss;
  self->value_->stringify(ss, CHPL_SYNTAX);
  auto typeString = ss.str();
  return Py_BuildValue("s", typeString.c_str());
}

PyObject* TypedSignatureObject::str(TypedSignatureObject* self) {
  if (!self->value_.signature) {
    raiseExceptionForIncorrectlyConstructedType("TypedSignature");
    return nullptr;
  }
  std::stringstream ss;
  self->value_.signature->stringify(ss, CHPL_SYNTAX);
  auto typeString = ss.str();
  return Py_BuildValue("s", typeString.c_str());
}
PyObject* TypedSignatureObject::repr(TypedSignatureObject* self) {
  if (!self->value_.signature) {
    raiseExceptionForIncorrectlyConstructedType("TypedSignature");
    return nullptr;
  }
  std::stringstream ss;
  self->value_.signature->stringify(ss, CHPL_SYNTAX);
  if (auto poi = self->value_.poiScope) {
    poi->stringify(ss, CHPL_SYNTAX);
  }
  auto typeString = ss.str();
  return Py_BuildValue("s", typeString.c_str());
}
Py_hash_t TypedSignatureObject::hash(TypedSignatureObject* self) {
  return chpl::hash(self->value_.signature, self->value_.poiScope);
}
PyObject* TypedSignatureObject::richcompare(TypedSignatureObject* self, PyObject* other, int op) {
  if (other->ob_type != TypedSignatureObject::PythonType) {
    Py_RETURN_NOTIMPLEMENTED;
  }
  auto otherCast = (TypedSignatureObject*) other;
  auto selfVal = std::make_tuple(self->value_.signature, self->value_.poiScope);
  auto otherVal = std::make_tuple(otherCast->value_.signature, otherCast->value_.poiScope);

  Py_RETURN_RICHCOMPARE(selfVal, otherVal, op);
}

PyTypeObject* parentTypeFor(asttags::AstTag tag) {
#define AST_NODE(NAME)
#define AST_LEAF(NAME)
#define AST_BEGIN_SUBCLASSES(NAME)
#define AST_END_SUBCLASSES(NAME) \
  if (tag > asttags::START_##NAME && tag < asttags::END_##NAME) { \
    return NAME##Type; \
  }
#include "chpl/uast/uast-classes-list.h"
#undef AST_NODE
#undef AST_LEAF
#undef AST_BEGIN_SUBCLASSES
#undef AST_END_SUBCLASSES
  return AstNodeObject::PythonType;
}

PyTypeObject* parentTypeFor(types::typetags::TypeTag tag) {
#define TYPE_NODE(NAME)
#define BUILTIN_TYPE_NODE(NAME, CHPL_NAME)
#define TYPE_BEGIN_SUBCLASSES(NAME)
#define TYPE_END_SUBCLASSES(NAME) \
  if (tag > types::typetags::START_##NAME && tag < types::typetags::END_##NAME) { \
    return NAME##Type; \
  }
#include "chpl/types/type-classes-list.h"
#undef TYPE_NODE
#undef BUILTIN_TYPE_NODE
#undef TYPE_BEGIN_SUBCLASSES
#undef TYPE_END_SUBCLASSES
  return ChapelTypeObject::PythonType;
}

PyTypeObject* parentTypeFor(chpl::types::paramtags::ParamTag tag) {
  return ParamObject::PythonType;
}

PyTypeObject* parentTypeFor(chpl::ErrorType tag) {
  return ErrorObject::PythonType;
}

PyObject* wrapGeneratedType(ContextObject* context, const AstNode* node) {
  PyObject* toReturn = nullptr;
  if (node == nullptr) {
    PyErr_SetString(PyExc_RuntimeError, "implementation attempted to wrap a null pointer");
    return nullptr;
  }
  PyObject* args = Py_BuildValue("(O)", (PyObject*) context);
  switch (node->tag()) {
#define CAST_TO(NAME) \
    case asttags::NAME: \
      toReturn = PyObject_CallObject((PyObject*) NAME##Type, args); \
      ((NAME##Object*) toReturn)->parent.value_ = node->to##NAME(); \
      break;
#define AST_NODE(NAME) CAST_TO(NAME)
#define AST_LEAF(NAME) CAST_TO(NAME)
/* No need to handle abstract parent classes. */
#define AST_BEGIN_SUBCLASSES(NAME)
#define AST_END_SUBCLASSES(NAME)
#include "chpl/uast/uast-classes-list.h"
#undef AST_NODE
#undef AST_LEAF
#undef AST_BEGIN_SUBCLASSES
#undef AST_END_SUBCLASSES
#undef CAST_TO
    default: break;
  }
  Py_XDECREF(args);
  return toReturn;
}

PyObject* wrapGeneratedType(ContextObject* context, const types::Type* node) {
  PyObject* toReturn = nullptr;
  if (node == nullptr) {
    PyErr_SetString(PyExc_RuntimeError, "implementation attempted to wrap a null pointer");
    return nullptr;
  }
  PyObject* args = Py_BuildValue("(O)", (PyObject*) context);
  switch (node->tag()) {
#define CAST_TO(NAME) \
    case types::typetags::NAME: \
      toReturn = PyObject_CallObject((PyObject*) NAME##Type, args); \
      ((NAME##Object*) toReturn)->parent.value_ = (const types::Type*) node->to##NAME(); \
      break;
#define TYPE_NODE(NAME) CAST_TO(NAME)
#define BUILTIN_TYPE_NODE(NAME, CHPL_NAME) CAST_TO(NAME)
/* No need to handle abstract parent classes. */
#define TYPE_BEGIN_SUBCLASSES(NAME)
#define TYPE_END_SUBCLASSES(NAME)
#include "chpl/types/type-classes-list.h"
#undef TYPE_NODE
#undef BUILTIN_TYPE_NODE
#undef TYPE_BEGIN_SUBCLASSES
#undef TYPE_END_SUBCLASSES
#undef CAST_TO
    default: break;
  }
  Py_XDECREF(args);
  return toReturn;
}

PyObject* wrapGeneratedType(ContextObject* context, const chpl::types::Param* node) {
  PyObject* toReturn = nullptr;
  if (node == nullptr) {
    PyErr_SetString(PyExc_RuntimeError, "implementation attempted to wrap a null pointer");
    return nullptr;
  }
  PyObject* args = Py_BuildValue("(O)", (PyObject*) context);
  switch (node->tag()) {
#define PARAM_NODE(NAME, TYPE) \
    case chpl::types::paramtags::NAME: \
      toReturn = PyObject_CallObject((PyObject*) NAME##Type, args); \
      ((NAME##Object*) toReturn)->parent.value_ = node->to##NAME(); \
      break;
#include "chpl/types/param-classes-list.h"
#undef PARAM_NODE
  }
  Py_XDECREF(args);
  return toReturn;
}

PyObject* wrapGeneratedType(ContextObject* context, const chpl::ErrorBase* node) {
  PyObject* toReturn = nullptr;
  if (node == nullptr) {
    PyErr_SetString(PyExc_RuntimeError, "implementation attempted to wrap a null pointer");
    return nullptr;
  }
  PyObject* args = Py_BuildValue("(O)", (PyObject*) context);
  switch (node->type()) {
    case chpl::ErrorType::General:
      toReturn = PyObject_CallObject((PyObject*) GeneralErrorType, args);
      ((GeneralErrorObject*) toReturn)->parent.value_ = node->clone();
      break;
#define DIAGNOSTIC_CLASS(NAME, KIND, EINFO...) \
    case chpl::ErrorType::NAME: \
      toReturn = PyObject_CallObject((PyObject*) NAME##Type, args); \
      ((NAME##Object*) toReturn)->parent.value_ = node->clone(); \
      break;
#include "chpl/framework/error-classes-list.h"
#undef DIAGNOSTIC_CLASS
  }
  Py_XDECREF(args);
  return toReturn;
}
