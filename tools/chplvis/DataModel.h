/*
 * Copyright 2015 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef DATAMODEL_H
#define DATAMODEL_H

#include "Event.h"
#include <list>
#include <vector>
#include <map>

// This class builds a list of events 
//   Start, Stop, Pause, and Tag events are grouped together 
//   Other events are placed in a time sorted group between
//   the grouped events.

// This is the class that reads the files as generated by runtime/src/chpl-visual-debug.c
// in the Chapel runtime.
//
// Initially the data files are in ascii.  To turn these into binary data files,
// both this class and runtime/src/chpl-visual-debug.c need to be modified to
// write (chpl-visual-debug.c) and read (this class) in binary.

// Support Structs used by DataModel

// Used to track tasks,  each tag/locale has a map of taskData
struct taskData {
  E_task *taskRec;
  E_begin_task *beginRec;
  E_end_task *endRec;

  taskData() : taskRec(NULL), beginRec(NULL), endRec(NULL) {};
};

// Used to track a locale,  each tag has an array of locales
struct localeData {
  double userCpu;
  double sysCpu;
  double Cpu;
  double refUserCpu;
  double refSysCpu;
  double clockTime;
  double refTime;
  long    numTasks;
  std::map<long,taskData> tasks;

  localeData() : userCpu(0), sysCpu(0), Cpu(0), refUserCpu(0), refSysCpu(0),
                 clockTime(0), refTime(0), numTasks(0) {};
};

// Used to track communication,  each tag has a 2D array of commData, one for each direction
struct commData {
  long numComms;
  long numGets;
  long numPuts;
  long numForks;
  long commSize;
  
  commData() :  numComms(0), numGets(0), numPuts(0), numForks(0), commSize(0) {};
};

// Primary data structure built by reading the data files dumped by using VisualDebug.chpl

class DataModel {

 public:

  // Forward declaration
  struct tagData;

 private:

  typedef std::list<Event*>::iterator evItr;

  int numLocales;
  int numTags;
  
  // Includes entries for -2 (TagAll), and -1 (TagStart->0),  size is numTags+2
  tagData **tagList;  
  
  std::list<Event*> theEvents;
  std::list<Event*>::iterator curEvent;
  
  // Utility routines
  
  int LoadFile (const char *filename, int index, double seq);
  
  void newList ();
  
 public:
  
  // Tag array has two extra entries, one for "All" and
  // one for Start (startVdebug() call) to the first tag.
  // Tags are numbered 0 to numTags-1
  
  static const int TagALL = -2, TagStart = -1;
  
  // Tags and manipulation of them
  
  struct tagData { // a class with public elements the default
    friend class DataModel;
    const long numLocales;
    std::string name;
    localeData *locales;
    commData **comms;
    
    // Local Maxes
    double maxCpu;
    double maxClock;
    long   maxTasks;
    long   maxComms;
    long   maxSize;
    
    tagData(long numLoc) : numLocales(numLoc), name(""),
      maxCpu(0), maxClock(0), maxTasks(0), maxComms(0), maxSize(0) {
      locales = new localeData[numLocales];
      comms = new  commData * [numLocales];
      for (int i = 0; i < numLocales; i++ )
        comms[i] = new commData[numLocales];
    }
    
    ~tagData() {
      delete [] locales;
      locales = NULL;
      for (int i = 0; i < numLocales; i++) {
        delete [] comms[i];
        comms[i] = NULL;
      }
      delete [] comms;
      comms = NULL;
    }

    private:
      evItr firstTag;
  };
  // End of struct tagData

  // DataModel methods
  
  int NumTags () { return numTags; }
  
  std::string getTagName (const int tagNo) {
    if (tagNo < 0 || tagNo >= numTags) 
      return "";
    else
      return tagList[tagNo-TagALL]->name;
  }
  
  tagData * getTagData(int tagno) {
    if (tagno < TagALL || tagno >= numTags) 
      return NULL;
    return tagList[tagno-TagALL];
  }
  
  // Constructor for DataModel
  
  DataModel() {
    numLocales = -1;
    numTags = 0;
    tagList = NULL;
    curEvent = theEvents.begin();
  }
  
  // Destructor for DataModel
  ~DataModel() {
    if (tagList != NULL)
      delete [] tagList;
  }
  
  //  LoadData loads data from a collection of files
  //  filename of the form  basename-n, where n can
  //  be a multi-digit number
  //  Returns 1 if successful, 0 if not
  
  int LoadData (const char *filename);
  
  //  Number of locales found in loading files
  
  int NumLocales () { return numLocales; }
  
};

#endif
