#include <mpi.h>
#include <armci.h>
#include <gpc.h>

#include <stdio.h> // for sprintf()
#include <stdint.h>
#include <string.h>
#include <strings.h>

#include "chpl-comm.h"
#include "chpl-comm-heap-macros.h"
#include "chpl-mem.h"
#include "chplrt.h"
#include "error.h"

#define MEG (1024 * 1024)
#define _MAX_ARMCI_MEMSZ (64 * MEG)

// Undefine this symbol to deactivate extra runtime error checking
#define _ARMCI_DEBUG

#ifdef _ARMCI_DEBUG
#define ARMCI_SAFE(fncall)                                 \
{                                                          \
  int ret;                                                 \
  char buff[256];                                          \
                                                           \
  ret = fncall;                                            \
  if (ret != 0) {                                          \
    sprintf(buff, "ARMCI function call error: %d %s %d\n", \
            ret, __FILE__, __LINE__);                      \
    ARMCI_Error(buff, ret);                                \
  }                                                        \
}
#else
#define ARMCI_SAFE(fncall) fncall
#endif

#ifdef _ARMCI_DEBUG
#define MPI_SAFE(fncall)                              \
{                                                     \
  char errmsg[MPI_MAX_ERROR_STRING];                  \
  int len;                                            \
  int ret;                                            \
                                                      \
  ret = fncall;                                       \
  if (ret != MPI_SUCCESS) {                           \
    MPI_Error_string(ret, errmsg, &len);              \
    chpl_internal_error("MPI error:");                \
    chpl_internal_error(errmsg);                      \
    MPI_Abort(MPI_COMM_WORLD, ret);                   \
  }                                                   \
}
#else
#define MPI_SAFE(fncall) fncall
#endif

typedef struct {
  int               caller;
  chpl_bool         serial_state; // whether the current thread is allowed to spawn new threads
  chpl_fn_int_t     fid;
  chpl_bool         block; // whether the fork is blocking or not
  int               arg_size;
  char              arg[0];       // variable-sized data here
} dist_fork_t;

typedef struct {
  dist_fork_t *info; // Input data
  int *rhdr; // completion signal data
} gpc_info_t;

static int gpc_call_handler(int to, int from, void *hdr, int hlen,
                            void *data,  int dlen,
                            void *rhdr,  int rhlen, int *rhsize,
                            void *rdata, int rdlen, int *rdsize,
                            int rtype);
static int ghndl = -1;
static chpl_sync_aux_t armci_sync;

int32_t chpl_comm_getMaxThreads(void) {
  return 0; // set to 0 assuming ARMCI does not limit the number of
            // threads that can be running on a process
}

//
// initializes the communications package
//   set chpl_localeID and chpl_numLocales
// notes:
//   * For a user invocation of main(), this routine is called with
//     the argc/argv pair generated by chpl_comm_create_argcv
//   * For a comm-layer invocation of main(), it is called with the
//     argc/argv pair passed to main()

static int armci_init_called = 0;
static void **globalPtrs = NULL;

//
void chpl_comm_init(int *argc_p, char ***argv_p) {
  // This will probably be one of the trickiest routines to implement;
  // the details will depend on what sorts of mechanisms ARMCI
  // supports to create the multiple cooperating executables.  If, for
  // example, one needed to invoke an mpirun-like command to start the
  // program up, you'd want this routine to:
  //
  //   - for the user's invocation of the program, invoke that command
  //     on this same executable, adding an additional command line
  //     argument so that you could determine that those invocations
  //     were not the user's invocation
  //
  //   - for the non-user inovcations, you'd want to strip off those
  //     sentinel argv arguments so that Chapel's argument parsing
  //     routines wouldn't choke on them
  //
  // Don't forget to also set chpl_localeID and chpl_numLocales before
  // returning (this should only matter for the non-user invocations,
  // I believe)

  int nprocs, me;
  armci_size_t sz;

  chpl_sync_initAux(&armci_sync);

  MPI_SAFE(MPI_Init(argc_p, argv_p));
  ARMCI_SAFE(ARMCI_Init());
  armci_init_called = 1;

  MPI_SAFE(MPI_Comm_size(MPI_COMM_WORLD, &nprocs));
  MPI_SAFE(MPI_Comm_rank(MPI_COMM_WORLD, &me));

  chpl_localeID = me;
  chpl_numLocales = nprocs;

  globalPtrs = ARMCI_Malloc_local(chpl_numLocales * sizeof(void *));
  sz = _MAX_ARMCI_MEMSZ;

  ARMCI_SAFE(ARMCI_Malloc(globalPtrs, sz));

  ghndl = ARMCI_Gpc_register(gpc_call_handler);
}

void chpl_comm_post_mem_init(void) { }

int chpl_comm_run_in_gdb(int argc, char* argv[], int gdbArgnum, int* status) {
  chpl_error("--gdb not yet implemented for ARMCI", gdbArgnum, 
             "<command-line>");
  return 0;
}

void chpl_comm_post_task_init(void) { }

//
// a final comm layer stub before barrier synching and calling into
// the user code.  It is recommended that a debugging message be
// printed here indicating that each locale has started using
// chpl_msg() and a verbosity level of 2 (which will cause it to be
// displayed using the -v flag).
//
void chpl_comm_rollcall(void) {
  // Something like the following should work:
  chpl_msg(2, "executing on locale %d of %d locale(s)\n", chpl_localeID, 
            chpl_numLocales);
}

void chpl_comm_desired_shared_heap(void** start_p, size_t* size_p) {
  *start_p = chpl_numGlobalsOnHeap * sizeof(void*)
             + (char*)globalPtrs[chpl_localeID];
  *size_p  = _MAX_ARMCI_MEMSZ - chpl_numGlobalsOnHeap * sizeof(void*);
}

void chpl_comm_alloc_registry(int numGlobals) {
  chpl_globals_registry = globalPtrs[chpl_localeID];
}

void chpl_comm_broadcast_global_vars(int numGlobals) {
  int i;

  if (chpl_localeID != 0) {
    for (i = 0; i < numGlobals; i++)
      chpl_comm_get(chpl_globals_registry[i], 0, &((void **)globalPtrs[0])[i],
                    sizeof(void *), -1, 1, 0, "");
  }
}

typedef struct __broadcast_private_helper {
  int locid;
  void *raddr;
  int locale;
  size_t size;
} _broadcast_private_helper;

static void _broadcastPrivateHelperFn(struct __broadcast_private_helper *arg);

void _broadcastPrivateHelperFn(struct __broadcast_private_helper *arg) {
  chpl_comm_get(chpl_private_broadcast_table[arg->locid],
                arg->locale, arg->raddr, arg->size, -1, 1, 0, "");
}

void chpl_comm_broadcast_private(int id, int32_t size, int32_t tid) {
  int i;
  _broadcast_private_helper bph;
  void* heapAddr = NULL;

  heapAddr = chpl_mem_allocMany(1, size, CHPL_RT_MD_COMM_PRIVATE_BROADCAST_DATA, 0, 0);
  bcopy(chpl_private_broadcast_table[id], heapAddr, size);
  for (i = 0; i < chpl_numLocales; i++)
    if (i != chpl_localeID) {
      bph.locid = id;
      bph.raddr = heapAddr;
      bph.locale = chpl_localeID;
      bph.size = size;

      chpl_comm_fork(i, -1, &bph, sizeof(_broadcast_private_helper), -1);
    }
}

//
// barrier for synchronization between all processes; currently only
// used for startup and teardown.  msg is a string that can be used
// for debugging to determine where the barrier is being called.
//
void chpl_comm_barrier(const char *msg) {
  // Insert ARMCI barrier between all processes here
  ARMCI_Barrier();
}

void chpl_comm_pre_task_exit(int all) {
  if (all)
    chpl_comm_barrier("chpl_comm_pre_task_exit");
}

void chpl_comm_exit(int all, int status) {
  // Any or all threads should be able to call ARMCI exit
  if (armci_init_called) {
    if (globalPtrs)
      ARMCI_Free_local(globalPtrs);

    if (ghndl != -1)
      ARMCI_Gpc_release(ghndl);

    ARMCI_Finalize();
    MPI_SAFE(MPI_Finalize());
  }
}


//
// write 'size' bytes of local data at 'addr' to remote data at
// 'raddr' on locale 'locale'
// notes:
//   address is arbitrary
//   size and locale are part of p
//
void  chpl_comm_put(void* addr, int32_t locale, void* raddr,
                    int32_t elemSize, int32_t typeIndex, int32_t len,
                    int ln, chpl_string fn) {
  // this should be an ARMCI put call
  const int size = elemSize*len;
  if (chpl_localeID == locale)
    memmove(raddr, addr, size);
  else {
    chpl_sync_lock(&armci_sync);
    ARMCI_SAFE(ARMCI_Put(addr, raddr, size, locale));
    chpl_sync_unlock(&armci_sync);
  }
}


//
// read 'size' bytes of remote data at 'raddr' on locale 'locale' to
// local data at 'addr'
// notes:
//   address is arbitrary
//   size and locale are part of p
//
void  chpl_comm_get(void *addr, int32_t locale, void* raddr,
                    int32_t elemSize, int32_t typeIndex, int32_t len,
                    int ln, chpl_string fn) {
  // this should be an ARMCI get call
  const int size = elemSize*len;
  if (chpl_localeID == locale)
    memmove(addr, raddr, size);
  else {
    chpl_sync_lock(&armci_sync);
    ARMCI_SAFE(ARMCI_Get((void*)raddr, addr, size, locale));
    chpl_sync_unlock(&armci_sync);
  }
}

//
// remote fork should launch a thread on locale that runs function f
// passing it arg where the size of arg is stored in arg_size
// notes:
//   multiple forks to the same locale should be handled concurrently
//

static void chpl_comm_fork_common(int locale, chpl_fn_int_t fid, void *arg, int arg_size, chpl_bool block) {
  const int rhdr_size = sizeof(int);

  int ret;
  void *header;
  volatile void *rheader;
  void *rdata;
  int rdlen;
  dist_fork_t *info;
  int info_size;
  volatile int *done;

  if (chpl_localeID == locale) {
    if (fid == -1) {
      _broadcastPrivateHelperFn(arg);
    } else {
      (*chpl_ftable[fid])(arg);
    }
    return;
  }

  if (ghndl == -1) {
    chpl_internal_error("ARMCI GPC handler function not registered");
    return;
  }

  info_size = sizeof(dist_fork_t) + arg_size;
  info = (dist_fork_t *)chpl_mem_allocMany(info_size, sizeof(char), CHPL_RT_MD_COMM_FORK_SEND_INFO, 0, 0);

  info->caller = chpl_localeID;
  info->serial_state = chpl_task_getSerial();
  info->fid = fid;
  info->arg_size = arg_size;
  info->block = block;
  if (arg_size)
    bcopy(arg, &(info->arg), arg_size);

  if (arg_size > 0)
    rdata = chpl_mem_allocMany(arg_size, sizeof(char), CHPL_RT_MD_COMM_FORK_SEND_RESPONSE_DATA, 0, 0);
  else
    rdata = NULL;
  rdlen = arg_size;

  header = chpl_mem_allocMany(sizeof(void *), sizeof(char),
                              CHPL_RT_MD_COMM_FORK_SEND_INFO, 0, 0);
  rheader = chpl_mem_allocMany(rhdr_size, sizeof(char),
                               CHPL_RT_MD_COMM_FORK_SEND_INFO, 0, 0);
  // must be non-empty  

  *(intptr_t *)header = (intptr_t)rheader;

  done = rheader;
  *done = 0;

  chpl_sync_lock(&armci_sync);
  ret = ARMCI_Gpc_exec(ghndl, locale, header, sizeof(void *), info, info_size, (void *)rheader, rhdr_size,
                       rdata, rdlen, NULL);
  chpl_sync_unlock(&armci_sync);

  if (ret != 0) {
    chpl_internal_error("ARMCI_Gpc_exec() failed");
    chpl_mem_free(info, 0, 0);
    if (rdata)
      chpl_mem_free(rdata, 0, 0);
    chpl_mem_free(header, 0, 0);
    chpl_mem_free((void *)rheader, 0, 0);
    return;
  }

  while (block && *done == 0) {
#ifdef CHPL_COMM_YIELD_TASK_WHILE_POLLING
    chpl_task_yield();
#endif
  }

  chpl_mem_free(info, 0, 0);
  if (rdata) {
    if (block)
      bcopy(rdata, arg, rdlen);
    chpl_mem_free(rdata, 0, 0);
  }
  chpl_mem_free(header, 0, 0);
  chpl_mem_free((void *)rheader, 0, 0);
}

void  chpl_comm_fork(int locale, chpl_fn_int_t fid,
                     void *arg, int32_t arg_size, int32_t arg_tid) {
  chpl_comm_fork_common(locale, fid, arg, arg_size, true);
}

void  chpl_comm_fork_nb(int locale, chpl_fn_int_t fid,
                        void *arg, int32_t arg_size, int32_t arg_tid) {
  chpl_comm_fork_common(locale, fid, arg, arg_size, false);
}

// Same as chpl_comm_fork()
void  chpl_comm_fork_fast(int locale, chpl_fn_int_t fid,
                          void *arg, int32_t arg_size, int32_t arg_tid) {
  chpl_comm_fork_common(locale, fid, arg, arg_size, true);
}

int chpl_comm_numPollingTasks(void) { return 0; }

void chpl_startVerboseComm() { }
void chpl_stopVerboseComm() { }
void chpl_startVerboseCommHere() { }
void chpl_stopVerboseCommHere() { }

void chpl_startCommDiagnostics() { }
void chpl_stopCommDiagnostics() { }
void chpl_startCommDiagnosticsHere() { }
void chpl_stopCommDiagnosticsHere() { }

void chpl_resetCommDiagnosticsHere() { }
void chpl_getCommDiagnosticsHere(chpl_commDiagnostics *cd) {
  cd->put = -1;
  cd->get = -1;
  cd->get_nb = -1;
  cd->get_nb_test = -1;
  cd->get_nb_wait = -1;
  cd->fork = -1;
  cd->fork_fast = -1;
  cd->fork_nb = -1;
}

uint64_t chpl_numCommGets(void) { return -1; }
uint64_t chpl_numCommNBGets(void) { return -1; }
uint64_t chpl_numCommTestNBGets(void) { return -1; }
uint64_t chpl_numCommWaitNBGets(void) { return -1; }
uint64_t chpl_numCommPuts(void) { return -1; }
uint64_t chpl_numCommForks(void) { return -1; }
uint64_t chpl_numCommFastForks(void) { return -1; }
uint64_t chpl_numCommNBForks(void) { return -1; }

static void _gpc_thread_handler(void *arg);

int gpc_call_handler(int to, int from, void *hdr, int hlen,
                     void *data,  int dlen,
                     void *rhdr,  int rhlen, int *rhsize,
                     void *rdata, int rdlen, int *rdsize,
                     int rtype)
{
  dist_fork_t *finfo;
  gpc_info_t *ginfo;
  intptr_t prhdr;

  finfo = chpl_mem_allocMany(dlen, sizeof(char), CHPL_RT_MD_COMM_FORK_RECV_INFO, 0, 0);
  bcopy(data, finfo, dlen);

  ginfo = chpl_mem_allocMany(sizeof(gpc_info_t), sizeof(char), CHPL_RT_MD_COMM_FORK_RECV_INFO, 0, 0);
  ginfo->info = finfo;
  prhdr = *(intptr_t *)hdr;
  ginfo->rhdr = (int *)prhdr;

  chpl_task_begin(_gpc_thread_handler, ginfo, true, finfo->serial_state, NULL);

  /* Small return header */
  *rhsize = sizeof(int);
  *rdsize = 0;

  return GPC_DONE;
} /* gpc_call_handler */

void _gpc_thread_handler(void *arg)
{
  gpc_info_t *ginfo;
  int *done;

  done = ARMCI_Malloc_local(sizeof(int));

  *done = 0;
  ginfo = (gpc_info_t *)arg;

  if (ginfo->info->fid == -1)
    _broadcastPrivateHelperFn((struct __broadcast_private_helper*)(ginfo->info->arg));
  else if (ginfo->info->arg_size)
    (*chpl_ftable[ginfo->info->fid])(ginfo->info->arg);
  else
    (*chpl_ftable[ginfo->info->fid])(0);

  *done = 1;

  if (ginfo->info->block)
    chpl_comm_put(done, ginfo->info->caller, ginfo->rhdr, sizeof(int), -1, 1, 0, "");

  ARMCI_Free_local(done);

  chpl_mem_free(ginfo->info, 0, 0);
  chpl_mem_free(ginfo, 0, 0);
} /* _gpc_thread_handler */


void chpl_comm_armci_help_register_global_var(int i, void* addr) {
  if (chpl_localeID == 0) {
    ((void **)globalPtrs[0])[i] = addr;
  }
}
