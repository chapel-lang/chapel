<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>MassiveThreads User&rsquo;s Guide</title>

<meta name="description" content="MassiveThreads User&rsquo;s Guide">
<meta name="keywords" content="MassiveThreads User&rsquo;s Guide">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body{
  font-family      :times-roman;
  font-size        :16pt;
}

h1{
  color            :#036;
  font-size        :28pt;
  padding          :14pt;

  border-style     :solid;
  border-color     :#c00;
  border-width     :1px;
  text-align       :center;
}

h2{
  color            :#036;
  font-size        :24pt;
  padding          :12pt;

  border-style     :solid;
  border-color     :#c00;
  border-width     :1px;
}


h3{
  color            :#036;
  font-size        :20pt;
  padding          :10pt;

  border-style     :solid;
  border-color     :#c00;
  border-width     :0px 0px 1px 0px;
}

h4{
  color            :#036;
  font-size        :16pt;
  padding          :8pt;

  border-style     :solid;
  border-color     :#c00;
  border-width     :0px 0px 1px 0px;
}

div.header { 
  padding          :2pt;
  font-size        :12pt;
  border-style     :solid;
  border-width     :1px;
}

div.example { 
  padding          :2pt;
  font-size        :14pt;
  border-style     :solid;
  border-width     :1px;
}




-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">MassiveThreads User&rsquo;s Guide</h1>


<p>Copyright 2010-2014 Jun Nakashima (Read COPYRIGHT for detailed information.)
</p>
<p>Copyright 2010-2014 Kenjiro Taura (Read COPYRIGHT for detailed information.)
</p>

<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">
<ul class="no-bullet">
<li><a name="toc-Getting-Started" href="#Top">1 Getting Started</a></li>
<li><a name="toc-MassiveThreads-Library-1" href="#MassiveThreads-Library">2 MassiveThreads Library</a></li>
<li><a name="toc-Higher_002dLevel-Interfaces-1" href="#Higher_002dLevel-Interfaces">3 Higher-Level Interfaces</a>
<ul class="no-bullet">
  <li><a name="toc-Higher-Level-Interfaces-Overview-1" href="#Higher-Level-Interfaces-Overview">3.1 Higher Level Interfaces Overview</a></li>
  <li><a name="toc-TBB_002dCompatible-Interface-1" href="#TBB_002dCompatible-Interface">3.2 TBB-Compatible Interface</a>
  <ul class="no-bullet">
    <li><a name="toc-TBB_002dCompatible-Interface-Overview-1" href="#TBB_002dCompatible-Interface-Overview">3.2.1 TBB-Compatible Interface Overview</a></li>
    <li><a name="toc-Installing-TBB_002dCompatible-Interface-1" href="#Installing-TBB_002dCompatible-Interface">3.2.2 Installing TBB-Compatible Interface</a></li>
    <li><a name="toc-Writing-Programs-Using-TBB_002dCompatible-Interface-1" href="#Writing-Programs-Using-TBB_002dCompatible-Interface">3.2.3 Writing Programs Using TBB-Compatible Interface</a></li>
    <li><a name="toc-Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface-1" href="#Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface">3.2.4 Choosing Schedulers Beneath the TBB-Compatible Interface</a></li>
  </ul></li>
  <li><a name="toc-Task-Parallel-Switcher-1" href="#Task-Parallel-Switcher">3.3 Task Parallel Switcher</a></li>
</ul></li>
<li><a name="toc-DAG-Recorder-1" href="#DAG-Recorder">4 DAG Recorder</a>
<ul class="no-bullet">
  <li><a name="toc-DAG-Recorder-Overview-1" href="#DAG-Recorder-Overview">4.1 DAG Recorder Overview</a></li>
  <li><a name="toc-Installing-DAG-Recorder-1" href="#Installing-DAG-Recorder">4.2 Installing DAG Recorder</a></li>
  <li><a name="toc-Writing-Programs-That-Use-DAG-Recorder-1" href="#Writing-Programs-That-Use-DAG-Recorder">4.3 Writing Programs That Use DAG Recorder</a>
  <ul class="no-bullet">
    <li><a name="toc-Common-Basics-1" href="#Common-Basics">4.3.1 Common Basics</a></li>
    <li><a name="toc-Using-DAG-Recorder-with-TBB_002dCompatible-Interface-1" href="#Using-DAG-Recorder-with-TBB_002dCompatible-Interface">4.3.2 Using DAG Recorder with TBB-Compatible Interface</a></li>
    <li><a name="toc-Using-DAG-Recorder-with-OpenMP-1" href="#Using-DAG-Recorder-with-OpenMP">4.3.3 Using DAG Recorder with OpenMP</a></li>
    <li><a name="toc-Using-DAG-Recorder-with-Cilk-and-CilkPlus-1" href="#Using-DAG-Recorder-with-Cilk-and-CilkPlus">4.3.4 Using DAG Recorder with Cilk and CilkPlus</a></li>
    <li><a name="toc-Using-DAG-Recorder-with-tpswitch_002eh-1" href="#Using-DAG-Recorder-with-tpswitch_002eh">4.3.5 Using DAG Recorder with tpswitch.h</a></li>
  </ul></li>
  <li><a name="toc-Running-Your-Programs-with-DAG-Recorder-1" href="#Running-Your-Programs-with-DAG-Recorder">4.4 Running Your Programs with DAG Recorder</a>
  <ul class="no-bullet">
    <li><a name="toc-Basics-of-Running-Your-Programs-with-DAG-Recorder-1" href="#Basics-of-Running-Your-Programs-with-DAG-Recorder">4.4.1 Basics of Running Your Programs with DAG Recorder</a></li>
    <li><a name="toc-Controlling-the-Behavior-of-DAG-Recorder-1" href="#Controlling-the-Behavior-of-DAG-Recorder">4.4.2 Controlling the Behavior of DAG Recorder</a></li>
  </ul></li>
  <li><a name="toc-dag2any-DAG-to-any-data-converter-1" href="#dag2any-DAG-to-any-data-converter">4.5 dag2any DAG to any data converter</a></li>
  <li><a name="toc-Viewing-Recorded-Data-1" href="#Viewing-Recorded-Data">4.6 Viewing Recorded Data</a>
  <ul class="no-bullet">
    <li><a name="toc-Viewing-Parallelism-Profile-with-gnuplot-1" href="#Viewing-Parallelism-Profile-with-gnuplot">4.6.1 Viewing Parallelism Profile with gnuplot</a></li>
    <li><a name="toc-Visualizing-the-DAG-via-graphviz-1" href="#Visualizing-the-DAG-via-graphviz">4.6.2 Visualizing the DAG via graphviz</a></li>
    <li><a name="toc-Understanding-Stat-File-1" href="#Understanding-Stat-File">4.6.3 Understanding Stat File</a></li>
    <li><a name="toc-Viewing-DAG-file-with-drview-1" href="#Viewing-DAG-file-with-drview">4.6.4 Viewing DAG file with drview</a></li>
  </ul></li>
  <li><a name="toc-Querying-Recorded-Data-1" href="#Querying-Recorded-Data">4.7 Querying Recorded Data</a></li>
</ul></li>

</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#MassiveThreads-Library" accesskey="n" rel="next">MassiveThreads Library</a>, Previous: <a href="dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>

<a name="Getting-Started"></a>
<h2 class="chapter">1 Getting Started</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#MassiveThreads-Library" accesskey="1">MassiveThreads Library</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Higher_002dLevel-Interfaces" accesskey="2">Higher-Level Interfaces</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DAG-Recorder" accesskey="3">DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment"> &mdash; The Detailed Node Listing &mdash;

Higher-Level Interfaces

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Higher-Level-Interfaces-Overview" accesskey="4">Higher Level Interfaces Overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TBB_002dCompatible-Interface" accesskey="5">TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Task-Parallel-Switcher" accesskey="6">Task Parallel Switcher</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
TBB-Compatible Interface

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#TBB_002dCompatible-Interface-Overview" accesskey="7">TBB-Compatible Interface Overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-TBB_002dCompatible-Interface" accesskey="8">Installing TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Writing-Programs-Using-TBB_002dCompatible-Interface" accesskey="9">Writing Programs Using TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface">Choosing Schedulers Beneath the TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
DAG Recorder

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#DAG-Recorder-Overview">DAG Recorder Overview </a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-DAG-Recorder">Installing DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Writing-Programs-That-Use-DAG-Recorder">Writing Programs That Use DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Running-Your-Programs-with-DAG-Recorder">Running Your Programs with DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dag2any-DAG-to-any-data-converter">dag2any DAG to any data converter</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Viewing-Recorded-Data">Viewing Recorded Data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Querying-Recorded-Data">Querying Recorded Data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Writing Programs That Use DAG Recorder

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Common-Basics">Common Basics</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-TBB_002dCompatible-Interface">Using DAG Recorder with TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-OpenMP">Using DAG Recorder with OpenMP</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-Cilk-and-CilkPlus">Using DAG Recorder with Cilk and CilkPlus</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-tpswitch_002eh">Using DAG Recorder with tpswitch.h</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Running Your Programs with DAG Recorder

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Basics-of-Running-Your-Programs-with-DAG-Recorder">Basics of Running Your Programs with DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Controlling-the-Behavior-of-DAG-Recorder">Controlling the Behavior of DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Viewing Recorded Data

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Viewing-Parallelism-Profile-with-gnuplot">Viewing Parallelism Profile with gnuplot </a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Visualizing-the-DAG-via-graphviz">Visualizing the DAG via graphviz</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Understanding-Stat-File">Understanding Stat File</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Viewing-DAG-file-with-drview">Viewing DAG file with drview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr></table>

<hr>
<a name="MassiveThreads-Library"></a>
<div class="header">
<p>
Next: <a href="#Higher_002dLevel-Interfaces" accesskey="n" rel="next">Higher-Level Interfaces</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="MassiveThreads-Library-1"></a>
<h2 class="chapter">2 MassiveThreads Library</h2>

<p>TODO: write about the library API itself.
</p>
<hr>
<a name="Higher_002dLevel-Interfaces"></a>
<div class="header">
<p>
Next: <a href="#DAG-Recorder" accesskey="n" rel="next">DAG Recorder</a>, Previous: <a href="#MassiveThreads-Library" accesskey="p" rel="prev">MassiveThreads Library</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Higher_002dLevel-Interfaces-1"></a>
<h2 class="chapter">3 Higher-Level Interfaces</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Higher-Level-Interfaces-Overview" accesskey="1">Higher Level Interfaces Overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TBB_002dCompatible-Interface" accesskey="2">TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Task-Parallel-Switcher" accesskey="3">Task Parallel Switcher</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Higher-Level-Interfaces-Overview"></a>
<div class="header">
<p>
Next: <a href="#TBB_002dCompatible-Interface" accesskey="n" rel="next">TBB-Compatible Interface</a>, Previous: <a href="#Higher_002dLevel-Interfaces" accesskey="p" rel="prev">Higher-Level Interfaces</a>, Up: <a href="#Higher_002dLevel-Interfaces" accesskey="u" rel="up">Higher-Level Interfaces</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Higher-Level-Interfaces-Overview-1"></a>
<h3 class="section">3.1 Higher Level Interfaces Overview</h3>

<p>MassiveThreads API described so far is still low level and bit
burdensome as a parallel programming interface.  MassiveThreads also
provides higher level APIs, easier and more convenient APIs for
programmers.
</p>
<p>One is what we call <i>TBB-compatible interface</i>, that provides a subset
of functions of Intel Threading Building Block.  It does not only
provide TBB-compatible interface, but also allows you to switch between
various lightweight thread libraries under the same TBB-compatible
interface.  Currently supported libraries include MassiveThreads,
Qthreads, Nanos++, and what we call a dummy scheduler.  The last one
elides task parallel primitives.
</p>
<p>The other interface is what we call a <i>task parallel switcher</i>, with
which you can write a single program running on top of even wider set of
task parallel systems including OpenMP, Cilk, and TBB.
</p>
<p>Besides providing a uniform API on various runtime systems, they serve
another important purpose, which is to allow you to trace your task
parallel programs with DAG Recorder, a tracing tool described later in
this manual. See <a href="#DAG-Recorder">DAG Recorder</a>. By programming in these APIs, rather
than in the native API of the respective runtime system, your are free
from the burden of manually instrumenting your programs for tracing.  To
this end, we also provide headers to facilitate instrumentation of
OpenMP and Cilk.  They do not serve any purpose of making OpenMP and
Cilk more convenient nor more uniform; they simply make instrumenting
OpenMP and Cilk easier.
</p>
<p>Here is the summary of choices of APIs and runtime systems.
</p>
<table>
<thead><tr><th width="25%">API</th><th width="20%">Runtime System</th><th width="25%">Header file</th><th width="30%">flags</th></tr></thead>
<tr><td width="25%">TBB-compatible</td><td width="20%">None (dummy)</td><td width="25%"><code>mtbb/task_group.h</code></td><td width="30%"><code>-DTO_SERIAL</code></td></tr>
<tr><td width="25%">TBB-compatible</td><td width="20%">Intel TBB</td><td width="25%"><code>mtbb/task_group.h</code></td><td width="30%"><code>-DTO_TBB -ltbb</code></td></tr>
<tr><td width="25%">TBB-compatible</td><td width="20%">MassiveThreads</td><td width="25%"><code>mtbb/task_group.h</code></td><td width="30%"><code>-lmyth-native</code></td></tr>
<tr><td width="25%">TBB-compatible</td><td width="20%">Qthreads</td><td width="25%"><code>mtbb/task_group.h</code></td><td width="30%"><code>-DTO_QTHREAD -lqthread</code></td></tr>
<tr><td width="25%">TBB-compatible</td><td width="20%">Nanos++</td><td width="25%"><code>mtbb/task_group.h</code></td><td width="30%"><code>-DTO_NANOX -lnanox-c</code></td></tr>
<tr><td width="25%">OpenMP-like</td><td width="20%">OpenMP</td><td width="25%"><code>tpswitch/omp_dr.h</code></td><td width="30%"></td></tr>
<tr><td width="25%">Cilk-like</td><td width="20%">Cilk</td><td width="25%"><code>tpswitch/cilk_dr.h</code></td><td width="30%"></td></tr>
<tr><td width="25%">Cilkplus-like</td><td width="20%">Cilkplus</td><td width="25%"><code>tpswitch/cilk_dr.h</code></td><td width="30%"></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">None (dummy)</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_SERIAL</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">Intel TBB</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code> -DTO_TBB -ltbb</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">MassiveThreads</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_MTHREAD_NATIVE -lmyth-native</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">Qthreads</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_QTHREAD -lqthread</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">Nanos++</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_NANOX -lnanox-c</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">OpenMP</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_OMP</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">Cilk</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_CILK</code></td></tr>
<tr><td width="25%">Task Parallel Switcher</td><td width="20%">Cilkplus</td><td width="25%"><code>tpswitch/tpswitch.h</code></td><td width="30%"><code>-DTO_CILKPLUS</code></td></tr>
</table>

<hr>
<a name="TBB_002dCompatible-Interface"></a>
<div class="header">
<p>
Next: <a href="#Task-Parallel-Switcher" accesskey="n" rel="next">Task Parallel Switcher</a>, Previous: <a href="#Higher-Level-Interfaces-Overview" accesskey="p" rel="prev">Higher Level Interfaces Overview</a>, Up: <a href="#Higher_002dLevel-Interfaces" accesskey="u" rel="up">Higher-Level Interfaces</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="TBB_002dCompatible-Interface-1"></a>
<h3 class="section">3.2 TBB-Compatible Interface</h3>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#TBB_002dCompatible-Interface-Overview" accesskey="1">TBB-Compatible Interface Overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-TBB_002dCompatible-Interface" accesskey="2">Installing TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Writing-Programs-Using-TBB_002dCompatible-Interface" accesskey="3">Writing Programs Using TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface" accesskey="4">Choosing Schedulers Beneath the TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="TBB_002dCompatible-Interface-Overview"></a>
<div class="header">
<p>
Next: <a href="#Installing-TBB_002dCompatible-Interface" accesskey="n" rel="next">Installing TBB-Compatible Interface</a>, Previous: <a href="#TBB_002dCompatible-Interface" accesskey="p" rel="prev">TBB-Compatible Interface</a>, Up: <a href="#TBB_002dCompatible-Interface" accesskey="u" rel="up">TBB-Compatible Interface</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="TBB_002dCompatible-Interface-Overview-1"></a>
<h4 class="subsection">3.2.1 TBB-Compatible Interface Overview</h4>

<p>As of writing, it supports <samp>task_group</samp> class, <samp>parallel_for</samp>
template function, and <samp>parallel_reduce</samp> template function.  See
respective sections of the TBB reference manual for these classes.
We will see examples using <samp>task_group</samp> class below.
</p>
<hr>
<a name="Installing-TBB_002dCompatible-Interface"></a>
<div class="header">
<p>
Next: <a href="#Writing-Programs-Using-TBB_002dCompatible-Interface" accesskey="n" rel="next">Writing Programs Using TBB-Compatible Interface</a>, Previous: <a href="#TBB_002dCompatible-Interface-Overview" accesskey="p" rel="prev">TBB-Compatible Interface Overview</a>, Up: <a href="#TBB_002dCompatible-Interface" accesskey="u" rel="up">TBB-Compatible Interface</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Installing-TBB_002dCompatible-Interface-1"></a>
<h4 class="subsection">3.2.2 Installing TBB-Compatible Interface</h4>

<p>TBB-compatible interface is distributed as a part of MassiveThreads, so
you do not do anything particular to install it besides the installation
procedure of MassiveThreads.
</p>
<p>After installation, the files constituting the API are installed as:
</p><ul>
<li> <i>PREFIX</i><samp>/include/mtbb/task_group.h</samp>
</li><li> <i>PREFIX</i><samp>/include/mtbb/parallel_for.h</samp>
</li><li> <i>PREFIX</i><samp>/include/mtbb/parallel_reduce.h</samp>
</li></ul>
<p>Note that they are under <samp>mtbb</samp> directory, instead of <samp>tbb</samp>
directory as in the original TBB.
</p>
<hr>
<a name="Writing-Programs-Using-TBB_002dCompatible-Interface"></a>
<div class="header">
<p>
Next: <a href="#Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface" accesskey="n" rel="next">Choosing Schedulers Beneath the TBB-Compatible Interface</a>, Previous: <a href="#Installing-TBB_002dCompatible-Interface" accesskey="p" rel="prev">Installing TBB-Compatible Interface</a>, Up: <a href="#TBB_002dCompatible-Interface" accesskey="u" rel="up">TBB-Compatible Interface</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Writing-Programs-Using-TBB_002dCompatible-Interface-1"></a>
<h4 class="subsection">3.2.3 Writing Programs Using TBB-Compatible Interface</h4>

<p>Using TBB-Compatible interface is a lot like using the regular TBB.  You
include <samp>mtbb/{task_group,parallel_for,parallel_reduce}.h</samp>
instead of <samp>tbb/{task_group,parallel_for,parallel_reduce}.h</samp>, and
use namespace <samp>mtbb</samp> instead of namespace <samp>tbb</samp>.
</p>
<p>Here is a simple example (<samp>bin_mtbb.cc</samp>).
</p><div class="example">
<pre class="verbatim">#include &lt;mtbb/task_group.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    mtbb::task_group tg;
    long x, y;
    tg.run([=,&amp;x] { x = bin(n - 1); });
    y = bin(n - 1);
    tg.wait();
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x = bin(n);
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}

</pre></div>

<p>I hope you agree that changes are minimal.  The original TBB version
would look like this (only differences are the file name of the include
file and namespace prefix of the <samp>task_group</samp> class).
</p>
<div class="example">
<pre class="verbatim">#include &lt;tbb/task_group.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    tbb::task_group tg;
    long x, y;
    tg.run([=,&amp;x] { x = bin(n - 1); });
    y = bin(n - 1);
    tg.wait();
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x = bin(n);
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}

</pre></div>

<p>Without DAG Recorder, you would compile <samp>bin_mtbb.cc</samp> as follows.
</p><div class="example">
<pre class="verbatim">$ g++ --std=c++0x bin_mtbb.cc -lmyth-native
</pre></div>

<p>Remark 1: <samp>--std=c++0x</samp> is given to use C++ lambda expression at
line 8, proposed in C++0x and standardized in C++11.  GCC supports it
since 4.5, when one of the following command line options
<samp>--std=c++0x, --std=gnu0x, --std=c++11</samp>, or <samp>--std=gnu11</samp> is
supplied.  If your GCC does not support it, you could pass any callable
object (any object supporting <samp>operator()</samp>).  We use lambda
expressions for brevity in this manual.
</p>
<p>Remark 2: Depending on your configuration, you might need to add
<samp>-I, -L,</samp> and <samp>-Wl,-R</samp> options to the command line.  For
example, if you install MassiveThreads under <samp>/home/you/local</samp> (i.e.,
gave <samp>/home/you/local</samp> to <samp>--prefix</samp> of the <samp>configure</samp>
command), the command line will be:
</p><div class="example">
<pre class="verbatim">$ g++ --std=c++0x -I/home/you/local/include -L/home/you/local/lib -Wl,-R/home/you/local/lib bin_mtbb.cc -lmyth-native
</pre></div>

<hr>
<a name="Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface"></a>
<div class="header">
<p>
Previous: <a href="#Writing-Programs-Using-TBB_002dCompatible-Interface" accesskey="p" rel="prev">Writing Programs Using TBB-Compatible Interface</a>, Up: <a href="#TBB_002dCompatible-Interface" accesskey="u" rel="up">TBB-Compatible Interface</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface-1"></a>
<h4 class="subsection">3.2.4 Choosing Schedulers Beneath the TBB-Compatible Interface</h4>

<p>With the above command, you get a program that uses TBB-compatible API
with MassiveThreads as the underlying scheduler.  Roughly speaking,
task_group&rsquo;s <samp>run</samp> method will create a thread of MassiveThreads
library via <samp>myth_create</samp> and wait method will wait for all threads
associated with the task group object to finish via <samp>myth_join</samp>.
</p>
<p>The <samp>mtbb/task_group.h</samp> file allows you to use threading libraries other than MassiveThreads, by defining a compile time flag <samp>TO_XXX</samp>.  Currently, you can choose from the original Intel TBB, MassiveThreads, Qthreads, Nanos++, or None.  Flags you should give to them are listed below.
</p>
<table>
<thead><tr><th width="50%">Runtime system</th><th width="50%">Flag</th></tr></thead>
<tr><td width="50%">Intel TBB</td><td width="50%"><samp>-DTO_TBB</samp></td></tr>
<tr><td width="50%">MassiveThreads</td><td width="50%"><samp>-DTO_MTHREAD_NATIVE</samp> (or nothing)</td></tr>
<tr><td width="50%">Qthreads</td><td width="50%"><samp>-DTO_QTHREAD</samp></td></tr>
<tr><td width="50%">Nanos++</td><td width="50%"><samp>-DTO_NANOX</samp></td></tr>
<tr><td width="50%">None</td><td width="50%"><samp>-DTO_SERIAL</samp></td></tr>
</table>

<p>The last one, None, elides all tasking primitives; <samp>run(<i>c</i>)</samp> executes <samp><i>c</i>()</samp> serially and <samp>wait()</samp> is a noop.  
</p>
<p>In order to use <samp>mtbb/task_group.h</samp> with the scheduler you chose, you of course need to install the respective scheduler and link your program with it.  
</p>
<hr>
<a name="Task-Parallel-Switcher"></a>
<div class="header">
<p>
Previous: <a href="#TBB_002dCompatible-Interface" accesskey="p" rel="prev">TBB-Compatible Interface</a>, Up: <a href="#Higher_002dLevel-Interfaces" accesskey="u" rel="up">Higher-Level Interfaces</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Task-Parallel-Switcher-1"></a>
<h3 class="section">3.3 Task Parallel Switcher</h3>

<p>TBB-compatible interface unifies various schedulers under the same,
TBB-compatible interface.  Task parallel switcher goes one step further 
by defining an API that can be mapped onto OpenMP and Cilk as well.
</p>
<p>OpenMP, Cilk, and TBB&rsquo;s task_group interfaces are all conceptually very
similar; they all define ways to create tasks and wait for outstanding
tasks to finish, after all.
</p>
<p>Yet there are idiosyncrasies that make defining truly uniform APIs
difficult.  
</p>
<p>TODO: detail the following
</p>
<ul>
<li> mk_task_group
</li><li> create_taskc
</li><li> create_task0
</li><li> create_task1
</li><li> create_task2
</li><li> create_taskA
</li><li> call_task
</li><li> call_taskc
</li><li> create_task_and_wait
</li><li> wait_tasks
</li></ul>

<hr>
<a name="DAG-Recorder"></a>
<div class="header">
<p>
Previous: <a href="#Higher_002dLevel-Interfaces" accesskey="p" rel="prev">Higher-Level Interfaces</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DAG-Recorder-1"></a>
<h2 class="chapter">4 DAG Recorder</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#DAG-Recorder-Overview" accesskey="1">DAG Recorder Overview </a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-DAG-Recorder" accesskey="2">Installing DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="3">Writing Programs That Use DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Running-Your-Programs-with-DAG-Recorder" accesskey="4">Running Your Programs with DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dag2any-DAG-to-any-data-converter" accesskey="5">dag2any DAG to any data converter</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Viewing-Recorded-Data" accesskey="6">Viewing Recorded Data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Querying-Recorded-Data" accesskey="7">Querying Recorded Data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="DAG-Recorder-Overview"></a>
<div class="header">
<p>
Next: <a href="#Installing-DAG-Recorder" accesskey="n" rel="next">Installing DAG Recorder</a>, Previous: <a href="#DAG-Recorder" accesskey="p" rel="prev">DAG Recorder</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DAG-Recorder-Overview-1"></a>
<h3 class="section">4.1 DAG Recorder Overview</h3>

<p>DAG Recorder is a tracing tool to analyze execution of task parallel
programs.  It records all relevant events in an execution of the
program, such as task start, task creation, and task synchronization and
stores them in a manner that is able to reconstruct the computational
DAG of the execution.
</p>
<hr>
<a name="Installing-DAG-Recorder"></a>
<div class="header">
<p>
Next: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="n" rel="next">Writing Programs That Use DAG Recorder</a>, Previous: <a href="#DAG-Recorder-Overview" accesskey="p" rel="prev">DAG Recorder Overview</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Installing-DAG-Recorder-1"></a>
<h3 class="section">4.2 Installing DAG Recorder</h3>

<p>DAG Recorder is distributed as a part of MassiveThreads, so installing
MassiveThreads automatically installs DAG Recorder too.  DAG Recorder
does not internally depend on MassiveThreads in any way, however; you
can, for example, use DAG Recorder to analyze TBB or OpenMP programs.  
</p>
<p>After installation, files directly visible to the user are the following.
</p><ul>
<li> <i>PREFIX</i><samp>/lib/libdr.so</samp> &mdash; library
</li><li> <i>PREFIX</i><samp>/include/dag_recorder.h</samp> &mdash; include file
</li></ul>
<p>where PREFIX is the path you specified with <samp>--prefix</samp> at
<samp>configure</samp> command line.  
</p>
<p>In most cases, you do not have to directly include
<samp>dag_recorder.h</samp>.  TBB-compatible interface or aforementioned
wrappers (<samp>omp_dr.h</samp> and <samp>cilk_dr.h</samp>) will automatically
include it.
</p>
<hr>
<a name="Writing-Programs-That-Use-DAG-Recorder"></a>
<div class="header">
<p>
Next: <a href="#Running-Your-Programs-with-DAG-Recorder" accesskey="n" rel="next">Running Your Programs with DAG Recorder</a>, Previous: <a href="#Installing-DAG-Recorder" accesskey="p" rel="prev">Installing DAG Recorder</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Writing-Programs-That-Use-DAG-Recorder-1"></a>
<h3 class="section">4.3 Writing Programs That Use DAG Recorder</h3>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Common-Basics" accesskey="1">Common Basics</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-TBB_002dCompatible-Interface" accesskey="2">Using DAG Recorder with TBB-Compatible Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-OpenMP" accesskey="3">Using DAG Recorder with OpenMP</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-Cilk-and-CilkPlus" accesskey="4">Using DAG Recorder with Cilk and CilkPlus</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-DAG-Recorder-with-tpswitch_002eh" accesskey="5">Using DAG Recorder with tpswitch.h</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Common-Basics"></a>
<div class="header">
<p>
Next: <a href="#Using-DAG-Recorder-with-TBB_002dCompatible-Interface" accesskey="n" rel="next">Using DAG Recorder with TBB-Compatible Interface</a>, Previous: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="p" rel="prev">Writing Programs That Use DAG Recorder</a>, Up: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="u" rel="up">Writing Programs That Use DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Common-Basics-1"></a>
<h4 class="subsection">4.3.1 Common Basics</h4>

<p>Currently, DAG Recorder supports the following task parallel APIs.
</p>
<ul>
<li> TBB or the TBB-compatible interface See <a href="#Writing-Programs-Using-TBB_002dCompatible-Interface">Writing Programs Using TBB-Compatible Interface</a>.
</li><li> OpenMP. #pragma task and #pragma taskwait
</li><li> Cilk and Cilkplus. spawn and sync
</li></ul>

<p>Making your programs ready for DAG Recorder involves replacing original
task parallel primitives with equivalent, instrumented versions.  You
also need to specify where to start/stop instrumentation and dump the
result.  We provide header files to make the instrumentation nearly
automatic or at least quite mechanical.  What you exactly need to do
depends on the programming model you chose and are detailed in the
following subsections.
</p>
<hr>
<a name="Using-DAG-Recorder-with-TBB_002dCompatible-Interface"></a>
<div class="header">
<p>
Next: <a href="#Using-DAG-Recorder-with-OpenMP" accesskey="n" rel="next">Using DAG Recorder with OpenMP</a>, Previous: <a href="#Common-Basics" accesskey="p" rel="prev">Common Basics</a>, Up: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="u" rel="up">Writing Programs That Use DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-DAG-Recorder-with-TBB_002dCompatible-Interface-1"></a>
<h4 class="subsection">4.3.2 Using DAG Recorder with TBB-Compatible Interface</h4>

<p>If you are using TBB-Compatible Interface (see <a href="#Writing-Programs-Using-TBB_002dCompatible-Interface">Writing Programs Using TBB-Compatible Interface</a>), the instrumentation is most straightforward and least intrusive.  Let&rsquo;s say you have a program including <samp>mtbb/task_group.h</samp> such as this.
</p><div class="example">
<pre class="verbatim">#include &lt;mtbb/task_group.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    mtbb::task_group tg;
    long x, y;
    tg.run([=,&amp;x] { x = bin(n - 1); });
    y = bin(n - 1);
    tg.wait();
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x = bin(n);
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}

</pre></div>

<p>Instrumentation is turned on simply by giving <code>-DDAG_RECORDER=2</code> at the command line.  What else you need to do is to insert calls to <code>dr_start, dr_stop,</code> and <code>dr_dump</code> at appropriate places like this  (<samp>bin_mtbb_dr.cc</samp>).
</p><div class="example">
<pre class="verbatim">#include &lt;mtbb/task_group.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    mtbb::task_group tg;
    long x, y;
    tg.run([=,&amp;x] { x = bin(n - 1); });
    y = bin(n - 1);
    tg.wait();
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  dr_start(0);
  long x = bin(n);
  dr_stop();
  dr_dump();
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}

</pre></div>

<p>As you will see already, you should insert:
</p><ul>
<li> <code>dr_start(0)</code> at the point you want to start recording,
</li><li> <code>dr_stop()</code> at the point you want to stop recording, and
</li><li> <code>dr_dump()</code> at the point you want to dump the result.
</li></ul>

<p><code>dr_start</code> takes a pointer, which may be zero, to <code>dr_options</code> data structure as the argument.  
<a href="#Controlling-the-Behavior-of-DAG-Recorder">Controlling the Behavior of DAG Recorder</a> for options you can specify.
</p>
<p>Here are the command lines to compile this program, with and without DAG Recorder
</p><ul>
<li> with DAG Recorder:
<div class="example">
<pre class="verbatim">g++ --std=c++0x bin_mtbb_dr.cc -DDAG_RECORDER=2 -ldr -lmyth-native 
</pre></div>
</li><li> without DAG Recorder:
<div class="example">
<pre class="verbatim">g++ --std=c++0x bin_mtbb_dr.cc -lmyth-native
</pre></div>
</li></ul>

<p>The reason why you set DAG_RECORDER to &ldquo;2&rdquo; is historical.  There was a version one, which have become obsolete by now.
</p>
<p>You could switch to other schedulers in the way described already. See <a href="#Choosing-Schedulers-Beneath-the-TBB_002dCompatible-Interface">Choosing Schedulers Beneath the TBB-Compatible Interface</a>.  For example, you will get the original TBB scheduler with the following command line.
</p><div class="example">
<pre class="verbatim">g++ --std=c++0x bin_mtbb_dr.cc -DTO_TBB -DDAG_RECORDER=2 -ldr -ltbb 
</pre></div>

<hr>
<a name="Using-DAG-Recorder-with-OpenMP"></a>
<div class="header">
<p>
Next: <a href="#Using-DAG-Recorder-with-Cilk-and-CilkPlus" accesskey="n" rel="next">Using DAG Recorder with Cilk and CilkPlus</a>, Previous: <a href="#Using-DAG-Recorder-with-TBB_002dCompatible-Interface" accesskey="p" rel="prev">Using DAG Recorder with TBB-Compatible Interface</a>, Up: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="u" rel="up">Writing Programs That Use DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-DAG-Recorder-with-OpenMP-1"></a>
<h4 class="subsection">4.3.3 Using DAG Recorder with OpenMP</h4>

<p>OpenMP uses directives (<code>pragma omp task</code> and <code>pragma omp
taskwait</code>) to express task parallel programs.  It almost always uses
<code>pragma omp parallel</code> and <code>pragma omp single</code> (or <code>pragma
omp master</code>) to enter a task parallel section.  Here is an equivalent
program to our example, written in the regular OpenMP.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    long x, y;
#pragma omp task shared(x)
    x = bin(n - 1);
#pragma omp task shared(y)
    y = bin(n - 1);
#pragma omp taskwait
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
#pragma omp parallel 
#pragma omp single
  {
    long x = bin(n);
    printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  }
  return 0;
}

</pre></div>

<p>We need to instrument these pragmas, for which we defined equivalent
<i>macros</i> (not pragmas) in a header file <samp>tpswitch/omp_dr.h</samp>.
This is not as straightforward as we hope, but we do not know any good
mechanism to introduce a new pragma or redefine existing pragmas.
</p>
<p><samp>tpswitch/omp_dr.h</samp> defines the following macros.
</p>
<ul>
<li> <code>pragma_omp_task(<i>clauses, statement</i>)</code>
</li><li> <code>pragma_omp_taskwait</code>
</li><li> <code>pragma_omp_parallel_single(<i>clauses, statement</i>)</code>
</li></ul>

<p>Without DAG Recorder, they are expanded into equivalent OpenMP pragmas
in an obvious manner:
</p>
<ul>
<li> pragma_omp_task(<i>clauses</i>, <i>statement</i>) =
<div class="example">
<pre class="example">#pragma omp task <i>clauses</i>
  <i>statement</i>
</pre></div>
</li><li> pragma_omp_taskwait 
<div class="example">
<pre class="example">#pragma omp taskwait
</pre></div>
</li><li> pragma_omp_parallel_single(<i>clauses</i>, <i>statement</i>)
<div class="example">
<pre class="example">#pragma omp parallel <i>clauses</i>
#pragma omp single
{
  <i>statement</i>
}
</pre></div>
</li></ul>

<p>So, here is DAG Recorder-ready version of the above program.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;tpswitch/omp_dr.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    long x, y;
    pragma_omp_task(shared(x), 
		    x = bin(n - 1));
    pragma_omp_task(shared(y), 
		    y = bin(n - 1));
    pragma_omp_taskwait;
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  pragma_omp_parallel_single(, {
      dr_start(0);
      long x = bin(n);
      dr_stop();
      printf(&quot;bin(%d) = %ld\n&quot;, n, x);
      dr_dump();
    });
  return 0;
}

</pre></div>

<p>This source code can be compiled with and without DAG Recorder.
</p>
<ul>
<li> Without DAG Recorder:
<div class="example">
<pre class="example">g++ -fopenmp bin_omp_dr.cc 
</pre></div>

</li><li> With DAG Recorder:
<div class="example">
<pre class="example">g++ -fopenmp -DDAG_RECORDER=2 bin_omp_dr.cc -ldr
</pre></div>
</li></ul>

<hr>
<a name="Using-DAG-Recorder-with-Cilk-and-CilkPlus"></a>
<div class="header">
<p>
Next: <a href="#Using-DAG-Recorder-with-tpswitch_002eh" accesskey="n" rel="next">Using DAG Recorder with tpswitch.h</a>, Previous: <a href="#Using-DAG-Recorder-with-OpenMP" accesskey="p" rel="prev">Using DAG Recorder with OpenMP</a>, Up: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="u" rel="up">Writing Programs That Use DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-DAG-Recorder-with-Cilk-and-CilkPlus-1"></a>
<h4 class="subsection">4.3.4 Using DAG Recorder with Cilk and CilkPlus</h4>

<p>There are two versions of Cilk; the original MIT Cilk and CilkPlus.
The former is implemented as a source to source translator (cilkc) and it is a strictly C extension (C++ not supported).
The latter is natively supported by Intel C++ Compiler and GCC version $\geq$ 4.9.  
It supports both C and C++ for writing serial parts.
DAG Recorder supports both Cilk and CilkPlus.
Hereafter, when we say Cilk, it means the original MIT Cilk version.
</p>
<p>CilkPlus uses directives <code>_Cilk_spawn</code> and <code>_Cilk_sync</code> statements.
Here is our example in CilkPlus.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    long x, y;
    x = _Cilk_spawn bin(n - 1);
    y = _Cilk_spawn bin(n - 1);
    _Cilk_sync;
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x;
  x = _Cilk_spawn bin(n);
  _Cilk_sync;
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}
</pre></div>

<p>Alternatively you can include <code>&lt;cilk/cilk.h&gt;</code> and use more human friendly <code>cilk_spawn</code> and <code>cilk_sync</code> keywords.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cilk/cilk.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    long x, y;
    x = cilk_spawn bin(n - 1);
    y = cilk_spawn bin(n - 1);
    cilk_sync;
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x;
  x = cilk_spawn bin(n);
  cilk_sync;
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}
</pre></div>

<p>Cilk uses directives <code>spawn</code> and <code>sync</code> statements to create and synchronize tasks.
Here is our example in Cilk.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

cilk long bin(int n) {
  if (n == 0) return 1;
  else {
    long x, y;
    x = spawn bin(n - 1);
    y = spawn bin(n - 1);
    sync;
    return x + y;
  }
}

cilk int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x;
  x = spawn bin(n);
  sync;
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}
</pre></div>

<p>There is a subtle but important difference between Cilk and CilkPlus.
In Cilk, a function that spawns a task needs to be explicitly marked as
a <i>cilk procedure</i> by the <code>cilk</code> keyword at function declaration;
and, once a procedure is marked as a cilk procedure, it cannot be called
by a regular function call syntax; <i>it must always be spawned.</i>  That is,
in our example, the following is prohibited.
</p><div class="example">
<pre class="example">int x = bin(n);
</pre></div>

<p>It must instead be written as
</p><div class="example">
<pre class="example">int x;
x = spawn bin(n);
sync;
</pre></div>
<p>As a result, the enclosing function must also be marked as a cilk procedure.
</p>

<p>Whether you use Cilk or CilkPlus, modifications necessary to make these
programs ready are summarized as follows.
</p>
<ol>
<li> include <samp>tpswitch/cilk_dr.cilkh</samp> (Cilk) or <samp>tpswitch/cilkplus_dr.h</samp> (CilkPlus)
</li><li> enclose all <code>spawn, cilk_spawn,</code> and <code>_Cilk_spawn</code> statements with <code>spawn_(...)</code> macro.  e.g.,
<div class="example">
<pre class="example">y = cilk_spawn f(x);
</pre></div>
<p>should be rewritten to:
</p><div class="example">
<pre class="example">spawn_(y = cilk_spawn f(x));
</pre></div>
</li><li> replace all <code>sync</code> and <code>cilk_sync</code> statements with <code>sync_</code> and <code>cilk_sync_</code>, respectively.

</li><li> any function that spawns a task needs to begin with <code>cilk_begin</code>.  This is to indicate the beginning of a task.  If you forget this, a compilation error should result, complaining &ldquo;no such variable __cilk_begin__&rdquo;;

</li><li> replace return statements with either <code>cilk_return(<i>val</i>)</code> or <code>cilk_void_return</code>, depending on whether the return statement returns a value.  This is to indicate the end of a task.  

<p>(TODO : wish to fix this) If you forget this, a compilation
      succeeds, but DAG Recorder fails.
</p>
</li><li> (TODO : get rid of this restriction) As of writing, if you insert <code>cilk_begin</code>
      into a function, that function always needs to be spawned. That is,
      such a function cannot be called by a normal function call syntax.  
      This is prohibited in MIT Cilk
      anyways and flagged as a compilation error.  It is on you when
      you use CilkPlus, which allows task-spawning functions to be
      called serially without spawn keywords.  If you forget this, there
      are no compilation errors and DAG Recorder will be confused.
</li></ol>

<p>Here is the modified CilkPlus program.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;tpswitch/cilkplus_dr.h&gt;

long bin(int n) {
  cilk_begin;
  if (n == 0) cilk_return(1);
  else {
    long x, y;
    spawn_(x = cilk_spawn bin(n - 1));
    spawn_(y = cilk_spawn bin(n - 1));
    cilk_sync_;
    cilk_return(x + y);
  }
}

int main(int argc, char ** argv) {
  cilk_begin;
  int n = atoi(argv[1]);
  dr_start(0);
  long x;
  spawn_(x = cilk_spawn bin(n));
  cilk_sync_;
  dr_stop();
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  dr_dump();
  cilk_return(0);
}
</pre></div>

<p>And here is Cilk version.
</p>
<div class="example">
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cilk/cilk.h&gt;

long bin(int n) {
  if (n == 0) return 1;
  else {
    long x, y;
    x = cilk_spawn bin(n - 1);
    y = cilk_spawn bin(n - 1);
    cilk_sync;
    return x + y;
  }
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]);
  long x;
  x = cilk_spawn bin(n);
  cilk_sync;
  printf(&quot;bin(%d) = %ld\n&quot;, n, x);
  return 0;
}
</pre></div>

<p>This source code can be compiled with and without DAG Recorder.
</p>
<ul>
<li> CilkPlus, without DAG Recorder:
<div class="example">
<pre class="example">g++ -fcilkplus bin_cilkplus_dr.c
</pre></div>

</li><li> CilkPlus, with DAG Recorder:
<div class="example">
<pre class="example">g++ -fcilkplus -DDAG_RECORDER=2 bin_cilkplus_dr.c -ldr
</pre></div>

</li><li> Cilk, without DAG Recorder:
<div class="example">
<pre class="example">cilkc bin_cilk_dr.cilk
</pre></div>

</li><li> Cilk, with DAG Recorder:
<div class="example">
<pre class="example">cilkc -DDAG_RECORDER=2 bin_cilk_dr.cilk -ldr
</pre></div>
</li></ul>

<p>Instrumeting Cilk or CilkPlus programs is admittedly more burdensome
than instrumenting OpenMP or TBB.  The main reason for this is that
Cilk&rsquo;s <code>spawn</code> statement and CilkPlus&rsquo;s <code>cilk_spawn</code> 
statement create a task
that executes <i>the body of a procedure</i>, rather than an entire
procedure call statement, so we need to mark the beginning of the called
procedure as the beginning of the task.  That&rsquo;s why you need to insert
<code>cilk_begin</code>.  The difference between the two is subtle, but
consider the following example.
</p>
<div class="example">
<pre class="example">spawn f(g(x));
</pre></div>

<p>In this Cilk code, evaluation of <code>g(x)</code> is <i>not</i> performed by the
spawned task, so there is no way to mark the beginning of the task by
tweaking macros that receive the entire procedure call statement.
</p>
<p>In contrast, a similar TBB code:
</p><div class="example">
<pre class="verbatim">tg.run([=] { f(g(x)); });
</pre></div>
<p>spawns a task that performs <code>f(g(x))</code> entirely.  
To make matters even simpler, the task spawning primitive
is just another method rather than a builtin syntax, 
which we can transparently instrument by having another 
class that implements <code>run</code> method.
</p>


<hr>
<a name="Using-DAG-Recorder-with-tpswitch_002eh"></a>
<div class="header">
<p>
Previous: <a href="#Using-DAG-Recorder-with-Cilk-and-CilkPlus" accesskey="p" rel="prev">Using DAG Recorder with Cilk and CilkPlus</a>, Up: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="u" rel="up">Writing Programs That Use DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-DAG-Recorder-with-tpswitch_002eh-1"></a>
<h4 class="subsection">4.3.5 Using DAG Recorder with tpswitch.h</h4>

<p>Just give <samp>-DDAG_RECORDER=2</samp> 
and respective linker options (e.g., -lmyth-native -ldr -lpthread)
to the command line.
</p>
<p>TODO: more detailed and reader-friendly description.
</p>
<hr>
<a name="Running-Your-Programs-with-DAG-Recorder"></a>
<div class="header">
<p>
Next: <a href="#dag2any-DAG-to-any-data-converter" accesskey="n" rel="next">dag2any DAG to any data converter</a>, Previous: <a href="#Writing-Programs-That-Use-DAG-Recorder" accesskey="p" rel="prev">Writing Programs That Use DAG Recorder</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Running-Your-Programs-with-DAG-Recorder-1"></a>
<h3 class="section">4.4 Running Your Programs with DAG Recorder</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Basics-of-Running-Your-Programs-with-DAG-Recorder" accesskey="1">Basics of Running Your Programs with DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Controlling-the-Behavior-of-DAG-Recorder" accesskey="2">Controlling the Behavior of DAG Recorder</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Basics-of-Running-Your-Programs-with-DAG-Recorder"></a>
<div class="header">
<p>
Next: <a href="#Controlling-the-Behavior-of-DAG-Recorder" accesskey="n" rel="next">Controlling the Behavior of DAG Recorder</a>, Previous: <a href="#Running-Your-Programs-with-DAG-Recorder" accesskey="p" rel="prev">Running Your Programs with DAG Recorder</a>, Up: <a href="#Running-Your-Programs-with-DAG-Recorder" accesskey="u" rel="up">Running Your Programs with DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Basics-of-Running-Your-Programs-with-DAG-Recorder-1"></a>
<h4 class="subsection">4.4.1 Basics of Running Your Programs with DAG Recorder</h4>

<p>Once you obtained an executable compiled and linked with DAG Recorder, you can run it just normally.  
</p>
<div class="example">
<pre class="verbatim">$ ./bin_mtbb_dr 20
bin(20) = 1048576
</pre></div>

<p>You will find the following three files generated under the current directory.
</p><ul>
<li> <samp>00dr.dag</samp> &mdash; The DAG file. This is the primary file generated by DAG Recorder, from which other files are derived
</li><li> <samp>00dr.gpl</samp> &mdash; The parallelism file.  This is a file showing the actual and available parallelism, in a gnuplot format. 
</li><li> <samp>00dr.stat</samp> &mdash; The summary stat file.  This is a text file showing, among others, the number of tasks, total work time (time spent in the application code), critical path, the number of steals, etc.  The contents of this file will be explained later.
</li></ul>

<p>Run this program with setting environment variable <code>DR=0</code>, and you
can run the program with DAG Recorder turned off.
</p>
<div class="example">
<pre class="verbatim">$ DR=0 ./bin_mtbb_dr 20
bin(20) = 1048576
</pre></div>

<p>It still imposes a small overhead (essentially, looking up a global
variable + branch) for each tasking primitive.  We believe this overhead
is rarely an issue, but if you want to completely eliminate this
overhead, compile the program without <code>DAG_RECORDER=2</code>.
</p>
<hr>
<a name="Controlling-the-Behavior-of-DAG-Recorder"></a>
<div class="header">
<p>
Previous: <a href="#Basics-of-Running-Your-Programs-with-DAG-Recorder" accesskey="p" rel="prev">Basics of Running Your Programs with DAG Recorder</a>, Up: <a href="#Running-Your-Programs-with-DAG-Recorder" accesskey="u" rel="up">Running Your Programs with DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Controlling-the-Behavior-of-DAG-Recorder-1"></a>
<h4 class="subsection">4.4.2 Controlling the Behavior of DAG Recorder</h4>

<p>The behavior of DAG Recorder can be controlled either from within the
program or by environment variables; you can pass a pointer to
<code>dr_options</code> structure to <code>dr_start</code>, which has been 0 in the
examples we have shown so far.  If the argument to <code>dr_start</code> is
null (zero), options can be set via environment variables.  We will
illustrate how they work.
</p>
<p>First about environment variables.  Run the program with setting the
environment variable <code>DR_VERBOSE</code> to <code>1</code>, and you will see the
list of environment variables and their values printed by
<code>dr_start</code>.  You will also see messages about files generated by
<code>dr_dump</code>.
</p>
<div class="example">
<pre class="verbatim">$ DR_VERBOSE=1 ./bin_mtbb_dr 10
DAG Recorder Options:
dag_file_prefix (DAG_RECORDER_DAG_FILE_PREFIX,DR_PREFIX) : 00dr
dag_file_yes (DAG_RECORDER_DAG_FILE,DR_DAG) : 1
stat_file_yes (DAG_RECORDER_STAT_FILE,DR_STAT) : 1
gpl_file_yes (DAG_RECORDER_GPL_FILE,DR_GPL) : 1
dot_file_yes (DAG_RECORDER_DOT_FILE,DR_DOT) : 0
text_file_yes (DAG_RECORDER_TEXT_FILE,DR_TEXT) : 0
gpl_sz (DAG_RECORDER_GPL_SIZE,DR_GPL_SZ) : 4000
text_file_sep (DAG_RECORDER_TEXT_FILE_SEP,DR_TEXT_SEP) : |
dbg_level (DAG_RECORDER_DBG_LEVEL,DR_DBG) : 0
verbose_level (DAG_RECORDER_VERBOSE_LEVEL,DR_VERBOSE) : 1
chk_level (DAG_RECORDER_CHK_LEVEL,DR_CHK) : 0
uncollapse_min (DAG_RECORDER_UNCOLLAPSE_MIN,DR_UNCOLLAPSE_MIN) : 0
collapse_max (DAG_RECORDER_COLLAPSE_MAX,DR_COLLAPSE_MAX) : 1152921504606846976
node_count_target (DAG_RECORDER_NODE_COUNT,DR_NC) : 0
prune_threshold (DAG_RECORDER_PRUNE_THRESHOLD,DR_PRUNE) : 100000
alloc_unit_mb (DAG_RECORDER_ALLOC_UNIT_MB,DR_ALLOC_UNIT_MB) : 1
pre_alloc_per_worker (DAG_RECORDER_PRE_ALLOC_PER_WORKER,DR_PRE_ALLOC_PER_WORKER) : 0
pre_alloc (DAG_RECORDER_PRE_ALLOC,DR_PRE_ALLOC) : 0
dag_recorder: writing dag to 00dr.dag
dr_pi_dag_dump: 28648 bytes
dag recorder: writing stat to 00dr.stat
dag recorder: writing parallelism to 00dr.gpl
bin(10) = 1024
</pre></div>

<p>Uppercase names within parentheses are environment variables you might want to
set.  They start with a prefix <code>DAG_RECORDER_</code> and many of them
have a shorter version that begin with <code>DR_</code>.  The list will change
as our experiences accumulate.  Below is the list of frequently used
variables (consider other variables are still experimental).
</p>
<table>
<thead><tr><th width="15%">variable</th><th width="15%">default</th><th width="70%">description</th></tr></thead>
<tr><td width="15%"><code>DR_DAG_PREFIX</code></td><td width="15%"><samp>00dr</samp></td><td width="70%">Prefix of all files below</td></tr>
<tr><td width="15%"><code>DR_DAG</code></td><td width="15%">1</td><td width="70%">1 if generate a DAG file (to <code>DR_DAG_PREFIX</code>.dag)</td></tr>
<tr><td width="15%"><code>DR_STAT</code></td><td width="15%">1</td><td width="70%">1 if generate a summary stat file (to <code>DR_DAG_PREFIX</code>.stat)</td></tr>
<tr><td width="15%"><code>DR_GPL</code></td><td width="15%">1</td><td width="70%">1 if generate a parallelism profile file (to <code>DR_DAG_PREFIX</code>.gpl)</td></tr>
<tr><td width="15%"><code>DR_DOT</code></td><td width="15%">0</td><td width="70%">1 if generate a DAG file in a graphviz format (to <code>DR_DAG_PREFIX</code>.dot), which can be converted into viewable images by the <samp>dot</samp> command.  You need to have graphviz package installed in yours system</td></tr>
<tr><td width="15%"><code>DR_TEXT</code></td><td width="15%">0</td><td width="70%">1 if generate a human-readable text-formatted DAG file (to <code>DR_DAG_PREFIX</code>.txt).  Specify this when you want to inspect raw data</td></tr>
<tr><td width="15%"><code>DR_TEXT_SEP</code></td><td width="15%"><code>|</code></td><td width="70%">The field delimiter used in the text-formatted DAG file</td></tr>
<tr><td width="15%"><code>DR_VERBOSE</code></td><td width="15%">0</td><td width="70%">Set verbosity</td></tr>
<tr><td width="15%"><code>DR_COLLAPSE_MAX</code></td><td width="15%">a huge value</td><td width="70%">Determine how aggressively the DAG Recorder collapses subgraphs.  Specifically, the value determines an upper bound of time (in clock cycles) any single node resulted from collapsing a subgraph can span.  In other words, any single node in the DAG represents either a true single node (i.e., performed no tasking primitives) or a subgraph that took shorter than this number of clocks.  The default is a huge value, which means the system can collapse subgraphs as much as it can.  Set it to a small value to guarantee a minimum resolution.</td></tr>
</table>

<p>Let us move on to the second method, which is to control the behavior
from your program.  As briefly noted above, this is done by passing a
pointer to <code>dr_options</code> structure to <code>dr_start</code>.  See
<i>PREFIX</i><samp>/include/dag_recorder.h</samp> for the list of fields.  Note
that field names were also displayed with <code>DR_VERBOSE=1</code> option
above.  For example, the line:
</p><div class="example">
<pre class="example">dag_file_prefix (DAG_RECORDER_DAG_FILE_PREFIX,DR_PREFIX) : 00dr
</pre></div>
<p>tells you <code>dag_file_prefix</code> is the field name you want to set to change
the prefix of generated files.
</p>
<p>When you change some of these fields, you will want to leave other
fields to their default values.  <code>dr_options_default(opts)</code>
is the function that fills the structure pointed to by <code>opts</code>
with default and environmentally-set values.  So, the typical sequence you want to use will be:
</p><div class="example">
<pre class="example">dr_options opts[1];
dr_options_default(opts);
opts-&gt;dag_file = ...;
opts-&gt;<i>whatever_you_want_to_change</i> = ...;
   ...
dr_start(opts);
</pre></div>

<hr>
<a name="dag2any-DAG-to-any-data-converter"></a>
<div class="header">
<p>
Next: <a href="#Viewing-Recorded-Data" accesskey="n" rel="next">Viewing Recorded Data</a>, Previous: <a href="#Running-Your-Programs-with-DAG-Recorder" accesskey="p" rel="prev">Running Your Programs with DAG Recorder</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="dag2any-DAG-to-any-data-converter-1"></a>
<h3 class="section">4.5 dag2any DAG to any data converter</h3>

<p>about dag2any
</p>
<hr>
<a name="Viewing-Recorded-Data"></a>
<div class="header">
<p>
Next: <a href="#Querying-Recorded-Data" accesskey="n" rel="next">Querying Recorded Data</a>, Previous: <a href="#dag2any-DAG-to-any-data-converter" accesskey="p" rel="prev">dag2any DAG to any data converter</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Viewing-Recorded-Data-1"></a>
<h3 class="section">4.6 Viewing Recorded Data</h3>

<p>Tools to view DAG Recorder data are still ad-hoc; ideally there should
be a single tool to view the same data from many angles.  As of writing,
there instead is an interactive tool to show parallelism profile and a
set of files derived from the DAG data, viewable by standard tools such as
gnuplot.  We will continue to work on developing tools to analyze DAG
data from many angles and unify their user interfaces.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Viewing-Parallelism-Profile-with-gnuplot" accesskey="1">Viewing Parallelism Profile with gnuplot </a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Visualizing-the-DAG-via-graphviz" accesskey="2">Visualizing the DAG via graphviz</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Understanding-Stat-File" accesskey="3">Understanding Stat File</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Viewing-DAG-file-with-drview" accesskey="4">Viewing DAG file with drview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Viewing-Parallelism-Profile-with-gnuplot"></a>
<div class="header">
<p>
Next: <a href="#Visualizing-the-DAG-via-graphviz" accesskey="n" rel="next">Visualizing the DAG via graphviz</a>, Previous: <a href="#Viewing-Recorded-Data" accesskey="p" rel="prev">Viewing Recorded Data</a>, Up: <a href="#Viewing-Recorded-Data" accesskey="u" rel="up">Viewing Recorded Data</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Viewing-Parallelism-Profile-with-gnuplot-1"></a>
<h4 class="subsection">4.6.1 Viewing Parallelism Profile with gnuplot</h4>

<p>By default, programs traced by DAG Recorder generates a parallelism profile as a gnuplot file.  You can simply view it by gnuplot.  A parallelism profile looks like this.
</p>
<img src="gpl/tbb.png" alt="gpl/tbb">


<p>The horizontal axis represents time (in clock cycles) and the vertical
axis the number of tasks of various conditions, indicated by colors.
</p>
<ul>
<li> &ldquo;running&rdquo; means the number of actually running tasks.
The number of running tasks should never exceed the number of workers used
by the execution.  In the graph above, it is constant around 64.  As you
will have guessed already, it was an execution with 64 cores.

</li><li> all other colors mean the number of &ldquo;available&rdquo; or 
&ldquo;runnable&rdquo; but not running tasks; a task is available when all its
predecessors in the DAG have finished.  Available tasks are classified
by the type of event that made them runnable.  

<ul>
<li> &ldquo;end&rdquo; means the task became available as its awaiting task finished.

</li><li> &ldquo;create&rdquo; means the task became available as its parent created it.

</li><li> &ldquo;create cont&rdquo; means the task became available as it created a task and continues.

</li><li> &ldquo;wait cont&rdquo; means the task became available as it reached synchronization point (i.e., issued tg.wait() in TBB, sync in Cilk, pragma task wait in OpenMP, etc.) and child tasks have already finished by that point.

</li><li> &ldquo;other cont&rdquo; means the task became available as it performed any operation that might enter the runtime system.  In practice, you will never see this event.

</li></ul>
</li></ul>

<p>For example, consider the following program:
</p><div class="example">
<pre class="verbatim">#include &lt;mtbb/task_gorup.h&gt;
int main() {
  mtbb::task_group tg;
  a();
  tg.run([=] b());
  c();
  tg.wait();
  d();
}
</pre></div>
<p>and the DAG resulting from executing this program.
</p>
<img src="svg/dag.png" alt="svg/dag">

<p>The label of an edge indicates how the node it points to is classified
when its source node has finished.  For example, the node <i>q</i> is
counted as <i>create</i>, from the time when <i>p</i> finished (i.e., the task
entered <code>tg.run([=] { b(); })</code>) to the time when <i>q</i> started.
</p>
<p><i>p&rdquo;</i> becomes available when <i>both</i> <i>q</i> and <i>p&rsquo;</i> finished, so
how it is classified depends on which of them finished last.  If <i>q</i>
finished later than <i>p&rsquo;</i>, it is classified as <i>end</i>; otherwise as
<i>wait cont</i>.
</p>
<p>In most cases, your primary interest will be in &ldquo;running.&rdquo;  If this
stays constant around the number of workers used, it means the same
number of cores are maximally utilized (as long as the operating system
runs each worker on a distinct core).  If it is not the case, that is,
there are intervals in which the number of running tasks is lower than
the number of workers used, you should check if there are enough
<i>available</i> tasks.
</p>
<p>If there are no or little available tasks in an interval, it means your
program did not have enough tasks in that interval, so you might have to
consider increasing the parallelism in that interval.  In some cases you
have simply left some section of your code left not parallelized at all,
which is easily visible in the parallelism profile.  A tool drview will
help you spot source code locations when this happens.  
see <a href="#Viewing-DAG-file-with-drview">Viewing DAG file with drview</a>.
</p>
<p>If, on the other hand, available tasks are abundant, it means the
runtime system, for whatever reasons, was not able to fully exploit
available parallelism.  There are several possible reasons for this.
</p>
<ul>
<li> Your tasks are too fine grained, so you observe the overhead
of task creation or task stealing.  For example, let&rsquo;s say a runtime
system takes 10000 cycles from the point a task is created until the
point it actually gets started, it is not counted as running during that
interval of 10000 cycles.  If average task granularity is only, say,
5000 cycles, then on average only 33% (5000/15000) of CPU time will be
spent on actually running tasks.  With a 64 workers execution, you will
observe about 20 running tasks.  The more overhead the runtime system
imposes, the less number of running tasks you will observe.

</li><li> The runtime system somehow imposes constraints on workers that can run 
certain tasks, so some available tasks are left unexecuted when workers
meeting the condition are busy on other tasks.  A typical example is
OpenMP tied tasks and TBB (where all tasks are tied); tied tasks cannot
migrate once started by a certain worker.

</li></ul>

<hr>
<a name="Visualizing-the-DAG-via-graphviz"></a>
<div class="header">
<p>
Next: <a href="#Understanding-Stat-File" accesskey="n" rel="next">Understanding Stat File</a>, Previous: <a href="#Viewing-Parallelism-Profile-with-gnuplot" accesskey="p" rel="prev">Viewing Parallelism Profile with gnuplot</a>, Up: <a href="#Viewing-Recorded-Data" accesskey="u" rel="up">Viewing Recorded Data</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Visualizing-the-DAG-via-graphviz-1"></a>
<h4 class="subsection">4.6.2 Visualizing the DAG via graphviz</h4>

<p>You can generate the DAG captured by DAG Recorder, by setting
environment variable <code>DAG_RECORDER_DAG_FILE</code> 
(or <code>DR_DAG</code>) to the filename
you want to have it in.  The file is a text file of a graphviz dot
format, which can then be transformed into various graphics format by
graphviz tool dot.
</p>
<p>Since a program easily generates a DAG of millions or more nodes, this
feature will be useful only for short runs.  
</p>
<p>For example, you can see the DAG by any SVG viewer by the following
procedure.
</p><div class="example">
<pre class="example">$ DR_DAG=00dr.dot ./a.out
$ dot -Tsvg -o 00dr.svg 00dr.dot 
$ <i>any-svg-viewer</i> 00dr.svg
</pre></div>

<p>See graphviz package and dot manual for further information about the
dot tool.
</p>
<p>When you use this feature to visualize the true topology of the DAG your
program generated, you might want to turn off the subgraph contraction
algorithm DAG Recorder implements to save space.  To this end, you can
set <code>DR_COLLAPSE_MAX</code> environment variable to zero.
</p>
<div class="example">
<pre class="example">$ DR_COLLAPSE_MAX=0 DR_DAG=00dr.dot ./a.out
$ dot -Tsvg -o 00dr.svg 00dr.dot 
$ <i>any-svg-viewer</i> 00dr.svg
</pre></div>

<hr>
<a name="Understanding-Stat-File"></a>
<div class="header">
<p>
Next: <a href="#Viewing-DAG-file-with-drview" accesskey="n" rel="next">Viewing DAG file with drview</a>, Previous: <a href="#Visualizing-the-DAG-via-graphviz" accesskey="p" rel="prev">Visualizing the DAG via graphviz</a>, Up: <a href="#Viewing-Recorded-Data" accesskey="u" rel="up">Viewing Recorded Data</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Understanding-Stat-File-1"></a>
<h4 class="subsection">4.6.3 Understanding Stat File</h4>

<p>By default, programs traced by DAG Recorder generates a small text file that summarizes various pieces of information of the execution.  You can view it by any text editor.  Here is an example.
</p>
<div class="example">
<pre class="verbatim">create_task           = 1048575
wait_tasks            = 1048575
end_task              = 1048576
work (T1)             = 1313026836
delay                 = 9031849743
no_work               = 11285973
critical_path (T_inf) = 91285263
n_workers (P)         = 4
elapsed               = 2589040638
T1/P                  = 328256709.000
T1/P+T_inf            = 419541972.000
T1/T_inf              = 14.384
greedy speedup        = 3.130
observed speedup      = 0.507
observed/greedy       = 0.162
task granularity      = 9601.938
interval granularity  = 3200.645
dag nodes             = 5242877
materialized nodes    = 351
compression ratio     = 0.000067
end-parent edges:
 266182 7 7 1
 1 253506 16 2
 0 8 280326 5
 1 4 9 248486
create-child edges:
 266204 0 0 0
 0 253527 0 0
 0 0 280342 0
 0 0 0 248502
create-cont edges:
 266187 7 6 4
 2 253514 9 2
 3 7 280329 3
 4 3 0 248495
wait-cont edges:
 266183 0 1 0
 0 253531 0 0
 1 0 280361 0
 0 0 0 248498
other-cont edges:
 0 0 0 0
 0 0 0 0
 0 0 0 0
 0 0 0 0
</pre></div>

<ul>
<li> The first three items show the number of events:
<table>
<tr><td width="10%"><code>create_task</code></td><td width="90%">The number of times tasks are created, not including the main task.</td></tr>
<tr><td width="10%"><code>wait_tasks</code></td><td width="90%">The number of times wait operations are issued. Each wait may wait for multiple tasks, so this number may not match create_task</td></tr>
<tr><td width="10%"><code>end_task</code></td><td width="90%">The number of times tasks are ended. This should be <code>create_task</code> + 1.  +1 is because the former does not include the main task, but <code>end_task</code> does.</td></tr>
</table>

</li><li> Then there are three numbers showing the breakdown of the total 
time spent by the execution.
<table>
<tr><td width="10%"><code>work (T1)</code></td><td width="90%">The cumulative time (clock cycles) spent
in executing the application code.  Total across all cores.  This does
not include time spent in the runtime system (e.g., task creation
overhead).  If the application perfectly scales, this number should be
constant no matter how many cores you used for execution.  This is the
area of the &ldquo;running&rdquo; region in the parallelism profile graph.</td></tr>
<tr><td width="10%"><code>delay</code></td><td width="90%">The cumulative time available tasks are not
executed despite there are &ldquo;spare&rdquo; cores not executing any task.  This
is the area of &ldquo;available&rdquo; region below the horizontal line at the
number of cores in the parallelism profile graph.  This value would be
zero under a hypothetical &ldquo;genuinely greedy&rdquo; scheduler, a scheduler
which immediately dispatches any available task to if any available
core, without any delay or whatsoever.</td></tr>
<tr><td width="10%"><code>no_work</code></td><td width="90%">The cumulative time cores spent without available
tasks.  This is the area not filled by running or available tasks below
the horizontal line at the number of cores in the parallelism profile
graph.</td></tr>
</table>

<p>The following is a conceptual model to understand what each of them is.
Imagine we stop all workers at each processor cycle and count the number
of tasks running (<i>= R</i>), as well as the number of tasks available but
not running (<i>= A</i>).
</p>
<p>Let <i>W =</i> the number of workers.  In this setting,
</p><ul>
<li> <code>T1</code> is the total of <i>R</i> over all cycles
</li><li> <code>delay</code> is the total of min(<i>A, W - R</i>) over all cycles
</li><li> <code>no_work</code> is the total of min(0, <i>W - R - A</i>) over all cycles
</li></ul>

<p>Observe that at any point, the sum of the three terms is always <i>W</i>.
Therefore, it always holds that 
</p>
<div class="display">
<pre class="display"><code>T1</code> + <code>delay</code> + <code>no_work</code> = <i>W</i> x elapsed time
</pre></div>

<p>In other words, <code>T1, delay</code>, and <code>no_work</code> give a
<i>breakdown</i> of the whole execution time.  Perfectly scalable
executions have <code>T1</code> approximately the same as that of serial
execution and have both <code>delay</code> and <code>no_work</code> nearly zero.
They in general give you a quantitative information on why your
application does not ideally scale.
</p>
<p>Applications that do not have enough parallelism will have large
<code>no_work</code>, those that have enough parallelism that cannot
be utilized by the runtime system will show a large <code>delay</code> value,
and those that have their work time increased (presumably due to
cache misses due to inter-core communication, false sharing, or 
capacity overflows on shared caches) will show a <code>T1</code> value
significantly larger than that of serial execution.
</p>
</li><li> Nine metrics that follow give you a better idea about the
speedup.

<table>
<tr><td width="15%"><code>critical_path (T_inf)</code></td><td width="85%">Critical path of the DAG.  This
is the longest time spent in a path in the DAG.  The time does not
include time spent in the runtime system.</td></tr>
<tr><td width="15%"><code>n_workers (P)</code></td><td width="85%">The number of workers that participated in the execution.  This is
the value DAG Recorder observed during execution and, in rare occasions,
may not match the number of cores you asked the runtime system to use.
If, for example, the program was so short lived or created so few tasks
that some cores were not used at all, you may observe a number smaller than
the number you specified.</td></tr>
<tr><td width="15%"><code>elapsed</code></td><td width="85%">Elapsed time (clock cycles) of the application.
As we stated above, <code>elapsed</code> x <code>P</code> should match the sum
of <code>T1, delay,</code> and <code>no_work</code>.</td></tr>
<tr><td width="15%"><code>T1/P</code></td><td width="85%">This is simply <code>T1</code> divided by <code>P</code>. 
This gives an obvious lower bound on achievable elapsed time.</td></tr>
<tr><td width="15%"><code>T1/P+T_inf</code></td><td width="85%">This is simply <code>T1</code> divided by <code>P</code>. 
This gives an upper bound of elapsed time by a hypothetical greedy
scheduler.  If the scheduler is &ldquo;greedy enough&rdquo; (available tasks
will be executed quickly enough as long as there is an available core),
the elapsed time you observed should be close to this value.</td></tr>
<tr><td width="15%"><code>T1/T_inf</code></td><td width="85%">This is simply <code>T1</code> divided by <code>T_inf</code>, 
or the &ldquo;average parallelism&rdquo; of the execution.  In general, if you
hope your application to scale, this value should be much larger than
the number of cores you hope to utilize.</td></tr>
<tr><td width="15%"><code>greedy speedup</code></td><td width="85%">The speedup that should be achieved
by a hypothetical greedy scheduler.  It is, <code>T1</code> divided
by <code>T1/P+T_inf</code>.</td></tr>
<tr><td width="15%"><code>observed speedup</code></td><td width="85%">The actual speed up observed,
which is <code>T1</code> divided by <code>elapsed time</code>.</td></tr>
<tr><td width="15%"><code>observed/greedy</code></td><td width="85%">The ratio of the above two terms.
It indicates how greedy the scheduler was.</td></tr>
</table>

</li><li> The following two terms give you an idea about granularity

<table>
<tr><td width="15%">task granularity</td><td width="85%">This is the average number of cycles
between to task creations.  That is, <code>T1</code> divided by
the number of tasks.</td></tr>
<tr><td width="15%">interval granularity</td><td width="85%">This is the average number of cycles spent in a single DAG node,
or cycles between any two consecutive
task parallel operations (e.g., a task creation followed by a sync).</td></tr>
</table>

</li><li> Three terms that follow give you the number of DAG nodes
and the effectiveness of the DAG contraction algorithm.

<table>
<tr><td width="15%">dag nodes</td><td width="85%">The number of DAG nodes if there would be no 
contraction.</td></tr>
<tr><td width="15%">materialized nodes</td><td width="85%">The number of nodes after DAG contraction.
If <code>DR_COLLAPSE_MAX=0</code> (DAG contraction turned off), this should
equal to dag nodes.  If this value is large (default) and you use
only a single core, this is always one!</td></tr>
<tr><td width="15%">compression ratio</td><td width="85%">The ratio between the two.  DAG contraction
is more effective (thus the value is small) when many large subgraphs
are executed in a single core, and thus are contracted.</td></tr>
</table>

</li><li> Finally, there are five matrices that describe the number of edges
in the DAG connecting two nodes executed by a pair of workers.
Specifically, each matrix is <i>P</i> x <i>P</i> matrix (where <i>P</i> is the
number of workers) whose <i>P[i,j]</i> element (<i>i</i> : row number, <i>j</i> :
column number) is the number of edges of a respective type connecting
from a node executed by worker <i>i</i> to a node executed by worker <i>j</i>.
Five matrices are:

<table>
<tr><td width="15%">end-parent edges</td><td width="85%">This matrix counts edges
from the last node of a task to the node that follows a wait
operation that synchronized with the task.</td></tr>
<tr><td width="15%">create-child edges</td><td width="85%">This matrix counts edges
from a task creation node to the first node of the created task.</td></tr>
<tr><td width="15%">create-cont edges</td><td width="85%">This matrix counts edges from
a task creation node to its continuation in the same task.</td></tr>
<tr><td width="15%">wait-cont edges</td><td width="85%">This matrix counts edges from
a synchronization node (a node that ends by issuing OpenMP 
<code>taskwait</code>,
TBB <code>task_group::wait()</code> method, 
Cilk <code>sync</code> statement, etc.) to its continuation in 
the same task.</td></tr>
<tr><td width="15%">other-cont edges</td><td width="85%">This matrix counts edges from
a node that ends by entering the runtime system for any reason other
than task creation or synchronization to the node that starts after the
operation.</td></tr>
</table>

</li></ul>

<hr>
<a name="Viewing-DAG-file-with-drview"></a>
<div class="header">
<p>
Previous: <a href="#Understanding-Stat-File" accesskey="p" rel="prev">Understanding Stat File</a>, Up: <a href="#Viewing-Recorded-Data" accesskey="u" rel="up">Viewing Recorded Data</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Viewing-DAG-file-with-drview-1"></a>
<h4 class="subsection">4.6.4 Viewing DAG file with drview</h4>

<p><code>drview</code> is a tool that shows parallelism profile of an execution
and allows you to zoom into an interval in it.  This way it helps you
pinpoint tasks executing when parallelism was low.
</p>
<p>Prerequisites:  <code>drview</code> is a python script that 
relies on the following libraries.
</p><ul>
<li> matplotlib (Debian package name: python-matplotlib)
</li><li> gtk (Debian package name: python-gtk2 and perhaps python-gtk2-dev)
</li></ul>
<p>Please make sure you should be able to import respective python modules
(<code>matplotlib</code> and <code>gtk</code>).
</p>
<p>To use <code>drview</code>, you first need to convert the .dag file 
generated by DAG Recorder into
SQLite3 format using <code>dag2any</code> tool described above.  
Then you pass the resulting
SQLite3 file to <code>drview</code>.
</p>
<p>TODO: We are planning to improve this crude interface, so you can
directly give a <code>.dag</code> file to drview.
</p>
<div class="example">
<pre class="example">$ dag2any 00dr.dag 
writing sqlite3 to 00dr.sqlite
basics:  ........................................
nodes:   ........................................
edges:   ........................................
strings: ........................................
committing
$ drview 00dr.sqlite
</pre></div>
<p>This will bring up the user interface window.
</p>
<p>BUG: The initial configuration of panes is far from satisfactory.
Please adjust their sizes manually by grabbing borders between panes.  I
am still trying to figure out how to configure their sizes.
</p>
<p>After manually adjusting pane sizes, you will obtain something like this.
</p>
<img src="img/drview_screenshot_resized.png" alt="img/drview_screenshot_resized">

<p>On the leftmost pane, you see the parallelism profile, the same
information you can see by the gnuplot-formatted parallelism profile.
see <a href="#Viewing-Parallelism-Profile-with-gnuplot">Viewing Parallelism Profile with gnuplot</a>. 
</p>
<p>On the center pane is the list of DAG nodes executed.  Each row
represents a group of nodes that share the same start and end positions.
They are ordered by the total number of cycles spent in the group of
tasks.  If you double-click on a row, the right pane shows the source
code of the corresponding location.  By clicking somewhere in the
&ldquo;start&rdquo; or &ldquo;end&rdquo; column, the source code pane will display the
group&rsquo;s start or end position, respectively.
</p>
<p>The most useful feature of this tool is that you can zoom into an
interval of your interest in the parallelism pane.  Hold the left button
of the mouse pushed and specify a rectangular region in the parallelism
pane, and you will see the parallelism and the task panes redrawn to
reflect the tasks executed in the selected interval.  This way, you can
easily know the source locations of low parallelism.
</p>
<hr>
<a name="Querying-Recorded-Data"></a>
<div class="header">
<p>
Previous: <a href="#Viewing-Recorded-Data" accesskey="p" rel="prev">Viewing Recorded Data</a>, Up: <a href="#DAG-Recorder" accesskey="u" rel="up">DAG Recorder</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Querying-Recorded-Data-1"></a>
<h3 class="section">4.7 Querying Recorded Data</h3>


<hr>



</body>
</html>
