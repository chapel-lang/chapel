.TH qthread_syncvar_empty/fill 3 "JUNE 2010" libqthread "libqthread"
.SH NAME
.BR qthread_syncvar_empty ,
.B qthread_syncvar_fill
\- sets the given syncvar to either "empty" or "full"
.SH SYNOPSIS
.B #include <qthread.h>

.I int
.br
.B qthread_syncvar_empty
.RI "(qthread_t *" me ", syncvar_t *" dest );
.PP
.I int
.br
.B qthread_syncvar_fill
.RI "(qthread_t *" me ", syncvar_t *" dest );
.SH DESCRIPTION
The
.BR qthread_syncvar_empty ()
and
.BR qthread_syncvar_fill ()
functions assert the empty or full state of the given
.I dest
addresses. They do not wait for the addresses to be in any particular state.
.PP
The
.I me
argument is used for memory pooling purposes. Memory is allocated on a
per-shepherd basis (to avoid needing to protect the memory pool), thus it needs
to know which shepherd it is currently on. HOWEVER, this argument is merely an
optimization; these functions CAN figure out which pools to use without this
information (i.e. if the
.I me
argument is NULL).
.PP
Note that
.RS
.PP
.B qthread_syncvar_empty
(NULL,
.IR addr )
.RE
.PP
is faster than
.RS
.PP
.B qthread_syncvar_empty
.RB ( qthread_self (),
.IR addr )
.RE
.SH RETURN VALUE
On success, the full/empty bits are modified and 0 is returned. On error, an
non-zero error code is returned.
.SH ERRORS
.TP 12
.B QTHREAD_TIMEOUT
Could not obtain the lock on the syncvar_t's status bits. This may be caused by
many things, including memory corruption, invalid syncvar, or even absurdly
excessive contention (because its protected by a naive spinlock rather than a
fair spinlock).
.SH SEE ALSO
.BR qthread_syncvar_writeF (3),
.BR qthread_syncvar_writeEF (3),
.BR qthread_syncvar_readFF (3),
.BR qthread_syncvar_readFE (3)
