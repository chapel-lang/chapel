<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Qthreads Performance Measurement API</title>
<!-- 2016-08-11 Thu 11:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="Erik Lee"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Qthreads Performance Measurement API</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a></li>
<li><a href="#sec-2">2. Quick note on memory management</a></li>
<li><a href="#sec-3">3. Building</a>
<ul>
<li><a href="#sec-3-1">3.1. CFLAGS for performance monitoring</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Enable testing for performance API</a></li>
<li><a href="#sec-3-1-2">3.1.2. Enable debug output</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Tutorial</a>
<ul>
<li><a href="#sec-4-1">4.1. Quickstart</a></li>
<li><a href="#sec-4-2">4.2. Setup Functions</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1. <code>qtperf_set_instrument_workers(int yes_or_no)</code></a></li>
<li><a href="#sec-4-2-2">4.2.2. <code>qtperf_set_instrument_qthreads(int yes_or_no)</code></a></li>
<li><a href="#sec-4-2-3">4.2.3. <code>qtstategroup_t* qtperf_create_state_group(size_t num_states, const char* group_name, const char** state_names)</code></a></li>
<li><a href="#sec-4-2-4">4.2.4. <code>qtperfdata_t* qtperf_create_perfdata(qtstategroup_t* group)</code></a></li>
<li><a href="#sec-4-2-5">4.2.5. <code>qtperfdata_t* qtperf_create_aggregated_perfdata(qtstategroup_t* group)</code></a></li>
<li><a href="#sec-4-2-6">4.2.6. <code>void qtperf_piggyback_state(&#x2026;)</code></a></li>
</ul>
</li>
<li><a href="#sec-4-3">4.3. Runtime Functions</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1. <code>void qtperf_enter_state(qtperfdata_t* data, qtperfid_t state_id)</code></a></li>
<li><a href="#sec-4-3-2">4.3.2. <code>const char* qtperf_state_name(qtstategroup_t* group, qtperfid_t state_id)</code></a></li>
<li><a href="#sec-4-3-3">4.3.3. <code>void qtperf_start()</code></a></li>
<li><a href="#sec-4-3-4">4.3.4. <code>void qtperf_stop()</code></a></li>
</ul>
</li>
<li><a href="#sec-4-4">4.4. Reporting and data access functions</a>
<ul>
<li><a href="#sec-4-4-1">4.4.1. <code>void qtperf_print_results()</code></a></li>
<li><a href="#sec-4-4-2">4.4.2. <code>void qtperf_print_delimited(qtstategroup_t* group, const char* delim, bool print_headers, const char* prefix)</code></a></li>
<li><a href="#sec-4-4-3">4.4.3. <code>void qtperf_print_perfdata(qtperfdata_t* perfdata, bool show_states_with_zero_time)</code></a></li>
<li><a href="#sec-4-4-4">4.4.4. <code>void qtperf_print_group(qtstategroup_t* group)</code></a></li>
<li><a href="#sec-4-4-5">4.4.5. <code>void qtperf_print_perfdata(qtperfdata_t* data, bool show_states_with_zero_time)</code></a></li>
<li><a href="#sec-4-4-6">4.4.6. <code>qtperfcounter_t qtperf_total_group_time(qtstategroup_t* group)</code></a></li>
<li><a href="#sec-4-4-7">4.4.7. <code>qtperfcounter_t qtperf_total_time(qtperfdata_t* data)</code></a></li>
</ul>
</li>
<li><a href="#sec-4-5">4.5. Iterators</a>
<ul>
<li><a href="#sec-4-5-1">4.5.1. <code>void qtperf_iter_begin(qtperf_iterator** iter)</code></a></li>
<li><a href="#sec-4-5-2">4.5.2. <code>qtperfdata_t* qtperf_iter_next(qtperf_iterator_t** iter)</code></a></li>
<li><a href="#sec-4-5-3">4.5.3. <code>qtperfdata_t* qtperf_iter_deref(qtperf_iterator_t * iter)</code></a></li>
<li><a href="#sec-4-5-4">4.5.4. <code>qtperf_iterator_t* qtperf_iter_end()</code></a></li>
</ul>
</li>
<li><a href="#sec-4-6">4.6. Teardown</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
The Qthreads performance measurement API (qtperf) is a set of
functions that make it easier to keep track of time-related data
during a run. It supports tracking of internal library timings for
measuring the actual overhead imposed by the library itself, and it
also supports arbitrary user-defined timing measurements.
</p>

<p>
Qtperf is modeled on the idea of a state machine. If you can model the
performance data you want to collect as a set of discrete states with
associated time spent in each state, you will be able to use this set
of functions to track it. The basic unit of data collection is a
state, which is just an arbitrary identifier. These are bundled into
state groups, which represent a state machine with all of its valid
states. After state groups are defined, you can instantiate them as
many times as necessary to track same-type data (for example, if you
want to measure overhead of communications in each thread, you could
define a communication state group and then instantiate it for each
thread that will be communicating). While the program is running, your
code can signal that a new state is being entered for the currently
active state group, and the library will add the elapsed time in the
previous state to its total, update the state variable, and return
control.
</p>

<p>
Instantiating a state group for every thread is often going to be too
much detail and overhead, so the library also supports
aggregation. When you have a large number of threads that will be
doing basically the same thing, you can define a state group to
represent the task, then instantiate it <i>once</i> and have all of the
threads post their updates to that shared instance. This requires the
limited use of mutual exclusion, so there will be a tradeoff in terms
of memory savings versus performance costs.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Quick note on memory management</h2>
<div class="outline-text-2" id="text-2">
<p>
This library uses dynamically allocated memory to track the
performance data it captures. The only functions that perform
allocations are the functions with <code>create</code> in their names. You
should <b>not</b> manually deallocate any structures provided by this
library. Instead, call <code>qtperf_free_data()</code> at the end of your run,
and all memory will be safely deallocated.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Building</h2>
<div class="outline-text-2" id="text-3">
<p>
The performance API is only loosely integrated with qthreads
proper. In order to build qthreads with support for performance
monitoring, there are two steps to complete:
</p>

<ol class="org-ol">
<li>Run autogen.sh to create the <code>configure</code> script.
</li>
<li>Choose your CFLAGS appropriately (see below) and run the
     <code>configure</code> script
</li>
</ol>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> CFLAGS for performance monitoring</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The performance API is enabled by passing a couple of flags to the
C preprocessor. To get the basic API without testing or debug
messages, use <code>QTHREAD_PERFORMANCE</code>:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ff00;">CFLAGS</span>=<span style="color: #af5f00;">'-DQTHREAD_PERFORMANCE'</span> ./configure --disable-lazy-threadids --enable-picky [..your selections here..]
</pre>
</div>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Enable testing for performance API</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
To enable the test harness for the performance API, you'll need to
have cmocka installed (<a href="https://cmocka.org">https://cmocka.org</a>). After that, you'll need
to tell configure how to link <code>cmocka</code> and to enable testing, using
the <code>QTPERF_TESTING</code> preprocessor flag (note backslashes at the
ends of lines - this should all be on one command line).
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ff00;">CFLAGS</span>=<span style="color: #af5f00;">'-DQTHREAD_PERFORMANCE -DQTPERF_TESTING'</span> <span style="color: #af5f00;">\</span>
  <span style="color: #00ff00;">LDFLAGS</span>=<span style="color: #af5f00;">'-L/path/to/cmocka/lib'</span> <span style="color: #af5f00;">\</span>
  <span style="color: #00ff00;">LIBS</span>=-lcmocka <span style="color: #af5f00;">\</span>
  ./configure --enable-debugging --disable-lazy-threadids --enable-picky [..your selections here..]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Enable debug output</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The performance API can print messages to the console that
indicate potentially useful information about what's happening
inside as it's running. To enable those messages, use the
<code>PERFDBG</code> flag:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ff00;">CFLAGS</span>=<span style="color: #af5f00;">'-DQTHREAD_PERFORMANCE -DPERFDBG=1'</span> ./configure --disable-lazy-threadids --enable-picky [..your selections here..]
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Tutorial</h2>
<div class="outline-text-2" id="text-4">
<p>
Qtperf is designed to be used with three distinct phases of
operation: setup, run, and teardown. This is necessary because of
memory allocation and cleanup requirements, and also because
instrumentation must be initialized for internal library states if
they are to be tracked.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Quickstart</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Here is a quick example of a tiny program that makes use of the
basic internal logging features of qtperf:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #87ffd7; font-weight: bold;">#include</span><span style="color: #af5f00;">&lt;qthread/qthread.h&gt;</span>
<span style="color: #87ffd7; font-weight: bold;">#include</span><span style="color: #af5f00;">&lt;qthread/performance.h&gt;</span>
<span style="color: #87ffd7; font-weight: bold;">#include</span><span style="color: #af5f00;">&lt;qthread/logging.h&gt;</span>

<span style="color: #5fd787;">aligned_t</span> <span style="color: #87d7ff;">spin</span>(){
  <span style="color: #5fd787;">size_t</span> <span style="color: #00ff00;">i</span>=0;
  <span style="color: #5fd787;">aligned_t</span> <span style="color: #00ff00;">result</span>=2;
  <span style="color: #afffaf;">for</span>(i=0; i&lt;1000000; i++){
    result = result * result + i;
  }
  <span style="color: #afffaf;">return</span> result;
}

<span style="color: #5fd787;">size_t</span> <span style="color: #00ff00;">num_threads</span>=5;
<span style="color: #5fd787;">int</span> <span style="color: #87d7ff;">main</span>(){
  <span style="color: #5fd787;">size_t</span> <span style="color: #00ff00;">i</span>=0;
  <span style="color: #5fd787;">aligned_t</span> <span style="color: #00ff00;">ret</span>=0;

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Enable monitoring of qthread internal workers</span>
  qtperf_set_instrument_workers(1);

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Enable monitoring of internal qthreads (jobs)</span>
  qtperf_set_instrument_qthreads(1);

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Initialize and allocate data, enable collection</span>
  qtperf_start();

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Call this *after* qtperf_start()</span>
  qthread_initialize();

  <span style="color: #afffaf;">for</span>(i=0; i&lt;num_threads; i++){
    qthread_fork(spin, <span style="color: #87ffd7;">NULL</span>,&amp;ret);
  }
  <span style="color: #afffaf;">for</span>(i=0; i&lt;num_threads; i++){
    qthread_readFE(<span style="color: #87ffd7;">NULL</span>, &amp;ret);
  }
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Disable collection, you can switch on and off at will during a run</span>
  qtperf_stop();

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Print the results in a human readable format</span>
  qtperf_print_results();

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Deallocate everything. No more calls to qtperf_* after this!</span>
  qtperf_free_data();

  <span style="color: #afffaf;">return</span> 0;
}
</pre>
</div>

<p>
Here is a program to demonstrate how to set up and use a custom state group:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #87ffd7; font-weight: bold;">#include</span><span style="color: #af5f00;">&lt;qthread/qthread.h&gt;</span>
<span style="color: #87ffd7; font-weight: bold;">#include</span><span style="color: #af5f00;">&lt;qthread/performance.h&gt;</span>
<span style="color: #87ffd7; font-weight: bold;">#include</span><span style="color: #af5f00;">&lt;qthread/logging.h&gt;</span>

<span style="color: #afffaf;">static</span> <span style="color: #afffaf;">inline</span> <span style="color: #5fd787;">int</span> <span style="color: #87d7ff;">spin_lock</span>(<span style="color: #afffaf;">volatile</span> <span style="color: #5fd787;">uint32_t</span>* <span style="color: #00ff00;">busy</span>);

<span style="color: #afffaf;">static</span> <span style="color: #afffaf;">inline</span> <span style="color: #5fd787;">int</span> <span style="color: #87d7ff;">spin_lock</span>(<span style="color: #afffaf;">volatile</span> <span style="color: #5fd787;">uint32_t</span>* <span style="color: #00ff00;">busy</span>){
  <span style="color: #5fd787;">int</span> <span style="color: #00ff00;">ret</span>=0;
  <span style="color: #afffaf;">while</span>(qthread_cas32(busy, 0, 1) != 0){
    ret=1;
  }
  <span style="color: #afffaf;">return</span> ret;
}

<span style="color: #afffaf;">typedef</span> <span style="color: #afffaf;">enum</span> {
  <span style="color: #00ff00;">SPIN_WORKING</span>,
  <span style="color: #00ff00;">SPIN_WAITING</span>,
  <span style="color: #00ff00;">SPIN_COMPLETE</span>,
  <span style="color: #00ff00;">SPIN_NUM_STATES</span>
} <span style="color: #5fd787;">spinstate_t</span>;

<span style="color: #afffaf;">const</span> <span style="color: #5fd787;">char</span>* <span style="color: #00ff00;">spin_names</span>[] = {
  <span style="color: #af5f00;">"SPIN_WORKING"</span>,
  <span style="color: #af5f00;">"SPIN_WAITING"</span>,
  <span style="color: #af5f00;">"SPIN_COMPLETE"</span>,
  <span style="color: #af5f00;">"SPIN_NUM_STATES"</span>
};

<span style="color: #afffaf;">volatile</span> <span style="color: #5fd787;">uint32_t</span> <span style="color: #00ff00;">busy</span>=0;
<span style="color: #5fd787;">int</span> <span style="color: #00ff00;">strct</span>=0;
<span style="color: #5fd787;">aligned_t</span> <span style="color: #00ff00;">bit</span>=0;

<span style="color: #87ffd7; font-weight: bold;">#define</span> <span style="color: #00ff00;">SPIN</span> 1
<span style="color: #5fd787;">aligned_t</span> <span style="color: #87d7ff;">struct_edit</span>(<span style="color: #5fd787;">void</span>*<span style="color: #00ff00;">data</span>){
  <span style="color: #5fd787;">int</span> <span style="color: #00ff00;">start</span> =0;
  <span style="color: #5fd787;">size_t</span> <span style="color: #00ff00;">i</span>=0;
  <span style="color: #5fd787;">aligned_t</span> <span style="color: #00ff00;">ret</span>=0;
  <span style="color: #5fd787;">int</span> <span style="color: #00ff00;">interruptions</span>=0;
  <span style="color: #5fd787;">qtperfdata_t</span>* <span style="color: #00ff00;">mydata</span> = (<span style="color: #5fd787;">qtperfdata_t</span>*)data;

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Upon entry, timing is recorded for previous state</span>
  qtperf_enter_state(mydata, SPIN_WORKING);

  <span style="color: #afffaf;">for</span>(i=0; i&lt;100; i++){
    <span style="color: #5fd787;">size_t</span> <span style="color: #00ff00;">j</span>=0;

    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Multiple state transitions are expected, timing will not be</span>
    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">affected by transitioning to the same state multiple times.</span>
    qtperf_enter_state(mydata, SPIN_WAITING);

    interruptions += spin_lock(&amp;busy);
    qtperf_enter_state(mydata, SPIN_WORKING);
    start = strct;
    <span style="color: #afffaf;">for</span>(j=0; j&lt;1000000; j++){
      strct = strct+1;
    }
    start = strct;
    busy = 0;
  }

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Entering the QTPERF_INVALID_STATE state temporarily switches off</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">data collection for this instance. In this case, this thread is</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">now done so I want to switch it off.</span>
  qtperf_enter_state(mydata, QTPERF_INVALID_STATE);

  qtlogargs(SPIN, <span style="color: #af5f00;">"%d interruptions"</span>, interruptions);
  ret = strct;
  <span style="color: #afffaf;">return</span> ret;
}

<span style="color: #afffaf;">typedef</span> <span style="color: #afffaf;">enum</span> {
  <span style="color: #00ff00;">RUNNING</span>,
  <span style="color: #00ff00;">DONE</span>,
  <span style="color: #00ff00;">TOTAL_NUM_STATES</span>
} <span style="color: #5fd787;">total_t</span>;
<span style="color: #afffaf;">const</span> <span style="color: #5fd787;">char</span>* <span style="color: #00ff00;">total_names</span>[]={
  <span style="color: #af5f00;">"RUNNING"</span>,
  <span style="color: #af5f00;">"DONE"</span>
};

<span style="color: #5fd787;">int</span> <span style="color: #87d7ff;">main</span>() {
  <span style="color: #5fd787;">aligned_t</span> <span style="color: #00ff00;">ret</span>=0;
  <span style="color: #5fd787;">size_t</span> <span style="color: #00ff00;">i</span>=0;
  <span style="color: #5fd787;">qtstategroup_t</span>* <span style="color: #00ff00;">spingroup</span>=<span style="color: #87ffd7;">NULL</span>;
  <span style="color: #5fd787;">qtstategroup_t</span>* <span style="color: #00ff00;">totalgroup</span>=<span style="color: #87ffd7;">NULL</span>;
  <span style="color: #5fd787;">qtperfdata_t</span>* <span style="color: #00ff00;">totaldata</span>=<span style="color: #87ffd7;">NULL</span>;

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Enable collection and setup data structures. Library internals</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">will NOT be logged during this run, because</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">qtperf_set_instrument_* were not called.</span>
  qtperf_start();

  qthread_initialize();

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Create a state group for the spinstate_t state group. The names</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">array can be NULL, in which case the library will just report</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">numeric identifiers in the final output.</span>
  spingroup=qtperf_create_state_group(SPIN_NUM_STATES, <span style="color: #af5f00;">"Spin Testing"</span>, spin_names);

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Create a state group for the total elapsed time.</span>
  totalgroup=qtperf_create_state_group(TOTAL_NUM_STATES, <span style="color: #af5f00;">"Total Time"</span>, total_names);

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Instantiate the total elapsed time state group into a perfdata_t</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">structure to collect data for the run.</span>
  totaldata=qtperf_create_perfdata(totalgroup);

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Initially, perfdata_t are in the QTPERF_INVALID_STATE state, so</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">you must make at least one transition into your start state in</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">order to have logging enabled for the instance.</span>
  qtperf_enter_state(totaldata,RUNNING);

  <span style="color: #afffaf;">for</span>(i=0; i&lt;10; i++){
    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Create a new instance of the spinstate_t state group for each</span>
    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">thread.</span>
    <span style="color: #5fd787;">qtperfdata_t</span>* <span style="color: #00ff00;">spindata</span> = qtperf_create_perfdata(spingroup);

    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">The perfdata_t struct is passed through to the threads. If you</span>
    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">want to aggregate this, you can make use a global variable</span>
    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">because the perfdata will be shared between threads anyway.</span>
    qthread_fork(struct_edit, (<span style="color: #5fd787;">void</span>*)spindata, &amp;ret);
  }
  <span style="color: #afffaf;">for</span>(i=0; i&lt;10; i++){
    qthread_readFE(<span style="color: #87ffd7;">NULL</span>,&amp;ret);
  }
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Signal that the run is complete for the total elapsed time state</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">group.</span>
  qtperf_enter_state(totaldata,DONE);

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Stop collection. This is not final - collection could be</span>
  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">restarted if desired by a call to qtperf_start()</span>
  qtperf_stop();

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">Display the results in a human readable format.</span>
  qtperf_print_results();

  <span style="color: #5faf00;">// </span><span style="color: #5faf00;">signal the library to clean itself up.</span>
  qtperf_free_data();

  <span style="color: #afffaf;">return</span> 0;
}
</pre>
</div>
<p>
API
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Setup Functions</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Setting up qtperf varies a bit depending on what you want to
measure and how you want to track it. In the most minimal form, all
you have to do is call <code>qtperf_start()</code>, then allocate your groups
and you're off to the races. You can also tell the library to
record data from the qthreads internally, and from the library's
workers threads.
</p>

<p>
There are two ways to get internal data out of qthreads using
qtperf. You can measure either the workers (typically a smaller
number of actual operating system threads that implement the work
stealing behavior of qthreads), or you can instrument the qthreads
themselves (which represent tasks visible to the user of the
library). These measurements can be taken together during the same
run.
</p>

<p>
You must inform the library that you want to record this data
<i>before</i> you call <code>qthread_initialize()</code>.
</p>

<p>
The main abstraction that this API relies upon is a state
group. As the user, you will define a set of states that your code
can be in, tell the library when the code makes a transition, and
the library will track the amount of time spent in each state.
</p>

<p>
A state group is a connected set of states - these states are
allowed to have transitions to each other. Transitions can <i>only</i>
be between states that are in the same state group. This is a
constraint that the library has only limited power to enforce. If
a transition is requested to a state that is out of bounds, the
library will flag the error, but if the state number is valid for
the group it will just complete the transition, even if you
mistakenly used the wrong enum variant in the source code. 
</p>

<p>
A state group represents an abstract set of states. In order to
actually attach those states to a thread and measure something,
you need to make a <code>qtperfdata_t</code> struct.
</p>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> <code>qtperf_set_instrument_workers(int yes_or_no)</code></h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
This function will create a state group that allows you to
measure internal timing data for the qthreads library's
workers. Qthreads implements a system of work stealing, in which
a (relatively) small number of system threads aggressively switch
between a large number of task threads so as to maximize the time
spent actually doing productive work. This instrumentation flag
allows you to see how the workers themselves are doing by
measuring their idle versus busy time. Using this data you can
determine how well the processors are being utilized.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> <code>qtperf_set_instrument_qthreads(int yes_or_no)</code></h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
This function allows you to measure the overhead of the qthreads
scheduling systems in sending task work to the worker
threads. Each qthread you create will be monitored to measure how
much time is spent on task versus stalled in various parts of the
qthreads system.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3"><span class="section-number-4">4.2.3</span> <code>qtstategroup_t* qtperf_create_state_group(size_t num_states, const char* group_name, const char** state_names)</code></h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
This function creates a new state group. You must provide a name,
but the array of state names is optional. If no state names are
provided, the library will simply assign numeric identifiers to
the states when output is requested.
</p>

<p>
The value returned is a newly-malloc'd qtstategroup<sub>t</sub>
structure. This structure is meant to be mostly opaque to users,
though you can access its fields if you need to as with any other
struct. For details of its contents, see <code>qthreads/performance.h</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-4" class="outline-4">
<h4 id="sec-4-2-4"><span class="section-number-4">4.2.4</span> <code>qtperfdata_t* qtperf_create_perfdata(qtstategroup_t* group)</code></h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
This creates a new performance counters structure
(<code>qtperfdata_t</code>) that will use the given state group to measure
transitions. This function should be called for each thread that
you want to measure. Data logged here will be kept separate from
other threads. If you want to log data from a group of similar
threads into the same performance counters structure, use
<code>qtperf_create_aggregated_perfdata()</code> (see below).
</p>

<p>
The value returned from this function should be treated as an
opaque identifier unless you are very sure of what you need to do
to it. In order to cause a state transition for this counter,
call <code>qtperf_enter_state</code> with it.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-5" class="outline-4">
<h4 id="sec-4-2-5"><span class="section-number-4">4.2.5</span> <code>qtperfdata_t* qtperf_create_aggregated_perfdata(qtstategroup_t* group)</code></h4>
<div class="outline-text-4" id="text-4-2-5">
<p>
This function is similar to <code>qtperf_create_perfdata</code> except that
it creates a performance counter that is intended to be shared by
many threads during a run. In some cases, large numbers of
threads are doing essentially the same task, and the data you
really want is how the overall task performed for the whole
system. This function is intended to support that use case.
</p>

<p>
If you need to measure data for each thread separately, use
<code>qtperf_create_perfdata</code> instead.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-6" class="outline-4">
<h4 id="sec-4-2-6"><span class="section-number-4">4.2.6</span> <code>void qtperf_piggyback_state(&#x2026;)</code></h4>
<div class="outline-text-4" id="text-4-2-6">
<p>
Arguments:
</p>
<ol class="org-ol">
<li><code>qtperfdata_t* source_data</code> - The perfdata you want to
piggyback onto
</li>
<li><code>qtperfid_t trigger_state</code> - Trigger piggyback when the source
data enters this state
</li>
<li><code>qtperfdata_t* piggyback_data</code> - The counter you want to
attach to the source
</li>
<li><code>qtperfid_t piggyback_state</code> - The state that the piggyback
should enter when the trigger condition is met
</li>
</ol>

<p>
The performance library allows you to add "piggybacks" onto other
states. This means that you can set it up so that a state
transition in one performance counter triggers a state transition
in another performance counter automatically. The primary use of
this is to allow you to pull data out of the internal
instrumentation states and into your own state groups. For
example, you might want to record the time a thread spends
communicating via an external library, processing the data, and
waiting for the qthreads library to schedule it. You would
piggyback your performance counter onto the qthreads internal
performance counters so that the library's internal state changes
are recorded in your own structure. That gives you an easy way to
monitor the internal overhead of the library compared with the
task-related states in a given thread.
</p>
</div>

<ol class="org-ol"><li>Performance impacts! Caution!<br/><div class="outline-text-6" id="text-4-2-6-0-1">
<p>
There are two things to watch out for if you start using
piggybacks heavily. First, it is possible to create a cycle, in
which case your thread will enter an infinite loop and
hang. This is easy to detect in most cases and you'll find the
bug quickly. The second issue to look out for is that each
piggyback you add to a <code>perfdata_t</code> adds a small constant amount
of execution time to each state transition it makes. If you add
a large number of piggybacks, or if you have a bunch of
piggybacks attached in a chain, you may see a performance impact
from processing all of the state transitions. Use piggybacks
sparingly.
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Runtime Functions</h3>
<div class="outline-text-3" id="text-4-3">
<p>
These functions are intended for use while the experiment is
running. They are oriented toward making measurements as painlessly
as possible, and also support getting output at various points.
</p>
</div>

<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> <code>void qtperf_enter_state(qtperfdata_t* data, qtperfid_t state_id)</code></h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
This is the function that you should call each time you want to
record that something has changed. The data argument is the
pointer returned by the <code>qtperf_create_*_perfdata</code> functions, and
the state<sub>id</sub> is the identifier of the state you are entering. The
library will sample the current time, subtract from that the time
that the current state was entered, and add the difference to the
current state's total before entering the new state. If the
perfdata<sub>t</sub> is an aggregated collector, it will also ensure that
only one thread is updating at a time using a CAS-based spin lock.
</p>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2"><span class="section-number-4">4.3.2</span> <code>const char* qtperf_state_name(qtstategroup_t* group, qtperfid_t state_id)</code></h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
This just returns the state name you provided when the state group
was created, for convenience. If you did not define names, this
function returns <code>NULL</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3"><span class="section-number-4">4.3.3</span> <code>void qtperf_start()</code></h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
This function enables data recording. It and its opposite function
(<code>qtperf_stop</code>) can be called any number of times while the
program is running to turn collection on and off as needed.
</p>
</div>
</div>
<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4"><span class="section-number-4">4.3.4</span> <code>void qtperf_stop()</code></h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
This function halts collection globally. You can restart it with
<code>qtperf_start</code>, and both can be called at any time during program
execution without danger.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Reporting and data access functions</h3>
<div class="outline-text-3" id="text-4-4">
<p>
These functions allow you to get the recorded data out of the
library in various forms. Currently, you can have data reported as
human-readable text or comma-separated values, and you can get
access directly to the data structures themselves via an iterator
for low-level or programmatic access.
</p>
</div>

<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> <code>void qtperf_print_results()</code></h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
Print out all of the data for all of the counters, using the
human-readable format provided by <code>qtperf_print_delimited</code>. States
with zero time will be omitted for brevity.
</p>
</div>
</div>
<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2"><span class="section-number-4">4.4.2</span> <code>void qtperf_print_delimited(qtstategroup_t* group, const char* delim, bool print_headers, const char* prefix)</code></h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
This function is intended to make it easy to export data from a
run into other tools by printing it in tabular, delimited
format. It prints out by state <i>group</i>, so all instances of that
group will be printed, one in each row of the table. You can
specify what delimiter to use within rows with <code>delim</code>, and you
can also specify an optional prefix to be printed at column zero
of each row (including the optional header). If <code>print_headers</code> is
true, the name of each state will be printed in a header row so
that the columns of the table are identifiable.
</p>

<p>
The prefix allows you to easily split out a number of different
tables froma single run and divert them to their own files with a
simple command line. For example, if you use bash for your shell
and have two tables you want to keep separate, you can set one
delimiter to '*' and the other to "+", then use this command to
put the data from a single run into two separate files:
</p>

<p>
<code>./program | tee &gt;(egrep '^\*' &gt; stars.csv) &gt;(egrep '^\+' &gt; pluses.csv)</code>
</p>

<p>
This will create a file called <code>stars.csv</code> that has all lines that
begin with '*', and a separate file called <code>pluses.csv</code> that has
all lines that begin with '+'.
</p>
</div>
</div>
<div id="outline-container-sec-4-4-3" class="outline-4">
<h4 id="sec-4-4-3"><span class="section-number-4">4.4.3</span> <code>void qtperf_print_perfdata(qtperfdata_t* perfdata, bool show_states_with_zero_time)</code></h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
This prints the states in a human-readable format along with their
recorded times. If <code>show_states_with_zero_time</code> is non-zero, it
will display all states regardless of their time data. Otherwise,
it will only display states that have non-zero tick counts. This
is mostly useful if you have a number of states that aren't used
yet but might be in the future.
</p>
</div>
</div>
<div id="outline-container-sec-4-4-4" class="outline-4">
<h4 id="sec-4-4-4"><span class="section-number-4">4.4.4</span> <code>void qtperf_print_group(qtstategroup_t* group)</code></h4>
<div class="outline-text-4" id="text-4-4-4">
<p>
Print the performance data for a state group in human-readable
list format. This will print a list of all instances of this
group, along with some summary information for the group as a
whole.
</p>
</div>
</div>
<div id="outline-container-sec-4-4-5" class="outline-4">
<h4 id="sec-4-4-5"><span class="section-number-4">4.4.5</span> <code>void qtperf_print_perfdata(qtperfdata_t* data, bool show_states_with_zero_time)</code></h4>
<div class="outline-text-4" id="text-4-4-5">
<p>
This prints a single entry in the human-readable list format. If
<code>show_states_with_zero_time</code> is true, it will print an entry for
all states, otherwise it will only print if the state actually has
some time recorded.
</p>
</div>
</div>
<div id="outline-container-sec-4-4-6" class="outline-4">
<h4 id="sec-4-4-6"><span class="section-number-4">4.4.6</span> <code>qtperfcounter_t qtperf_total_group_time(qtstategroup_t* group)</code></h4>
<div class="outline-text-4" id="text-4-4-6">
<p>
This function adds up all of the time for all of the instances of
the given state group and returns the result.A
</p>
</div>
</div>
<div id="outline-container-sec-4-4-7" class="outline-4">
<h4 id="sec-4-4-7"><span class="section-number-4">4.4.7</span> <code>qtperfcounter_t qtperf_total_time(qtperfdata_t* data)</code></h4>
<div class="outline-text-4" id="text-4-4-7">
<p>
This function returns the total time elapsed in all states of the
given perfdata instance. If you put your perfdata into the
<code>QTHREAD_INVALID_STATE</code> state when it finishes or is otherwise not
executing, you can use this function to get a simple measurement
of how long the thread was actually running (because time is not
recorded when the thread is in <code>QTHREAD_INVALID_STATE</code>).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Iterators</h3>
<div class="outline-text-3" id="text-4-5">
<p>
A simple iterator is provided for traversing through the
performance data. The iterator traverses stategroups, hitting all
perfcounters within a stategroup before moving to the next
stategroup.  In order to avoid allocation, the iterator interface
expects you to provide it with an iterator struct to use. This is
typically done by declaring a <code>qtperf_iterator_t</code> as a local
variable, then declaring <b>another</b> local variable that points to
the iterator itself, and passing a <b>pointer</b> to that pointer for
the iterator functions. This allows the API to initialize and
update the iterator struct, and to indicate when the end of the
chain has been reached by returning NULL. A basic example of use
would look like this:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #5faf00;">// </span><span style="color: #5faf00;">... </span>
  <span style="color: #5fd787;">qtperfdata_t</span>* <span style="color: #00ff00;">iterdata</span> = <span style="color: #87ffd7;">NULL</span>;
  <span style="color: #5fd787;">qtperf_iterator_t</span> <span style="color: #00ff00;">iterator</span>;
  <span style="color: #5fd787;">qtperf_iterator_t</span>* <span style="color: #00ff00;">iter</span>=&amp;iterator;
  qtperf_iter_begin(&amp;iter);

  <span style="color: #afffaf;">for</span>(iterdata = qtperf_iter_next(&amp;iter);
      iterdata != <span style="color: #87ffd7;">NULL</span>;
      iterdata = qtperf_iter_next(&amp;iter)){
    <span style="color: #5faf00;">// </span><span style="color: #5faf00;">.. do something with the data</span>
  }
<span style="color: #5faf00;">// </span><span style="color: #5faf00;">...</span>
</pre>
</div>

<p>
That snippet of code would loop through all of the perfdata<sub>t</sub>
instances, ordered by state group, and execute the body of the
<code>for</code> loop on each one.
</p>

<p>
The primary use for this is to provide access to the raw data in a
way that will remain consistent when internal changes occur, so
that you can do custom data processing.  If you find you need to
access to the internal data structures, try to do it using this API
so that future changes to the library will be less likely to break
your code.
</p>
</div>

<div id="outline-container-sec-4-5-1" class="outline-4">
<h4 id="sec-4-5-1"><span class="section-number-4">4.5.1</span> <code>void qtperf_iter_begin(qtperf_iterator** iter)</code></h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
This function initializes a new iterator. <code>iter</code> should be a
pointer to a pointer that has been initialized to point at a
<code>qtperf_iterator_t</code> that you allocated (usually on the stack, by
simply declaring it as a local variable). This function <b>will not</b>
allocate a new iterator, so don't pass it <code>NULL</code>, or a pointer to
<code>NULL</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-5-2" class="outline-4">
<h4 id="sec-4-5-2"><span class="section-number-4">4.5.2</span> <code>qtperfdata_t* qtperf_iter_next(qtperf_iterator_t** iter)</code></h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
This function advances the iterator one slot, and returns the
<code>qtperfdata_t</code> it was pointing at before it advanced. You can use
this in the termination condition of a loop as described at the
top of this section.
</p>
</div>
</div>
<div id="outline-container-sec-4-5-3" class="outline-4">
<h4 id="sec-4-5-3"><span class="section-number-4">4.5.3</span> <code>qtperfdata_t* qtperf_iter_deref(qtperf_iterator_t * iter)</code></h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
This function returns the <code>qtperfdata_t</code> that the iterator is
currently pointing at. If the iterator is exhausted, it will
return NULL.
</p>
</div>
</div>
<div id="outline-container-sec-4-5-4" class="outline-4">
<h4 id="sec-4-5-4"><span class="section-number-4">4.5.4</span> <code>qtperf_iterator_t* qtperf_iter_end()</code></h4>
<div class="outline-text-4" id="text-4-5-4">
<p>
This function returns a termination value that you can use to
compare with your iterator to see if you're done. Currently, this
is just NULL, but in the future it may be a value that points to
something else. The correct way to check to see if your iterator
is done is with the comparison <code>myiter == qtperf_iterator_end()</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Teardown</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Stopping the performance system and cleaning up is done with a
single function call to <code>qtperf_free_data()</code>. It has no arguments
and returns <code>void</code>, just call it at the end of your run to free up
resources, particularly if your program will continue running after
performance measurement is no longer needed.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 8/1/2016</p>
<p class="author">Author: Erik Lee</p>
<p class="date">Created: 2016-08-11 Thu 11:01</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.0.3)</p>
<p class="xhtml-validation"><a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a></p>
</div>
</body>
</html>
