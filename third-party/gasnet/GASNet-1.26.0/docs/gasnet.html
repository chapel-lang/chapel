<html lang="en">
<head>
<title>GASNet Specification</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GASNet Specification">
<meta name="generator" content="makeinfo 4.5">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home">
</head>
<body>
<h1 class="settitle">GASNet Specification</h1>
<a name="Top"></a>

<h2 class="unnumbered">GASNet Specification</h2>

   <p>Version 1.8
<br>Released November 2nd, 2006
<br>$Date: 2008/10/11 04:34:38 $
<br>$Revision: 1.44 $
<script>
function emailto(login,domain) {
var result = "m"+"a"+"i"+"l"+"t"+"o"+":" + login + "@" + domain;
//window.confirm(result);
window.location.assign(result);
}
</script>
<br>Editor: <a href="javascript:emailto('bonachea','cs.berkeley.edu')">Dan Bonachea</a>
<br><a href="http://www.cs.berkeley.edu/~bonachea/gasnet">http://www.cs.berkeley.edu/~bonachea/gasnet</a>
<br><a href="http://upc.lbl.gov/">http://upc.lbl.gov/</a>
<hr>

   <p>Copyright &copy; 2002-2004, Dan Bonachea.<br>
Selected portions adapted from:
     <ul>
<li><cite>A. Mainwaring and D. Culler, "Active Message Applications Programming Interface and Communication Subsystem Organization", U.C. Berkeley Computer Science Technical Report, 1996.</cite>
<li><cite>D. Culler et al., "Generic Active Message Interface Specification v1.1", U.C. Berkeley Computer Science Technical Report, Feb, 1995.</cite>
</ul>

   <blockquote>
Permission is granted to freely distribute this specification and use it in
creating GASNet clients or implementations. The authoritative version of the GASNet specification
is maintained by Dan Bonachea and any proposed changes should be submitted for review. 
</blockquote>

   <p>Published by LBNL FTG and U.C. Berkeley
<hr>

   </ul>

<a name="Introduction"></a>

<h2 class="chapter">Introduction</h2>

<h3 class="section">Scope</h3>

   <p>This GASNet specification describes a network-independent and
language-independent high-performance communication interface intended for use in
implementing the runtime system for global address space languages (such as
UPC or Titanium). GASNet stands for
"<strong>G</strong>lobal-<strong>A</strong>ddress <strong>S</strong>pace <strong>Net</strong>working".

<h3 class="section">Organization</h3>

   <p>The interface is divided into 2 layers - the GASNet core API and the GASNet
extended API:

     <ul>
<li>The extended API is a richly expressive and flexible interface that
provides medium and high-level operations on remote memory and collective
operations (basically anything that we could imagine being implemented using
hardware support on some NIC's).

     <li>The core API is a narrow interface based on the Active Messages paradigm,
which is general enough to implement everything in the extended API. 
</ul>

   <p>The core API is the minimum interface that must be implemented on each
network when porting to a new system, and we provide a network-independent
reference implementation of the extended API which is written purely in
terms of the core API to ease porting and quick prototyping. Implementors
for NIC's that provide some hardware support for higher-level messaging
operations (e.g. support for servicing remote reads/writes on the NIC
without involving the main CPU) are encouraged to also implement an
appropriate subset of the extended API directly on the network of interest
(bypassing the core API) to achieve maximal performance for those operations
(but this is an optimization and is not required to have a working system). 
Most clients will use calls to the extended API functions to implement the
bulk of their communication work (thereby ensuring optimal performance
across platforms). However the client is also permitted to use the core
active message interface to implement non-trivial language-specific or
compiler-specific communication operations which would not be appropriate in
a language-independent API (e.g. implementing distributed language-level
locks, distributed garbage collection, collective memory allocation, etc.).

   <p>Note the extended API interface is meant primarily as a low-level
compilation target, not a library for hand-written code - as such, the goals
of expressiveness and performance generally take precedence over readability
and minimality.

<h3 class="section">Conventions</h3>

     <ul>
<li>All GASNet entry points are lower-case identifiers with the prefix <code>gasnet_</code>
<li>All constants are upper-case and preceded with the prefix <code>GASNET_</code>
<li>Clients access the GASNet interface by including the header <code>gasnet.h</code> and
linking the appropriate library
<li>Except where otherwise noted, any of the operations in the GASNet
interface could be implemented using macros or inline functions in an actual
implementation - they are specified using function declaration syntax below
to make the types clear, and all correct client code must type check using
the definitions below. In no case should client code assume it can create a
"function pointer" to any of these operations. Any macro implementations
will ensure that arguments are evaluated exactly once. 
<li>Implementation-specific values in declarations are indicated using "???" 
<li>Sections marked "Implementor's note" are recommendations to implementors
and are not part of the specification
</ul>

<h3 class="section">Definitions</h3>

     <ul>
<li><strong>node</strong> - An OS-level process which returns from <code>gasnet_init()</code>, and its associated
local memory space and system resources. The basic unit of control when
interfacing with GASNet.

     <li><strong>thread</strong> - A single thread of control within a GASNet node, which possibly
shares a virtual memory space and OS-level process-id with other threads in
the node. Clients which may concurrently call GASNet from more than a single
thread must compile to the multi-threaded version of the GASNet library. 
Except where otherwise noted, GASNet makes no distinction between the
threads within a multi-threaded node, and all control functions (e.g. 
barriers) should be executed by a single thread on the node on behalf of all
local threads.

     <li><strong>job</strong> - The collection of nodes making up a parallel execution environment. 
Nodes often correspond to physical, architectural units, but this need not
be the case (e.g. nodes may share a physical CPU/memory/NIC in
multiprogrammed systems with sufficient sharable resources - note that some
GASNet implementations may limit the number nodes which can run concurrently
on a single system based on the number of physical network interfaces)
</ul>

<h3 class="section">Configuration of GASNet</h3>

   <p>Client code must <code>#define</code> exactly one of <code>GASNET_PAR</code>, <code>GASNET_PARSYNC</code> or
<code>GASNET_SEQ</code> when compiling the GASNet library and the client code (before
including <code>gasnet.h</code>) to indicate the threading environment.

     <dl>
<dt><code>GASNET_PAR</code>
     <dd>The most general configuration. Indicates a fully multi-threaded
and thread-safe environment - the client may call GASNet
concurrently from more than one thread. The exact threading system in use is
system-specific, although for obvious reasons both GASNet and the client
code must agree on the threading system - unless otherwise noted, the
default mechanism is POSIX threads.

     <br><dt><code>GASNET_PARSYNC</code>
     <dd>Indicates a multi-threaded but non-concurrent (non-
threadsafe) GASNet environment, where multiple client threads may call
GASNet, but their accesses to GASNet are fully serialized (e.g. by some
level of synchronization above the GASNet interface). GASNet may safely
assume that it will never be called from more than one client thread
<em>concurrently</em> (and the client must ensure this property holds). Client code
must still use GASNet No-Interrupt Sections and Handler-Safe Locks to ensure
correct operation.

     <br><dt><code>GASNET_SEQ</code>
     <dd>Indicates a single-threaded, non-threadsafe environment. GASNet
may safely assume that it will only ever be called from one unique client
thread. Client code must still use GASNet No-Interrupt Sections and
Handler-Safe Locks to ensure correct operation. 
</dl>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>We may be able to make GASNet implementations independent of the
threading system by having the client provide a few callback functions (e.g. 
mutex create/lock/unlock, thread create, threadid query and thread-local-
data set/get)
<li>change the name of gasnet_init based on which mode is selected to ensure
correct version is linked
<li>An implementation of <code>GASNET_PAR</code> is sufficient to handle all the
configurations - the other configurations just permit certain useful
optimizations (such as removing unnecessary locking in the library)
<li>Interrupt-driven implementations of <code>GASNET_SEQ</code> and <code>GASNET_PARSYNC</code> using
signals must be prepared to handle the case where the thread responding to
the signal may not be the thread currently inside a GASNet call. They may
also need to use a private lock during HSL release to prevent multiple
threads from polling simultaneously

   </ul>
   </td></tr></table>

<h3 class="section">Errors</h3>

   <p>Many GASNet core functions return 0 on success (<code>GASNET_OK</code>), or else they
return errors from the following list, as specified by each function:
     <dl>
<dt><code>GASNET_OK = 0 (no error)</code>
     <dd><br><dt><code>GASNET_ERR_RESOURCE</code>
     <dd><br><dt><code>GASNET_ERR_BAD_ARG</code>
     <dd><br><dt><code>GASNET_ERR_NOT_INIT</code>
     <dd><br><dt><code>GASNET_ERR_BARRIER_MISMATCH</code>
     <dd><br><dt><code>GASNET_ERR_NOT_READY</code>
     <dd></dl>

   <p>Except where otherwise noted, errors that occur during a call to the
extended API are fatal.

   <p>Many of the core API functions will return <code>GASNET_ERR_RESOURCE</code> to
indicate a generic failure in the hardware or communications system,
<code>GASNET_ERR_BAD_ARG</code> to indicate an illegal client argument, or
<code>GASNET_ERR_NOT_INIT</code> to indicate that <code>gasnet_attach()</code> has not been called.

   <p>If any node of a GASNet job crashes, aborts, or suffers a fatal hardware
error, GASNet should make every attempt to ensure that the remaining nodes
of the job are terminated in a timely manner to prevent creation of orphaned
processes.

<a name="gasnet_ErrorName"></a>

<h5 class="subsubsection">gasnet_ErrorName, gasnet_ErrorDesc</h5>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>gasnet_ErrorName</b><i> </i>(<i>int </i><var>errval</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">char * <b>gasnet_ErrorDesc</b><i> </i>(<i>int </i><var>errval</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>gasnet_ErrorName()</code> and <code>gasnet_ErrorDesc()</code> convert the GASNet
error number <var>errval</var> into a string containing the name or description
(respectively) of the given error number. The client must not modify the
string returned.

        </td></tr>
</table>

<h3 class="section">GASNet Types</h3>

     <dl>
<dt><code>gasnet_node_t</code>
     <dd>unsigned integer type representing a unique 0-based node index

     <br><dt><code>gasnet_handle_t</code>
     <dd>an opaque type representing a non-blocking operation
in-progress initiated using the extended API

     <br><dt><code>gasnet_handler_t</code>
     <dd>an unsigned integer type representing an index into the core API AM handler table

     <br><dt><code>gasnet_handlerarg_t</code>
     <dd>a 32-bit signed integer type which is used to express
the user-provided arguments to all AM handlers. Platforms lacking a native
32-bit type may define this to a 64-bit type, but only the lower 32-bits are
transmitted during an AM message send (and sign-extended on the receiver).

     <br><dt><code>gasnet_token_t</code>
     <dd>an opaque type passed to core API handlers which may be used to query message information

     <br><dt><code>gasnet_register_value_t</code>
     <dd>the largest unsigned integer type that can fit
entirely in a single CPU register for the current architecture and ABI. 
<code>SIZEOF_GASNET_REGISTER_VALUE_T</code> is a preprocess-time literal integer constant
(i.e. not <code>sizeof()</code>)indicating the size of this type in bytes

     <br><dt><code>gasnet_handlerentry_t</code>
     <dd>struct type used to negotiate handler registration
in <code>gasnet_attach()</code>
</dl>

<h3 class="section">Compile-time constants</h3>

     <dl>
<dt><code>GASNET_SPEC_VERSION_MAJOR</code>
     <dd><br><dt><code>GASNET_SPEC_VERSION_MINOR</code>
     <dd>Integral values corresponding to the major and minor version numbers of the GASNet
specification version adhered to by a particular implementation. The minor version is
incremented whenever new functionality is added to the specification without breaking backward compatibility. 
The major version is incremented whenever specification changes require breaking backward compatibility. 
The title page of this document provides the specification version
corresponding to this version of the specification.

     <br><dt><code>GASNET_RELEASE_VERSION_MAJOR</code>
     <dd><br><dt><code>GASNET_RELEASE_VERSION_MINOR</code>
     <dd><br><dt><code>GASNET_RELEASE_VERSION_PATCH</code>
     <dd>Integral values corresponding to the major, minor and patch version numbers of the release
identifiers corresponding to the packaging on an implementation of GASNet. 
The significance of these values is implementation-defined.

     <br><dt><code>GASNET_VERSION (deprecated)</code>
     <dd>equivalent to GASNET_SPEC_VERSION_MAJOR

     <br><dt><code>GASNET_CONFIG_STRING</code>
     <dd>a string representing any the relevant GASNet compile-time configuration settings
that can be compared using string compare to verify version compatibility. 
The string is also embedded into the library itself such that it can be
scanned for within a binary executable which is statically linked with GASNet.

     <br><dt><code>GASNET_MAXNODES</code>
     <dd>an integer representing the maximum number of nodes supported in a single
GASNet job. This value must be representable as a <code>gasnet_node_t</code>.

     <br><dt><code>GASNET_ALIGNED_SEGMENTS</code>
     <dd>defined by the GASNet implementation to the value 1 if <code>gasnet_attach()</code>
guarantees that the remote-access memory segment will be aligned at the same virtual
address on all nodes. Defined to 0 otherwise.

     <br><dt><code>GASNET_PAGESIZE</code>
     <dd>a preprocessor constant integer which provides the memory granularity size used for
various GASNet parameters which are required to be page-aligned. On many systems this
will be the system page size. 
</dl>

<h3 class="section">General notes</h3>

     <ul>
<li>All GASNet functions (in the extended <em>and</em> core API) support loopback
(i.e. a node sending a get or active message to itself), and all functions
will still work in the case of single-node jobs (e.g. barriers are basically
no-ops in that case)
<li>GASNet will ensure that stdout/stderr are correctly propagated in a
system-specific way (e.g. to the spawning console or possibly to a file or
set of files). No guarantees are made about propagation of stdin, although
some implementations may choose to deal with this. 
<li>GASNet makes no guarantees about the propagation of external signals
across a job - however, see comments in <code>gasnet_exit</code>
</ul>

   <hr>

<a name="Core%20API"></a>

<h2 class="chapter">Core API</h2>

   <p>The core API consists of:
     <ul>
<li>A job control interface for bootstrapping, job termination and job
environment queries
<li>The active messaging interface for implementing requests, replies and
handlers
<li>An interface which provides handler signal-safety and atomicity control
(No-Interrupt Sections and Handler-Safe Locks)
</ul>

<a name="Job%20Control%20Interface"></a>

<h3 class="section">Job Control Interface</h3>

   <p>Job startup in GASNet is a two-step process. GASNet programs should start by calling
gasnet_init() as the first statement in their main() function, which bootstraps the nodes
and establishes command-line arguments and the job environment. All nodes then call the
gasnet_attach() function to initialize the network and register shared memory segments.

   <p>GASNet initialization may register some UNIX signal handlers (e.g. to support
interrupt-based implementations or aggressive segment registration policies). Client
code which registers signal handlers must be careful not to preempt any
GASNet-registered signal handlers (even for seemingly fatal signals such as
<code>SIGABRT</code>) - the only signal which the client may always safely catch is
<code>SIGQUIT</code>.

   <p>Any GASNet library implementation can be built in one of the following three
configurations, which affects the behavior of remote-access memory segment registration
during gasnet_attach(). 
The <code>gasnet.h</code> header file will define the appropriate preprocessor symbol
to indicate which configuration is active.

     <dl>
<dt><code>GASNET_SEGMENT_FAST</code>
     <dd>The remote-access memory segment is limited to an implementation-defined "reasonable" size,
and optimized in an implementation-specific way to provide the fastest possible
remote accesses. The maximum segment size may be queried using
<code>gasnet_getMaxLocalSegmentSize()</code>.

     <br><dt><code>GASNET_SEGMENT_LARGE</code>
     <dd>This configuration allows clients with larger shared data requirements to
register a larger remote-access memory segment, possibly at some cost in the
efficiency of remote accesses. The maximum segment size may be queried using
<code>gasnet_getMaxLocalSegmentSize()</code>, and should be comparable to the maximum
total data size allowed for processes on the given system.

     <br><dt><code>GASNET_SEGMENT_EVERYTHING</code>
     <dd>The entire virtual memory space of each process is made available for remote access,
in a way such that any memory access that would succeed when executed locally by this node
would also succeed if executed by other nodes remotely. This can be used by clients which
need to make the entire memory heap, stack and static data areas available for remote access. 
</dl>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>The maximum segment size for <code>GASNET_SEGMENT_FAST</code> on many implementations
is likely to to be limited by factors such as the amount of pinnable physical memory
currently available in the system, and the access range of the NIC hardware. 
<li><code>GASNET_SEGMENT_EVERYTHING</code> support can trivially be provided by implementing all
the remote-access operations and long AM messages using core API medium messages,
such that all data accesses are actually executed by the local host processor. 
However, implementors are encouraged to investigate higher-performance alternatives whenever possible. 
<li>On systems requiring pinned segments, <code>GASNET_SEGMENT_LARGE</code> can be implemented
using dynamic pinning schemes (possibly with caching to amortize rendezvous and
pinning costs) or combinations of direct remote accesses and AM-based accesses.

   </ul>
   </td></tr></table>

<a name="gasnet_init"></a>

<h5 class="subsubsection">gasnet_init</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_init</b><i> </i>(<i>int *</i><var>argc</var><i>, char ***</i><var>argv</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Bootstraps a GASNet job and performs any system-specific setup required.

     <p>Called by all GASNet-based applications upon startup to bootstrap the nodes,
before any other processing takes place. Must be called before
any calls to any other functions in this specification, and before any
investigation of the command-line parameters passed to the program in
<var>argc</var>/<var>argv</var>, which may be modified or augmented by this call. 
The semantics of any code executing before the call to <code>gasnet_init()</code>
is implementation-specific (for example, it is undefined whether
<code>stdin/stdout/stderr</code> are functional, or even how many nodes will run that code).

     <p>Upon return from <code>gasnet_init()</code>, all the nodes of the job will be running,
stdout/stderr will be functional, and the basic job environment will be established,
however the primary network resources may not yet have been initialized. 
The following GASNet functions are the only ones that may be called between
<code>gasnet_init()</code> and <code>gasnet_attach()</code>:
     <pre class="example">          <code>gasnet_mynode()</code>
          <code>gasnet_nodes()</code>
          <code>gasnet_getMaxLocalSegmentSize()</code>
          <code>gasnet_getMaxGlobalSegmentSize()</code>
          <code>gasnet_getenv()</code>
          <code>gasnet_exit()</code>
          </pre>
     All other GASNet calls are prohibited until after a successful <code>gasnet_attach()</code>.

     <p><code>gasnet_init()</code> may fail with a fatal error and implementation-defined message if
the nodes of the job cannot be successfully bootstrapped. It also may return
an error code such as <code>GASNET_ERR_RESOURCE</code> to indicate there was a problem
acquiring network or system resources. Otherwise, it returns <code>GASNET_OK</code> to indicate success. 
May only be called once during a process lifetime, subsequent calls will
return an error. 
</td></tr>
</table>

<a name="gasnet_attach"></a>

<h5 class="subsubsection">gasnet_attach</h5>

<pre class="lisp">     typedef struct {
       gasnet_handler_t index; // == 0 for don't care
       void (*fnptr)();
     } gasnet_handlerentry_t;
     </pre>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_attach</b><i> </i>(<i>gasnet_handlerentry_t *</i><var>table</var><i>, int </i><var>numentries</var><i>, uintptr_t&nbsp;</i><var>segsize</var><i>,&nbsp;uintptr_t&nbsp;</i><var>minheapoffset</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Initializes the GASNet network system and performs any system-specific setup
required.

     <p><var>table</var> is an array of <var>numentries</var> gasnet_handlerentry_t elements used for registering
active-message handlers provided by the client code. Clients that never explicitly
call the active-message request functions in the core API need not register
any handlers, and may pass a <code>NULL</code> pointer for <var>table</var>. Clients wishing to
register some handlers should fill in <var>table</var> with function pointers and
the desired handler index (or index 0 for "don't-care") - note that handlers
0..127 are reserved for GASNet internal use, and handlers 128..255 are
available for client-provided handlers. Once <code>gasnet_attach()</code> returns, any
"don't care" handler indexes in the table will be modified in place to
reflect the handler index assigned for each handler - the assignment
algorithm is deterministic: passing the same handler table on each node will
guarantee an identical resulting assignment on each node. Handler function
prototypes should match the prototypes described in the Active Message
Interface section.

     <p><var>segsize</var> and <var>minheapoffset</var> are used to communicate the desired size and
location of the remote-access memory data segment for the local node that
will be used for all remote accesses (i.e. using the data transfer functions
of the extended API) or as the target of any Long active-messages in
the core API. The client passes the desired size of this area in bytes as
<var>segsize</var>, which must be a multiple of <code>GASNET_PAGESIZE</code>, and
should be less than or equal to the value returned by <code>gasnet_getMaxLocalSegmentSize()</code>. 
<var>minheapoffset</var> specifies the minimum amount of virtual memory space (in bytes)
to leave between the end of the current memory heap and the beginning of the
remote-access memory segment (on some systems the size of this offset
may limit the total future growth of the local memory heap, on other systems it may be irrelevant). 
All nodes are required to pass the same value for <var>minheapoffset</var>. 
Note that specifying a large
<var>minheapoffset</var> may limit the possible size of the remote-access segment on some systems. 
Passing a <var>segsize</var> of zero disables the remote-access segment for this node, meaning
other nodes cannot access it with remote-memory operations and this node
cannot be the target of any Long AM messages.

     <p>GASNet will attempt to place the data segment in an area of the virtual memory space
whose pages are currently unused (e.g. by calling <code>mmap</code>). 
The actual remote-access segment size achieved may be less than <var>segsize</var> if insufficient
system resources are available - the exact size and location of the segment
for all nodes should be queried after attach using <code>gasnet_getSegmentInfo()</code>. 
The segment assignment is guaranteed to have a <code>GASNET_PAGESIZE</code>-aligned base address and size,
but may differ in size across nodes, according to the requested segment sizes and
system resource availability. 
GASNet will not initialize data within the memory segment in any way, nor
will it attempt to access the memory locations within the segment until
directed to do so by a data transfer function or Long active message.

     <p>If the GASNet implementation defines the macro <code>GASNET_ALIGNED_SEGMENTS</code> to 1, then
<code>gasnet_attach()</code> guarantees that the base of the remote-access memory segment will be
aligned at the same virtual address across all nodes (and will fail if it cannot
provide this). Otherwise, this guarantee is not provided. Note the segment sizes may
still differ across nodes, based on <var>segsize</var> and system resource availability.

     <p>In the <code>GASNET_SEGMENT_FAST</code> and <code>GASNET_SEGMENT_LARGE</code>
configurations, GASNet guarantees that data transfer functions,
Long active messages and local accesses referencing memory locations
in the remote-access memory segment will succeed, even before any local activity
takes place on those pages
(i.e. in an implementation performing lazy registration, first touch = allocate).

     <p><var>segsize</var> and <var>minheapoffset</var> are ignored in the <code>GASNET_SEGMENT_EVERYTHING</code>
configuration, as the entire virtual memory space is implicitly shared for remote access. 
Under this configuration, it is the client's responsibility to ensure that any
remote-memory references fall within the legal areas of the current heap and data segment
for the target node -
remote accesses or Long active messages to locations outside these areas will have undefined effects
(for example, they <em>may</em> cause a segmentation fault on the target node).

     <p><code>gasnet_attach()</code> may fail with a fatal error and implementation-defined message if
the network cannot be successfully initialized. It also may return
an error code such as <code>GASNET_ERR_RESOURCE</code> to indicate there was a problem
acquiring network or system resources. Otherwise, it returns <code>GASNET_OK</code> to indicate success.

     <p>A successful call acts as a global
barrier and blocks until all other nodes which are part of this parallel job
have successfully called <code>gasnet_attach()</code>. 
May only be called once during a process lifetime, subsequent calls will
return an error. 
</td></tr>
</table>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>In the <code>GASNET_SEGMENT_FAST</code> and <code>GASNET_SEGMENT_LARGE</code>
configurations, GASNet must take steps to ensure the pages in the
segment have been properly registered for remote access in a system-specific
and implementation-specific way (e.g. mmapping them so they get added to the
process page table, pinning the pages, registering the physical address with
the NIC, etc.). Implementations are encouraged to defer consuming physical
memory or swap space resources for pages in the segment until the first
actual reference to them. 
<li>Every implementation that pins pages needs a strategy for handling remote accesses
under the <code>GASNET_SEGMENT_LARGE</code> and <code>GASNET_SEGMENT_EVERYTHING</code> configurations
when the segment size exceeds the amount of pinnable pages - e.g. some
implementations may dynamically pin pages, others may pin only a portion of
the segment and use an extra copy to handle access to data outside the
pinned region. 
<li>Some GASNet implementations may need to allocate and pin additional memory
for their own internal use in messaging (e.g. send buffers), but such memory
should not fall within the client's data segment under <code>GASNET_SEGMENT_FAST</code> and <code>GASNET_SEGMENT_LARGE</code>
(although it may be adjacent to it). 
<li>Some GASNet implementations may also choose to pin other pages to optimize
access and remove extra copies - for example, pinning the program stack may
be advisable on some systems since a large number of the data transfer
functions in the extended API are likely to use stack locations as the local
source/destination.

   </ul>
   </td></tr></table>

<a name="gasnet_getMaxLocalSegmentSize"></a>

<h5 class="subsubsection">gasnet_getMaxLocalSegmentSize</h5>

<p>
<table width="100%">
<tr>
<td align="left">uintptr_t <b>gasnet_getMaxLocalSegmentSize</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Retrieve an approximate, optimistic maximum size in bytes for the remote-access memory segment
that may be provided to <code>gasnet_attach()</code> under the current configuration.

     <p>The return value of this function may depend on
current system resource usage, and may return different values on different nodes
of a job, according to current system utilization. The value returned will
always be a multiple of <code>GASNET_PAGESIZE</code>.

     <p>The value returned is an optimistic approximation of the segment size
which can be acquired by <code>gasnet_attach()</code> - the actual size achieved can be queried
after attach using <code>gasnet_getSegmentInfo()</code>.

     <p>On many implementations, this function will return different values in the
<code>GASNET_SEGMENT_FAST</code> and <code>GASNET_SEGMENT_LARGE</code> configurations. 
Under the <code>GASNET_SEGMENT_EVERYTHING</code> configuration, this function returns -1.

     <p>This function has undefined behavior after <code>gasnet_attach()</code>. 
</td></tr>
</table>

<a name="gasnet_getMaxGlobalSegmentSize"></a>

<h5 class="subsubsection">gasnet_getMaxGlobalSegmentSize</h5>

<p>
<table width="100%">
<tr>
<td align="left">uintptr_t <b>gasnet_getMaxGlobalSegmentSize</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Returns a global minimum value
that would be returned by a call to <code>gasnet_getMaxLocalSegmentSize</code>
on any node of the current job (i.e. the smallest max segment size
estimated for any node in the job).

     <p>This function has undefined behavior after <code>gasnet_attach()</code>. 
</td></tr>
</table>

<a name="gasnet_exit"></a>

<h5 class="subsubsection">gasnet_exit</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_exit</b><i> </i>(<i>int </i><var>exitcode</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Terminate the current GASNet job and return the given <var>exitcode</var> to the
console which invoked the job (in a system-specific way). This call is <em>not</em>
a collective operation, meaning any node may call it at any time after
initialization. It causes the system to flush all I/O, release all resources
and terminate the job for all active nodes. If several nodes and/or threads
call it simultaneously with different exit codes within a given
synchronization phase, the result provided to the console will be one of the
provided exit codes (chosen arbitrarily). This function should be called at
the end of <code>main()</code> after a barrier to ensure proper system exit, and should
also be called in the event of any fatal errors. GASNet clients are
encouraged to call <code>gasnet_exit()</code> before explicitly exiting (by calling
<code>exit(),</code> <code>abort()</code>) to reduce the possibility and lifetime of orphaned nodes,
but this is not required.

     <p>GASNet will send a <code>SIGQUIT</code> signal to the node if it detects that a remote
node has called <code>gasnet_exit</code> or crashed (in which case the node should catch
the signal, perform any system-specific shutdown, then call <code>gasnet_exit()</code> to
end the local node process). GASNet will also send a <code>SIGQUIT</code> signal if it
detects that the job has received a different catchable
terminate-the-program signal (e.g. <code>SIGTERM</code>, <code>SIGINT</code>) since some of these other signals
may be meaningful (and non-fatal) to certain GASNet implementations. 
</td></tr>
</table>

<a name="Job%20Environment%20Queries"></a>

<h3 class="section">Job Environment Queries</h3>

<a name="gasnet_mynode"></a>

<h5 class="subsubsection">gasnet_mynode</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_node_t <b>gasnet_mynode</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>returns the unique, 0-based node index representing this node in the current
GASNet job
</td></tr>
</table>

<a name="gasnet_nodes"></a>

<h5 class="subsubsection">gasnet_nodes</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_node_t <b>gasnet_nodes</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>returns the number of nodes in the current GASNet job
</td></tr>
</table>

<a name="gasnet_getSegmentInfo"></a>

<h5 class="subsubsection">gasnet_getSegmentInfo</h5>

<pre class="lisp">     typedef struct {
       void *addr;
       uintptr_t size;
     } gasnet_seginfo_t;
     </pre>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_getSegmentInfo</b><i> </i>(<i>gasnet_seginfo_t *</i><var>seginfo_table</var><i>, int </i><var>numentries</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Query the segment base addresses and sizes for all the nodes in the job. 
<var>seginfo_table</var> is an array of <code>gasnet_seginfo_t</code>
(and <var>numentries</var> is the number of entries in the table). 
GASNet fills in the table with the remote-access segment base address and size
in bytes for each node whose index is less than <var>numentries</var>. 
The value of <var>numentries</var> is usually equal to <code>gasnet_nodes()</code>, but is permitted
to be greater (in which case higher array entries are left untouched) or less (in which case
the higher-numbered nodes are not reported). 
This is a non-collective operation. 
Returns <code>GASNET_OK</code> on success.

     <p>Note that when GASNET_ALIGNED_SEGMENTS=1, the base addresses are guaranteed to be
equal (i.e. all remote-access segments start at the same virtual addresses). 
However, in any case
the segment sizes may differ across nodes, and specifically they may differ from the
size requested by the client in the <code>gasnet_attach()</code> size hint. 
</td></tr>
</table>

<a name="gasnet_getenv"></a>

<h5 class="subsubsection">gasnet_getenv</h5>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>gasnet_getenv</b><i> </i>(<i>const char *</i><var>name</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Has the same semantics as the POSIX <code>getenv()</code> call, except it queries the
system-specific environment which was used to spawn the job (e.g. the
environment of the spawning console). Calling POSIX <code>getenv()</code> directly on
some implementations may not correctly return values reflecting the
environment that initiated the job spawn, consequently GASNet clients wishing to
query a consistent snapshot of the spawning environment across nodes
should never call <code>getenv()</code> directly. The semantics of POSIX <code>setenv()</code>
are undefined in GASNet jobs (specifically, it will probably fail to
propagate changes across nodes). 
</td></tr>
</table>

<a name="Active%20Messaging%20Interface"></a>

<h3 class="section">Active Messaging Interface</h3>

   <p>Active message communication is formulated as logically matching request and
reply operations. Upon receipt of a request message, a request handler is
invoked; likewise, when a reply message is received, the reply handler is
invoked. Request handlers can reply at most once to the requesting node. If
no explicit reply is made, the layer may generate one (to an implicit
do-nothing reply handler). Thus a request handler can call reply at most once,
and may only reply to the requesting node. Reply handlers cannot request or reply.

   <p>Here is a high-level description of a typical active message exchange
between two nodes, A and B:

     <ol type=1 start=1>
<li>A calls <code>gasnet_AMRequest*()</code> to send a request to B. 
The call includes arguments, data payload, the node index of B and the index of
the request handler to run on B when the request arrives

     <li>At some later time, B receives the request, and runs the appropriate
request handler with the arguments and data (if any) provided in the
<code>gasnet_AMRequest*()</code> call. 
  The request handler does some work on the arguments, and usually finishes
by calling <code>gasnet_AMReply*()</code> to issue a reply message before it exits (replying is
optional in GASNet, but required in AM2 - if the request handler does not
reply then no further actions are taken). 
  <code>gasnet_AMReply*()</code> takes the token passed to the request handler, arguments and data
payload, and the index of the reply handler to run when the reply message
arrives. It does not take a node index because a request handler is only
permitted to send a reply to the requesting node

     <li>At some later time, A receives the reply message from B and runs the
appropriate reply handler, with the arguments and data (if any) provided in
the <code>gasnet_AMReply*()</code> call. 
  The reply handler does some work on the arguments and then exits. It is
not permitted to send further messages.
        </ol>

   <p>The message layer will deliver requests and replies to destination nodes
barring any catastrophic errors (e.g. node crashes). From a sender's point
of view, the request and reply functions block until the message is sent. A
message is defined to be sent once it is safe for the caller to reuse the storage
(registers or memory) containing the message (one notable exception to this
policy is <code>gasnet_RequestLongAsyncM()</code>). In implementations which copy or
buffer messages for transmission, the definition still holds: message sent
means the layer has copied the message and promises to deliver the copy with
its "best effort", and the original message storage may be reused. By best
effort, the message layer promises it will take care of all the details
necessary to transmit the message. These details include any retransmission
attempts and buffering issues on unreliable networks.

   <p>However, in either case, sent does not imply received. Once control returns
from a request or reply function, clients cannot assume that the message has
been received and handled at the destination. The message layer only
guarantees that if a request or reply is sent, and, if the receiver
occasionally polls for arriving messages, then the message will eventually
be received and handled. From a receiver's point of view, a message is
defined to be received only once its handler function is invoked. The
contents of partially received messages and messages whose handlers have not
executed are undefined.

   <p>If the client sends an AM request or AM reply to a handler index which has
not been registered on the destination node, GASNet will print an implementation-defined
error message and terminate the job. It is implementation-defined whether this
checking happens on the sending or receiving node.

<a name="Active%20Message%20Categories"></a>

<h4 class="subsection">Active Message Categories</h4>

   <p>There are three categories of active messages:

     <dl>
<dt><code>Short Active Message</code>
     <dd>These messages carry only a few integer arguments (up to <code>gasnet_AMMaxArgs()</code>)
<br>handler prototype:
     <pre class="lisp">          void handler(gasnet_token_t token,
                       gasnet_handlerarg_t arg0, ... gasnet_handlerarg_t argM-1);
          </pre>
     <br><dt><code>Medium Active Message</code>
     <dd>In addition to integer arguments, these messages can can carry an opaque
data payload (up to <code>gasnet_AMMaxMedium()</code> bytes in length), that will
be made available to the handler when it is run on the remote node. 
<br>handler prototype:
     <pre class="lisp">          void handler(gasnet_token_t token,
                       void *buf, size_t nbytes,
                       gasnet_handlerarg_t arg0, ... gasnet_handlerarg_t argM-1);
          </pre>
     <br><dt><code>Long Active Message</code>
     <dd>In addition to integer arguments, these messages can carry an opaque
data payload (up to <code>gasnet_AMMaxLong()</code> bytes in length) which is destined
for a particular predetermined address in the segment of the remote node
(often implemented using RDMA hardware assistance)
<br>handler prototype:
     <pre class="lisp">          void handler(gasnet_token_t token,
                       void *buf, size_t nbytes,
                       gasnet_handlerarg_t arg0, ... gasnet_handlerarg_t argM-1);
          </pre>
     </dl>

   <p>For more discussion on these three categories, see the Appendix.

   <p>The number of handler arguments (M) is specified upon issuing a request or
reply by choosing the request/reply function of the appropriate name. The
category of message and value of M used in the request/reply message sends
determines the appropriate handler prototype, as detailed above. If a
request or reply is sent to a handler whose prototype does not match the
requirements as detailed above, the result is undefined.

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>Some implementations may choose to optimize medium and long messages for
payloads whose base address and length are aligned with certain convenient
sizes (word-aligned, doubleword-aligned, page-aligned etc.) but this does
not affect correctness.

   </ul>
   </td></tr></table>

<a name="Active%20Message%20Size%20Limits"></a>

<h4 class="subsection">Active Message Size Limits</h4>

   <p>These functions are used to query the maximum size messages of each category supported by a
given implementation. These are likely to be implemented as macros for
efficiency of client code which uses them (within packing loops, etc.)

<a name="gasnet_AMMaxArgs"></a>

<h5 class="subsubsection">gasnet_AMMaxArgs</h5>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>gasnet_AMMaxArgs</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Returns the maximum number of handler arguments (i.e. M) that may be passed
with any AM request or reply function. This value is guaranteed to be at
least <code>(2 * MAX(sizeof(int),sizeof(void*)))</code> (i.e. 8 for 32-bit systems, 16
for 64-bit systems), which ensures that 8 ints and/or pointers can be sent
with any active message. All implementations must support <em>all</em> values of M
from 0...<code>gasnet_AMMaxArgs()</code>. 
</td></tr>
</table>

<a name="gasnet_AMMaxMedium"></a>

<h5 class="subsubsection">gasnet_AMMaxMedium</h5>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>gasnet_AMMaxMedium</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Returns the maximum number of bytes that can be sent in the payload of a
single medium AM request or reply. This value is guaranteed to be at least
512 bytes on any implementation. 
</td></tr>
</table>

<a name="gasnet_AMMaxLongRequest"></a>

<h5 class="subsubsection">gasnet_AMMaxLongRequest</h5>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>gasnet_AMMaxLongRequest</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Returns the maximum number of bytes that can be sent in the payload of a
single long AM request. This value is guaranteed to be at least 512 bytes on
any implementation. Implementations which use RDMA to implement long
messages are likely to support a much larger value. 
</td></tr>
</table>

<a name="gasnet_AMMaxLongReply"></a>

<h5 class="subsubsection">gasnet_AMMaxLongReply</h5>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>gasnet_AMMaxLongReply</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Returns the maximum number of bytes that can be sent in the payload of a
single long AM reply. This value is guaranteed to be at least 512 bytes on
any implementation. Implementations which use RDMA to implement long
messages are likely to support a much larger value. 
</td></tr>
</table>

<a name="Active%20Message%20Request%20Functions"></a>

<h4 class="subsection">Active Message Request Functions</h4>

   <p>In the function descriptions below, M is to be replaced with a number in [0 ... <code>gasnet_AMMaxArgs()</code>]

<a name="gasnet_AMRequestShortM"></a>

<h5 class="subsubsection">gasnet_AMRequestShortM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMRequestShortM</b><i> </i>(<i> gasnet_node_t </i><var>dest</var><i>, gasnet_handler_t </i><var>handler</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t </i><var>argM-1</var><i> </i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Send a short AM request to node <var>dest</var>,
to run the handler registered on the destination node at handler table index <var>handler</var>,
with the given M arguments. 
<code>gasnet_AMRequestShortM</code> returns control to the calling thread of computation
after sending the request message. Upon receipt, the receiver invokes the
appropriate active message request handler function with the M integer
arguments. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="gasnet_AMRequestMediumM"></a>

<h5 class="subsubsection">gasnet_AMRequestMediumM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMRequestMediumM</b><i> </i>(<i> gasnet_node_t </i><var>dest</var><i>, gasnet_handler_t </i><var>handler</var><i>, void&nbsp;*</i><var>source_addr</var><i>, size_t </i><var>nbytes</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t&nbsp;</i><var>argM-1</var><i> </i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Send a medium AM request to node <var>dest</var>,
to run the handler registered on the destination node at handler table index <var>handler</var>,
with the given M arguments.

     <p>The message also carries a data payload copied from the local node's memory
space as indicated by <var>source_addr</var> and <var>nbytes</var>
(which need not fall within the registered data segment on the local node). 
The value of <var>nbytes</var> must be no larger than the value returned by
<code>gasnet_AMMaxMedium()</code>, and is permitted to be zero (in which case
<var>source_addr</var> is ignored and the <var>buf</var> value passed to the handler
is undefined).

     <p><code>gasnet_AMRequestMediumM</code> returns control to the calling thread of computation
after sending the associated request, and the source memory may be freely
modified once the function returns. The active message is logically
delivered after the data transfer finishes.

     <p>Upon receipt, the receiver invokes the appropriate request handler function
with a pointer to temporary storage containing the data payload
(in a buffer which is suitably aligned to hold any datatype), the number
of data bytes transferred, and the M integer arguments. The dynamic scope of
the storage is the same as the dynamic scope of the handler. The data should
be copied if it is needed beyond this scope. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="gasnet_AMRequestLongM"></a>

<h5 class="subsubsection">gasnet_AMRequestLongM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMRequestLongM</b><i> </i>(<i> gasnet_node_t </i><var>dest</var><i>, gasnet_handler_t </i><var>handler</var><i>, void&nbsp;*</i><var>source_addr</var><i>, size_t </i><var>nbytes</var><i>, void *</i><var>dest_addr</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t </i><var>argM-1</var><i> </i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Send a long AM request to node <var>dest</var>,
to run the handler registered on the destination node at handler table index <var>handler</var>,
with the given M arguments.

     <p>The message also carries a data payload copied from the local node's memory
space as indicated by <var>source_addr</var> and <var>nbytes</var>
(which need not fall within the registered data segment on the local node). 
The value of nbytes must be no larger than the value returned by
<code>gasnet_AMMaxLongRequest()</code>, and is permitted to be zero (in which case
<var>source_addr</var> is ignored and the <var>buf</var> value passed to the handler
is undefined). 
The memory specified by [<var>dest_addr</var>...(<var>dest_addr</var>+<var>nbytes</var>-1)] must fall
entirely within the memory segment registered for remote access by the
destination node. This area will receive the data transfer before the handler runs.

     <p>If <var>dest</var> is the current node (i.e. loopback) and the source and destination
memory overlap, the result is undefined. 
<code>gasnet_AMRequestLongM</code> returns control to the calling thread of computation
after sending the associated request, and the source memory may be freely
modified once the function returns. The active message is logically
delivered after the bulk transfer finishes. Upon receipt, the receiver
invokes the appropriate request handler function with a pointer into the
memory segment where the data was placed, the number of data bytes
transferred, and the M integer arguments. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="gasnet_AMRequestLongAsyncM"></a>

<h5 class="subsubsection">gasnet_AMRequestLongAsyncM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMRequestLongAsyncM</b><i> </i>(<i> gasnet_node_t </i><var>dest</var><i>, gasnet_handler_t </i><var>handler</var><i>, void&nbsp;*</i><var>source_addr</var><i>, size_t </i><var>nbytes</var><i>, void *</i><var>dest_addr</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t </i><var>argM-1</var><i> </i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>gasnet_AMRequestLongAsyncM()</code> has identical semantics to
<code>gasnet_AMRequestLongM()</code>, except that the handler is required to send an AM reply
and the data payload source memory must NOT be modified until this matching
reply handler has begun execution. 
Some implementations may leverage this additional constraint to provide
higher performance (e.g. by reducing extra data copying). 
</td></tr>
</table>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>Note that unlike the AM2.0 function of similar name, this function is permitted to block
temporarily if the network is unable to immediately accept the new request.

   </ul>
   </td></tr></table>

<a name="Active%20Message%20Reply%20Functions"></a>

<h4 class="subsection">Active Message Reply Functions</h4>

   <p>The following active message reply functions may only be called from the context of a
running active message request handler, and a reply function may be called at most once from any
given request handler (it is an error to do otherwise).

<a name="gasnet_AMReplyShortM"></a>

<h5 class="subsubsection">gasnet_AMReplyShortM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMReplyShortM</b><i> </i>(<i> gasnet_token_t </i><var>token</var><i>, gasnet_handler_t </i><var>handler</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t </i><var>argM-1</var><i> </i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Send a short AM reply to the indicated <var>handler</var> on the requesting node (i.e. the
node responsible for this particular invocation of the request handler), and
include the given M arguments. 
<code>gasnet_AMReplyShortM</code> returns control to the calling thread of computation
after sending the reply message.

     <p>Upon receipt, the receiver invokes the appropriate active message reply
handler function with the M integer arguments. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="gasnet_AMReplyMediumM"></a>

<h5 class="subsubsection">gasnet_AMReplyMediumM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMReplyMediumM</b><i> </i>(<i> gasnet_token_t </i><var>token</var><i>, gasnet_handler_t </i><var>handler</var><i>, void&nbsp;*</i><var>source_addr</var><i>, size_t </i><var>nbytes</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t&nbsp;</i><var>argM-1</var><i> </i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Send a medium AM reply to the indicated <var>handler</var> on the requesting node (i.e. the
node responsible for this particular invocation of the request handler), with
the given M arguments and given data payload copied from the local node's
memory space (<var>source_addr</var> need not fall within the registered data segment
on the local node). 
The value of <var>nbytes</var> must be no larger than the value returned by
<code>gasnet_AMMaxMedium()</code>, and is permitted to be zero (in which case
<var>source_addr</var> is ignored and the <var>buf</var> value passed to the handler
is undefined). 
<code>gasnet_AMReplyMediumM</code> returns control to the calling thread of computation
after sending the associated reply, and the source memory may be freely
modified once the function returns. The active message is logically
delivered after the data transfer finishes.

     <p>Upon receipt, the receiver invokes the appropriate reply handler function
with a pointer to temporary storage containing the data payload, the number
of data bytes transferred, and the M integer arguments. The dynamic scope of
the storage is the same as the dynamic scope of the handler. The data should
be copied if it is needed beyond this scope. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="gasnet_AMReplyLongM"></a>

<h5 class="subsubsection">gasnet_AMReplyLongM</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMReplyLongM</b><i> </i>(<i> gasnet_token_t </i><var>token</var><i>, gasnet_handler_t </i><var>handler</var><i>, void&nbsp;*</i><var>source_addr</var><i>, size_t </i><var>nbytes</var><i>, void *</i><var>dest_addr</var><i>, gasnet_handlerarg_t </i><var>arg0</var><i>, ..., gasnet_handlerarg_t </i><var>argM-1</var><i> </i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Send a long AM reply to the indicated <var>handler</var> on the requesting node (i.e. the
node responsible for this particular invocation of the request handler), with
the given M arguments and given data payload copied from the local node's
memory space (<var>source_addr</var> need not fall within the registered data segment
on the local node). 
The value of <var>nbytes</var> must be no larger than the value returned by
<code>gasnet_AMMaxLongReply()</code>, and is permitted to be zero (in which case
<var>source_addr</var> is ignored and the <var>buf</var> value passed to the handler
is undefined). 
The memory specified by [<var>dest_addr</var>...(<var>dest_addr</var>+<var>nbytes</var>-1)] must fall
entirely within the memory segment registered for remote access by the
destination node. 
If dest is the current node (i.e. loopback) and the source and destination
memory overlap, the result is undefined. 
<code>gasnet_AMReplyLongM</code> returns control to the calling thread of computation
after sending the associated reply, and the source memory may be freely
modified once the function returns. The active message is logically
delivered after the bulk transfer finishes.

     <p>Upon receipt, the receiver
invokes the appropriate reply handler function with a pointer into the
memory segment where the data was placed, the number of data bytes
transferred, and the M integer arguments. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="Misc.%20Active%20Message%20Functions"></a>

<h4 class="subsection">Misc. Active Message Functions</h4>

<a name="gasnet_AMPoll"></a>

<h5 class="subsubsection">gasnet_AMPoll</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMPoll</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>An explicit call to service the network, process pending messages and run
handlers as appropriate. 
Most of the message-sending primitives in GASNet poll the network
implicitly. 
Purely polling-based implementations of GASNet may require occasional calls
to this function to ensure progress of remote nodes during compute-only
loops. Any client code which spin-waits for the arrival of a message should
call this function within the spin loop to optimize response time. 
This call may be a no-op on some implementations (e.g. purely interrupt-based
implementations). 
Returns <code>GASNET_OK</code> unless an error condition was detected. 
</td></tr>
</table>

<a name="GASNET_BLOCKUNTIL"></a>

<h5 class="subsubsection">GASNET_BLOCKUNTIL</h5>

   <p><code>#define GASNET_BLOCKUNTIL(cond) ???</code>

   <p>This is a macro which implements a busy-wait/blocking polling loop in the
way most efficient for the current GASNet core implementation. The macro
blocks execution of the current thread and services the network until the
provided condition becomes true. <var>cond</var> is an arbitrary C expression which
will be evaluated by the macro one or more times as active messages arrive
until the condition evaluates to a non-zero value. <var>cond</var> is an expression
whose value is altered by the execution of an AM handler which the client
thread is waiting for - GASNet may safely assume that the value of <var>cond</var> will
only change while an AM handler is executing.

   <p>Example usage:
<pre class="lisp">      int doneflag = 0;
      gasnet_AMRequestShort1(..., &amp;doneflag); // reply handler sets doneflag to 1
      GASNET_BLOCKUNTIL(doneflag == 1);
     </pre>

   <p>Note that code like this would be illegal and could cause node 0 to sleep
forever:
<pre class="lisp">      static int doneflag = 0;
      node 0:                                 node 1:
      GASNET_BLOCKUNTIL(doneflag == 1);       gasnet_put_val(0, &amp;doneflag, 1, sizeof(int));
     </pre>
   because <code>gasnet_put_val</code> (and other extended API functions) might not be
implemented using AM handlers.  Also note that <var>cond</var> may be evaluated
concurrently with handler execution, so the client is responsible for negotiating
any atomicity concerns between the cond expression and handlers (for example, protecting
both with a handler-safe lock if the <var>cond</var> expression reads two or more values which are all
updated by handlers). Finally, note that unsynchronized handler code which modifies
one or more locations and then performs a flag write to signal a different thread
may need to execute a local memory barrier before the flag write to ensure correct
ordering on non-sequentially-consistent SMP hardware.

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>one trivial implementation:
<code>#define GASNET_BLOCKUNTIL(cond) while (!(cond)) gasnet_AMPoll()</code>
<li>smarter implementations may choose to spin for awhile and then block
<li>Any implementation that includes blocking must ensure progress if all
client threads call GASNET_BLOCKUNTIL(), and must ensure the blocked thread
is awakened even if the handler is run synchronously during a
<code>gasnet_AMPoll()</code> call from a different client thread. Other client threads
performing sends or polls must not be prevented from making progress by the
blocking thread (possibly a motivation <em>against</em> the "trivial
implementation" above).

   </ul>
   </td></tr></table>

<a name="gasnet_AMGetMsgSource"></a>

<h5 class="subsubsection">gasnet_AMGetMsgSource</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_AMGetMsgSource</b><i> </i>(<i>gasnet_token_t </i><var>token</var><i>, gasnet_node_t *</i><var>srcindex</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Can be called by handlers to query the source of the message being handled. 
The <var>token</var> argument must be the token passed into the handler on entry. 
Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

<a name="Atomicity%20Control"></a>

<h3 class="section">Atomicity Control</h3>

<a name="Atomicity%20semantics%20of%20handlers"></a>

<h4 class="subsection">Atomicity semantics of handlers</h4>

   <p>Handlers may run asynchronously with respect to the main computation (in an
implementation which uses interrupts to run some or all handlers), and they
may run concurrently with each other on separate threads (e.g. in a CLUMP
implementation where several threads may be polling the network at once). An
implementation using interrupts may result in handler code running within a
signal handler context. Some implementations may even choose to run handlers
on a separate private thread created by GASNet (making handlers asynchronous
with respect to all client threads). Note that polling-based GASNet
implementations are likely to poll (and possibly run handlers) from within
<em>any</em> GASNet call (i.e. not just <code>gasnet_AMPoll()</code>). Because of all this,
handler code should run quickly and to completion without making blocking
calls, and should not make assumptions about the context in which it is
being run (special care must be taken to ensure safety in a signal handler
context, see below).

   <p>Regardless, handlers themselves are not interruptible - any given thread
will only be running a single AM handler at a time and will never be
interrupted to run another AM handler (there is one exception to this rule -
the <code>gasnet_AMReply*()</code> call in a request handler may cause reply handlers to
run synchronously, which may be necessary to avoid deadlock in some
implementations. This should not be a problem since <code>gasnet_AMReply*()</code> is
often the last action taken by a request handler).  Handlers are
specifically prohibited from initiating random network communication to
prevent deadlock - request handlers must generate at most one reply (to the
requestor) and make no other communication calls (including polling), and
reply handlers may not communicate or poll at all.

   <p>The asynchronous nature of handlers requires two mechanisms to make them
safe: a mechanism to ensure signal safety for GASNet implementations using
interrupt-based mechanisms, and a locking mechanism to allow atomic updates
from handlers to data structures shared with the client threads and other
handlers.

   <p>(see <a href="http://www.cs.berkeley.edu/~bonachea/upc/">http://www.cs.berkeley.edu/~bonachea/upc/</a> for a more
detailed discussion on handler atomicity)

<a name="No-Interrupt%20Sections"></a>

<h4 class="subsection">No-Interrupt Sections - Ensuring signal-safety for handlers</h4>

   <p>Traditionally, code running in signal handler context is extremely
circumscribed in what it can do: e.g. none of the standard pthreads/System V
synchronization calls are on the list of signal-safe functions (for such a
list see <cite>POSIX System Interfaces 2.4, IEEE Std 1003.1-2001</cite>). 
Note that even most "thread-safe" libraries will break or deadlock if
called from a signal handler by the same thread currently executing a
different call to that library in an earlier stack frame. One specific case
where this is likely to arise in practice is calls to <code>malloc()</code>/<code>free()</code>. To
overcome these limitations, and allow our handlers to be more useful, the
normal limitations on signal handlers will be avoided by allowing the client
thread to temporarily disable the network interrupts that run handlers. All
function calls that are not signal-safe and could possibly access state
shared by functions also called from handlers MUST be called within a GASNet
"No-Interrupt Section":

<a name="gasnet_hold_interrupts"></a>

<h5 class="subsubsection">gasnet_hold_interrupts, gasnet_resume_interrupts</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_hold_interrupts</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_resume_interrupts</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>gasnet_hold_interrupts()</code> and <code>gasnet_resume_interrupts()</code> are used to define a
GASNet No-Interrupt Section (any code which dynamically executes between the
hold and resume calls is said to be "inside" the No-Interrupt Section). 
These are likely to be implemented as macros and highly tuned for
efficiency. 
The hold and resume calls must be paired, and may <em>not</em> be nested
recursively or the results are undefined (this means that clients should be
especially careful when calling other functions in the client from within a
No-Interrupt Section). 
Both calls will return immediately in the common case, although one or both
may cause messages to be serviced on some implementations. 
GASNet guarantees that no handlers will run asynchronously
<strong>on the current thread</strong> within the No-Interrupt Section. 
The no-interrupt state is a
per-thread setting, and GASNet may continue running handlers synchronously or
asynchronously on other client threads or GASNet-private threads (even in a
<code>GASNET_SEQ</code> configuration) - specifically, a No-Interrupt Section does <strong>not</strong>
guarantee atomicity with respect to handler code, it merely provides a way
to ensure that handlers won't run on a given thread while it's inside a call
to a non-signal-safe library. 
</td></tr>
</table>

<a name="Restrictions%20on%20No-Interrupt%20Sections"></a>

<h4 class="subsection">Restrictions on No-Interrupt Sections</h4>

   <p>There is a strict set of conventions governing the use of
No-Interrupt Sections which must be followed in order to ensure correct operation on all
GASNet implementations. Clients which violate any of these rules may be
subject to intermittent crashes, fatal errors or network deadlocks.

     <ul>
<li><code>gasnet_hold_interrupts()</code> and <code>gasnet_resume_interrupts()</code> need not be
called from within a handler context - handlers are run within an implicit
No-Interrupt Section, and <code>gasnet_hold_interrupts()</code> and <code>gasnet_resume_interrupts()</code>
calls are ignored within a handler context.

     <li>Code in a No-Interrupt Section must not call any GASNet functions that may
send requests or synchronously run handlers - specifically, the only GASNet
functions which may legally be called within the No-Interrupt Section are:
     <pre class="example">          <code>gasnet_mynode()</code>, <code>gasnet_nodes()</code>, <code>gasnet_hsl_*()</code>, <code>gasnet_exit()</code>, <code>gasnet_AMReply*()</code>
          </pre>
     Note that due to the previous rule, these are also the only GASNet functions
that may legally be called within a handler context (and <code>gasnet_AMReply*()</code>
is only legal in a request handler).

     <li>Code in a No-Interrupt Section must never block or spin-wait for an
unbounded amount of time, especially when awaiting a result produced by a
handler. The <em>only</em> exception to this rule is that a thread may call
<code>gasnet_hsl_lock</code> within a No-Interrupt Section (subject to the rules
in section see <a href="#Restrictions%20on%20Handler-Safe%20Locks">Restrictions on Handler-Safe Locks</a>).

     <li>No-Interrupt Sections should only be held "briefly" to avoid starving the
network (could cause performance degradation, but should not affect
correctness). Very long No-Interrupt Sections (i.e. on the order of 10 sec
or more) could cause some GASNet implementations employing timeout-based
mechanisms to fail (e.g. remote nodes may decide this node is dead and abort
the job). 
</ul>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>One possible implementation:
Keep a bit for each thread indicating whether or not a No-Interrupt Section
is in effect, which is checked by all asynchronous signal handlers. 
If a signal arrives while a No-Interrupt Section is in effect, a different
per-thread bit in memory will be marked indicating a "missed GASNet signal":
the <code>gasnet_resume_interrupts()</code> call will check this bit, and if it is set,
the action for the signal will be taken (the action for a GASNet signal is
always to check the queue of incoming network messages, so there's no
ambiguity on what the signal meant. Since messages are queued, the single
'signal missed' bit is sufficient for an arbitrary number of missed signals
during a single No-Interrupt Section - GASNet messages will be removed and
processed until the queue is empty). 
<li>Implementation needs to hold a No-Interrupt Section over a thread while
running handlers or holding HSL's
<li>Strictly polling-based implementations which never interrupt a thread can
implement these as a no-op.

   </ul>
   </td></tr></table>

<a name="Handler-Safe%20Locks"></a>

<h4 class="subsection">Handler-Safe Locks</h4>

   <p>In order to support handlers atomically updating data structures accessed by
the main-line client code and other handlers, GASNet provides the
Handler-Safe Lock (HSL) mechanism. As the name implies, these are a special kind of
lock which are distinguished as being the <strong>only</strong> type of lock which may be
safely acquired from a handler context. There is also a set of restrictions
on their usage which allows this to be safe (see below). All lock-protected
data structures in the client that need to be accessed by handlers should be
protected using a Handler-Safe Lock (i.e. instead of a standard POSIX
mutex).

<a name="gasnet_hsl_t"></a>

<h5 class="subsubsection">gasnet_hsl_t</h5>

   <p><code>gasnet_hsl_t</code> is an opaque type representing a Handler-Safe Lock. 
HSL's operate analogously to POSIX mutexes, in that they are always
manipulated using a pointer.

<a name="gasnet_hsl_init"></a>

<h5 class="subsubsection">gasnet_hsl_init, gasnet_hsl_destroy</h5>

   <p><code>gasnet_hsl_t hsl = GASNET_HSL_INITIALIZER;</code>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_hsl_init</b><i> </i>(<i>gasnet_hsl_t *</i><var>hsl</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_hsl_destroy</b><i> </i>(<i>gasnet_hsl_t *</i><var>hsl</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Similarly to POSIX mutexes, HSL's can be created in two ways. They can be
statically declared and initialized using the <code>GASNET_HSL_INITIALIZER</code>
constant. Alternately, HSL's allocated using other means (such as dynamic
allocation) may be initialized by calling <code>gasnet_hsl_init()</code>. 
<code>gasnet_hsl_destroy()</code> may be called on either type of HSL once it's no longer
needed to release any system resources associated with it. 
It is erroneous to call <code>gasnet_hsl_init()</code> on a given HSL more than once. It
is erroneous to destroy an HSL which is currently locked. Any errors
detected in HSL initialization/destruction are fatal. 
</td></tr>
</table>

<a name="gasnet_hsl_lock"></a>

<h5 class="subsubsection">gasnet_hsl_lock, gasnet_hsl_unlock</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_hsl_lock</b><i> </i>(<i>gasnet_hsl_t *</i><var>hsl</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_hsl_trylock</b><i> </i>(<i>gasnet_hsl_t *</i><var>hsl</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_hsl_unlock</b><i> </i>(<i>gasnet_hsl_t *</i><var>hsl</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Lock and unlock HSL's.

     <p><code>gasnet_hsl_lock(hsl)</code> will block until the <var>hsl</var> lock can be
acquired by the current thread. <code>gasnet_hsl_lock()</code> may be called from within
main-line client code or from within handlers - this is the <strong>only</strong> blocking
call which is permitted to execute within a GASNet handler context (e.g. it
is erroneous to call POSIX mutex locking functions).

     <p><code>gasnet_hsl_trylock(hsl)</code> attempts to acquire <code>hsl</code> for the current
thread, returning immediately (without blocking).  If the lock was successfully
acquired, this function returns <code>GASNET_OK</code>.  If the lock could not be
acquired (e.g it was found to be held by another thread) then this function
returns GASNET_ERR_NOT_READY and the lock is not acquired.  It is <em>not</em>
legal for an AM handler to spin-poll a lock without bound using
<code>gasnet_hsl_trylock()</code> waiting for success - AM handlers must always use
<code>gasnet_hsl_lock()</code> when they wish to block to acquire an HSL.

     <p><code>gasnet_hsl_unlock(hsl)</code> releases the <var>hsl</var> lock previously acquired
using <code>gasnet_hsl_lock(hsl)</code> or a successful
<code>gasnet_hsl_trylock(hsl)</code>, and not yet released. 
It is erroneous to call any of these functions on HSL's which have not been
properly initialized.

     <p>Note that under the <code>GASNET_SEQ</code> configuration, HSL locking functions may only
be called from handlers and the designated GASNet client thread (<em>not</em> from
other client threads that may happen to exist - those threads are not
permitted to make <em>any</em> GASNet calls, which includes HSL locking calls).

     <p>All HSL locking/unlocking calls must follow the usage rules documented in the
next section.

        </td></tr>
</table>

<a name="Restrictions%20on%20Handler-Safe%20Locks"></a>

<h4 class="subsection">Restrictions on Handler-Safe Locks</h4>

   <p>There is a strict set of conventions governing the use of HSL's which must
be followed in order to ensure correct operation on all GASNet
implementations. Amongst other things, the restrictions are designed to
ensure that HSL's are always held for a strictly bounded amount of time, to
ensure that acquiring them from within a handler can't lead to deadlock. 
Clients which violate any of these rules may be subject to intermittent
crashes, fatal errors or network deadlocks.

     <ul>
<li>Code executing on a thread holding an HSL is implicitly within a
No-Interrupt Section, and must follow all the restrictions on code within a
No-Interrupt Section (see <a href="#Restrictions%20on%20No-Interrupt%20Sections">Restrictions on No-Interrupt Sections</a>). 
Calls to <code>gasnet_hold_interrupts()</code> and <code>gasnet_resume_interrupts()</code>
are ignored while holding an HSL.

     <li>Any handler which locks one or more HSL's <strong>must</strong> unlock them all before
returning or calling <code>gasnet_AMReply*()</code>

     <li>HSL's may <strong>not</strong> be locked recursively (i.e. calling <code>gasnet_hsl_lock()</code>
or <code>gasnet_hsl_trylock(hsl)</code> on a
lock already held by the current thread) and attempting to do so will lead
to undefined behavior. It <strong>is</strong> permitted for a thread to acquire more than
one HSL, although the traditional cautions about the possibility of deadlock
in the presence of multiple locks apply (e.g. the common solution is to
define a total order on locks and always acquire them in a monotonically
ascending sequence).

     <li>HSL's must be unlocked in the reverse order they were locked (e.g. lock A;
lock B; ... unlock B; unlock A; is legal - reversing the order of unlocks is
erroneous)

     <li>HSL's may not be shared across GASNet processes executing on a machine -
for example, it is specifically disallowed to place an HSL in a system V or
mmapped shared memory segment and attempt to access it from two different
GASNet processes. 
</ul>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>HSL's are likely to just be a thin wrapper around a POSIX mutex - need to
add just enough state/code to ensure the safety properties (must be a real
lock, even under <code>GASNET_PARSYNC</code> because client may still have multiple threads). 
The only specific action required is that a No-Interrupt Section is enforced
while the main-line code is holding an HSL (must be careful this works
properly when multiple HSL's are held or when running in a handler). 
<li>Robust implementations may add extra error checking to help discover
violations of the restrictions, at least when compiled in a debugging mode -
for example, it should be easy to detect: attempts at recursive locking on
HSL's, incorrectly ordered unlocks, handlers that fail to release HSL's,
explicit calls to <code>gasnet_hold_interrupts()</code> and <code>gasnet_resume_interrupts()</code> in
a handler or while an HSL is held or in a No-Interrupt Section, and illegal
calls to GASNet messaging functions while holding an HSL or inside a
No-Interrupt Section.

   </ul>
   </td></tr></table>

   <hr>

<a name="Extended%20API"></a>

<h2 class="chapter">Extended API</h2>

   <p>Errors in calls to the extended API are considered fatal and abort the job
(by sending a <code>SIGABORT</code> signal) after printing an appropriate error message.

<a name="Memory-to-memory%20Data%20Transfer%20Functions"></a>

<h3 class="section">Memory-to-memory Data Transfer Functions</h3>

   <p>These comments apply to all put/get functions:

     <ul>
<li>The <var>nbytes</var> parameter should be a compile-time constant whenever possible (for
efficiency)

     <li>The source memory address for all gets and the target memory address for
all puts must fall within the memory area registered for remote access by
the remote node (see <code>gasnet_attach()</code>), or the results are undefined

     <li>Pointers to remote memory are passed as an ordered pair of arguments: an
integer node rank (a <code>gasnet_node_t</code>) and a <code>void *</code> virtual memory address,
which logically represent a global pointer to the given address on the given
node. These global pointers need not be remote - the node rank passed to
these functions may in fact be the rank of the current node -
implementations must support this form of loopback, and should probably
attempt to optimize it by avoiding network traffic for such purely local
operations.

     <li>If the source memory and destination memory regions overlap (but do not
exactly coincide) the resulting value is undefined
</ul>

<a name="Blocking%20memory-to-memory%20Transfers"></a>

<h3 class="section">Blocking memory-to-memory Transfers</h3>

<a name="gasnet_get"></a>

<h5 class="subsubsection">gasnet_get, gasnet_put</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_get</b><i> </i>(<i>void *</i><var>dest</var><i>, gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_put</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Blocking get/put operations for aligned data. The get operation fetches
<var>nbytes</var> bytes from the address <var>src</var> on node <var>node</var> and places them at
<var>dest</var> in the local memory space. The put operation sends <var>nbytes</var> bytes
from the address <var>src</var> in the local address space, and places them at the
address <var>dest</var> in the memory space of node <var>node</var>. A call to these functions
blocks until the transfer is complete, and the contents of the destination
memory are undefined until it completes. If the contents of the source
memory change while the operation is in progress the result will be
implementation-specific. The <var>src</var> and <var>dest</var> addresses (whether local or
remote) must be properly aligned for accessing objects of size <var>nbytes</var>. 
<var>nbytes</var> must be &gt;= 0 and has no maximum size, but implementations will likely
optimize for small powers of 2. 
</td></tr>
</table>

<a name="gasnet_get_bulk"></a>

<h5 class="subsubsection">gasnet_get_bulk, gasnet_put_bulk</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_get_bulk</b><i> </i>(<i>void *</i><var>dest</var><i>, gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_put_bulk</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Blocking get/put operations for bulk (unaligned) data. These function
similarly to the aligned get/put operations above, except the data is
permitted to be unaligned, and implementations are likely to optimize for
larger sizes of nbytes. 
</td></tr>
</table>

<a name="gasnet_memset"></a>

<h5 class="subsubsection">gasnet_memset</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_memset</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, int </i><var>val</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Blocking operation that has the same effect as if the <var>dest</var> node had executed the POSIX call
<code>memset(</code><var>dest</var><code>, </code><var>val</var><code>, </code><var>nbytes</var><code>)</code>. 
As with puts, the destination memory must fall entirely within the memory area
registered for remote access by the <var>dest</var> node (see <code>gasnet_attach</code>). 
</td></tr>
</table>

<a name="Non-blocking%20memory-to-memory%20transfers"></a>

<h3 class="section">Non-blocking memory-to-memory transfers</h3>

   <p>The following functions provide non-blocking, split-phase memory access to
shared data.

   <p>All such non-blocking operations require an initiation (generally a put or get) and a
subsequent synchronization on the completion of that operation before the
result is guaranteed.

   <p>There are two basic categories of non-blocking operations,
defined by the synchronization mechanism used:
     <dl>
<dt><em>"explicit handle" (nb) operations</em>
     <dd>These operations return a specific handle from the initiation that is used for synchronization. 
The handle can be used to synchronize a specific subset of the nb operations in-flight
<br><dt><em>"implicit handle" (nbi) operations</em>
     <dd>These operations don't return a handle from the initiation -
synchronization is accomplished by calling a synchronization
routine that synchronizes all outstanding nbi operations. 
</dl>

<a name="Synchronization%20semantics%20of%20non-blocking%20data%20transfers"></a>

<h4 class="subsection">Synchronization semantics of non-blocking data transfers</h4>

   <p>Successful synchronization of a non-blocking get operation means the local
result is ready to be examined, and will contain a value held by the source
location at some time in the interval between the call to the initiation
function and the successful completion of the synchronization (note this
specifically allows implementations to delay the underlying read until the
synchronization operation is called, provided they preserve the blocking
semantics of the synchronization function).

   <p>Successful synchronization of a put operation means the source data has
been written to the destination location and get operations issued
subsequently by any thread (or load instructions issued by the destination
node) will receive the new value or a subsequently written value (assuming
no other threads are writing the location)

   <p>Note that the order in which non-blocking operations complete is
intentionally unspecified - the system is free to coalesce and/or reorder
non-blocking operations with respect to other blocking or non-blocking
operations, or operations initiated from a separate thread - the only
ordering constraints that must be satisfied are those explicitly enforced
using the synchronization functions (i.e. the non-blocking operation is only
guaranteed to occur somewhere in the interval between initiation and
successful synchronization on that operation).

   <p>Implementors should attempt to make the non-blocking initiation operations
return as quickly as possible - however in some cases (e.g. when a large
number of non-blocking operations have been issued or the network is
otherwise busy) it may be necessary to block temporarily while waiting for
the network to become available. In any case, all implementations must
support at least 2^16-1
 non-blocking operations in-progress - that
is, the client is free to issue up to 2^16-1
 non-blocking
operations before issuing a sync operation, and the implementation must
handle this correctly without deadlock or livelock.

<a name="Non-blocking%20memory-to-memory%20transfers%20(explicit%20handle)"></a>

<h4 class="subsection">Non-blocking memory-to-memory transfers (explicit handle)</h4>

   <p>The explicit-handle non-blocking data transfer functions return a
<code>gasnet_handle_t</code> value to represent the non-blocking operation in flight. 
<code>gasnet_handle_t</code> is an opaque scalar type whose contents are implementation-defined,
with one exception - every implementation must provide a scalar value corresponding
to an "invalid" handle (<code>GASNET_INVALID_HANDLE</code>) and furthermore this value
must be the result of setting all the bytes in the <code>gasnet_handle_t</code> datatype
to zero. Implementators are free to define the <code>gasnet_handle_t</code> type to be
any reasonable and appropriate size, although they are recommended to use a
type which fits within a single standard register on the target
architecture. In any case, the datatype should be wide enough to express at least
2^16-1

   <p>different handle values, to prevent limiting the number of
non-blocking operations in progress due to the number of handles available.  It
<strong>is</strong> legal for clients to pass <code>gasnet_handle_t</code> values into function callees
or back to function callers.

   <p>In the case of multithreaded clients (<code>GASNET_PAR</code> or <code>GASNET_PARSYNC</code>),
<code>gasnet_handle_t</code> values are thread-specific. In other words, it is an error
to obtain a handle value by initiating a non-blocking operation on one
thread, and later pass that handle into a synchronization function from a
different thread.

   <p>Any explicit-handle, non-blocking operation may return <code>GASNET_INVALID_HANDLE</code>
to indicate it was possible to complete the operation immediately without
blocking (e.g. operations where the "remote" node is actually the local
node)

   <p>It is always an error to discard the <code>gasnet_handle_t</code> value for an
explicit-handle operation in-flight - i.e. to initiate an operation and never
synchronize on its completion.

<a name="gasnet_get_nb"></a>

<h5 class="subsubsection">gasnet_get_nb, gasnet_put_nb</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_handle_t <b>gasnet_get_nb</b><i> </i>(<i>void *</i><var>dest</var><i>, gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">gasnet_handle_t <b>gasnet_put_nb</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Non-blocking get/put functions for aligned data. These functions operate
similarly to their blocking counterparts, except they initiate a
non-blocking operation and return immediately with a handle (<code>gasnet_handle_t</code>)
which must later be used (by calling an explicit <code>gasnet_*_syncnb*()</code> function), to
synchronize on completion of the non-blocking operation. The contents of the
destination memory address are undefined until a synchronization completes
successfully for the non-blocking operation. For the put version, the source
memory may be safely overwritten once the initiation function returns. 
</td></tr>
</table>

<a name="gasnet_get_nb_bulk"></a>

<h5 class="subsubsection">gasnet_get_nb_bulk, gasnet_put_nb_bulk</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_handle_t <b>gasnet_get_nb_bulk</b><i> </i>(<i>void *</i><var>dest</var><i>, gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t&nbsp;</i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">gasnet_handle_t <b>gasnet_put_nb_bulk</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, void *</i><var>src</var><i>, size_t&nbsp;</i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Non-blocking get/put functions for bulk (unaligned) data. For the put
version, the source memory may <strong>not</strong> be safely overwritten until a
successful synchronization for the operation. If the contents of the source
memory change while the operation is in progress the result will be
implementation-specific. These otherwise behave identically to the non-bulk
variants (but are likely to be optimized for large transfers). 
</td></tr>
</table>

<a name="gasnet_memset_nb"></a>

<h5 class="subsubsection">gasnet_memset_nb</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_handle_t <b>gasnet_memset_nb</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, int </i><var>val</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Non-blocking operation that has the same effect as if the <var>dest</var> node had executed the POSIX call
<code>memset(</code><var>dest</var><code>, </code><var>val</var><code>, </code><var>nbytes</var><code>)</code>. 
As with puts, the destination memory must fall entirely within the memory area
registered for remote access by the <var>dest</var> node (see <code>gasnet_attach</code>).

     <p>The synchronization behavior is identical to a non-blocking, explicit-handle put operation (the
<code>gasnet_handle_t</code> return value must be synchronized using an explicit-handle
synchronization operation). 
</td></tr>
</table>

<a name="Synchronization%20for%20explicit-handle%20non-blocking%20operations%3a"></a>

<h4 class="subsection">Synchronization for explicit-handle non-blocking operations:</h4>

   <p>GASNet supports two basic types of synchronization for non-blocking
operations - trying (polling) and waiting (blocking). All explicit-handle
synchronization functions take one or more <code>gasnet_handle_t</code> values as input
and either return an indication of whether the operation has completed or
block until it completes.

<a name="gasnet_wait_syncnb"></a>

<h5 class="subsubsection">gasnet_wait_syncnb, gasnet_try_syncnb</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_wait_syncnb</b><i> </i>(<i>gasnet_handle_t </i><var>handle</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_try_syncnb</b><i> </i>(<i>gasnet_handle_t </i><var>handle</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Synchronize on the completion of a single specified explicit-handle
non-blocking operation that was initiated by the calling thread. 
<code>gasnet_wait_syncnb()</code> blocks until the specified operation has completed (or
returns immediately if it has already completed). In any case, the handle
value is "dead" after <code>gasnet_wait_syncnb()</code> returns and may not be used in
future synchronization operations. 
<code>gasnet_try_syncnb()</code> always returns immediately, with the value <code>GASNET_OK</code> if
the operation is complete (at which point the handle value is "dead", and
may not be used in future synchronization operations), or
<code>GASNET_ERR_NOT_READY</code> if the operation is not yet complete and future
synchronization is necessary to complete this operation.

     <p>It is legal to pass <code>GASNET_INVALID_HANDLE</code> as input to these functions -
<code>gasnet_wait_sync(GASNET_INVALID_HANDLE)</code> returns immediately and
<code>gasnet_try_sync(GASNET_INVALID_HANDLE)</code> returns <code>GASNET_OK</code>.

     <p>It is an error to pass a <code>gasnet_handle_t</code> value for an operation which has
already been successfully synchronized using one of the explicit-handle
synchronization functions. 
</td></tr>
</table>

<a name="gasnet_wait_syncnb_all"></a>

<h5 class="subsubsection">gasnet_wait_syncnb_all, gasnet_try_syncnb_all</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_wait_syncnb_all</b><i> </i>(<i>gasnet_handle_t *</i><var>handles</var><i>, size_t </i><var>numhandles</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_try_syncnb_all</b><i> </i>(<i>gasnet_handle_t *</i><var>handles</var><i>, size_t </i><var>numhandles</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Synchronize on the completion of an array of non-blocking explicit-handle
operations (all of which were initiated by this thread). <var>numhandles</var>
specifies the number of handles in the provided array of handles. 
<code>gasnet_wait_syncnb_all()</code> blocks until all the specified operations have
completed (or returns immediately if they have all already completed). 
<code>gasnet_try_syncnb_all</code> always returns immediately, with the value <code>GASNET_OK</code>
if all the specified operations have completed, or <code>GASNET_ERR_NOT_READY</code> if
one or more of the operations is not yet complete and future synchronization
is necessary to complete some of the operations.

     <p>Both functions will modify the provided array to reflect completions -
handles whose operations have completed are overwritten with the value
<code>GASNET_INVALID_HANDLE</code>, and the client may test against this value when
<code>gasnet_try_syncnb_all()</code> returns <code>GASNET_ERR_NOT_READY</code> to determine which
operations are complete and which are still pending.

     <p>It is legal to pass the value <code>GASNET_INVALID_HANDLE</code> in some of the array
entries, and both functions will ignore it so that it has no effect on
behavior. For example, if all entries in the array are <code>GASNET_INVALID_HANDLE</code>
(or <var>numhandles</var>==0), then <code>gasnet_try_sync_all_list()</code> will return <code>GASNET_OK</code>. 
</td></tr>
</table>

<a name="gasnet_wait_syncnb_some"></a>

<h5 class="subsubsection">gasnet_wait_syncnb_some, gasnet_try_syncnb_some</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_wait_syncnb_some</b><i> </i>(<i>gasnet_handle_t *</i><var>handles</var><i>, size_t </i><var>numhandles</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_try_syncnb_some</b><i> </i>(<i>gasnet_handle_t *</i><var>handles</var><i>, size_t </i><var>numhandles</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>These operate analogously to the <code>gasnet_*_syncnb_all</code> variants, except they only
wait/test for at least one operation corresponding to a <em>valid</em> handle in
the provided list to be complete (the valid handles values are all those
which are not <code>GASNET_INVALID_HANDLE</code>). Specifically,
<code>gasnet_wait_syncnb_some()</code> will block until at least one of the valid handles
in the list has completed, and indicate the operations that have completed
by setting the corresponding handles to the value <code>GASNET_INVALID_HANDLE</code>. 
Similarly, <code>gasnet_try_syncnb_some</code> will check if at least one valid handle in
the list has completed (setting those completed handles to
<code>GASNET_INVALID_HANDLE</code>) and return <code>GASNET_OK</code> if it detected at least one
completion or <code>GASNET_ERR_NOT_READY</code> otherwise.

     <p>Both functions ignore <code>GASNET_INVALID_HANDLE</code> values so those values have no
effect on behavior. If the input array is empty or consists only of
<code>GASNET_INVALID_HANDLE</code> values, <code>gasnet_wait_sync_some_list</code> will return
immediately and <code>gasnet_try_sync_some_list</code> will return <code>GASNET_OK</code>. 
</td></tr>
</table>

<a name="Non-blocking%20memory-to-memory%20transfers%20(implicit%20handle)"></a>

<h4 class="subsection">Non-blocking memory-to-memory transfers (implicit handle)</h4>

<a name="gasnet_get_nbi"></a>

   <p>gasnet_memset_nbi

<h5 class="subsubsection">gasnet_get_nbi, gasnet_put_nbi, gasnet_get_nbi_bulk, gasnet_put_nbi_bulk, gasnet_memset_nbi</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_get_nbi</b><i> </i>(<i>void *</i><var>dest</var><i>, gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_put_nbi</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_get_nbi_bulk</b><i> </i>(<i>void *</i><var>dest</var><i>, gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_put_nbi_bulk</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_memset_nbi</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, int </i><var>val</var><i>, size_t </i><var>nbytes</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Non-blocking get/put functions for aligned and unaligned (bulk) data. These
functions operate similarly to their explicit-handle counterparts, except
they do not return a handle and must be synchronized using the
implicit-handle synchronization operations. The contents of the destination memory
address are undefined until a synchronization completes successfully for the
non-blocking operation. As with the explicit-handle variants, the source
memory for the non-bulk put operation may be safely overwritten once the
initiation function returns, but the bulk put version requires the source
memory to remain unchanged until the operation has been successfully
completed using a synchronization.

     <p><code>gasnet_memset_nbi</code> behaves identically to <code>gasnet_memset_nb</code>,
except that it is synchronized as if it were a non-blocking, implicit-handle put operation.

        </td></tr>
</table>

<a name="Synchronization%20for%20implicit-handle%20non-blocking%20operations%3a"></a>

<h4 class="subsection">Synchronization for implicit-handle non-blocking operations:</h4>

   <p>The following functions are used to synchronize implicit-handle non-blocking operations.

   <p>In the case of multithreaded clients, implicit-handle synchronization
functions only synchronize the implicit-handle non-blocking operations
initiated from the calling thread. Operations initiated by other threads
sharing the GASNet interface proceed independently and are not synchronized. 
Implicit-handle synchronization functions will synchronize operations
initiated within other function frames by the calling thread (but this
cannot affect the correctness of correctly synchronized code).

<a name="gasnet_wait_syncnbi_gets"></a>

   <p>gasnet_try_syncnbi_puts, gasnet_try_syncnbi_all

<h5 class="subsubsection">gasnet_wait_syncnbi_gets, gasnet_wait_syncnbi_puts, gasnet_wait_syncnbi_all, gasnet_try_syncnbi_gets, gasnet_try_syncnbi_puts, gasnet_try_syncnbi_all</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_wait_syncnbi_gets</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_wait_syncnbi_puts</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_wait_syncnbi_all</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_try_syncnbi_gets</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_try_syncnbi_puts</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">int <b>gasnet_try_syncnbi_all</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>These functions implicitly specify a set of non-blocking operations on which
to synchronize. They synchronize on a set of outstanding non-blocking
implicit-handle operations initiated by this thread - either all such gets,
all such puts, or all such puts and gets (where outstanding is defined as
all those implicit-handle operations which have been initiated (outside an
access region) but not yet completed through a successful implicit
synchronization). The wait variants block until all operations in this
implicit set have completed (indicating these operations have been
successfully synchronized). The try variants test whether all operations in
the implicit set have completed, and return <code>GASNET_OK</code> if so (which indicates
these operations have been successfully synchronized) or
<code>GASNET_ERR_NOT_READY</code> otherwise (in which case <em>none</em> of these operations may
be considered successfully synchronized).

     <p>If there are no outstanding implicit-handle operations, these
synchronization functions all return immediately (with <code>GASNET_OK</code> for the try
variants). 
</td></tr>
</table>

   <table border="1" width="100%"><tr><td width="100%">
<strong>Implementor's Note:</strong>
     <ul>
<li>Some implementations may choose to synchronize operations from other
independent threads as well, but they must ensure progress for the calling
thread in the presence of another thread which is continuously initiating
implicit-handle non-blocking operations.

   </ul>
   </td></tr></table>

<a name="Implicit%20access%20region%20synchronization"></a>

<h4 class="subsection">Implicit access region synchronization</h4>

   <p>In some cases, it may be useful or desirable to initiate a number of
non-blocking shared-memory operations (possibly without knowing how many at
compile-time) and synchronize them at a later time using a single, fast
synchronization. 
Simple implicit handle synchronization may not be appropriate for this
situation if there are intervening implicit accesses which are not to be
synchronized. 
This situation could be handled using explicit-handle non-blocking
operations and a list synchronization (e.g. <code>gasnet_wait_syncnb_all()</code>), but
this may not be desirable because it requires managing an array of handles
(which could have negative cache effects on performance, or could be
expensive to allocate when the size is not known until runtime). 
To handle these cases, we provide "implicit access region" synchronization,
described below.

<a name="gasnet_begin_nbi_accessregion"></a>

<h5 class="subsubsection">gasnet_begin_nbi_accessregion, gasnet_end_nbi_accessregion</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_begin_nbi_accessregion</b><i> </i>(<i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">gasnet_handle_t <b>gasnet_end_nbi_accessregion</b><i> </i>(<i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>gasnet_begin_nbi_accessregion()</code> and <code>gasnet_end_nbi_accessregion()</code> are used
to define an implicit access region (any code which dynamically executes
between the begin and end calls is said to be "inside" the region)
The begin and end calls must be paired, and may not be nested recursively or
the results are undefined. 
It is erroneous to call any implicit-handle synchronization function within
the access region. 
All implicit-handle non-blocking operations initiated inside the region
become "associated" with the abstract access region handle being
constructed. <code>gasnet_end_nbi_accessregion()</code> returns an explicit handle which
collectively represents all the associated implicit-handle operations (those
initiated within the access region). 
This handle can then be passed to the regular explicit-handle
synchronization functions, and will be successfully synchronized when <em>all</em> of
the associated non-blocking operations (both puts and gets) initiated in the
access region have completed. 
The associated operations cease to be implicit-handle operations, and are
<em>not</em> synchronized by subsequent calls to the implicit-handle
synchronization functions occurring after the access region (e.g. 
<code>gasnet_wait_syncnbi_all()</code>). 
Explicit-handle operations initiated within the access region operate as
usual and do <em>not</em> become associated with the access region. 
</td></tr>
</table>

   <p>Sample code:
<pre class="lisp">       gasnet_begin_nbi_accessregion(); // begin the access region
     
       gasnet_put_nbi(...); // becomes assoc. with access region
       while (...) {
         gasnet_put_nbi(...); // becomes assoc. with access region
       }
     
       // unrelated explicit-handle operation not assoc. with access region
       h2 = gasnet_get_nb(...);
       gasnet_wait_syncnb(h2);
     
       // end the access region and get the handle
       handle = gasnet_end_nbi_accessregion();
     
       .... // other code, which may include unrelated implicit-handle
            // operations+syncs, or other regions, etc
     
       // wait for all the operations assoc. with access region to complete
       gasnet_wait_syncnb(handle);
     </pre>

<a name="Register-memory%20operations"></a>

<h3 class="section">Register-memory operations</h3>

   <p>Register-memory operations allow client code to avoid forcing communicated
data to pass through the local memory system. Some interconnects may be able
to take advantage of this capability and launch remote puts directly from
registers or recieve remote gets directly into registers.

<a name="Value%20Put"></a>

<h4 class="subsection">Value Put</h4>

<a name="gasnet_put_val"></a>

<h5 class="subsubsection">gasnet_put_val, gasnet_put_nb_val, gasnet_put_nbi_val</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_put_val</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, gasnet_register_value_t&nbsp;</i><var>value</var><i>,&nbsp;size_t&nbsp;</i><var>nbytes</var><i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">gasnet_handle_t <b>gasnet_put_nb_val</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, gasnet_register_value_t&nbsp;</i><var>value</var><i>,&nbsp;size_t&nbsp;</i><var>nbytes</var><i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">void <b>gasnet_put_nbi_val</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>dest</var><i>, gasnet_register_value_t&nbsp;</i><var>value</var><i>,&nbsp;size_t&nbsp;</i><var>nbytes</var><i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Register-to-remote-memory put - these functions take the value to be put as
input parameter to avoid forcing outgoing values to local memory in client
code. 
Otherwise, the behavior is identical to the memory-to-memory versions of put above. 
Requires: <code>nbytes &gt; 0 &amp;&amp; nbytes &lt;= SIZEOF_GASNET_REGISTER_VALUE_T</code>. 
The value written to the target address is a direct byte copy of the
8*<var>nbytes</var> low-order bits of value, written with the endianness appropriate
for an <var>nbytes</var> integral value on the current architecture. 
The non-blocking forms of value put must be synchronized using the explicit
or implicit synchronization functions defined above, as appropriate
</td></tr>
</table>

<a name="Blocking%20Value%20Get"></a>

<h4 class="subsection">Blocking Value Get</h4>

<a name="gasnet_get_val"></a>

<h5 class="subsubsection">gasnet_get_val</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_register_value_t <b>gasnet_get_val</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>This function returns the fetched value to avoid
forcing incoming values through local memory (on architectures
which pass the return value in a register). 
Otherwise, the behavior is identical to the memory-to-memory blocking get. 
Requires: <code>nbytes &gt; 0 &amp;&amp; nbytes &lt;= SIZEOF_GASNET_REGISTER_VALUE_T</code>. 
The value returned is the one obtained by reading the <var>nbytes</var> bytes starting
at the source address with the endianness appropriate for an <var>nbytes</var> integral
value on the current architecture and setting the high-order bits (if any)
to zero (i.e. no sign-extension)
</td></tr>
</table>

<a name="Non-Blocking%20Value%20Get%20(explicit-handle)"></a>

<h4 class="subsection">Non-Blocking Value Get (explicit-handle)</h4>

   <p>This operates similarly to the blocking form of value get, but is split-phase. 
Non-blocking value gets are synchronized independently of all other
operations in GASNet.

   <p><code>typedef ??? gasnet_valget_handle_t;</code>

<a name="gasnet_get_nb_val"></a>

<h5 class="subsubsection">gasnet_get_nb_val, gasnet_wait_syncnb_valget</h5>

<p>
<table width="100%">
<tr>
<td align="left">gasnet_valget_handle_t <b>gasnet_get_nb_val</b><i> </i>(<i>gasnet_node_t </i><var>node</var><i>, void *</i><var>src</var><i>, size_t </i><var>nbytes</var><i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">gasnet_register_value_t <b>gasnet_wait_syncnb_valget</b><i> </i>(<i>gasnet_valget_handle_t </i><var>handle</var><i></i>)<i>;
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>gasnet_get_nb_val</code> initiates a non-blocking value get and returns an explicit
handle which <strong>must</strong> be synchronized using <code>gasnet_wait_syncnb_valget()</code>
<code>gasnet_wait_syncnb_valget()</code> synchronizes an outstanding <code>get_nb_val</code> operation
and returns the retrieved value as described for the blocking version. 
Note that <code>gasnet_valget_handle_t</code> and <code>gasnet_handle_t</code> are completely
different datatypes and may not be intermixed (i.e. <code>gasnet_valget_handle_t</code>'s
cannot be used with other explicit synchronization functions, and
<code>gasnet_handle_t</code>'s cannot be passed to <code>gasnet_wait_syncnb_valget()</code>. 
The <code>gasnet_valget_handle_t</code> type is completely opaque (with no special
"invalid" value), although implementors are recommended to make
<code>sizeof(gasnet_valget_handle_t) &lt;= sizeof(gasnet_register_value_t)</code> to
facilitate register reuse. 
There is no try variant of value get synchronization, and no implicit-handle variant. 
</td></tr>
</table>

<a name="Barriers"></a>

<h3 class="section">Barriers</h3>

   <p>The following functions can be used to execute a parallel split-phase
barrier with the given barrier identifier across all nodes in the job. 
Note that the barrier wait/notify functions should only be called once (i.e. 
by one representative thread) on each node per barrier phase. 
The client must synchronize its own accesses to the barrier functions and
ensure that only one thread is ever inside a GASNet barrier function at a
time (esp. <code>gasnet_barrier_try()</code>).

<pre class="lisp">     #define GASNET_BARRIERFLAG_ANONYMOUS ???
     #define GASNET_BARRIERFLAG_MISMATCH ???
     </pre>

<a name="gasnet_barrier_notify"></a>

<h5 class="subsubsection">gasnet_barrier_notify</h5>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gasnet_barrier_notify</b><i> </i>(<i>int </i><var>id</var><i>, int </i><var>flags</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Execute the notification for a split-phase barrier, with a barrier value <var>id</var>. 
This is a non-blocking operation that completes immediately after noting the
barrier value. 
No synchronization is performed on outstanding non-blocking memory
operations.

     <p>Generates a fatal error if this is the second call to
<code>gasnet_barrier_notify()</code> on this node since the last call to
<code>gasnet_barrier_wait()</code> or the beginning of the program.

     <p>If <var>flags</var> == 0 then this is a "named" barrier notify that carries the given
<var>id</var> value. 
If <var>flags</var> == <code>GASNET_BARRIERFLAG_ANONYMOUS</code>, then <var>id</var> is ignored and the
barrier is anonymous - it has no specific value. 
If <var>flags</var> == <code>GASNET_BARRIERFLAG_MISMATCH</code>, then the subsequent
<code>gasnet_barrier_wait()</code> call on every node will return
<code>GASNET_ERR_BARRIER_MISMATCH</code> (i.e. allows the client to force a global
mismatch error when a mismatch was detected locally). 
</td></tr>
</table>

<a name="gasnet_barrier_wait"></a>

<h5 class="subsubsection">gasnet_barrier_wait</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_barrier_wait</b><i> </i>(<i>int </i><var>id</var><i>, int </i><var>flags</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Execute the wait for a split-phase barrier, with a barrier value. 
This is a blocking operation that returns only after all remote nodes have
called <code>gasnet_barrier_notify()</code>. 
No synchronization is performed on outstanding non-blocking memory
operations .

     <p>Generates a fatal error if there were no preceding calls to
<code>gasnet_barrier_notify()</code> on this node, or if this is the second call to
<code>gasnet_barrier_wait()</code> (or successful call to <code>gasnet_barrier_try()</code>) since the
last call to <code>gasnet_barrier_notify()</code> on this node. 
On a <code>GASNET_PAR</code> or <code>GASNET_PARSYNC</code> configuration, the thread calling
<code>gasnet_barrier_notify()</code> is permitted to differ from the thread which calls
the paired <code>gasnet_barrier_wait()</code>, but the ordering between the calls must
still be maintained.

     <p>Returns <code>GASNET_ERR_BARRIER_MISMATCH</code> if <var>flags</var> is not equal to the <var>flags</var> value
passed to the preceding <code>gasnet_barrier_notify()</code> call made by this node. 
Returns <code>GASNET_ERR_BARRIER_MISMATCH</code> if the <var>flags</var> value passed to
<code>gasnet_barrier_notify()</code> on this or any other node was
<code>GASNET_BARRIERFLAG_MISMATCH</code>. 
Returns <code>GASNET_ERR_BARRIER_MISMATCH</code> if <var>flags</var>==0 and the supplied <var>id</var> value
doesn't match the <var>id</var> value provided in the preceding <code>gasnet_barrier_notify()</code>
call made by this node. 
Returns <code>GASNET_ERR_BARRIER_MISMATCH</code> if any two nodes passed non-anonymous
barrier values which didn't match during the <code>gasnet_barrier_notify()</code> calls
which began this barrier phase. 
Otherwise, returns <code>GASNET_OK</code> to indicate that all nodes have called a
matching <code>gasnet_barrier_notify()</code> and the barrier phase is complete. 
</td></tr>
</table>

<a name="gasnet_barrier_try"></a>

<h5 class="subsubsection">gasnet_barrier_try</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_barrier_try</b><i> </i>(<i>int </i><var>id</var><i>, int </i><var>flags</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>gasnet_barrier_try()</code> functions similarly to <code>gasnet_wait()</code>, except that it
always returns immediately. 
If the barrier has been notified by all nodes, the call behaves as a call to
<code>gasnet_barrier_wait()</code> with the same barrier <var>id</var> and <var>flags</var>, and returns
<code>GASNET_OK</code> (or <code>GASNET_ERR_BARRIER_MISMATCH</code> in the case a mismatch is
detected). 
If the barrier has not yet been notified by some node, the call is a no-op
and returns the value <code>GASNET_ERR_NOT_READY</code>.

     <p>Generates a fatal error if there were no preceding calls to
<code>gasnet_barrier_notify()</code> on this node, or if this is the second call to
<code>gasnet_barrier_wait()</code> (or successful call to <code>gasnet_barrier_try()</code>) since the
last call to <code>gasnet_barrier_notify()</code> on this node. 
</td></tr>
</table>

<a name="Threading%20support"></a>

<h3 class="section">Threading support</h3>

<a name="Thread-identification%20optimization%3a"></a>

<h4 class="subsection">Thread-identification optimization:</h4>

   <p>When compiled in the <code>GASNET_PAR</code> or <code>GASNET_PARSYNC</code> configurations, GASNet is
capable of handling multiple client threads. It is likely that GASNet
implementations will need to distinguish these threads, specifically they
may need to store some metadata associated with each client thread. 
Unfortunately, the overhead of discovering the identity of a particular
client thread making a GASNet call (hereafter termed "thread discovery") can
have a non-trivial overhead on some threading systems (e.g. the cost of
calling <code>pthread_self()</code> or <code>pthread_getspecific()</code>). Many of the simpler GASNet
functions could have their performance dominated by this cost if they need
to perform thread discovery on every call.

   <p>The following macros provide a way for the client to amortize the cost of
thread discovery over many GASNet calls made by the same thread. This is an
optimization which is <em>totally</em> optional - clients need not make any of the
calls below to have a working system, although GASNet performance is likely
to suffer without it in a <code>GASNET_PAR</code> or <code>GASNET_PARSYNC</code> configuration.

   <p><code>typedef void *gasnet_threadinfo_t;</code>

   <p><code>gasnet_threadinfo_t</code> is an opaque pointer representing the internal GASNet
metadata associated with a particular client thread.

<a name="GASNET_GET_THREADINFO"></a>

<h5 class="subsubsection">GASNET_GET_THREADINFO</h5>

   <p><code>#define GASNET_GET_THREADINFO() ???</code>

   <p>Returns a value of type <code>gasnet_threadinfo_t</code> which represents the GASNet
internal metadata associated with the current client thread. This
<code>gasnet_threadinfo_t</code> value can be passed into or out of functions and may be
posted for GASNet's use with <code>GASNET_POST_THREADINFO()</code>. May be called from
anywhere in the client program, at any time after GASNet initialization. It
is erroneous to hand-off this <code>gasnet_threadinfo_t</code> value to a different
client thread.

<a name="GASNET_POST_THREADINFO"></a>

<h5 class="subsubsection">GASNET_POST_THREADINFO</h5>

   <p><code>#define GASNET_POST_THREADINFO(info) ???</code>

   <p>This macro may <em>optionally</em> be placed at the top of functions which make
calls to GASNet. It has no runtime semantics, but it may provide a
performance boost on some implementations (especially in functions which
make multiple calls to the extended API - e.g. it provides the
implementation with a place for minimal per-function initialization or
temporary storage that may be helpful in amortizing implementation-specific
overheads). 
When used, it must appear only at the very beginning of a function or block
(before any declarations or calls to the API in that function).  It may not
appear as a global declaration. The info argument must be a
<code>gasnet_threadinfo_t</code> value acquired from a previous call to
<code>GASNET_GET_THREADINFO()</code> on this thread.

<a name="GASNET_BEGIN_FUNCTION"></a>

<h5 class="subsubsection">GASNET_BEGIN_FUNCTION</h5>

   <p><code>#define GASNET_BEGIN_FUNCTION()   ???</code>

   <p>A convenience macro that may <em>optionally</em> be placed at the top of functions which
repeatedly make GASNet calls, to amortize the overhead of thread discovery
on some implementations.

   <p>It has behavior equivalent to <code>GASNET_POST_THREADINFO(GASNET_GET_THREADINFO())</code>,
however some implementations may choose to lazily postpone performing thread discovery
until the first place where it is actually needed.

<a name="Thread%20management"></a>

<h4 class="subsection">Thread management</h4>

<a name="gasnet_set_waitmode"></a>

<h5 class="subsubsection">gasnet_set_waitmode</h5>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gasnet_set_waitmode</b><i> </i>(<i>int </i><var>wait_mode</var><i></i>)<i>
     </i></td>
<td align="right"></td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>Optional call which gives the GASNet implementation a hint about how
aggressively threads within blocking GASNet calls should contend for
CPU resources. <var>wait_mode</var> must be one of the following recognized values:

          <dl>
<dt><code>GASNET_WAIT_SPIN</code>
          <dd>contend aggressively for CPU resources while waiting (spin)
<br><dt><code>GASNET_WAIT_BLOCK</code>
          <dd>yield CPU resources immediately while waiting (block)
<br><dt><code>GASNET_WAIT_SPINBLOCK</code>
          <dd>spin for an implementation-dependent period, then block
</dl>

     <p>Wait mode is a per-node hint which is permitted to differ across GASNet nodes.

     <p>Returns <code>GASNET_OK</code> on success. 
</td></tr>
</table>

   <hr>

<a name="Appendix"></a>

<h2 class="appendix">Notes</h2>

   </ul>

<a name="Open%20Issues"></a>

<h3 class="appendixsec">Open Issues in the GASNet Specification</h3>

     <ul>
<li>Add support for strided &amp; scatter/gather accesses (spec underway - will be included in GASNet spec v2.0)
<li>Add collective ops - reductions, scans, etc. (spec underway - will be included in GASNet spec v2.0)
<li>Is it worthwhile to add a blocking barrier call? May want to tune this differently
from split-phase barrier on some networks, but would need to define the semantics
of how blocking and non-blocking barriers can be used together. 
</ul>

<a name="Differences%20from%20AM2"></a>

<h3 class="appendixsec">Core API Active Messaging Functions - differences from Active Messages 2.0</h3>

   <p>The GASNet core API was originally based on Active Messages 2.0 (as
described in <cite>A. Mainwaring and D. Culler in "Active Message Applications
Programming Interface and Communication Subsystem Organization"</cite>), however
we've removed some of the generality which is not required (and can lead to
performance degradation and more implementation effort), and stripped it
down to the bare essentials required for active messages in a purely SPMD
environment. The final spec more closely resembles the <cite>"Generic Active
Message Interface Specification v.1.1", by D.Culler et al.</cite>, however
we describe the differences from AM2.0 for readers familiar with that
specification (and because we envision a number of the GASNet core
implementations being simply a thin wrapper over the existing AM2.0
implementations on a number of platforms).

   <p>Here are a summary of the changes (informal style.. this is not really part
of the spec):

     <ul>
<li>the functions are renamed to match the GASNet conventions

     <li>there are no bundles and only one (implicit) endpoint. This necessitates
the following changes:
          <ul>
<li>All AM2 functions which took an endpoint or bundle argument have that
argument removed
<li>The following functions no longer exist: <code>AM_Init</code>, <code>AM_Terminate</code>,
<code>AM_AllocateBundle</code>, <code>AM_AllocateEndpoint</code>, <code>AM_FreeEndpoint</code>, <code>AM_FreeBundle</code>,
<code>AM_MoveEndpoint</code>, <code>AM_GetXferM</code>, <code>AM_GetDestEndpoint</code>
</ul>

     <li>all handler registration is performed during <code>gasnet_attach()</code>, and the
maximum number of handlers is fixed at 256 (including handler 0, the error
handler)
          <ul>
<li>The following functions no longer exist: <code>AM_SetHandler</code> and
<code>AM_SetHandlerAny</code>, <code>AM_GetNumHandlers</code>, <code>AM_SetNumberHandlers</code>, <code>AM_MaxNumHandlers</code>
</ul>

     <li>Segment registration is handled by <code>gasnet_attach()</code> (using a <code>uintptr_t</code> to
allow entire VA space)
          <ul>
<li>The following functions no longer exist: <code>AM_SetSeg</code> and <code>AM_MaxSegLength</code>
(still have <code>AM_GetSeg</code>)
<li>implementations must support an endpoint segment length that spans the
entire virtual address space, though the performance may change for larger
segment sizes (if <code>gasnet_attach</code> requests a size larger than what underlying
<code>AM_SetSeg</code> can provide, then we turn off large AM Xfers and emulate
gasnet_Xfer using medium messages)
<li>the <code>dest_offset</code> argument to the Xfer functions is changed to a <code>void *</code>
address
</ul>

     <li>there are no tags or endpoint names visible to the user - such details are
all handled internally by the job startup mechanism, which sets up a
SPMD-style mapping table (all the nodes, including the current node, in ascending
order by rank).
          <ul>
<li>Therefore, the following functions no longer exist: <code>AM_Map</code>, <code>AM_MapAny</code>,
<code>AM_Unmap</code>, <code>AM_SetTag</code>, <code>AM_GetTag</code>, <code>AM_GetTranslationName</code>, <code>AM_GetTranslationTag</code>,
<code>AM_GetTranslationInUse</code>, <code>AM_MaxNumTranslations</code>, <code>AM_GetNumTranslations</code>,
<code>AM_SetNumTranslations</code>, <code>AM_GetMsgTag</code>
<li>the <code>en_t *</code> argument to <code>AM_GetSourceEndpoint</code> is now an <code>gasnet_node_t *</code>
and returns the node rank of the sender (the now-opaque token could be
implemented as the integer node index itself, although we allow
implementations to still use it as a ptr to metadata if required)
</ul>

     <li><code>AM_RequestXferAsyncM</code> has more useful semantics (may block)

     <li><code>AM_SetExpectedResources</code> no longer exists

     <li>all implementations must support the <code>AM_PAR</code> (multi-threaded) access mode
(<code>GASNET_PAR</code> configuration)

     <li>we handle 64-bit implementations - require small size to be 16 32-bit args
(ensure 8 <code>(void*)</code>'s can be sent)

     <p>cons: handler code needs to be rewritten for 64-bit platforms to perform
packing/unpacking

     </p><li>Blocking polling operation is simplified in the following ways:
          <ul>
<li><code>AM_GetEventMask</code> and <code>AM_SetEventMask</code> no longer exist
<li><code>AM_WaitSema</code> is replaced with <code>GASNET_BLOCKUNTIL()</code>
</ul>

     <li>Maybe deprecate <code>ReplyXfer</code> in favor of <code>GetXfer</code>
          <ul>
<li>some implementations have trouble with large <code>ReplyXfer</code>'s (with software
flow control &amp; reliability)
<li>better yet, just separate <code>AM_MaxLong</code> into <code>AM_MaxLongRequest</code>, and
<code>AM_MaxLongReply</code>
<li>AM2.0 <code>GetXfer</code> doesn't add any expressiveness - really want a way to get
from remote segment into arbitrary local memory address
</ul>

     <li>All Xfer functions specify the destination using a virtual memory address
(which must fall within the registered segment) rather than a segment
offset.

     <li>request handlers are permitted to omit a reply call if no reply handler is
needed (and some implementations may optimize this case)

   </ul>

<a name="Alternate%20formulation%20of%20Active%20Messages"></a>

<h3 class="appendixsec">Active Message Categories - Alternate formulation of AM (not part of spec)</h3>

   <p>Newcomers to Active Messages and GASNet occasionally express confusion over the concepts
of Short, Medium and Long AM's. Despite the somewhat misleading naming convention,
the three categories of messages may actually bear only a loose correllation to the
actual message/data sizes. The important distinctions are semantic, and sufficiently
minor that one might imagine replacing the three categories with a single,
more general type of AM that provides the functionality of each GASNet AM category
as a special case.

   <p>Specifically, a GASNet Short AM can be seen as a special case of a Medium or Long AM
where the payload has length zero. Furthermore, the only important semantic distinction between
Medium and Long AM's are that Medium AM's provide the payload to the handler in a temporary
network buffer, whereas Long AM's write the payload (often using RDMA) to a sender-specified
location in the user memory segment of the target node before running the handler
(each semantic is useful for different usage scenarios).

   <p>Hence, some users may find it helpful to consider building "unified" AM request/reply
functions such as suggested below:

<pre class="lisp">     /* unified request function */
     int unified_AMRequestM(
            gasnet_node_t dest, gasnet_handler_t handler,
            void *buf, size_t buf_len,
            void *dest_addr,
            int32 arg0, int32 arg1, ...) {
       if (buf == NULL)
         return gasnet_AMRequestShortM(dest,handler,arg0,arg1,...);
       else if (dest_addr == NULL)
         return gasnet_AMRequestMediumM(dest,handler,buf,buf_len,arg0,arg1,...);
       else
         return gasnet_AMRequestLongM(dest,handler,buf,buf_len,dest_addr,arg0,arg1,...);
     }
     </pre>

     <ul>
<li>M is the number of arguments, which must be &lt;= <code>gasnet_AMMaxArgs()</code>
<li><code>dest_addr == NULL</code> requires <code>buf_len</code> &lt;= <code>gasnet_AMMaxMedium()</code>,
 and the payload is delivered in a temporary buffer
<li><code>dest_addr != NULL</code> requires <code>buf_len</code> &lt;= <code>gasnet_AMMaxLongRequest()</code>
    (or <code>gasnet_AMMaxLongReply()</code> for replies),
 and the payload is written into the target node segment at <code>dest_addr</code>
<li>Handler prototypes remain the same as under GASNet:
<br><code>buf == NULL</code>:
     <pre class="lisp">            void handler_nopayload(gasnet_token_t token,
                                    gasnet_handlerarg_t arg0, gasnet_handlerarg_t arg1...);
          </pre>
     <br><code>buf != NULL</code>:
     <pre class="lisp">            void handler_withpayload(gasnet_token_t token,
                                  void *buf, size_t buf_len,
                                  gasnet_handlerarg_t arg0, gasnet_handlerarg_t arg1...);
          </pre>
     </ul>

<a name="Concept%20Index"></a>

<h2 class="unnumbered">Concept Index</h2>

<ul class="index-cp" compact>
<li>Atomicity: <a href="#Atomicity%20Control">Atomicity Control</a>
<li>barrier: <a href="#Barriers">Barriers</a>
<li>Configurations: <a href="#Introduction">Introduction</a>
<li>Conventions: <a href="#Introduction">Introduction</a>
<li>Core API: <a href="#Core%20API">Core API</a>, <a href="#Introduction">Introduction</a>
<li>Data transfer semantics: <a href="#Memory-to-memory%20Data%20Transfer%20Functions">Memory-to-memory Data Transfer Functions</a>
<li>environment variables: <a href="#gasnet_getenv">gasnet_getenv</a>
<li>Errors: <a href="#Introduction">Introduction</a>
<li>exit: <a href="#gasnet_exit">gasnet_exit</a>
<li>explicit handle non-blocking operations: <a href="#Non-blocking%20memory-to-memory%20transfers">Non-blocking memory-to-memory transfers</a>
<li>Extended API: <a href="#Extended%20API">Extended API</a>, <a href="#Introduction">Introduction</a>
<li>GASNet organization: <a href="#Introduction">Introduction</a>
<li>gasnet_handlerentry_t: <a href="#gasnet_attach">gasnet_attach</a>
<li>gasnet_seginfo_t: <a href="#gasnet_getSegmentInfo">gasnet_getSegmentInfo</a>
<li>gets: <a href="#Register-memory%20operations">Register-memory operations</a>, <a href="#Non-blocking%20memory-to-memory%20transfers">Non-blocking memory-to-memory transfers</a>, <a href="#Blocking%20memory-to-memory%20Transfers">Blocking memory-to-memory Transfers</a>
<li>implicit handle non-blocking operations: <a href="#Non-blocking%20memory-to-memory%20transfers">Non-blocking memory-to-memory transfers</a>
<li>implicit-handle: <a href="#Non-blocking%20memory-to-memory%20transfers%20(implicit%20handle)">Non-blocking memory-to-memory transfers (implicit handle)</a>
<li>Introduction: <a href="#Introduction">Introduction</a>
<li>job: <a href="#Introduction">Introduction</a>
<li>Locks: <a href="#Handler-Safe%20Locks">Handler-Safe Locks</a>
<li>Long Active Message: <a href="#Active%20Message%20Categories">Active Message Categories</a>
<li>Medium Active Message: <a href="#Active%20Message%20Categories">Active Message Categories</a>
<li>memset: <a href="#Non-blocking%20memory-to-memory%20transfers%20(implicit%20handle)">Non-blocking memory-to-memory transfers (implicit handle)</a>, <a href="#gasnet_get_nb_bulk">gasnet_get_nb_bulk</a>, <a href="#gasnet_get_bulk">gasnet_get_bulk</a>
<li>Message size: <a href="#Active%20Message%20Size%20Limits">Active Message Size Limits</a>
<li>node: <a href="#Introduction">Introduction</a>
<li>Poll: <a href="#Misc.%20Active%20Message%20Functions">Misc. Active Message Functions</a>
<li>puts: <a href="#Register-memory%20operations">Register-memory operations</a>, <a href="#Non-blocking%20memory-to-memory%20transfers">Non-blocking memory-to-memory transfers</a>, <a href="#Blocking%20memory-to-memory%20Transfers">Blocking memory-to-memory Transfers</a>
<li>Replies: <a href="#Active%20Message%20Reply%20Functions">Active Message Reply Functions</a>
<li>Requests: <a href="#Active%20Message%20Request%20Functions">Active Message Request Functions</a>
<li>segment: <a href="#gasnet_getSegmentInfo">gasnet_getSegmentInfo</a>, <a href="#gasnet_getMaxGlobalSegmentSize">gasnet_getMaxGlobalSegmentSize</a>, <a href="#gasnet_getMaxLocalSegmentSize">gasnet_getMaxLocalSegmentSize</a>, <a href="#gasnet_attach">gasnet_attach</a>
<li>Short Active Message: <a href="#Active%20Message%20Categories">Active Message Categories</a>
<li>startup: <a href="#gasnet_init">gasnet_init</a>
<li>synchronization: <a href="#Implicit%20access%20region%20synchronization">Implicit access region synchronization</a>, <a href="#Synchronization%20for%20implicit-handle%20non-blocking%20operations%3a">Synchronization for implicit-handle non-blocking operations:</a>, <a href="#Synchronization%20for%20explicit-handle%20non-blocking%20operations%3a">Synchronization for explicit-handle non-blocking operations:</a>
<li>Synchronization semantics: <a href="#Synchronization%20semantics%20of%20non-blocking%20data%20transfers">Synchronization semantics of non-blocking data transfers</a>
<li>thread: <a href="#Introduction">Introduction</a>
<li>Titanium: <a href="#Introduction">Introduction</a>
<li>Types: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li>UPC: <a href="#Introduction">Introduction</a>
   </ul>
<a name="Function%20Macro%20and%20Type%20Index"></a>

<h2 class="unnumbered">Function, Macro and Type Index</h2>

<ul class="index-fn" compact>
<li><code>GASNET_ALIGNED_SEGMENTS</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_AMGetMsgSource</code>: <a href="#gasnet_AMGetMsgSource">gasnet_AMGetMsgSource</a>
<li><code>gasnet_AMMaxArgs</code>: <a href="#gasnet_AMMaxArgs">gasnet_AMMaxArgs</a>
<li><code>gasnet_AMMaxLongReply</code>: <a href="#gasnet_AMMaxLongReply">gasnet_AMMaxLongReply</a>
<li><code>gasnet_AMMaxLongRequest</code>: <a href="#gasnet_AMMaxLongRequest">gasnet_AMMaxLongRequest</a>
<li><code>gasnet_AMMaxMedium</code>: <a href="#gasnet_AMMaxMedium">gasnet_AMMaxMedium</a>
<li><code>gasnet_AMPoll</code>: <a href="#gasnet_AMPoll">gasnet_AMPoll</a>
<li><code>gasnet_AMReplyLongM</code>: <a href="#gasnet_AMReplyLongM">gasnet_AMReplyLongM</a>
<li><code>gasnet_AMReplyMediumM</code>: <a href="#gasnet_AMReplyMediumM">gasnet_AMReplyMediumM</a>
<li><code>gasnet_AMReplyShortM</code>: <a href="#gasnet_AMReplyShortM">gasnet_AMReplyShortM</a>
<li><code>gasnet_AMRequestLongAsyncM</code>: <a href="#gasnet_AMRequestLongAsyncM">gasnet_AMRequestLongAsyncM</a>
<li><code>gasnet_AMRequestLongM</code>: <a href="#gasnet_AMRequestLongM">gasnet_AMRequestLongM</a>
<li><code>gasnet_AMRequestMediumM</code>: <a href="#gasnet_AMRequestMediumM">gasnet_AMRequestMediumM</a>
<li><code>gasnet_AMRequestShortM</code>: <a href="#gasnet_AMRequestShortM">gasnet_AMRequestShortM</a>
<li><code>gasnet_attach</code>: <a href="#gasnet_attach">gasnet_attach</a>
<li><code>gasnet_barrier_notify</code>: <a href="#gasnet_barrier_notify">gasnet_barrier_notify</a>
<li><code>gasnet_barrier_try</code>: <a href="#gasnet_barrier_try">gasnet_barrier_try</a>
<li><code>gasnet_barrier_wait</code>: <a href="#gasnet_barrier_wait">gasnet_barrier_wait</a>
<li><code>GASNET_BARRIERFLAG_ANONYMOUS</code>: <a href="#Barriers">Barriers</a>
<li><code>GASNET_BARRIERFLAG_MISMATCH</code>: <a href="#Barriers">Barriers</a>
<li><code>GASNET_BEGIN_FUNCTION</code>: <a href="#GASNET_BEGIN_FUNCTION">GASNET_BEGIN_FUNCTION</a>
<li><code>gasnet_begin_nbi_accessregion</code>: <a href="#gasnet_begin_nbi_accessregion">gasnet_begin_nbi_accessregion</a>
<li><code>GASNET_BLOCKUNTIL</code>: <a href="#GASNET_BLOCKUNTIL">GASNET_BLOCKUNTIL</a>
<li><code>GASNET_CONFIG_STRING</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_end_nbi_accessregion</code>: <a href="#gasnet_begin_nbi_accessregion">gasnet_begin_nbi_accessregion</a>
<li><code>GASNET_ERR_BAD_ARG</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_ERR_BARRIER_MISMATCH</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_ERR_NOT_INIT</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_ERR_NOT_READY</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_ERR_RESOURCE</code>: <a href="#Introduction">Introduction</a>
<li><code>gasnet_ErrorDesc</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_ErrorName</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_exit</code>: <a href="#gasnet_exit">gasnet_exit</a>
<li><code>gasnet_get</code>: <a href="#gasnet_get">gasnet_get</a>
<li><code>gasnet_get_bulk</code>: <a href="#gasnet_get_bulk">gasnet_get_bulk</a>
<li><code>gasnet_get_nb</code>: <a href="#gasnet_get_nb">gasnet_get_nb</a>
<li><code>gasnet_get_nb_bulk</code>: <a href="#gasnet_get_nb_bulk">gasnet_get_nb_bulk</a>
<li><code>gasnet_get_nb_val</code>: <a href="#gasnet_get_nb_val">gasnet_get_nb_val</a>
<li><code>gasnet_get_nbi</code>: <a href="#gasnet_get_nbi">gasnet_get_nbi</a>
<li><code>gasnet_get_nbi_bulk</code>: <a href="#gasnet_get_nbi">gasnet_get_nbi</a>
<li><code>GASNET_GET_THREADINFO</code>: <a href="#GASNET_GET_THREADINFO">GASNET_GET_THREADINFO</a>
<li><code>gasnet_get_val</code>: <a href="#gasnet_get_val">gasnet_get_val</a>
<li><code>gasnet_getenv</code>: <a href="#gasnet_getenv">gasnet_getenv</a>
<li><code>gasnet_getMaxGlobalSegmentSize</code>: <a href="#gasnet_getMaxGlobalSegmentSize">gasnet_getMaxGlobalSegmentSize</a>
<li><code>gasnet_getMaxLocalSegmentSize</code>: <a href="#gasnet_getMaxLocalSegmentSize">gasnet_getMaxLocalSegmentSize</a>
<li><code>gasnet_getSegmentInfo</code>: <a href="#gasnet_getSegmentInfo">gasnet_getSegmentInfo</a>
<li><code>gasnet_hold_interrupts</code>: <a href="#gasnet_hold_interrupts">gasnet_hold_interrupts</a>
<li><code>gasnet_hsl_destroy</code>: <a href="#gasnet_hsl_init">gasnet_hsl_init</a>
<li><code>gasnet_hsl_init</code>: <a href="#gasnet_hsl_init">gasnet_hsl_init</a>
<li><code>GASNET_HSL_INITIALIZER</code>: <a href="#gasnet_hsl_init">gasnet_hsl_init</a>
<li><code>gasnet_hsl_lock</code>: <a href="#gasnet_hsl_lock">gasnet_hsl_lock</a>
<li><code>gasnet_hsl_t</code>: <a href="#gasnet_hsl_t">gasnet_hsl_t</a>
<li><code>gasnet_hsl_trylock</code>: <a href="#gasnet_hsl_lock">gasnet_hsl_lock</a>
<li><code>gasnet_hsl_unlock</code>: <a href="#gasnet_hsl_lock">gasnet_hsl_lock</a>
<li><code>gasnet_init</code>: <a href="#gasnet_init">gasnet_init</a>
<li><code>GASNET_MAXNODES</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_memset</code>: <a href="#gasnet_memset">gasnet_memset</a>
<li><code>gasnet_memset_nb</code>: <a href="#gasnet_memset_nb">gasnet_memset_nb</a>
<li><code>gasnet_memset_nbi</code>: <a href="#gasnet_get_nbi">gasnet_get_nbi</a>
<li><code>gasnet_mynode</code>: <a href="#gasnet_mynode">gasnet_mynode</a>
<li><code>gasnet_nodes</code>: <a href="#gasnet_nodes">gasnet_nodes</a>
<li><code>GASNET_OK = 0 (no error)</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_PAGESIZE</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>GASNET_PAR</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_PARSYNC</code>: <a href="#Introduction">Introduction</a>
<li><code>GASNET_POST_THREADINFO</code>: <a href="#GASNET_POST_THREADINFO">GASNET_POST_THREADINFO</a>
<li><code>gasnet_put</code>: <a href="#gasnet_get">gasnet_get</a>
<li><code>gasnet_put_bulk</code>: <a href="#gasnet_get_bulk">gasnet_get_bulk</a>
<li><code>gasnet_put_nb</code>: <a href="#gasnet_get_nb">gasnet_get_nb</a>
<li><code>gasnet_put_nb_bulk</code>: <a href="#gasnet_get_nb_bulk">gasnet_get_nb_bulk</a>
<li><code>gasnet_put_nb_val</code>: <a href="#gasnet_put_val">gasnet_put_val</a>
<li><code>gasnet_put_nbi</code>: <a href="#gasnet_get_nbi">gasnet_get_nbi</a>
<li><code>gasnet_put_nbi_bulk</code>: <a href="#gasnet_get_nbi">gasnet_get_nbi</a>
<li><code>gasnet_put_nbi_val</code>: <a href="#gasnet_put_val">gasnet_put_val</a>
<li><code>gasnet_put_val</code>: <a href="#gasnet_put_val">gasnet_put_val</a>
<li><code>GASNET_RELEASE_VERSION_MAJOR</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>GASNET_RELEASE_VERSION_MINOR</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>GASNET_RELEASE_VERSION_PATCH</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_resume_interrupts</code>: <a href="#gasnet_hold_interrupts">gasnet_hold_interrupts</a>
<li><code>GASNET_SEGMENT_EVERYTHING</code>: <a href="#Job%20Control%20Interface">Job Control Interface</a>
<li><code>GASNET_SEGMENT_FAST</code>: <a href="#Job%20Control%20Interface">Job Control Interface</a>
<li><code>GASNET_SEGMENT_LARGE</code>: <a href="#Job%20Control%20Interface">Job Control Interface</a>
<li><code>GASNET_SEQ</code>: <a href="#Introduction">Introduction</a>
<li><code>gasnet_set_waitmode</code>: <a href="#gasnet_set_waitmode">gasnet_set_waitmode</a>
<li><code>GASNET_SPEC_VERSION_MAJOR</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>GASNET_SPEC_VERSION_MINOR</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>gasnet_try_syncnb</code>: <a href="#gasnet_wait_syncnb">gasnet_wait_syncnb</a>
<li><code>gasnet_try_syncnb_all</code>: <a href="#gasnet_wait_syncnb_all">gasnet_wait_syncnb_all</a>
<li><code>gasnet_try_syncnb_some</code>: <a href="#gasnet_wait_syncnb_some">gasnet_wait_syncnb_some</a>
<li><code>gasnet_try_syncnbi_all</code>: <a href="#gasnet_wait_syncnbi_gets">gasnet_wait_syncnbi_gets</a>
<li><code>gasnet_try_syncnbi_gets</code>: <a href="#gasnet_wait_syncnbi_gets">gasnet_wait_syncnbi_gets</a>
<li><code>gasnet_try_syncnbi_puts</code>: <a href="#gasnet_wait_syncnbi_gets">gasnet_wait_syncnbi_gets</a>
<li><code>gasnet_valget_handle_t</code>: <a href="#Non-Blocking%20Value%20Get%20(explicit-handle)">Non-Blocking Value Get (explicit-handle)</a>
<li><code>GASNET_VERSION (deprecated)</code>: <a href="#gasnet_ErrorName">gasnet_ErrorName</a>
<li><code>GASNET_WAIT_BLOCK</code>: <a href="#gasnet_set_waitmode">gasnet_set_waitmode</a>
<li><code>GASNET_WAIT_SPIN</code>: <a href="#gasnet_set_waitmode">gasnet_set_waitmode</a>
<li><code>GASNET_WAIT_SPINBLOCK</code>: <a href="#gasnet_set_waitmode">gasnet_set_waitmode</a>
<li><code>gasnet_wait_syncnb</code>: <a href="#gasnet_wait_syncnb">gasnet_wait_syncnb</a>
<li><code>gasnet_wait_syncnb_all</code>: <a href="#gasnet_wait_syncnb_all">gasnet_wait_syncnb_all</a>
<li><code>gasnet_wait_syncnb_some</code>: <a href="#gasnet_wait_syncnb_some">gasnet_wait_syncnb_some</a>
<li><code>gasnet_wait_syncnb_valget</code>: <a href="#gasnet_get_nb_val">gasnet_get_nb_val</a>
<li><code>gasnet_wait_syncnbi_all</code>: <a href="#gasnet_wait_syncnbi_gets">gasnet_wait_syncnbi_gets</a>
<li><code>gasnet_wait_syncnbi_gets</code>: <a href="#gasnet_wait_syncnbi_gets">gasnet_wait_syncnbi_gets</a>
<li><code>gasnet_wait_syncnbi_puts</code>: <a href="#gasnet_wait_syncnbi_gets">gasnet_wait_syncnbi_gets</a>
   </ul>

...Table of Contents...

   </body></html>

