<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Comparing memory node attributes for finding where to allocate on</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hardware Locality (hwloc)
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Comparing memory node attributes for finding where to allocate on</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00329.html">hwloc_location</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacc82003a8610be554615995f0996c888"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a></td></tr>
<tr class="separator:gacc82003a8610be554615995f0996c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab4bde745db676fc2ea4b47011cd9a80e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gab4bde745db676fc2ea4b47011cd9a80e">hwloc_memattr_id_e</a> { <br />
&#160;&#160;<a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80eaa1cfa3ff3d56ff00ecabf7da4f5642cc">HWLOC_MEMATTR_ID_CAPACITY</a>
, <a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80ea9334e3a4c30a67f491c6523255134efe">HWLOC_MEMATTR_ID_LOCALITY</a>
, <a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80ea25fe3c7376ae6f9b584bacdb039f8c0f">HWLOC_MEMATTR_ID_BANDWIDTH</a>
, <a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80eac34dce925d3dadb7e255391d142b4828">HWLOC_MEMATTR_ID_READ_BANDWIDTH</a>
, <br />
&#160;&#160;<a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80ea44762e8ebe327cfe665cccf1f58f7530">HWLOC_MEMATTR_ID_WRITE_BANDWIDTH</a>
, <a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80ead1796413759b8b87b61ad195a9349b19">HWLOC_MEMATTR_ID_LATENCY</a>
, <a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80ea52cab56571c7fafea42a694d80ad3dd0">HWLOC_MEMATTR_ID_READ_LATENCY</a>
, <a class="el" href="a00224.html#ggab4bde745db676fc2ea4b47011cd9a80eaaf6cd383da87dc9f5e3a608a535a768e">HWLOC_MEMATTR_ID_WRITE_LATENCY</a>
, <br />
&#160;&#160;<b>HWLOC_MEMATTR_ID_MAX</b>
<br />
 }</td></tr>
<tr class="separator:gab4bde745db676fc2ea4b47011cd9a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33099ba58f607fc70925da3777688586"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga33099ba58f607fc70925da3777688586">hwloc_location_type_e</a> { <a class="el" href="a00224.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174">HWLOC_LOCATION_TYPE_CPUSET</a>
, <a class="el" href="a00224.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84">HWLOC_LOCATION_TYPE_OBJECT</a>
 }</td></tr>
<tr class="separator:ga33099ba58f607fc70925da3777688586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c963ca37255da71b00d94e1b106f9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gab9c963ca37255da71b00d94e1b106f9d">hwloc_local_numanode_flag_e</a> { <a class="el" href="a00224.html#ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc">HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</a>
, <a class="el" href="a00224.html#ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57">HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</a>
, <a class="el" href="a00224.html#ggab9c963ca37255da71b00d94e1b106f9dab5778b34c961a5d56f98f1549edeaed0">HWLOC_LOCAL_NUMANODE_FLAG_ALL</a>
 }</td></tr>
<tr class="separator:gab9c963ca37255da71b00d94e1b106f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga79f44f8e1cfd2f97a19171417a75a137"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga79f44f8e1cfd2f97a19171417a75a137">hwloc_memattr_get_by_name</a> (<a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const char *name, <a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> *id)</td></tr>
<tr class="separator:ga79f44f8e1cfd2f97a19171417a75a137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569e80c5be7ef27649b0ef5aa52ffcdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga569e80c5be7ef27649b0ef5aa52ffcdc">hwloc_get_local_numanode_objs</a> (<a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, struct <a class="el" href="a00329.html">hwloc_location</a> *location, unsigned *nr, <a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *nodes, unsigned long flags)</td></tr>
<tr class="separator:ga569e80c5be7ef27649b0ef5aa52ffcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297e4a9adc2272446a4c7449dacef0df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga297e4a9adc2272446a4c7449dacef0df">hwloc_memattr_get_value</a> (<a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, <a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> target_node, struct <a class="el" href="a00329.html">hwloc_location</a> *initiator, unsigned long flags, hwloc_uint64_t *value)</td></tr>
<tr class="separator:ga297e4a9adc2272446a4c7449dacef0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884d1f2ad745c2fa69c1583c82d28f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga884d1f2ad745c2fa69c1583c82d28f10">hwloc_memattr_get_best_target</a> (<a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, struct <a class="el" href="a00329.html">hwloc_location</a> *initiator, unsigned long flags, <a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *best_target, hwloc_uint64_t *value)</td></tr>
<tr class="separator:ga884d1f2ad745c2fa69c1583c82d28f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a453879892893cf8a3fcd431ade84cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9a453879892893cf8a3fcd431ade84cd">hwloc_memattr_get_best_initiator</a> (<a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, <a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> target, unsigned long flags, struct <a class="el" href="a00329.html">hwloc_location</a> *best_initiator, hwloc_uint64_t *value)</td></tr>
<tr class="separator:ga9a453879892893cf8a3fcd431ade84cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Platforms with heterogeneous memory require ways to decide whether a buffer should be allocated on "fast" memory (such as HBM), "normal" memory (DDR) or even "slow" but large-capacity memory (non-volatile memory). These memory nodes are called "Targets" while the CPU accessing them is called the "Initiator". Access performance depends on their locality (NUMA platforms) as well as the intrinsic performance of the targets (heterogeneous platforms).</p>
<p>The following attributes describe the performance of memory accesses from an Initiator to a memory Target, for instance their latency or bandwidth. Initiators performing these memory accesses are usually some PUs or Cores (described as a CPU set). Hence a Core may choose where to allocate a memory buffer by comparing the attributes of different target memory nodes nearby.</p>
<p>There are also some attributes that are system-wide. Their value does not depend on a specific initiator performing an access. The memory node Capacity is an example of such attribute without initiator.</p>
<p>One way to use this API is to start with a cpuset describing the Cores where a program is bound. The best target NUMA node for allocating memory in this program on these Cores may be obtained by passing this cpuset as an initiator to <a class="el" href="a00224.html#ga884d1f2ad745c2fa69c1583c82d28f10" title="Return the best target NUMA node for the given attribute and initiator.">hwloc_memattr_get_best_target()</a> with the relevant memory attribute. For instance, if the code is latency limited, use the Latency attribute.</p>
<p>A more flexible approach consists in getting the list of local NUMA nodes by passing this cpuset to <a class="el" href="a00224.html#ga569e80c5be7ef27649b0ef5aa52ffcdc" title="Return an array of local NUMA nodes.">hwloc_get_local_numanode_objs()</a>. Attribute values for these nodes, if any, may then be obtained with <a class="el" href="a00224.html#ga297e4a9adc2272446a4c7449dacef0df" title="Return an attribute value for a specific target NUMA node.">hwloc_memattr_get_value()</a> and manually compared with the desired criteria.</p>
<dl class="section see"><dt>See also</dt><dd>An example is available in doc/examples/memory-attributes.c in the source tree.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The API also supports specific objects as initiator, but it is currently not used internally by hwloc. Users may for instance use it to provide custom performance values for host memory accesses performed by GPUs.</dd>
<dd>
The interface actually also accepts targets that are not NUMA nodes. </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacc82003a8610be554615995f0996c888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc82003a8610be554615995f0996c888">&#9670;&nbsp;</a></span>hwloc_memattr_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A memory attribute identifier. May be either one of <a class="el" href="a00224.html#gab4bde745db676fc2ea4b47011cd9a80e" title="Memory node attributes.">hwloc_memattr_id_e</a> or a new id returned by <a class="el" href="a00225.html#ga770657d1e44b09e93e09f623936c1e5f" title="Register a new memory attribute.">hwloc_memattr_register()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab9c963ca37255da71b00d94e1b106f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c963ca37255da71b00d94e1b106f9d">&#9670;&nbsp;</a></span>hwloc_local_numanode_flag_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00224.html#gab9c963ca37255da71b00d94e1b106f9d">hwloc_local_numanode_flag_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for selecting target NUMA nodes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc"></a>HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY&#160;</td><td class="fielddoc"><p>Select NUMA nodes whose locality is larger than the given cpuset. For instance, if a single PU (or its cpuset) is given in <code>initiator</code>, select all nodes close to the package that contains this PU. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57"></a>HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY&#160;</td><td class="fielddoc"><p>Select NUMA nodes whose locality is smaller than the given cpuset. For instance, if a package (or its cpuset) is given in <code>initiator</code>, also select nodes that are attached to only a half of that package. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9dab5778b34c961a5d56f98f1549edeaed0"></a>HWLOC_LOCAL_NUMANODE_FLAG_ALL&#160;</td><td class="fielddoc"><p>Select all NUMA nodes in the topology. The initiator <code>initiator</code> is ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga33099ba58f607fc70925da3777688586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33099ba58f607fc70925da3777688586">&#9670;&nbsp;</a></span>hwloc_location_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00224.html#ga33099ba58f607fc70925da3777688586">hwloc_location_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of location. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174"></a>HWLOC_LOCATION_TYPE_CPUSET&#160;</td><td class="fielddoc"><p>Location is given as a cpuset, in the location cpuset union field. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84"></a>HWLOC_LOCATION_TYPE_OBJECT&#160;</td><td class="fielddoc"><p>Location is given as an object, in the location object union field. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab4bde745db676fc2ea4b47011cd9a80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4bde745db676fc2ea4b47011cd9a80e">&#9670;&nbsp;</a></span>hwloc_memattr_id_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00224.html#gab4bde745db676fc2ea4b47011cd9a80e">hwloc_memattr_id_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory node attributes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80eaa1cfa3ff3d56ff00ecabf7da4f5642cc"></a>HWLOC_MEMATTR_ID_CAPACITY&#160;</td><td class="fielddoc"><p>The "Capacity" is returned in bytes (local_memory attribute in objects). </p>
<p>Best capacity nodes are nodes with <b>higher capacity</b>.</p>
<p>No initiator is involved when looking at this attribute. The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea9334e3a4c30a67f491c6523255134efe"></a>HWLOC_MEMATTR_ID_LOCALITY&#160;</td><td class="fielddoc"><p>The "Locality" is returned as the number of PUs in that locality (e.g. the weight of its cpuset). </p>
<p>Best locality nodes are nodes with <b>smaller locality</b> (nodes that are local to very few PUs). Poor locality nodes are nodes with larger locality (nodes that are local to the entire machine).</p>
<p>No initiator is involved when looking at this attribute. The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea25fe3c7376ae6f9b584bacdb039f8c0f"></a>HWLOC_MEMATTR_ID_BANDWIDTH&#160;</td><td class="fielddoc"><p>The "Bandwidth" is returned in MiB/s, as seen from the given initiator location. </p>
<p>Best bandwidth nodes are nodes with <b>higher bandwidth</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a> and <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>.</p>
<p>This is the average bandwidth for read and write accesses. If the platform provides individual read and write bandwidths but no explicit average value, hwloc computes and returns the average. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80eac34dce925d3dadb7e255391d142b4828"></a>HWLOC_MEMATTR_ID_READ_BANDWIDTH&#160;</td><td class="fielddoc"><p>The "ReadBandwidth" is returned in MiB/s, as seen from the given initiator location. </p>
<p>Best bandwidth nodes are nodes with <b>higher bandwidth</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a> and <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea44762e8ebe327cfe665cccf1f58f7530"></a>HWLOC_MEMATTR_ID_WRITE_BANDWIDTH&#160;</td><td class="fielddoc"><p>The "WriteBandwidth" is returned in MiB/s, as seen from the given initiator location. </p>
<p>Best bandwidth nodes are nodes with <b>higher bandwidth</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a> and <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ead1796413759b8b87b61ad195a9349b19"></a>HWLOC_MEMATTR_ID_LATENCY&#160;</td><td class="fielddoc"><p>The "Latency" is returned as nanoseconds, as seen from the given initiator location. </p>
<p>Best latency nodes are nodes with <b>smaller latency</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9601b5b0e1e68635e7e9901f28bd93bf" title="The best nodes for this memory attribute are those with the lower values. For instance Latency.">HWLOC_MEMATTR_FLAG_LOWER_FIRST</a> and <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>.</p>
<p>This is the average latency for read and write accesses. If the platform provides individual read and write latencies but no explicit average value, hwloc computes and returns the average. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea52cab56571c7fafea42a694d80ad3dd0"></a>HWLOC_MEMATTR_ID_READ_LATENCY&#160;</td><td class="fielddoc"><p>The "ReadLatency" is returned as nanoseconds, as seen from the given initiator location. </p>
<p>Best latency nodes are nodes with <b>smaller latency</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9601b5b0e1e68635e7e9901f28bd93bf" title="The best nodes for this memory attribute are those with the lower values. For instance Latency.">HWLOC_MEMATTR_FLAG_LOWER_FIRST</a> and <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80eaaf6cd383da87dc9f5e3a608a535a768e"></a>HWLOC_MEMATTR_ID_WRITE_LATENCY&#160;</td><td class="fielddoc"><p>The "WriteLatency" is returned as nanoseconds, as seen from the given initiator location. </p>
<p>Best latency nodes are nodes with <b>smaller latency</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9601b5b0e1e68635e7e9901f28bd93bf" title="The best nodes for this memory attribute are those with the lower values. For instance Latency.">HWLOC_MEMATTR_FLAG_LOWER_FIRST</a> and <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga569e80c5be7ef27649b0ef5aa52ffcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga569e80c5be7ef27649b0ef5aa52ffcdc">&#9670;&nbsp;</a></span>hwloc_get_local_numanode_objs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_get_local_numanode_objs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00329.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an array of local NUMA nodes. </p>
<p>By default only select the NUMA nodes whose locality is exactly the given <code>location</code>. More nodes may be selected if additional flags are given as a OR'ed set of <a class="el" href="a00224.html#gab9c963ca37255da71b00d94e1b106f9d" title="Flags for selecting target NUMA nodes.">hwloc_local_numanode_flag_e</a>.</p>
<p>If <code>location</code> is given as an explicit object, its CPU set is used to find NUMA nodes with the corresponding locality. If the object does not have a CPU set (e.g. I/O object), the CPU parent (where the I/O object is attached) is used.</p>
<p>On input, <code>nr</code> points to the number of nodes that may be stored in the <code>nodes</code> array. On output, <code>nr</code> will be changed to the number of stored nodes, or the number of nodes that would have been stored if there were enough room.</p>
<dl class="section note"><dt>Note</dt><dd>Some of these NUMA nodes may not have any memory attribute values and hence not be reported as actual targets in other functions.</dd>
<dd>
The number of NUMA nodes in the topology (obtained by <a class="el" href="a00217.html#ga0200466842c0e1f5da75e84dde460b10" title="Compute the &quot;weight&quot; of bitmap bitmap (i.e., number of indexes that are in the bitmap).">hwloc_bitmap_weight()</a> on the root object nodeset) may be used to allocate the <code>nodes</code> array.</dd>
<dd>
When an object CPU set is given as locality, for instance a Package, and when flags contain both <a class="el" href="a00224.html#ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc" title="Select NUMA nodes whose locality is larger than the given cpuset. For instance, if a single PU (or it...">HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</a> and <a class="el" href="a00224.html#ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57" title="Select NUMA nodes whose locality is smaller than the given cpuset. For instance, if a package (or its...">HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</a>, the returned array corresponds to the nodeset of that object. </dd></dl>

</div>
</div>
<a id="ga9a453879892893cf8a3fcd431ade84cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a453879892893cf8a3fcd431ade84cd">&#9670;&nbsp;</a></span>hwloc_memattr_get_best_initiator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_best_initiator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00329.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>best_initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the best initiator for the given attribute and target NUMA node. </p>
<p>If the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>), <code>-1</code> is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
<p>If <code>value</code> is non <code>NULL</code>, the corresponding value is returned there.</p>
<p>If multiple initiators have the same attribute values, only one is returned (and there is no way to clarify how that one is chosen). Applications that want to detect initiators with identical/similar values, or that want to look at values for multiple attributes, should rather get all values using <a class="el" href="a00224.html#ga297e4a9adc2272446a4c7449dacef0df" title="Return an attribute value for a specific target NUMA node.">hwloc_memattr_get_value()</a> and manually select the initiator they consider the best.</p>
<p>The returned initiator should not be modified or freed, it belongs to the topology.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<p>If there are no matching initiators, <code>-1</code> is returned with <code>errno</code> set to <code>ENOENT</code>; </p>

</div>
</div>
<a id="ga884d1f2ad745c2fa69c1583c82d28f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga884d1f2ad745c2fa69c1583c82d28f10">&#9670;&nbsp;</a></span>hwloc_memattr_get_best_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_best_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00329.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *&#160;</td>
          <td class="paramname"><em>best_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the best target NUMA node for the given attribute and initiator. </p>
<p>If the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>), location <code>initiator</code> is ignored and may be <code>NULL</code>.</p>
<p>If <code>value</code> is non <code>NULL</code>, the corresponding value is returned there.</p>
<p>If multiple targets have the same attribute values, only one is returned (and there is no way to clarify how that one is chosen). Applications that want to detect targets with identical/similar values, or that want to look at values for multiple attributes, should rather get all values using <a class="el" href="a00224.html#ga297e4a9adc2272446a4c7449dacef0df" title="Return an attribute value for a specific target NUMA node.">hwloc_memattr_get_value()</a> and manually select the target they consider the best.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<p>If there are no matching targets, <code>-1</code> is returned with <code>errno</code> set to <code>ENOENT</code>;</p>
<dl class="section note"><dt>Note</dt><dd>The initiator <code>initiator</code> should be of type <a class="el" href="a00224.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174" title="Location is given as a cpuset, in the location cpuset union field.">HWLOC_LOCATION_TYPE_CPUSET</a> when refering to accesses performed by CPU cores. <a class="el" href="a00224.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84" title="Location is given as an object, in the location object union field.">HWLOC_LOCATION_TYPE_OBJECT</a> is currently unused internally by hwloc, but users may for instance use it to provide custom information about host memory accesses performed by GPUs. </dd></dl>

</div>
</div>
<a id="ga79f44f8e1cfd2f97a19171417a75a137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79f44f8e1cfd2f97a19171417a75a137">&#9670;&nbsp;</a></span>hwloc_memattr_get_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the identifier of the memory attribute with the given name. </p>

</div>
</div>
<a id="ga297e4a9adc2272446a4c7449dacef0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297e4a9adc2272446a4c7449dacef0df">&#9670;&nbsp;</a></span>hwloc_memattr_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00198.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00224.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>target_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00329.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an attribute value for a specific target NUMA node. </p>
<p>If the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00225.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>), location <code>initiator</code> is ignored and may be <code>NULL</code>.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section note"><dt>Note</dt><dd>The initiator <code>initiator</code> should be of type <a class="el" href="a00224.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174" title="Location is given as a cpuset, in the location cpuset union field.">HWLOC_LOCATION_TYPE_CPUSET</a> when refering to accesses performed by CPU cores. <a class="el" href="a00224.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84" title="Location is given as an object, in the location object union field.">HWLOC_LOCATION_TYPE_OBJECT</a> is currently unused internally by hwloc, but users may for instance use it to provide custom information about host memory accesses performed by GPUs. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
