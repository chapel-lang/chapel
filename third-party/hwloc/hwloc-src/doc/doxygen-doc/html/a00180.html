<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Finding objects, miscellaneous helpers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hardware Locality (hwloc)<span id="projectnumber">&#160;2.12.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Finding objects, miscellaneous helpers</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga050646458efc8ca1120d9f124c5ad861" id="r_ga050646458efc8ca1120d9f124c5ad861"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#ga050646458efc8ca1120d9f124c5ad861">hwloc_bitmap_singlify_per_core</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> cpuset, unsigned which)</td></tr>
<tr class="separator:ga050646458efc8ca1120d9f124c5ad861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac060ecf6683fb0d206e46b28c64648ac" id="r_gac060ecf6683fb0d206e46b28c64648ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#gac060ecf6683fb0d206e46b28c64648ac">hwloc_get_pu_obj_by_os_index</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, unsigned os_index)</td></tr>
<tr class="separator:gac060ecf6683fb0d206e46b28c64648ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7623746b55a89bdc175ee99930c420" id="r_gacc7623746b55a89bdc175ee99930c420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#gacc7623746b55a89bdc175ee99930c420">hwloc_get_numanode_obj_by_os_index</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, unsigned os_index)</td></tr>
<tr class="separator:gacc7623746b55a89bdc175ee99930c420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cd22a34360643f7f5bad09576dec205" id="r_ga2cd22a34360643f7f5bad09576dec205"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#ga2cd22a34360643f7f5bad09576dec205">hwloc_get_closest_objs</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> src, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *restrict objs, unsigned max)</td></tr>
<tr class="separator:ga2cd22a34360643f7f5bad09576dec205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f37fd3b4e890d6d488163634f6befd9" id="r_ga3f37fd3b4e890d6d488163634f6befd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#ga3f37fd3b4e890d6d488163634f6befd9">hwloc_get_obj_below_by_type</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type1, unsigned idx1, <a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type2, unsigned idx2)</td></tr>
<tr class="separator:ga3f37fd3b4e890d6d488163634f6befd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63546ee8a2bf78aba775c74dae97920" id="r_gae63546ee8a2bf78aba775c74dae97920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#gae63546ee8a2bf78aba775c74dae97920">hwloc_get_obj_below_array_by_type</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, int nr, <a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> *typev, unsigned *idxv)</td></tr>
<tr class="separator:gae63546ee8a2bf78aba775c74dae97920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5df3ad1e8565ea0c2cf06412f6f6233" id="r_gab5df3ad1e8565ea0c2cf06412f6f6233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html#gab5df3ad1e8565ea0c2cf06412f6f6233">hwloc_get_obj_with_same_locality</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> src, <a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type, const char *subtype, const char *nameprefix, unsigned long flags)</td></tr>
<tr class="separator:gab5df3ad1e8565ea0c2cf06412f6f6233"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Be sure to see the figure in <a class="el" href="a00367.html">Terms and Definitions</a> that shows a complete topology tree, including depths, child/sibling/cousin relationships, and an example of an asymmetric topology where one package has fewer caches than its peers. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga050646458efc8ca1120d9f124c5ad861" name="ga050646458efc8ca1120d9f124c5ad861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050646458efc8ca1120d9f124c5ad861">&#9670;&#160;</a></span>hwloc_bitmap_singlify_per_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_singlify_per_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove simultaneous multithreading PUs from a CPU set. </p>
<p>For each core in <code>topology</code>, if <code>cpuset</code> contains some PUs of that core, modify <code>cpuset</code> to only keep a single PU for that core.</p>
<p><code>which</code> specifies which PU will be kept. PU are considered in physical index order. If 0, for each core, the function keeps the first PU that was originally set in <code>cpuset</code>.</p>
<p>If <code>which</code> is larger than the number of PUs in a core there were originally set in <code>cpuset</code>, no PU is kept for that core.</p>
<dl class="section return"><dt>Returns</dt><dd>0.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>PUs that are not below a Core object are ignored (for instance if the topology does not contain any Core object). None of them is removed from <code>cpuset</code>. </dd></dl>

</div>
</div>
<a id="ga2cd22a34360643f7f5bad09576dec205" name="ga2cd22a34360643f7f5bad09576dec205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cd22a34360643f7f5bad09576dec205">&#9670;&#160;</a></span>hwloc_get_closest_objs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned hwloc_get_closest_objs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *restrict&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a depth-first traversal of the topology to find and sort. </p>
<p>all objects that are at the same depth than <code>src</code>. Report in <code>objs</code> up to <code>max</code> physically closest ones to <code>src</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of objects returned in <code>objs</code>.</dd>
<dd>
0 if <code>src</code> is an I/O object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires the <code>src</code> object to have a CPU set. </dd></dl>

</div>
</div>
<a id="gacc7623746b55a89bdc175ee99930c420" name="gacc7623746b55a89bdc175ee99930c420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7623746b55a89bdc175ee99930c420">&#9670;&#160;</a></span>hwloc_get_numanode_obj_by_os_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> hwloc_get_numanode_obj_by_os_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>os_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object of type <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a9d917a3e5497950c6d8948b8e183db5a" title="NUMA node. An object that contains memory that is directly and byte-accessible to the host processors...">HWLOC_OBJ_NUMANODE</a> with <code>os_index</code>. </p>
<p>This function is useful for converting a nodeset into the NUMA node objects it contains. When retrieving the current binding (e.g. with <a class="el" href="a00171.html#gae21f0a1a884929c784bebf070252aa56" title="Query the default memory binding policy and physical locality of the current process or thread.">hwloc_get_membind()</a> with HWLOC_MEMBIND_BYNODESET), one may iterate over the bits of the resulting nodeset with <a class="el" href="a00185.html#ga3f6861045a8029ade373510ffa727d2a" title="Loop macro iterating on bitmap bitmap.">hwloc_bitmap_foreach_begin()</a>, and find the corresponding NUMA nodes with this function.</p>
<dl class="section return"><dt>Returns</dt><dd>the NUMA node object, or <code>NULL</code> if none matches. </dd></dl>

</div>
</div>
<a id="gae63546ee8a2bf78aba775c74dae97920" name="gae63546ee8a2bf78aba775c74dae97920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63546ee8a2bf78aba775c74dae97920">&#9670;&#160;</a></span>hwloc_get_obj_below_array_by_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> hwloc_get_obj_below_array_by_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> *&#160;</td>
          <td class="paramname"><em>typev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idxv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an object below a chain of objects specified by types and indexes. </p>
<p>This is a generalized version of <a class="el" href="a00180.html#ga3f37fd3b4e890d6d488163634f6befd9" title="Find an object below another object, both specified by types and indexes.">hwloc_get_obj_below_by_type()</a>.</p>
<p>Arrays <code>typev</code> and <code>idxv</code> must contain <code>nr</code> types and indexes.</p>
<p>Start from the top system object and walk the arrays <code>typev</code> and <code>idxv</code>. For each type and logical index couple in the arrays, look under the previously found object to find the index-th object of the given type. Indexes are specified within the parent, not withing the entire system.</p>
<p>For instance, if nr is 3, typev contains NODE, PACKAGE and CORE, and idxv contains 0, 1 and 2, return the third core object below the second package below the first NUMA node.</p>
<dl class="section return"><dt>Returns</dt><dd>a matching object if any, <code>NULL</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires all these objects and the root object to have a CPU set. </dd></dl>

</div>
</div>
<a id="ga3f37fd3b4e890d6d488163634f6befd9" name="ga3f37fd3b4e890d6d488163634f6befd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f37fd3b4e890d6d488163634f6befd9">&#9670;&#160;</a></span>hwloc_get_obj_below_by_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> hwloc_get_obj_below_by_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an object below another object, both specified by types and indexes. </p>
<p>Start from the top system object and find object of type <code>type1</code> and logical index <code>idx1</code>. Then look below this object and find another object of type <code>type2</code> and logical index <code>idx2</code>. Indexes are specified within the parent, not withing the entire system.</p>
<p>For instance, if type1 is PACKAGE, idx1 is 2, type2 is CORE and idx2 is 3, return the fourth core object below the third package.</p>
<dl class="section return"><dt>Returns</dt><dd>a matching object if any, <code>NULL</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires these objects to have a CPU set. </dd></dl>

</div>
</div>
<a id="gab5df3ad1e8565ea0c2cf06412f6f6233" name="gab5df3ad1e8565ea0c2cf06412f6f6233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5df3ad1e8565ea0c2cf06412f6f6233">&#9670;&#160;</a></span>hwloc_get_obj_with_same_locality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> hwloc_get_obj_with_same_locality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameprefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an object of a different type with same locality. </p>
<p>If the source object <code>src</code> is a normal or memory type, this function returns an object of type <code>type</code> with same CPU and node sets, either below or above in the hierarchy.</p>
<p>If the source object <code>src</code> is a PCI or an OS device within a PCI device, the function may either return that PCI device, or another OS device in the same PCI parent. This may for instance be useful for converting between OS devices such as "nvml0" or "rsmi1" used in distance structures into the the PCI device, or the CUDA or OpenCL OS device that correspond to the same physical card.</p>
<p>If not <code>NULL</code>, parameter <code>subtype</code> only select objects whose subtype attribute exists and is <code>subtype</code> (case-insensitively), for instance "OpenCL" or "CUDA".</p>
<p>If not <code>NULL</code>, parameter <code>nameprefix</code> only selects objects whose name attribute exists and starts with <code>nameprefix</code> (case-insensitively), for instance "rsmi" for matching "rsmi0".</p>
<p>If multiple objects match, the first one is returned.</p>
<p>This function will not walk the hierarchy across bridges since the PCI locality may become different. This function cannot also convert between normal/memory objects and I/O or Misc objects.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section return"><dt>Returns</dt><dd>An object with identical locality, matching <code>subtype</code> and <code>nameprefix</code> if any.</dd>
<dd>
<code>NULL</code> if no matching object could be found, or if the source object and target type are incompatible, for instance if converting between CPU and I/O objects. </dd></dl>

</div>
</div>
<a id="gac060ecf6683fb0d206e46b28c64648ac" name="gac060ecf6683fb0d206e46b28c64648ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac060ecf6683fb0d206e46b28c64648ac">&#9670;&#160;</a></span>hwloc_get_pu_obj_by_os_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> hwloc_get_pu_obj_by_os_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>os_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object of type <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55abca6887e80cb291353b0a0c1da83f661" title="Processing Unit, or (Logical) Processor. An execution unit (may share a core with some other logical ...">HWLOC_OBJ_PU</a> with <code>os_index</code>. </p>
<p>This function is useful for converting a CPU set into the PU objects it contains. When retrieving the current binding (e.g. with <a class="el" href="a00170.html#gacba7ecb979baf824d5240fa2cb2a8be6" title="Get current process or thread binding.">hwloc_get_cpubind()</a>), one may iterate over the bits of the resulting CPU set with <a class="el" href="a00185.html#ga3f6861045a8029ade373510ffa727d2a" title="Loop macro iterating on bitmap bitmap.">hwloc_bitmap_foreach_begin()</a>, and find the corresponding PUs with this function.</p>
<dl class="section return"><dt>Returns</dt><dd>the PU object, or <code>NULL</code> if none matches. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
