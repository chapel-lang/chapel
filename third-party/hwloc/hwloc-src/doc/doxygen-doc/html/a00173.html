<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Topology Detection Configuration and Query</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hardware Locality (hwloc)<span id="projectnumber">&#160;2.12.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Topology Detection Configuration and Query</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">hwloc_topology_discovery_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html">hwloc_topology_cpubind_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00280.html">hwloc_topology_membind_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00284.html">hwloc_topology_misc_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">hwloc_topology_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada025d3ec20b4b420f8038d23d6e7bde" id="r_gada025d3ec20b4b420f8038d23d6e7bde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#gada025d3ec20b4b420f8038d23d6e7bde">hwloc_topology_flags_e</a> { <br />
&#160;&#160;<a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea10907044bbb306fd0dc76acf046d9258">HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED</a>
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a>
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea1b66bbd66e900e5c837f71defb32ad89">HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES</a>
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdead93e82b8668ee90e4f9354e201a2ed9c">HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT</a> = (1UL&lt;&lt;3)
, <br />
&#160;&#160;<a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdeaa595aed197779012acf43e8ca4a2658d">HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING</a> = (1UL&lt;&lt;4)
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea368d7741135fe309f3782c59644d3caa">HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_MEMBINDING</a> = (1UL&lt;&lt;5)
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdeae7a792e3db4360360a10f9160b10e631">HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING</a> = (1UL&lt;&lt;6)
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea5796b4909eba80f9727b66d07d3a7a05">HWLOC_TOPOLOGY_FLAG_NO_DISTANCES</a> = (1UL&lt;&lt;7)
, <br />
&#160;&#160;<a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdead5636766a6603f24486f79c48899c1c3">HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS</a> = (1UL&lt;&lt;8)
, <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea3497cd4c2f8b1d842dd49b3aaae56a24">HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS</a> = (1UL&lt;&lt;9)
<br />
 }</td></tr>
<tr class="separator:gada025d3ec20b4b420f8038d23d6e7bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5a1f0140cd1952544477833733195b" id="r_ga9a5a1f0140cd1952544477833733195b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> { <a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195bafda7b59e6810dfe778d8f9a4cc1e350e">HWLOC_TYPE_FILTER_KEEP_ALL</a>
, <a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195ba4f835955414de92c77d99b8419d4647a">HWLOC_TYPE_FILTER_KEEP_NONE</a>
, <a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195ba7664716643bf1db83e631eed34f659e4">HWLOC_TYPE_FILTER_KEEP_STRUCTURE</a>
, <a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195ba63fd24954e18c83ff7eae9588759adb5">HWLOC_TYPE_FILTER_KEEP_IMPORTANT</a>
 }</td></tr>
<tr class="separator:ga9a5a1f0140cd1952544477833733195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaeed4df656979e5f16befea9d29b814b" id="r_gaaeed4df656979e5f16befea9d29b814b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#gaaeed4df656979e5f16befea9d29b814b">hwloc_topology_set_flags</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, unsigned long flags)</td></tr>
<tr class="separator:gaaeed4df656979e5f16befea9d29b814b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09318f81c1d4713be907d64748a6f93c" id="r_ga09318f81c1d4713be907d64748a6f93c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga09318f81c1d4713be907d64748a6f93c">hwloc_topology_get_flags</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology)</td></tr>
<tr class="separator:ga09318f81c1d4713be907d64748a6f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ffdcfd9175cdf40709801092f18017" id="r_ga68ffdcfd9175cdf40709801092f18017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga68ffdcfd9175cdf40709801092f18017">hwloc_topology_is_thissystem</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology)</td></tr>
<tr class="separator:ga68ffdcfd9175cdf40709801092f18017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0927e93a9b962143be08a48bbff2e19" id="r_gac0927e93a9b962143be08a48bbff2e19"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00288.html">hwloc_topology_support</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#gac0927e93a9b962143be08a48bbff2e19">hwloc_topology_get_support</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology)</td></tr>
<tr class="separator:gac0927e93a9b962143be08a48bbff2e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad894e70f15f8d4aada7be8d1aba38b7e" id="r_gad894e70f15f8d4aada7be8d1aba38b7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#gad894e70f15f8d4aada7be8d1aba38b7e">hwloc_topology_set_type_filter</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type, enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> filter)</td></tr>
<tr class="separator:gad894e70f15f8d4aada7be8d1aba38b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137ad1178f7a79f2383974d983083401" id="r_ga137ad1178f7a79f2383974d983083401"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga137ad1178f7a79f2383974d983083401">hwloc_topology_get_type_filter</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type, enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> *filter)</td></tr>
<tr class="separator:ga137ad1178f7a79f2383974d983083401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb8dc3b106f84921bf5789101e97e24" id="r_ga9eb8dc3b106f84921bf5789101e97e24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga9eb8dc3b106f84921bf5789101e97e24">hwloc_topology_set_all_types_filter</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> filter)</td></tr>
<tr class="separator:ga9eb8dc3b106f84921bf5789101e97e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bd6d330fe3c8f0cbaad724d114ee20" id="r_ga30bd6d330fe3c8f0cbaad724d114ee20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga30bd6d330fe3c8f0cbaad724d114ee20">hwloc_topology_set_cache_types_filter</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> filter)</td></tr>
<tr class="separator:ga30bd6d330fe3c8f0cbaad724d114ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c7b2e599ed3cd76ad9164630024f30" id="r_ga37c7b2e599ed3cd76ad9164630024f30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga37c7b2e599ed3cd76ad9164630024f30">hwloc_topology_set_icache_types_filter</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> filter)</td></tr>
<tr class="separator:ga37c7b2e599ed3cd76ad9164630024f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ab38705357bc1203abe829da8a12ad3" id="r_ga0ab38705357bc1203abe829da8a12ad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga0ab38705357bc1203abe829da8a12ad3">hwloc_topology_set_io_types_filter</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> filter)</td></tr>
<tr class="separator:ga0ab38705357bc1203abe829da8a12ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc7b7b155cba58dda203e54f1637b9c" id="r_ga2cc7b7b155cba58dda203e54f1637b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#ga2cc7b7b155cba58dda203e54f1637b9c">hwloc_topology_set_userdata</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const void *userdata)</td></tr>
<tr class="separator:ga2cc7b7b155cba58dda203e54f1637b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47dee1a30f4b00486b54872af030b43" id="r_gad47dee1a30f4b00486b54872af030b43"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html#gad47dee1a30f4b00486b54872af030b43">hwloc_topology_get_userdata</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology)</td></tr>
<tr class="separator:gad47dee1a30f4b00486b54872af030b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Several functions can optionally be called between <a class="el" href="a00166.html#ga03fd4a16d8b9ee1ffc32b25fd2f6bdfa" title="Allocate a topology context.">hwloc_topology_init()</a> and <a class="el" href="a00166.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology.">hwloc_topology_load()</a> to configure how the detection should be performed, e.g. to ignore some objects types, define a synthetic topology, etc. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gada025d3ec20b4b420f8038d23d6e7bde" name="gada025d3ec20b4b420f8038d23d6e7bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada025d3ec20b4b420f8038d23d6e7bde">&#9670;&#160;</a></span>hwloc_topology_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00173.html#gada025d3ec20b4b420f8038d23d6e7bde">hwloc_topology_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be set onto a topology context before load. </p>
<p>Flags should be given to <a class="el" href="a00173.html#gaaeed4df656979e5f16befea9d29b814b" title="Set OR&#39;ed flags to non-yet-loaded topology.">hwloc_topology_set_flags()</a>. They may also be returned by <a class="el" href="a00173.html#ga09318f81c1d4713be907d64748a6f93c" title="Get OR&#39;ed flags of a topology.">hwloc_topology_get_flags()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea10907044bbb306fd0dc76acf046d9258" name="ggada025d3ec20b4b420f8038d23d6e7bdea10907044bbb306fd0dc76acf046d9258"></a>HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED&#160;</td><td class="fielddoc"><p>Detect the whole system, ignore reservations, include disallowed objects. </p>
<p>Gather all online resources, even if some were disabled by the administrator. For instance, ignore Linux Cgroup/Cpusets and gather all processors and memory nodes. However offline PUs and NUMA nodes are still ignored.</p>
<p>When this flag is not set, PUs and NUMA nodes that are disallowed are not added to the topology. Parent objects (package, core, cache, etc.) are added only if some of their children are allowed. All existing PUs and NUMA nodes in the topology are allowed. <a class="el" href="a00182.html#ga517d5d68ec9f24583d8933aab713be8e" title="Get allowed CPU set.">hwloc_topology_get_allowed_cpuset()</a> and <a class="el" href="a00182.html#ga21a4d7237a11e76b912ed4524ab78cbd" title="Get allowed node set.">hwloc_topology_get_allowed_nodeset()</a> are equal to the root object cpuset and nodeset.</p>
<p>When this flag is set, the actual sets of allowed PUs and NUMA nodes are given by <a class="el" href="a00182.html#ga517d5d68ec9f24583d8933aab713be8e" title="Get allowed CPU set.">hwloc_topology_get_allowed_cpuset()</a> and <a class="el" href="a00182.html#ga21a4d7237a11e76b912ed4524ab78cbd" title="Get allowed node set.">hwloc_topology_get_allowed_nodeset()</a>. They may be smaller than the root object cpuset and nodeset.</p>
<p>If the current topology is exported to XML and reimported later, this flag should be set again in the reimported topology so that disallowed resources are reimported as well. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" name="ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b"></a>HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM&#160;</td><td class="fielddoc"><p>Assume that the selected backend provides the topology for the system on which we are running. </p>
<p>This forces <a class="el" href="a00173.html#ga68ffdcfd9175cdf40709801092f18017" title="Does the topology context come from this system?">hwloc_topology_is_thissystem()</a> to return 1, i.e. makes hwloc assume that the selected backend provides the topology for the system on which we are running, even if it is not the OS-specific backend but the XML backend for instance. This means making the binding functions actually call the OS-specific system calls and really do binding, while the XML backend would otherwise provide empty hooks just returning success.</p>
<p>Setting the environment variable HWLOC_THISSYSTEM may also result in the same behavior.</p>
<p>This can be used for efficiency reasons to first detect the topology once, save it to an XML file, and quickly reload it later through the XML backend, but still having binding functions actually do bind. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea1b66bbd66e900e5c837f71defb32ad89" name="ggada025d3ec20b4b420f8038d23d6e7bdea1b66bbd66e900e5c837f71defb32ad89"></a>HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES&#160;</td><td class="fielddoc"><p>Get the set of allowed resources from the local operating system even if the topology was loaded from XML or synthetic description. </p>
<p>If the topology was loaded from XML or from a synthetic string, restrict it by applying the current process restrictions such as Linux Cgroup/Cpuset.</p>
<p>This is useful when the topology is not loaded directly from the local machine (e.g. for performance reason) and it comes with all resources, while the running process is restricted to only parts of the machine.</p>
<p>This flag is ignored unless <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running.">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> is also set since the loaded topology must match the underlying machine where restrictions will be gathered from.</p>
<p>Setting the environment variable HWLOC_THISSYSTEM_ALLOWED_RESOURCES would result in the same behavior. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdead93e82b8668ee90e4f9354e201a2ed9c" name="ggada025d3ec20b4b420f8038d23d6e7bdead93e82b8668ee90e4f9354e201a2ed9c"></a>HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT&#160;</td><td class="fielddoc"><p>Import support from the imported topology. </p>
<p>When importing a XML topology from a remote machine, binding is disabled by default (see <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running.">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a>). This disabling is also marked by putting zeroes in the corresponding supported feature bits reported by <a class="el" href="a00173.html#gac0927e93a9b962143be08a48bbff2e19" title="Retrieve the topology support.">hwloc_topology_get_support()</a>.</p>
<p>The flag <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdead93e82b8668ee90e4f9354e201a2ed9c" title="Import support from the imported topology.">HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT</a> actually imports support bits from the remote machine. It also sets the flag <code>imported_support</code> in the struct <a class="el" href="a00284.html" title="Flags describing miscellaneous features.">hwloc_topology_misc_support</a> array. If the imported XML did not contain any support information (exporter hwloc is too old), this flag is not set.</p>
<p>Note that these supported features are only relevant for the hwloc installation that actually exported the XML topology (it may vary with the operating system, or with how hwloc was compiled).</p>
<p>Note that setting this flag however does not enable binding for the locally imported hwloc topology, it only reports what the remote hwloc and machine support. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdeaa595aed197779012acf43e8ca4a2658d" name="ggada025d3ec20b4b420f8038d23d6e7bdeaa595aed197779012acf43e8ca4a2658d"></a>HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING&#160;</td><td class="fielddoc"><p>Do not consider resources outside of the process CPU binding. </p>
<p>If the binding of the process is limited to a subset of cores, ignore the other cores during discovery.</p>
<p>The resulting topology is identical to what a call to <a class="el" href="a00174.html#ga6db81ed13ac0a9d70cc80372ab537815" title="Restrict the topology to the given CPU set or nodeset.">hwloc_topology_restrict()</a> would generate, but this flag also prevents hwloc from ever touching other resources during the discovery.</p>
<p>This flag especially tells the x86 backend to never temporarily rebind a thread on any excluded core. This is useful on Windows because such temporary rebinding can change the process binding. Another use-case is to avoid cores that would not be able to perform the hwloc discovery anytime soon because they are busy executing some high-priority real-time tasks.</p>
<p>If process CPU binding is not supported, the thread CPU binding is considered instead if supported, or the flag is ignored.</p>
<p>This flag requires <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running.">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> as well since binding support is required. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea368d7741135fe309f3782c59644d3caa" name="ggada025d3ec20b4b420f8038d23d6e7bdea368d7741135fe309f3782c59644d3caa"></a>HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_MEMBINDING&#160;</td><td class="fielddoc"><p>Do not consider resources outside of the process memory binding. </p>
<p>If the binding of the process is limited to a subset of NUMA nodes, ignore the other NUMA nodes during discovery.</p>
<p>The resulting topology is identical to what a call to <a class="el" href="a00174.html#ga6db81ed13ac0a9d70cc80372ab537815" title="Restrict the topology to the given CPU set or nodeset.">hwloc_topology_restrict()</a> would generate, but this flag also prevents hwloc from ever touching other resources during the discovery.</p>
<p>This flag is meant to be used together with <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdeaa595aed197779012acf43e8ca4a2658d" title="Do not consider resources outside of the process CPU binding.">HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING</a> when both cores and NUMA nodes should be ignored outside of the process binding.</p>
<p>If process memory binding is not supported, the thread memory binding is considered instead if supported, or the flag is ignored.</p>
<p>This flag requires <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running.">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> as well since binding support is required. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdeae7a792e3db4360360a10f9160b10e631" name="ggada025d3ec20b4b420f8038d23d6e7bdeae7a792e3db4360360a10f9160b10e631"></a>HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING&#160;</td><td class="fielddoc"><p>Do not ever modify the process or thread binding during discovery. </p>
<p>This flag disables all hwloc discovery steps that require a change of the process or thread binding. This currently only affects the x86 backend which gets entirely disabled.</p>
<p>This is useful when <a class="el" href="a00166.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology.">hwloc_topology_load()</a> is called while the application also creates additional threads or modifies the binding.</p>
<p>This flag is also a strict way to make sure the process binding will not change to due thread binding changes on Windows (see <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdeaa595aed197779012acf43e8ca4a2658d" title="Do not consider resources outside of the process CPU binding.">HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea5796b4909eba80f9727b66d07d3a7a05" name="ggada025d3ec20b4b420f8038d23d6e7bdea5796b4909eba80f9727b66d07d3a7a05"></a>HWLOC_TOPOLOGY_FLAG_NO_DISTANCES&#160;</td><td class="fielddoc"><p>Ignore distances. </p>
<p>Ignore distance information from the operating systems (and from XML) and hence do not use distances for grouping. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdead5636766a6603f24486f79c48899c1c3" name="ggada025d3ec20b4b420f8038d23d6e7bdead5636766a6603f24486f79c48899c1c3"></a>HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS&#160;</td><td class="fielddoc"><p>Ignore memory attributes and tiers. </p>
<p>Ignore memory attribues from the operating systems (and from XML) Hence also do not try to build memory tiers. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea3497cd4c2f8b1d842dd49b3aaae56a24" name="ggada025d3ec20b4b420f8038d23d6e7bdea3497cd4c2f8b1d842dd49b3aaae56a24"></a>HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS&#160;</td><td class="fielddoc"><p>Ignore CPU Kinds. </p>
<p>Ignore CPU kind information from the operating systems (and from XML). </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9a5a1f0140cd1952544477833733195b" name="ga9a5a1f0140cd1952544477833733195b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a5a1f0140cd1952544477833733195b">&#9670;&#160;</a></span>hwloc_type_filter_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type filtering flags. </p>
<p>By default, most objects are kept (<a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195bafda7b59e6810dfe778d8f9a4cc1e350e" title="Keep all objects of this type.">HWLOC_TYPE_FILTER_KEEP_ALL</a>). Instruction caches, memory-side caches, I/O and Misc objects are ignored by default (<a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195ba4f835955414de92c77d99b8419d4647a" title="Ignore all objects of this type.">HWLOC_TYPE_FILTER_KEEP_NONE</a>). Group levels are ignored unless they bring structure (<a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195ba7664716643bf1db83e631eed34f659e4" title="Only ignore objects if their entire level does not bring any structure.">HWLOC_TYPE_FILTER_KEEP_STRUCTURE</a>).</p>
<p>Note that group objects are also ignored individually (without the entire level) when they do not bring structure. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a5a1f0140cd1952544477833733195bafda7b59e6810dfe778d8f9a4cc1e350e" name="gga9a5a1f0140cd1952544477833733195bafda7b59e6810dfe778d8f9a4cc1e350e"></a>HWLOC_TYPE_FILTER_KEEP_ALL&#160;</td><td class="fielddoc"><p>Keep all objects of this type. </p>
<p>Cannot be set for <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a5269ef95be72f88465559d35c9b7ad56" title="Group objects. Objects which do not fit in the above but are detected by hwloc and are useful to take...">HWLOC_OBJ_GROUP</a> (groups are designed only to add more structure to the topology). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a5a1f0140cd1952544477833733195ba4f835955414de92c77d99b8419d4647a" name="gga9a5a1f0140cd1952544477833733195ba4f835955414de92c77d99b8419d4647a"></a>HWLOC_TYPE_FILTER_KEEP_NONE&#160;</td><td class="fielddoc"><p>Ignore all objects of this type. </p>
<p>The bottom-level type <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55abca6887e80cb291353b0a0c1da83f661" title="Processing Unit, or (Logical) Processor. An execution unit (may share a core with some other logical ...">HWLOC_OBJ_PU</a>, the <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a9d917a3e5497950c6d8948b8e183db5a" title="NUMA node. An object that contains memory that is directly and byte-accessible to the host processors...">HWLOC_OBJ_NUMANODE</a> type, and the top-level type <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a3f4e83ffc4a259354959ae8a9eaa2a80" title="Machine. A set of processors and memory with cache coherency.">HWLOC_OBJ_MACHINE</a> may not be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a5a1f0140cd1952544477833733195ba7664716643bf1db83e631eed34f659e4" name="gga9a5a1f0140cd1952544477833733195ba7664716643bf1db83e631eed34f659e4"></a>HWLOC_TYPE_FILTER_KEEP_STRUCTURE&#160;</td><td class="fielddoc"><p>Only ignore objects if their entire level does not bring any structure. </p>
<p>Keep the entire level of objects if at least one of these objects adds structure to the topology. An object brings structure when it has multiple children and it is not the only child of its parent.</p>
<p>If all objects in the level are the only child of their parent, and if none of them has multiple children, the entire level is removed.</p>
<p>Cannot be set for I/O and Misc objects since the topology structure does not matter there. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a5a1f0140cd1952544477833733195ba63fd24954e18c83ff7eae9588759adb5" name="gga9a5a1f0140cd1952544477833733195ba63fd24954e18c83ff7eae9588759adb5"></a>HWLOC_TYPE_FILTER_KEEP_IMPORTANT&#160;</td><td class="fielddoc"><p>Only keep likely-important objects of the given type. </p>
<p>It is only useful for I/O object types. For <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a5d8117a54df1fbd3606ab19e42cb0ea9" title="PCI device (filtered out by default).">HWLOC_OBJ_PCI_DEVICE</a> and <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a51e7280240fd9f25589cbbe538bdb075" title="Operating system device (filtered out by default).">HWLOC_OBJ_OS_DEVICE</a>, it means that only objects of major/common kinds are kept (storage, network, OpenFabrics, CUDA, OpenCL, RSMI, NVML, and displays). Also, only OS devices directly attached on PCI (e.g. no USB) are reported. For <a class="el" href="a00164.html#ggacd37bb612667dc437d66bfb175a8dc55a6825f10895fea60aca7a6ba9fe273db0" title="Bridge (filtered out by default). Any bridge (or PCI switch) that connects the host or an I/O bus,...">HWLOC_OBJ_BRIDGE</a>, it means that bridges are kept only if they have children.</p>
<p>This flag equivalent to <a class="el" href="a00173.html#gga9a5a1f0140cd1952544477833733195bafda7b59e6810dfe778d8f9a4cc1e350e" title="Keep all objects of this type.">HWLOC_TYPE_FILTER_KEEP_ALL</a> for Normal, Memory and Misc types since they are likely important. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga09318f81c1d4713be907d64748a6f93c" name="ga09318f81c1d4713be907d64748a6f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09318f81c1d4713be907d64748a6f93c">&#9670;&#160;</a></span>hwloc_topology_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long hwloc_topology_get_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OR'ed flags of a topology. </p>
<p>Get the OR'ed set of <a class="el" href="a00173.html#gada025d3ec20b4b420f8038d23d6e7bde" title="Flags to be set onto a topology context before load.">hwloc_topology_flags_e</a> of a topology.</p>
<p>If <a class="el" href="a00173.html#gaaeed4df656979e5f16befea9d29b814b" title="Set OR&#39;ed flags to non-yet-loaded topology.">hwloc_topology_set_flags()</a> was not called earlier, no flags are set (<code>0</code> is returned).</p>
<dl class="section return"><dt>Returns</dt><dd>the flags previously set with <a class="el" href="a00173.html#gaaeed4df656979e5f16befea9d29b814b" title="Set OR&#39;ed flags to non-yet-loaded topology.">hwloc_topology_set_flags()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may also be called after <a class="el" href="a00166.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology.">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
<a id="gac0927e93a9b962143be08a48bbff2e19" name="gac0927e93a9b962143be08a48bbff2e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0927e93a9b962143be08a48bbff2e19">&#9670;&#160;</a></span>hwloc_topology_get_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="a00288.html">hwloc_topology_support</a> * hwloc_topology_get_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the topology support. </p>
<p>Each flag indicates whether a feature is supported. If set to 0, the feature is not supported. If set to 1, the feature is supported, but the corresponding call may still fail in some corner cases.</p>
<p>These features are also listed by hwloc-info --support</p>
<p>The reported features are what the current topology supports on the current machine. If the topology was exported to XML from another machine and later imported here, support still describes what is supported for this imported topology after import. By default, binding will be reported as unsupported in this case (see <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running.">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a>).</p>
<p>Topology flag <a class="el" href="a00173.html#ggada025d3ec20b4b420f8038d23d6e7bdead93e82b8668ee90e4f9354e201a2ed9c" title="Import support from the imported topology.">HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT</a> may be used to report the supported features of the original remote machine instead. If it was successfully imported, <code>imported_support</code> will be set in the struct <a class="el" href="a00284.html" title="Flags describing miscellaneous features.">hwloc_topology_misc_support</a> array.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a support structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function cannot return <code>NULL</code>. </dd>
<dd>
The returned pointer should not be freed, it belongs to the hwloc library.</dd>
<dd>
This function may be called before or after <a class="el" href="a00166.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology.">hwloc_topology_load()</a> but the support structure only contains valid information after. </dd></dl>

</div>
</div>
<a id="ga137ad1178f7a79f2383974d983083401" name="ga137ad1178f7a79f2383974d983083401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga137ad1178f7a79f2383974d983083401">&#9670;&#160;</a></span>hwloc_topology_get_type_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_get_type_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current filtering for the given object type. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="gad47dee1a30f4b00486b54872af030b43" name="gad47dee1a30f4b00486b54872af030b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad47dee1a30f4b00486b54872af030b43">&#9670;&#160;</a></span>hwloc_topology_get_userdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * hwloc_topology_get_userdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the topology-specific userdata pointer. </p>
<p>Retrieve the application-given private data pointer that was previously set with <a class="el" href="a00173.html#ga2cc7b7b155cba58dda203e54f1637b9c" title="Set the topology-specific userdata pointer.">hwloc_topology_set_userdata()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the private-data if any. </dd>
<dd>
<code>NULL</code> if no private-data was previoulsy set. </dd></dl>

</div>
</div>
<a id="ga68ffdcfd9175cdf40709801092f18017" name="ga68ffdcfd9175cdf40709801092f18017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ffdcfd9175cdf40709801092f18017">&#9670;&#160;</a></span>hwloc_topology_is_thissystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_is_thissystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the topology context come from this system? </p>
<dl class="section return"><dt>Returns</dt><dd>1 if this topology context was built using the system running this program. </dd>
<dd>
0 instead (for instance if using another file-system root, a XML topology file, or a synthetic topology).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may also be called after <a class="el" href="a00166.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology.">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
<a id="ga9eb8dc3b106f84921bf5789101e97e24" name="ga9eb8dc3b106f84921bf5789101e97e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb8dc3b106f84921bf5789101e97e24">&#9670;&#160;</a></span>hwloc_topology_set_all_types_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_all_types_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filtering for all object types. </p>
<p>If some types do not support this filtering, they are silently ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ga30bd6d330fe3c8f0cbaad724d114ee20" name="ga30bd6d330fe3c8f0cbaad724d114ee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30bd6d330fe3c8f0cbaad724d114ee20">&#9670;&#160;</a></span>hwloc_topology_set_cache_types_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_cache_types_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filtering for all CPU cache object types. </p>
<p>Memory-side caches are not involved since they are not CPU caches.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="gaaeed4df656979e5f16befea9d29b814b" name="gaaeed4df656979e5f16befea9d29b814b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeed4df656979e5f16befea9d29b814b">&#9670;&#160;</a></span>hwloc_topology_set_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OR'ed flags to non-yet-loaded topology. </p>
<p>Set a OR'ed set of <a class="el" href="a00173.html#gada025d3ec20b4b420f8038d23d6e7bde" title="Flags to be set onto a topology context before load.">hwloc_topology_flags_e</a> onto a topology that was not yet loaded.</p>
<p>If this function is called multiple times, the last invocation will erase and replace the set of flags that was previously set.</p>
<p>By default, no flags are set (<code>0</code>).</p>
<p>The flags set in a topology may be retrieved with <a class="el" href="a00173.html#ga09318f81c1d4713be907d64748a6f93c" title="Get OR&#39;ed flags of a topology.">hwloc_topology_get_flags()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 on error, for instance if flags are invalid. </dd></dl>

</div>
</div>
<a id="ga37c7b2e599ed3cd76ad9164630024f30" name="ga37c7b2e599ed3cd76ad9164630024f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37c7b2e599ed3cd76ad9164630024f30">&#9670;&#160;</a></span>hwloc_topology_set_icache_types_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_icache_types_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filtering for all CPU instruction cache object types. </p>
<p>Memory-side caches are not involved since they are not CPU caches.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ga0ab38705357bc1203abe829da8a12ad3" name="ga0ab38705357bc1203abe829da8a12ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ab38705357bc1203abe829da8a12ad3">&#9670;&#160;</a></span>hwloc_topology_set_io_types_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_io_types_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filtering for all I/O object types. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="gad894e70f15f8d4aada7be8d1aba38b7e" name="gad894e70f15f8d4aada7be8d1aba38b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad894e70f15f8d4aada7be8d1aba38b7e">&#9670;&#160;</a></span>hwloc_topology_set_type_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_type_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00164.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="a00173.html#ga9a5a1f0140cd1952544477833733195b">hwloc_type_filter_e</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the filtering for the given object type. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ga2cc7b7b155cba58dda203e54f1637b9c" name="ga2cc7b7b155cba58dda203e54f1637b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc7b7b155cba58dda203e54f1637b9c">&#9670;&#160;</a></span>hwloc_topology_set_userdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hwloc_topology_set_userdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the topology-specific userdata pointer. </p>
<p>Each topology may store one application-given private data pointer. It is initialized to <code>NULL</code>. hwloc will never modify it.</p>
<p>Use it as you wish, after <a class="el" href="a00166.html#ga03fd4a16d8b9ee1ffc32b25fd2f6bdfa" title="Allocate a topology context.">hwloc_topology_init()</a> and until hwloc_topolog_destroy().</p>
<p>This pointer is not exported to XML. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
