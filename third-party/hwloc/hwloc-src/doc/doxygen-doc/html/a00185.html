<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): The bitmap API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hardware Locality (hwloc)<span id="projectnumber">&#160;2.12.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">The bitmap API</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3f6861045a8029ade373510ffa727d2a" id="r_ga3f6861045a8029ade373510ffa727d2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3f6861045a8029ade373510ffa727d2a">hwloc_bitmap_foreach_begin</a>(id,  bitmap)</td></tr>
<tr class="separator:ga3f6861045a8029ade373510ffa727d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf3246db406218d4e155735b3fa6528" id="r_gafcf3246db406218d4e155735b3fa6528"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gafcf3246db406218d4e155735b3fa6528">hwloc_bitmap_foreach_end</a>()</td></tr>
<tr class="separator:gafcf3246db406218d4e155735b3fa6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa3c2bf4c776d603dcebbb61b0c923d84" id="r_gaa3c2bf4c776d603dcebbb61b0c923d84"><td class="memItemLeft" align="right" valign="top">typedef struct hwloc_bitmap_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a></td></tr>
<tr class="separator:gaa3c2bf4c776d603dcebbb61b0c923d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae991a108af01d408be2776c5b2c467b2" id="r_gae991a108af01d408be2776c5b2c467b2"><td class="memItemLeft" align="right" valign="top">typedef const struct hwloc_bitmap_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a></td></tr>
<tr class="separator:gae991a108af01d408be2776c5b2c467b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadece3d1eb5199fc2fb99bc7dcf1ccc05" id="r_gadece3d1eb5199fc2fb99bc7dcf1ccc05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gadece3d1eb5199fc2fb99bc7dcf1ccc05">hwloc_bitmap_alloc</a> (void)</td></tr>
<tr class="separator:gadece3d1eb5199fc2fb99bc7dcf1ccc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02853b4a224970587b9d7a0e20d857c0" id="r_ga02853b4a224970587b9d7a0e20d857c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga02853b4a224970587b9d7a0e20d857c0">hwloc_bitmap_alloc_full</a> (void)</td></tr>
<tr class="separator:ga02853b4a224970587b9d7a0e20d857c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156130d85b3a0674d6e0e6770fe68fbe" id="r_ga156130d85b3a0674d6e0e6770fe68fbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga156130d85b3a0674d6e0e6770fe68fbe">hwloc_bitmap_free</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga156130d85b3a0674d6e0e6770fe68fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae679434c1a5f41d3560a8a7e2c1b0dee" id="r_gae679434c1a5f41d3560a8a7e2c1b0dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae679434c1a5f41d3560a8a7e2c1b0dee">hwloc_bitmap_dup</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:gae679434c1a5f41d3560a8a7e2c1b0dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a29824798b48784b8217471ec8f14c" id="r_ga72a29824798b48784b8217471ec8f14c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga72a29824798b48784b8217471ec8f14c">hwloc_bitmap_copy</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> dst, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> src)</td></tr>
<tr class="separator:ga72a29824798b48784b8217471ec8f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9511644657030a021dce9941e3cda583" id="r_ga9511644657030a021dce9941e3cda583"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9511644657030a021dce9941e3cda583">hwloc_bitmap_snprintf</a> (char *restrict buf, size_t buflen, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga9511644657030a021dce9941e3cda583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fece972134fdecf2da9bc7a11dd827e" id="r_ga0fece972134fdecf2da9bc7a11dd827e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0fece972134fdecf2da9bc7a11dd827e">hwloc_bitmap_asprintf</a> (char **strp, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga0fece972134fdecf2da9bc7a11dd827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064a85c643a364b60acbfa0f3663fc18" id="r_ga064a85c643a364b60acbfa0f3663fc18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga064a85c643a364b60acbfa0f3663fc18">hwloc_bitmap_sscanf</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, const char *restrict string)</td></tr>
<tr class="separator:ga064a85c643a364b60acbfa0f3663fc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d06e6447edeb61e56a9ad83f31f0a37" id="r_ga3d06e6447edeb61e56a9ad83f31f0a37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3d06e6447edeb61e56a9ad83f31f0a37">hwloc_bitmap_list_snprintf</a> (char *restrict buf, size_t buflen, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga3d06e6447edeb61e56a9ad83f31f0a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c0f1b02053de66d205c9f8260b3665" id="r_ga39c0f1b02053de66d205c9f8260b3665"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga39c0f1b02053de66d205c9f8260b3665">hwloc_bitmap_list_asprintf</a> (char **strp, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga39c0f1b02053de66d205c9f8260b3665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9314311d482c621e17c6a53a9fe993e" id="r_gaf9314311d482c621e17c6a53a9fe993e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf9314311d482c621e17c6a53a9fe993e">hwloc_bitmap_list_sscanf</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, const char *restrict string)</td></tr>
<tr class="separator:gaf9314311d482c621e17c6a53a9fe993e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5beb68a987fe48e5c5edef06ab260e14" id="r_ga5beb68a987fe48e5c5edef06ab260e14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5beb68a987fe48e5c5edef06ab260e14">hwloc_bitmap_taskset_snprintf</a> (char *restrict buf, size_t buflen, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga5beb68a987fe48e5c5edef06ab260e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391312513f17c985d871f18367c59512" id="r_ga391312513f17c985d871f18367c59512"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga391312513f17c985d871f18367c59512">hwloc_bitmap_taskset_asprintf</a> (char **strp, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga391312513f17c985d871f18367c59512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f23db5041240e03e348752f8bd6ec2d" id="r_ga4f23db5041240e03e348752f8bd6ec2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4f23db5041240e03e348752f8bd6ec2d">hwloc_bitmap_taskset_sscanf</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, const char *restrict string)</td></tr>
<tr class="separator:ga4f23db5041240e03e348752f8bd6ec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97c5217613c8cae9862287170ea2132" id="r_gaa97c5217613c8cae9862287170ea2132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa97c5217613c8cae9862287170ea2132">hwloc_bitmap_zero</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:gaa97c5217613c8cae9862287170ea2132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b2de8786b3cdb22f21d9dd42588275" id="r_ga07b2de8786b3cdb22f21d9dd42588275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga07b2de8786b3cdb22f21d9dd42588275">hwloc_bitmap_fill</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga07b2de8786b3cdb22f21d9dd42588275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10be0840cdeb7ce26d862819dd303baa" id="r_ga10be0840cdeb7ce26d862819dd303baa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga10be0840cdeb7ce26d862819dd303baa">hwloc_bitmap_only</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned id)</td></tr>
<tr class="separator:ga10be0840cdeb7ce26d862819dd303baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d505f8a1c0a536614f65f503ee6d93" id="r_ga06d505f8a1c0a536614f65f503ee6d93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga06d505f8a1c0a536614f65f503ee6d93">hwloc_bitmap_allbut</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned id)</td></tr>
<tr class="separator:ga06d505f8a1c0a536614f65f503ee6d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59b0ebeb29c1bfabbb2a379e55c1159" id="r_gad59b0ebeb29c1bfabbb2a379e55c1159"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad59b0ebeb29c1bfabbb2a379e55c1159">hwloc_bitmap_from_ulong</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned long mask)</td></tr>
<tr class="separator:gad59b0ebeb29c1bfabbb2a379e55c1159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4947c46d47bcfcd3faf3f59569be3e37" id="r_ga4947c46d47bcfcd3faf3f59569be3e37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4947c46d47bcfcd3faf3f59569be3e37">hwloc_bitmap_from_ith_ulong</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned i, unsigned long mask)</td></tr>
<tr class="separator:ga4947c46d47bcfcd3faf3f59569be3e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcfef22f6fc4d4b33f068dd91a1c38f5" id="r_gabcfef22f6fc4d4b33f068dd91a1c38f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gabcfef22f6fc4d4b33f068dd91a1c38f5">hwloc_bitmap_from_ulongs</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned nr, const unsigned long *masks)</td></tr>
<tr class="separator:gabcfef22f6fc4d4b33f068dd91a1c38f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062dbff93baeff3b425a7260c5463646" id="r_ga062dbff93baeff3b425a7260c5463646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga062dbff93baeff3b425a7260c5463646">hwloc_bitmap_set</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned id)</td></tr>
<tr class="separator:ga062dbff93baeff3b425a7260c5463646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9a8433732fb9f24899e7aa4c014d7e" id="r_ga9c9a8433732fb9f24899e7aa4c014d7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9c9a8433732fb9f24899e7aa4c014d7e">hwloc_bitmap_set_range</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned begin, int end)</td></tr>
<tr class="separator:ga9c9a8433732fb9f24899e7aa4c014d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daeed965c35c6d2fd4820a318219985" id="r_ga3daeed965c35c6d2fd4820a318219985"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3daeed965c35c6d2fd4820a318219985">hwloc_bitmap_set_ith_ulong</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned i, unsigned long mask)</td></tr>
<tr class="separator:ga3daeed965c35c6d2fd4820a318219985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf20bb350b6844d08931a064a73f86743" id="r_gaf20bb350b6844d08931a064a73f86743"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf20bb350b6844d08931a064a73f86743">hwloc_bitmap_clr</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned id)</td></tr>
<tr class="separator:gaf20bb350b6844d08931a064a73f86743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833776709df94d727f8c22304b3388cf" id="r_ga833776709df94d727f8c22304b3388cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga833776709df94d727f8c22304b3388cf">hwloc_bitmap_clr_range</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap, unsigned begin, int end)</td></tr>
<tr class="separator:ga833776709df94d727f8c22304b3388cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa611a77c092e679246afdf9a60d5db8b" id="r_gaa611a77c092e679246afdf9a60d5db8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa611a77c092e679246afdf9a60d5db8b">hwloc_bitmap_singlify</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:gaa611a77c092e679246afdf9a60d5db8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a6bae22a33ec6adfc169a953c13e6c" id="r_gab6a6bae22a33ec6adfc169a953c13e6c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab6a6bae22a33ec6adfc169a953c13e6c">hwloc_bitmap_to_ulong</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:gab6a6bae22a33ec6adfc169a953c13e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92e6404f648d6b99d2c626b05b2ffa4" id="r_gac92e6404f648d6b99d2c626b05b2ffa4"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac92e6404f648d6b99d2c626b05b2ffa4">hwloc_bitmap_to_ith_ulong</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap, unsigned i)</td></tr>
<tr class="separator:gac92e6404f648d6b99d2c626b05b2ffa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd215a2348732de25d94a4ecd76d528c" id="r_gacd215a2348732de25d94a4ecd76d528c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gacd215a2348732de25d94a4ecd76d528c">hwloc_bitmap_to_ulongs</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap, unsigned nr, unsigned long *masks)</td></tr>
<tr class="separator:gacd215a2348732de25d94a4ecd76d528c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0744734d761d65c977aece565364908" id="r_gac0744734d761d65c977aece565364908"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac0744734d761d65c977aece565364908">hwloc_bitmap_nr_ulongs</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:gac0744734d761d65c977aece565364908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11340dd487f110bb84f0a6e4ae90bd06" id="r_ga11340dd487f110bb84f0a6e4ae90bd06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga11340dd487f110bb84f0a6e4ae90bd06">hwloc_bitmap_isset</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap, unsigned id)</td></tr>
<tr class="separator:ga11340dd487f110bb84f0a6e4ae90bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b64be28f5a7176ed8ad0d6a90bdf108" id="r_ga5b64be28f5a7176ed8ad0d6a90bdf108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5b64be28f5a7176ed8ad0d6a90bdf108">hwloc_bitmap_iszero</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga5b64be28f5a7176ed8ad0d6a90bdf108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fdcb8c19c336511c37076d649e74af4" id="r_ga5fdcb8c19c336511c37076d649e74af4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5fdcb8c19c336511c37076d649e74af4">hwloc_bitmap_isfull</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga5fdcb8c19c336511c37076d649e74af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec1ced43afadf8c0a7197320bc016ed" id="r_ga3ec1ced43afadf8c0a7197320bc016ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3ec1ced43afadf8c0a7197320bc016ed">hwloc_bitmap_first</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga3ec1ced43afadf8c0a7197320bc016ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab7240b4b644693b775dad17b44ffd68" id="r_gaab7240b4b644693b775dad17b44ffd68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaab7240b4b644693b775dad17b44ffd68">hwloc_bitmap_next</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap, int prev)</td></tr>
<tr class="separator:gaab7240b4b644693b775dad17b44ffd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9b08b060a59bbab5a4ea6d0a1ed7a6" id="r_ga3d9b08b060a59bbab5a4ea6d0a1ed7a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3d9b08b060a59bbab5a4ea6d0a1ed7a6">hwloc_bitmap_last</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga3d9b08b060a59bbab5a4ea6d0a1ed7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0200466842c0e1f5da75e84dde460b10" id="r_ga0200466842c0e1f5da75e84dde460b10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0200466842c0e1f5da75e84dde460b10">hwloc_bitmap_weight</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga0200466842c0e1f5da75e84dde460b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae408841487b288e148a478ba0465c99e" id="r_gae408841487b288e148a478ba0465c99e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae408841487b288e148a478ba0465c99e">hwloc_bitmap_first_unset</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:gae408841487b288e148a478ba0465c99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9653af34d1460ef106b7df25af4cdca8" id="r_ga9653af34d1460ef106b7df25af4cdca8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9653af34d1460ef106b7df25af4cdca8">hwloc_bitmap_next_unset</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap, int prev)</td></tr>
<tr class="separator:ga9653af34d1460ef106b7df25af4cdca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d49aeb45c7da631b1480a93dc3fc92" id="r_ga45d49aeb45c7da631b1480a93dc3fc92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga45d49aeb45c7da631b1480a93dc3fc92">hwloc_bitmap_last_unset</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga45d49aeb45c7da631b1480a93dc3fc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120b8aefb9ce7ef349929656359b1859" id="r_ga120b8aefb9ce7ef349929656359b1859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga120b8aefb9ce7ef349929656359b1859">hwloc_bitmap_or</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> res, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:ga120b8aefb9ce7ef349929656359b1859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674533016ffed922a28b4f0b49b82cd4" id="r_ga674533016ffed922a28b4f0b49b82cd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga674533016ffed922a28b4f0b49b82cd4">hwloc_bitmap_and</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> res, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:ga674533016ffed922a28b4f0b49b82cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca5c72db65406b85aca032c8a990f9e" id="r_ga7ca5c72db65406b85aca032c8a990f9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga7ca5c72db65406b85aca032c8a990f9e">hwloc_bitmap_andnot</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> res, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:ga7ca5c72db65406b85aca032c8a990f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205508218e09cb9befd0687f16409f09" id="r_ga205508218e09cb9befd0687f16409f09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga205508218e09cb9befd0687f16409f09">hwloc_bitmap_xor</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> res, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:ga205508218e09cb9befd0687f16409f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84cfdb4f8ab8c1f7e097728e613a2a3f" id="r_ga84cfdb4f8ab8c1f7e097728e613a2a3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga84cfdb4f8ab8c1f7e097728e613a2a3f">hwloc_bitmap_not</a> (<a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> res, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap)</td></tr>
<tr class="separator:ga84cfdb4f8ab8c1f7e097728e613a2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa070f9232857ba5a57297ea9a08ea2" id="r_gaefa070f9232857ba5a57297ea9a08ea2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaefa070f9232857ba5a57297ea9a08ea2">hwloc_bitmap_intersects</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:gaefa070f9232857ba5a57297ea9a08ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0526e03db81956fb02acc8260b66d6a4" id="r_ga0526e03db81956fb02acc8260b66d6a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0526e03db81956fb02acc8260b66d6a4">hwloc_bitmap_isincluded</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> sub_bitmap, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> super_bitmap)</td></tr>
<tr class="separator:ga0526e03db81956fb02acc8260b66d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32376b1405e57472b73c3aa53bb39663" id="r_ga32376b1405e57472b73c3aa53bb39663"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga32376b1405e57472b73c3aa53bb39663">hwloc_bitmap_isequal</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:ga32376b1405e57472b73c3aa53bb39663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39cda1510ab721b5c012c76ead72365" id="r_gaa39cda1510ab721b5c012c76ead72365"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa39cda1510ab721b5c012c76ead72365">hwloc_bitmap_compare_first</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:gaa39cda1510ab721b5c012c76ead72365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cdbc0ef0a705e84999bd48a2e649f3" id="r_ga14cdbc0ef0a705e84999bd48a2e649f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga14cdbc0ef0a705e84999bd48a2e649f3">hwloc_bitmap_compare</a> (<a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap1, <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a> bitmap2)</td></tr>
<tr class="separator:ga14cdbc0ef0a705e84999bd48a2e649f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84" title="Set of bits represented as an opaque pointer to an internal bitmap.">hwloc_bitmap_t</a> type represents a set of integers (positive or null). A bitmap may be of infinite size (all bits are set after some point). A bitmap may even be full if all bits are set.</p>
<p>Bitmaps are used by hwloc for sets of OS processors (which may actually be hardware threads) as by <a class="el" href="a00163.html#ga4bbf39b68b6f568fb92739e7c0ea7801" title="A CPU set is a bitmap whose bits are set according to CPU physical OS indexes.">hwloc_cpuset_t</a> (a typedef for <a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84" title="Set of bits represented as an opaque pointer to an internal bitmap.">hwloc_bitmap_t</a>), or sets of NUMA memory nodes as <a class="el" href="a00163.html#ga37e35730fa7e775b5bb0afe893d6d508" title="A node set is a bitmap whose bits are set according to NUMA memory node physical OS indexes.">hwloc_nodeset_t</a> (also a typedef for <a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84" title="Set of bits represented as an opaque pointer to an internal bitmap.">hwloc_bitmap_t</a>). Those are used for cpuset and nodeset fields in the <a class="el" href="a00220.html" title="Structure of a topology object.">hwloc_obj</a> structure, see <a class="el" href="a00163.html">Object Sets (hwloc_cpuset_t and hwloc_nodeset_t)</a>.</p>
<p><em>Both CPU and node sets are always indexed by OS physical number.</em> However users should usually not build CPU and node sets manually (e.g. with <a class="el" href="a00185.html#ga062dbff93baeff3b425a7260c5463646" title="Add index id in bitmap bitmap.">hwloc_bitmap_set()</a>). One should rather use existing object sets and combine them with <a class="el" href="a00185.html#ga120b8aefb9ce7ef349929656359b1859" title="Or bitmaps bitmap1 and bitmap2 and store the result in bitmap res.">hwloc_bitmap_or()</a>, etc. For instance, binding the current thread on a pair of cores may be performed with: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="a00220.html">hwloc_obj_t</a> core1 = ... , core2 = ... ;</div>
<div class="line"><a class="code hl_typedef" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> set = <a class="code hl_function" href="a00185.html#gadece3d1eb5199fc2fb99bc7dcf1ccc05">hwloc_bitmap_alloc</a>();</div>
<div class="line"><a class="code hl_function" href="a00185.html#ga120b8aefb9ce7ef349929656359b1859">hwloc_bitmap_or</a>(set, core1-&gt;<a class="code hl_variable" href="a00220.html#a67925e0f2c47f50408fbdb9bddd0790f">cpuset</a>, core2-&gt;cpuset);</div>
<div class="line"><a class="code hl_function" href="a00170.html#ga80bc07473a8edf840cae17bd7ec21d48">hwloc_set_cpubind</a>(topology, set, <a class="code hl_enumvalue" href="a00170.html#gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421">HWLOC_CPUBIND_THREAD</a>);</div>
<div class="line"><a class="code hl_function" href="a00185.html#ga156130d85b3a0674d6e0e6770fe68fbe">hwloc_bitmap_free</a>(set);</div>
<div class="ttc" id="aa00170_html_ga80bc07473a8edf840cae17bd7ec21d48"><div class="ttname"><a href="a00170.html#ga80bc07473a8edf840cae17bd7ec21d48">hwloc_set_cpubind</a></div><div class="ttdeci">int hwloc_set_cpubind(hwloc_topology_t topology, hwloc_const_cpuset_t set, int flags)</div><div class="ttdoc">Bind current process or thread on CPUs given in physical bitmap set.</div></div>
<div class="ttc" id="aa00170_html_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421"><div class="ttname"><a href="a00170.html#gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421">HWLOC_CPUBIND_THREAD</a></div><div class="ttdeci">@ HWLOC_CPUBIND_THREAD</div><div class="ttdoc">Bind current thread of current process.</div><div class="ttdef"><b>Definition</b> hwloc.h:1257</div></div>
<div class="ttc" id="aa00185_html_ga120b8aefb9ce7ef349929656359b1859"><div class="ttname"><a href="a00185.html#ga120b8aefb9ce7ef349929656359b1859">hwloc_bitmap_or</a></div><div class="ttdeci">int hwloc_bitmap_or(hwloc_bitmap_t res, hwloc_const_bitmap_t bitmap1, hwloc_const_bitmap_t bitmap2)</div><div class="ttdoc">Or bitmaps bitmap1 and bitmap2 and store the result in bitmap res.</div></div>
<div class="ttc" id="aa00185_html_ga156130d85b3a0674d6e0e6770fe68fbe"><div class="ttname"><a href="a00185.html#ga156130d85b3a0674d6e0e6770fe68fbe">hwloc_bitmap_free</a></div><div class="ttdeci">void hwloc_bitmap_free(hwloc_bitmap_t bitmap)</div><div class="ttdoc">Free bitmap bitmap.</div></div>
<div class="ttc" id="aa00185_html_gaa3c2bf4c776d603dcebbb61b0c923d84"><div class="ttname"><a href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a></div><div class="ttdeci">struct hwloc_bitmap_s * hwloc_bitmap_t</div><div class="ttdoc">Set of bits represented as an opaque pointer to an internal bitmap.</div><div class="ttdef"><b>Definition</b> bitmap.h:69</div></div>
<div class="ttc" id="aa00185_html_gadece3d1eb5199fc2fb99bc7dcf1ccc05"><div class="ttname"><a href="a00185.html#gadece3d1eb5199fc2fb99bc7dcf1ccc05">hwloc_bitmap_alloc</a></div><div class="ttdeci">hwloc_bitmap_t hwloc_bitmap_alloc(void)</div><div class="ttdoc">Allocate a new empty bitmap.</div></div>
<div class="ttc" id="aa00220_html"><div class="ttname"><a href="a00220.html">hwloc_obj</a></div><div class="ttdoc">Structure of a topology object.</div><div class="ttdef"><b>Definition</b> hwloc.h:432</div></div>
<div class="ttc" id="aa00220_html_a67925e0f2c47f50408fbdb9bddd0790f"><div class="ttname"><a href="a00220.html#a67925e0f2c47f50408fbdb9bddd0790f">hwloc_obj::cpuset</a></div><div class="ttdeci">hwloc_cpuset_t cpuset</div><div class="ttdoc">CPUs covered by this object.</div><div class="ttdef"><b>Definition</b> hwloc.h:548</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Most functions below return 0 on success and -1 on error. The usual error case would be an internal failure to realloc/extend the storage of the bitmap (<code>errno</code> would be set to <code>ENOMEM</code>). See also <a class="el" href="a00161.html">Error reporting in the API</a>.</dd>
<dd>
Several examples of using the bitmap API are available under the doc/examples/ directory in the source tree. Regression tests such as tests/hwloc/hwloc_bitmap*.c also make intensive use of this API. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3f6861045a8029ade373510ffa727d2a" name="ga3f6861045a8029ade373510ffa727d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f6861045a8029ade373510ffa727d2a">&#9670;&#160;</a></span>hwloc_bitmap_foreach_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hwloc_bitmap_foreach_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitmap&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop macro iterating on bitmap <code>bitmap</code>. </p>
<p>The loop must start with <a class="el" href="a00185.html#ga3f6861045a8029ade373510ffa727d2a" title="Loop macro iterating on bitmap bitmap.">hwloc_bitmap_foreach_begin()</a> and end with <a class="el" href="a00185.html#gafcf3246db406218d4e155735b3fa6528" title="End of loop macro iterating on a bitmap.">hwloc_bitmap_foreach_end()</a> followed by a terminating ';'.</p>
<p><code>id</code> is the loop variable; it should be an unsigned int. The first iteration will set <code>id</code> to the lowest index in the bitmap. Successive iterations will iterate through, in order, all remaining indexes set in the bitmap. To be specific: each iteration will return a value for <code>id</code> such that hwloc_bitmap_isset(bitmap, id) is true.</p>
<p>The assert prevents the loop from being infinite if the bitmap is infinitely set. </p>

</div>
</div>
<a id="gafcf3246db406218d4e155735b3fa6528" name="gafcf3246db406218d4e155735b3fa6528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf3246db406218d4e155735b3fa6528">&#9670;&#160;</a></span>hwloc_bitmap_foreach_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hwloc_bitmap_foreach_end</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of loop macro iterating on a bitmap. </p>
<p>Needs a terminating ';'.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00185.html#ga3f6861045a8029ade373510ffa727d2a" title="Loop macro iterating on bitmap bitmap.">hwloc_bitmap_foreach_begin()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa3c2bf4c776d603dcebbb61b0c923d84" name="gaa3c2bf4c776d603dcebbb61b0c923d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3c2bf4c776d603dcebbb61b0c923d84">&#9670;&#160;</a></span>hwloc_bitmap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct hwloc_bitmap_s* <a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of bits represented as an opaque pointer to an internal bitmap. </p>

</div>
</div>
<a id="gae991a108af01d408be2776c5b2c467b2" name="gae991a108af01d408be2776c5b2c467b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae991a108af01d408be2776c5b2c467b2">&#9670;&#160;</a></span>hwloc_const_bitmap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const struct hwloc_bitmap_s* <a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a non-modifiable <a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84" title="Set of bits represented as an opaque pointer to an internal bitmap.">hwloc_bitmap_t</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga06d505f8a1c0a536614f65f503ee6d93" name="ga06d505f8a1c0a536614f65f503ee6d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d505f8a1c0a536614f65f503ee6d93">&#9670;&#160;</a></span>hwloc_bitmap_allbut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_allbut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the bitmap <code>and</code> clear the index <code>id</code>. </p>

</div>
</div>
<a id="gadece3d1eb5199fc2fb99bc7dcf1ccc05" name="gadece3d1eb5199fc2fb99bc7dcf1ccc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadece3d1eb5199fc2fb99bc7dcf1ccc05">&#9670;&#160;</a></span>hwloc_bitmap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> hwloc_bitmap_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new empty bitmap. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid bitmap or <code>NULL</code>.</dd></dl>
<p>The bitmap should be freed by a corresponding call to <a class="el" href="a00185.html#ga156130d85b3a0674d6e0e6770fe68fbe" title="Free bitmap bitmap.">hwloc_bitmap_free()</a>. </p>

</div>
</div>
<a id="ga02853b4a224970587b9d7a0e20d857c0" name="ga02853b4a224970587b9d7a0e20d857c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02853b4a224970587b9d7a0e20d857c0">&#9670;&#160;</a></span>hwloc_bitmap_alloc_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> hwloc_bitmap_alloc_full </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new full bitmap. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid bitmap or <code>NULL</code>.</dd></dl>
<p>The bitmap should be freed by a corresponding call to <a class="el" href="a00185.html#ga156130d85b3a0674d6e0e6770fe68fbe" title="Free bitmap bitmap.">hwloc_bitmap_free()</a>. </p>

</div>
</div>
<a id="ga674533016ffed922a28b4f0b49b82cd4" name="ga674533016ffed922a28b4f0b49b82cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga674533016ffed922a28b4f0b49b82cd4">&#9670;&#160;</a></span>hwloc_bitmap_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>And bitmaps <code>bitmap1</code> and <code>bitmap2</code> and store the result in bitmap <code>res</code>. </p>
<p><code>res</code> can be the same as <code>bitmap1</code> or <code>bitmap2</code> </p>

</div>
</div>
<a id="ga7ca5c72db65406b85aca032c8a990f9e" name="ga7ca5c72db65406b85aca032c8a990f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca5c72db65406b85aca032c8a990f9e">&#9670;&#160;</a></span>hwloc_bitmap_andnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_andnot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>And bitmap <code>bitmap1</code> and the negation of <code>bitmap2</code> and store the result in bitmap <code>res</code>. </p>
<p><code>res</code> can be the same as <code>bitmap1</code> or <code>bitmap2</code> </p>

</div>
</div>
<a id="ga0fece972134fdecf2da9bc7a11dd827e" name="ga0fece972134fdecf2da9bc7a11dd827e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fece972134fdecf2da9bc7a11dd827e">&#9670;&#160;</a></span>hwloc_bitmap_asprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_asprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify a bitmap into a newly allocated string in the default hwloc format. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, it contains physical indexes.</b></p>
<p>Print the bits set inside a bitmap as a comma-separated list of hexadecimal 32-bit blocks. A bitmap containing bits 1, 33, 34, and all from 64 to 95 is printed as <code>"0xffffffff,0x00000006,0x00000002"</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that were written (not including the ending <code>\0</code>). </dd>
<dd>
-1 on error, for instance with <code>errno</code> set to <code>ENOMEM</code> on failure to allocate the output string. </dd></dl>

</div>
</div>
<a id="gaf20bb350b6844d08931a064a73f86743" name="gaf20bb350b6844d08931a064a73f86743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf20bb350b6844d08931a064a73f86743">&#9670;&#160;</a></span>hwloc_bitmap_clr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_clr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove index <code>id</code> from bitmap <code>bitmap</code>. </p>

</div>
</div>
<a id="ga833776709df94d727f8c22304b3388cf" name="ga833776709df94d727f8c22304b3388cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga833776709df94d727f8c22304b3388cf">&#9670;&#160;</a></span>hwloc_bitmap_clr_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_clr_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove indexes from <code>begin</code> to <code>end</code> in bitmap <code>bitmap</code>. </p>
<p>If <code>end</code> is <code>-1</code>, the range is infinite. </p>

</div>
</div>
<a id="ga14cdbc0ef0a705e84999bd48a2e649f3" name="ga14cdbc0ef0a705e84999bd48a2e649f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14cdbc0ef0a705e84999bd48a2e649f3">&#9670;&#160;</a></span>hwloc_bitmap_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare bitmaps <code>bitmap1</code> and <code>bitmap2</code> in lexicographic order. </p>
<p>Lexicographic comparison of bitmaps, starting for their highest indexes. Compare last indexes first, then second, etc. The empty bitmap is considered lower than anything.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>bitmap1</code> is considered smaller than <code>bitmap2</code>. </dd>
<dd>
1 if <code>bitmap1</code> is considered larger than <code>bitmap2</code>. </dd>
<dd>
0 if bitmaps are equal (contrary to <a class="el" href="a00185.html#gaa39cda1510ab721b5c012c76ead72365" title="Compare bitmaps bitmap1 and bitmap2 using their lowest index.">hwloc_bitmap_compare_first()</a>).</dd></dl>
<p>For instance comparing binary bitmaps 0011 and 0110 returns -1 (hence 0011 is considered smaller than 0110). Comparing 00101 and 01010 returns -1 too.</p>
<dl class="section note"><dt>Note</dt><dd>This is different from the non-existing hwloc_bitmap_compare_last() which would only compare the highest index of each bitmap. </dd></dl>

</div>
</div>
<a id="gaa39cda1510ab721b5c012c76ead72365" name="gaa39cda1510ab721b5c012c76ead72365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa39cda1510ab721b5c012c76ead72365">&#9670;&#160;</a></span>hwloc_bitmap_compare_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_compare_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare bitmaps <code>bitmap1</code> and <code>bitmap2</code> using their lowest index. </p>
<p>A bitmap is considered smaller if its least significant bit is smaller. The empty bitmap is considered higher than anything (because its least significant bit does not exist).</p>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>bitmap1</code> is considered smaller than <code>bitmap2</code>. </dd>
<dd>
1 if <code>bitmap1</code> is considered larger than <code>bitmap2</code>.</dd></dl>
<p>For instance comparing binary bitmaps 0011 and 0110 returns -1 (hence 0011 is considered smaller than 0110) because least significant bit of 0011 (0001) is smaller than least significant bit of 0110 (0010). Comparing 01001 and 00110 would also return -1 for the same reason.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if bitmaps are considered equal, even if they are not strictly equal. They just need to have the same least significant bit. For instance, comparing binary bitmaps 0010 and 0110 returns 0 because they have the same least significant bit. </dd></dl>

</div>
</div>
<a id="ga72a29824798b48784b8217471ec8f14c" name="ga72a29824798b48784b8217471ec8f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72a29824798b48784b8217471ec8f14c">&#9670;&#160;</a></span>hwloc_bitmap_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of bitmap <code>src</code> into the already allocated bitmap <code>dst</code>. </p>

</div>
</div>
<a id="gae679434c1a5f41d3560a8a7e2c1b0dee" name="gae679434c1a5f41d3560a8a7e2c1b0dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae679434c1a5f41d3560a8a7e2c1b0dee">&#9670;&#160;</a></span>hwloc_bitmap_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a> hwloc_bitmap_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate bitmap <code>bitmap</code> by allocating a new bitmap and copying <code>bitmap</code> contents. </p>
<p>If <code>bitmap</code> is <code>NULL</code>, <code>NULL</code> is returned. </p>

</div>
</div>
<a id="ga07b2de8786b3cdb22f21d9dd42588275" name="ga07b2de8786b3cdb22f21d9dd42588275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b2de8786b3cdb22f21d9dd42588275">&#9670;&#160;</a></span>hwloc_bitmap_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hwloc_bitmap_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill bitmap <code>bitmap</code> with all possible indexes (even if those objects don't exist or are otherwise unavailable) </p>

</div>
</div>
<a id="ga3ec1ced43afadf8c0a7197320bc016ed" name="ga3ec1ced43afadf8c0a7197320bc016ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ec1ced43afadf8c0a7197320bc016ed">&#9670;&#160;</a></span>hwloc_bitmap_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the first index (least significant bit) in bitmap <code>bitmap</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the first index set in <code>bitmap</code>. </dd>
<dd>
-1 if <code>bitmap</code> is empty. </dd></dl>

</div>
</div>
<a id="gae408841487b288e148a478ba0465c99e" name="gae408841487b288e148a478ba0465c99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae408841487b288e148a478ba0465c99e">&#9670;&#160;</a></span>hwloc_bitmap_first_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_first_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the first unset index (least significant bit) in bitmap <code>bitmap</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the first unset index in <code>bitmap</code>. </dd>
<dd>
-1 if <code>bitmap</code> is full. </dd></dl>

</div>
</div>
<a id="ga156130d85b3a0674d6e0e6770fe68fbe" name="ga156130d85b3a0674d6e0e6770fe68fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156130d85b3a0674d6e0e6770fe68fbe">&#9670;&#160;</a></span>hwloc_bitmap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hwloc_bitmap_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free bitmap <code>bitmap</code>. </p>
<p>If <code>bitmap</code> is <code>NULL</code>, no operation is performed. </p>

</div>
</div>
<a id="ga4947c46d47bcfcd3faf3f59569be3e37" name="ga4947c46d47bcfcd3faf3f59569be3e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4947c46d47bcfcd3faf3f59569be3e37">&#9670;&#160;</a></span>hwloc_bitmap_from_ith_ulong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_from_ith_ulong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup bitmap <code>bitmap</code> from unsigned long <code>mask</code> used as <code>i</code> -th subset. </p>

</div>
</div>
<a id="gad59b0ebeb29c1bfabbb2a379e55c1159" name="gad59b0ebeb29c1bfabbb2a379e55c1159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59b0ebeb29c1bfabbb2a379e55c1159">&#9670;&#160;</a></span>hwloc_bitmap_from_ulong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_from_ulong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup bitmap <code>bitmap</code> from unsigned long <code>mask</code>. </p>

</div>
</div>
<a id="gabcfef22f6fc4d4b33f068dd91a1c38f5" name="gabcfef22f6fc4d4b33f068dd91a1c38f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcfef22f6fc4d4b33f068dd91a1c38f5">&#9670;&#160;</a></span>hwloc_bitmap_from_ulongs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_from_ulongs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>masks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup bitmap <code>bitmap</code> from unsigned longs <code>masks</code> used as first <code>nr</code> subsets. </p>

</div>
</div>
<a id="gaefa070f9232857ba5a57297ea9a08ea2" name="gaefa070f9232857ba5a57297ea9a08ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefa070f9232857ba5a57297ea9a08ea2">&#9670;&#160;</a></span>hwloc_bitmap_intersects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether bitmaps <code>bitmap1</code> and <code>bitmap2</code> intersects. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if bitmaps intersect, 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The empty bitmap does not intersect any other bitmap. </dd></dl>

</div>
</div>
<a id="ga32376b1405e57472b73c3aa53bb39663" name="ga32376b1405e57472b73c3aa53bb39663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32376b1405e57472b73c3aa53bb39663">&#9670;&#160;</a></span>hwloc_bitmap_isequal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_isequal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether bitmap <code>bitmap1</code> is equal to bitmap <code>bitmap2</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if bitmaps are equal, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga5fdcb8c19c336511c37076d649e74af4" name="ga5fdcb8c19c336511c37076d649e74af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fdcb8c19c336511c37076d649e74af4">&#9670;&#160;</a></span>hwloc_bitmap_isfull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_isfull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether bitmap <code>bitmap</code> is completely full. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if bitmap is full, 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A full bitmap is always infinitely set. </dd></dl>

</div>
</div>
<a id="ga0526e03db81956fb02acc8260b66d6a4" name="ga0526e03db81956fb02acc8260b66d6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0526e03db81956fb02acc8260b66d6a4">&#9670;&#160;</a></span>hwloc_bitmap_isincluded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_isincluded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>sub_bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>super_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether bitmap <code>sub_bitmap</code> is part of bitmap <code>super_bitmap</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>sub_bitmap</code> is included in <code>super_bitmap</code>, 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The empty bitmap is considered included in any other bitmap. </dd></dl>

</div>
</div>
<a id="ga11340dd487f110bb84f0a6e4ae90bd06" name="ga11340dd487f110bb84f0a6e4ae90bd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11340dd487f110bb84f0a6e4ae90bd06">&#9670;&#160;</a></span>hwloc_bitmap_isset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_isset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether index <code>id</code> is part of bitmap <code>bitmap</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the bit at index <code>id</code> is set in bitmap <code>bitmap</code>, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga5b64be28f5a7176ed8ad0d6a90bdf108" name="ga5b64be28f5a7176ed8ad0d6a90bdf108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b64be28f5a7176ed8ad0d6a90bdf108">&#9670;&#160;</a></span>hwloc_bitmap_iszero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_iszero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether bitmap <code>bitmap</code> is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if bitmap is empty, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga3d9b08b060a59bbab5a4ea6d0a1ed7a6" name="ga3d9b08b060a59bbab5a4ea6d0a1ed7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9b08b060a59bbab5a4ea6d0a1ed7a6">&#9670;&#160;</a></span>hwloc_bitmap_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the last index (most significant bit) in bitmap <code>bitmap</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the last index set in <code>bitmap</code>. </dd>
<dd>
-1 if <code>bitmap</code> is empty, or if <code>bitmap</code> is infinitely set. </dd></dl>

</div>
</div>
<a id="ga45d49aeb45c7da631b1480a93dc3fc92" name="ga45d49aeb45c7da631b1480a93dc3fc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d49aeb45c7da631b1480a93dc3fc92">&#9670;&#160;</a></span>hwloc_bitmap_last_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_last_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the last unset index (most significant bit) in bitmap <code>bitmap</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the last index unset in <code>bitmap</code>. </dd>
<dd>
-1 if <code>bitmap</code> is full, or if <code>bitmap</code> is not infinitely set. </dd></dl>

</div>
</div>
<a id="ga39c0f1b02053de66d205c9f8260b3665" name="ga39c0f1b02053de66d205c9f8260b3665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c0f1b02053de66d205c9f8260b3665">&#9670;&#160;</a></span>hwloc_bitmap_list_asprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_list_asprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify a bitmap into a newly allocated list string. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, it contains physical indexes.</b></p>
<p>Lists are comma-separated indexes or ranges. Ranges are dash separated indexes. A bitmap containing bits 1, 33, 34, and all from 64 to 95 is printed as <code>"1,33-34,64-95"</code>. The last range may not have an ending index if the bitmap is infinitely set.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that were written (not including the ending <code>\0</code>). </dd>
<dd>
-1 on error, for instance with <code>errno</code> set to <code>ENOMEM</code> on failure to allocate the output string. </dd></dl>

</div>
</div>
<a id="ga3d06e6447edeb61e56a9ad83f31f0a37" name="ga3d06e6447edeb61e56a9ad83f31f0a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d06e6447edeb61e56a9ad83f31f0a37">&#9670;&#160;</a></span>hwloc_bitmap_list_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_list_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify a bitmap in the list format. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, it contains physical indexes.</b></p>
<p>Lists are comma-separated indexes or ranges. Ranges are dash separated indexes. A bitmap containing bits 1, 33, 34, and all from 64 to 95 is printed as <code>"1,33-34,64-95"</code>. The last range may not have an ending index if the bitmap is infinitely set.</p>
<p>Up to <code>buflen</code> characters may be written in buffer <code>buf</code>.</p>
<p>If <code>buflen</code> is 0, <code>buf</code> may safely be <code>NULL</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that were actually written if not truncating, or that would have been written (not including the ending <code>\0</code>). </dd>
<dd>
-1 on error. </dd></dl>

</div>
</div>
<a id="gaf9314311d482c621e17c6a53a9fe993e" name="gaf9314311d482c621e17c6a53a9fe993e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9314311d482c621e17c6a53a9fe993e">&#9670;&#160;</a></span>hwloc_bitmap_list_sscanf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_list_sscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a list string and stores it in bitmap <code>bitmap</code>. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, the input string must contain physical indexes.</b></p>
<p>Lists are comma-separated indexes or ranges. Ranges are dash separated indexes. String <code>"1,33-34,64-95"</code> is parsed as a bitmap containing bits 1, 33, 34, and all from 64 to 95. The last range may not have an ending index if the bitmap is infinitely set.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="gaab7240b4b644693b775dad17b44ffd68" name="gaab7240b4b644693b775dad17b44ffd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab7240b4b644693b775dad17b44ffd68">&#9670;&#160;</a></span>hwloc_bitmap_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the next index in bitmap <code>bitmap</code> which is after index <code>prev</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the first index set in <code>bitmap</code> if <code>prev</code> is <code>-1</code>. </dd>
<dd>
the next index set in <code>bitmap</code> if <code>prev</code> is not <code>-1</code>. </dd>
<dd>
-1 if no index with higher index is set in <code>bitmap</code>. </dd></dl>

</div>
</div>
<a id="ga9653af34d1460ef106b7df25af4cdca8" name="ga9653af34d1460ef106b7df25af4cdca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9653af34d1460ef106b7df25af4cdca8">&#9670;&#160;</a></span>hwloc_bitmap_next_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_next_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the next unset index in bitmap <code>bitmap</code> which is after index <code>prev</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the first index unset in <code>bitmap</code> if <code>prev</code> is <code>-1</code>. </dd>
<dd>
the next index unset in <code>bitmap</code> if <code>prev</code> is not <code>-1</code>. </dd>
<dd>
-1 if no index with higher index is unset in <code>bitmap</code>. </dd></dl>

</div>
</div>
<a id="ga84cfdb4f8ab8c1f7e097728e613a2a3f" name="ga84cfdb4f8ab8c1f7e097728e613a2a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84cfdb4f8ab8c1f7e097728e613a2a3f">&#9670;&#160;</a></span>hwloc_bitmap_not()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate bitmap <code>bitmap</code> and store the result in bitmap <code>res</code>. </p>
<p><code>res</code> can be the same as <code>bitmap</code> </p>

</div>
</div>
<a id="gac0744734d761d65c977aece565364908" name="gac0744734d761d65c977aece565364908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0744734d761d65c977aece565364908">&#9670;&#160;</a></span>hwloc_bitmap_nr_ulongs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_nr_ulongs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of unsigned longs required for storing bitmap <code>bitmap</code> entirely. </p>
<p>This is the number of contiguous unsigned longs from the very first bit of the bitmap (even if unset) up to the last set bit. This is useful for knowing the <code>nr</code> parameter to pass to <a class="el" href="a00185.html#gacd215a2348732de25d94a4ecd76d528c" title="Convert the first nr subsets of bitmap bitmap into the array of nr unsigned long masks.">hwloc_bitmap_to_ulongs()</a> (or which calls to <a class="el" href="a00185.html#gac92e6404f648d6b99d2c626b05b2ffa4" title="Convert the i -th subset of bitmap bitmap into unsigned long mask.">hwloc_bitmap_to_ith_ulong()</a> are needed) to entirely convert a bitmap into multiple unsigned longs.</p>
<p>When called on the output of <a class="el" href="a00182.html#ga79212faa07b70dd26588941b17d9fa82" title="Get topology CPU set.">hwloc_topology_get_topology_cpuset()</a>, the returned number is large enough for all cpusets of the topology.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of unsigned longs required. </dd>
<dd>
-1 if <code>bitmap</code> is infinite. </dd></dl>

</div>
</div>
<a id="ga10be0840cdeb7ce26d862819dd303baa" name="ga10be0840cdeb7ce26d862819dd303baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10be0840cdeb7ce26d862819dd303baa">&#9670;&#160;</a></span>hwloc_bitmap_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the bitmap <code>bitmap</code> and add bit <code>id</code>. </p>

</div>
</div>
<a id="ga120b8aefb9ce7ef349929656359b1859" name="ga120b8aefb9ce7ef349929656359b1859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga120b8aefb9ce7ef349929656359b1859">&#9670;&#160;</a></span>hwloc_bitmap_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Or bitmaps <code>bitmap1</code> and <code>bitmap2</code> and store the result in bitmap <code>res</code>. </p>
<p><code>res</code> can be the same as <code>bitmap1</code> or <code>bitmap2</code> </p>

</div>
</div>
<a id="ga062dbff93baeff3b425a7260c5463646" name="ga062dbff93baeff3b425a7260c5463646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062dbff93baeff3b425a7260c5463646">&#9670;&#160;</a></span>hwloc_bitmap_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add index <code>id</code> in bitmap <code>bitmap</code>. </p>

</div>
</div>
<a id="ga3daeed965c35c6d2fd4820a318219985" name="ga3daeed965c35c6d2fd4820a318219985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daeed965c35c6d2fd4820a318219985">&#9670;&#160;</a></span>hwloc_bitmap_set_ith_ulong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_set_ith_ulong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace <code>i</code> -th subset of bitmap <code>bitmap</code> with unsigned long <code>mask</code>. </p>

</div>
</div>
<a id="ga9c9a8433732fb9f24899e7aa4c014d7e" name="ga9c9a8433732fb9f24899e7aa4c014d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9a8433732fb9f24899e7aa4c014d7e">&#9670;&#160;</a></span>hwloc_bitmap_set_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_set_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexes from <code>begin</code> to <code>end</code> in bitmap <code>bitmap</code>. </p>
<p>If <code>end</code> is <code>-1</code>, the range is infinite. </p>

</div>
</div>
<a id="gaa611a77c092e679246afdf9a60d5db8b" name="gaa611a77c092e679246afdf9a60d5db8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa611a77c092e679246afdf9a60d5db8b">&#9670;&#160;</a></span>hwloc_bitmap_singlify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_singlify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep a single index among those set in bitmap <code>bitmap</code>. </p>
<p>May be useful before binding so that the process does not have a chance of migrating between multiple processors in the original mask. Instead of running the task on any PU inside the given CPU set, the operating system scheduler will be forced to run it on a single of these PUs. It avoids a migration overhead and cache-line ping-pongs between PUs.</p>
<dl class="section note"><dt>Note</dt><dd>This function is NOT meant to distribute multiple processes within a single CPU set. It always return the same single bit when called multiple times on the same input set. <a class="el" href="a00181.html#gac14e61485402837e87293079fa0270f2" title="Distribute n items over the topology under roots.">hwloc_distrib()</a> may be used for generating CPU sets to distribute multiple tasks below a single multi-PU object.</dd>
<dd>
This function cannot be applied to an object set directly. It should be applied to a copy (which may be obtained with <a class="el" href="a00185.html#gae679434c1a5f41d3560a8a7e2c1b0dee" title="Duplicate bitmap bitmap by allocating a new bitmap and copying bitmap contents.">hwloc_bitmap_dup()</a>). </dd></dl>

</div>
</div>
<a id="ga9511644657030a021dce9941e3cda583" name="ga9511644657030a021dce9941e3cda583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9511644657030a021dce9941e3cda583">&#9670;&#160;</a></span>hwloc_bitmap_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify a bitmap in the default hwloc format. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, it contains physical indexes.</b></p>
<p>Print the bits set inside a bitmap as a comma-separated list of hexadecimal 32-bit blocks. A bitmap containing bits 1, 33, 34, and all from 64 to 95 is printed as <code>"0xffffffff,0x00000006,0x00000002"</code>.</p>
<p>Up to <code>buflen</code> characters may be written in buffer <code>buf</code>.</p>
<p>If <code>buflen</code> is 0, <code>buf</code> may safely be <code>NULL</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that were actually written if not truncating, or that would have been written (not including the ending <code>\0</code>). </dd>
<dd>
-1 on error. </dd></dl>

</div>
</div>
<a id="ga064a85c643a364b60acbfa0f3663fc18" name="ga064a85c643a364b60acbfa0f3663fc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga064a85c643a364b60acbfa0f3663fc18">&#9670;&#160;</a></span>hwloc_bitmap_sscanf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_sscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a bitmap string as the default hwloc format and stores it in bitmap <code>bitmap</code>. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, the input string must contain physical indexes.</b></p>
<p>The input string should be a comma-separared list of hexadecimal 32-bit blocks. String <code>"0xffffffff,0x6,0x2"</code> is parsed as a bitmap containing all bits between 64 and 95, and bits 33, 34 and 1.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ga391312513f17c985d871f18367c59512" name="ga391312513f17c985d871f18367c59512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391312513f17c985d871f18367c59512">&#9670;&#160;</a></span>hwloc_bitmap_taskset_asprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_taskset_asprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify a bitmap into a newly allocated taskset-specific string. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, it contains physical indexes.</b></p>
<p>The taskset program manipulates bitmap strings that contain a single (possible very long) hexadecimal number starting with 0x. A bitmap containing bits 1, 33, 34, and all from 64 to 95 is printed as <code>"0xffffffff0000000600000002"</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that were written (not including the ending <code>\0</code>). </dd>
<dd>
-1 on error, for instance with <code>errno</code> set to <code>ENOMEM</code> on failure to allocate the output string. </dd></dl>

</div>
</div>
<a id="ga5beb68a987fe48e5c5edef06ab260e14" name="ga5beb68a987fe48e5c5edef06ab260e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5beb68a987fe48e5c5edef06ab260e14">&#9670;&#160;</a></span>hwloc_bitmap_taskset_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_taskset_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify a bitmap in the taskset-specific format. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, it contains physical indexes.</b></p>
<p>The taskset program manipulates bitmap strings that contain a single (possible very long) hexadecimal number starting with 0x. A bitmap containing bits 1, 33, 34, and all from 64 to 95 is printed as <code>"0xffffffff0000000600000002"</code>.</p>
<p>Up to <code>buflen</code> characters may be written in buffer <code>buf</code>.</p>
<p>If <code>buflen</code> is 0, <code>buf</code> may safely be <code>NULL</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that were actually written if not truncating, or that would have been written (not including the ending <code>\0</code>). </dd>
<dd>
-1 on error. </dd></dl>

</div>
</div>
<a id="ga4f23db5041240e03e348752f8bd6ec2d" name="ga4f23db5041240e03e348752f8bd6ec2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f23db5041240e03e348752f8bd6ec2d">&#9670;&#160;</a></span>hwloc_bitmap_taskset_sscanf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_taskset_sscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a taskset-specific bitmap string and stores it in bitmap <code>bitmap</code>. </p>
<p><b>Note that if the bitmap is a CPU or nodeset, the input string must contain physical indexes.</b></p>
<p>The taskset program manipulates bitmap strings that contain a single (possible very long) hexadecimal number starting with 0x. String <code>"0xffffffff0000000600000002"</code> is parsed as a bitmap containing all bits between 64 and 95, and bits 33, 34 and 1.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="gac92e6404f648d6b99d2c626b05b2ffa4" name="gac92e6404f648d6b99d2c626b05b2ffa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac92e6404f648d6b99d2c626b05b2ffa4">&#9670;&#160;</a></span>hwloc_bitmap_to_ith_ulong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long hwloc_bitmap_to_ith_ulong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <code>i</code> -th subset of bitmap <code>bitmap</code> into unsigned long mask. </p>

</div>
</div>
<a id="gab6a6bae22a33ec6adfc169a953c13e6c" name="gab6a6bae22a33ec6adfc169a953c13e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a6bae22a33ec6adfc169a953c13e6c">&#9670;&#160;</a></span>hwloc_bitmap_to_ulong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long hwloc_bitmap_to_ulong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the beginning part of bitmap <code>bitmap</code> into unsigned long <code>mask</code>. </p>

</div>
</div>
<a id="gacd215a2348732de25d94a4ecd76d528c" name="gacd215a2348732de25d94a4ecd76d528c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd215a2348732de25d94a4ecd76d528c">&#9670;&#160;</a></span>hwloc_bitmap_to_ulongs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_to_ulongs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>masks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the first <code>nr</code> subsets of bitmap <code>bitmap</code> into the array of <code>nr</code> unsigned long <code>masks</code>. </p>
<p><code>nr</code> may be determined earlier with <a class="el" href="a00185.html#gac0744734d761d65c977aece565364908" title="Return the number of unsigned longs required for storing bitmap bitmap entirely.">hwloc_bitmap_nr_ulongs()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a id="ga0200466842c0e1f5da75e84dde460b10" name="ga0200466842c0e1f5da75e84dde460b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0200466842c0e1f5da75e84dde460b10">&#9670;&#160;</a></span>hwloc_bitmap_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the "weight" of bitmap <code>bitmap</code> (i.e., number of indexes that are in the bitmap). </p>
<dl class="section return"><dt>Returns</dt><dd>the number of indexes that are in the bitmap. </dd>
<dd>
-1 if <code>bitmap</code> is infinitely set. </dd></dl>

</div>
</div>
<a id="ga205508218e09cb9befd0687f16409f09" name="ga205508218e09cb9befd0687f16409f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205508218e09cb9befd0687f16409f09">&#9670;&#160;</a></span>hwloc_bitmap_xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_bitmap_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00185.html#gae991a108af01d408be2776c5b2c467b2">hwloc_const_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Xor bitmaps <code>bitmap1</code> and <code>bitmap2</code> and store the result in bitmap <code>res</code>. </p>
<p><code>res</code> can be the same as <code>bitmap1</code> or <code>bitmap2</code> </p>

</div>
</div>
<a id="gaa97c5217613c8cae9862287170ea2132" name="gaa97c5217613c8cae9862287170ea2132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa97c5217613c8cae9862287170ea2132">&#9670;&#160;</a></span>hwloc_bitmap_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hwloc_bitmap_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00185.html#gaa3c2bf4c776d603dcebbb61b0c923d84">hwloc_bitmap_t</a>&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the bitmap <code>bitmap</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
