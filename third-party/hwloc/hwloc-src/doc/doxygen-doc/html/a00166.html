<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Topology Detection Configuration and Query</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hardware Locality (hwloc)
   &#160;<span id="projectnumber">1.11.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Topology Detection Configuration and Query</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">hwloc_topology_discovery_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">hwloc_topology_cpubind_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">hwloc_topology_membind_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html">hwloc_topology_support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada025d3ec20b4b420f8038d23d6e7bde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#gada025d3ec20b4b420f8038d23d6e7bde">hwloc_topology_flags_e</a> { <br />
&#160;&#160;<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea129b4fea1300be22bbaf0bb0958994c8">HWLOC_TOPOLOGY_FLAG_WHOLE_SYSTEM</a>, 
<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a>, 
<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea46ae25e8896278840b1800ae9ce4de41">HWLOC_TOPOLOGY_FLAG_IO_DEVICES</a>, 
<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea426b18c349f15d7046bb391d96fa947c">HWLOC_TOPOLOGY_FLAG_IO_BRIDGES</a>, 
<br />
&#160;&#160;<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea4a41dc181649ef81c2dcd44a54e271b9">HWLOC_TOPOLOGY_FLAG_WHOLE_IO</a>, 
<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdeaae509a0bed4a7067e0116c75c661178d">HWLOC_TOPOLOGY_FLAG_ICACHES</a>, 
<a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea1b66bbd66e900e5c837f71defb32ad89">HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES</a>
<br />
 }</td></tr>
<tr class="separator:gada025d3ec20b4b420f8038d23d6e7bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafcf30842e8cb47b4c3dcaebecea31e17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#gafcf30842e8cb47b4c3dcaebecea31e17">hwloc_topology_ignore_type</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00163.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type)</td></tr>
<tr class="separator:gafcf30842e8cb47b4c3dcaebecea31e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f987bca941d6949faf7b1554dd7bc12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga1f987bca941d6949faf7b1554dd7bc12">hwloc_topology_ignore_type_keep_structure</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00163.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type)</td></tr>
<tr class="separator:ga1f987bca941d6949faf7b1554dd7bc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9cf147442d65d755c664ccde3bb3ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga7c9cf147442d65d755c664ccde3bb3ef">hwloc_topology_ignore_all_keep_structure</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology)</td></tr>
<tr class="separator:ga7c9cf147442d65d755c664ccde3bb3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeed4df656979e5f16befea9d29b814b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#gaaeed4df656979e5f16befea9d29b814b">hwloc_topology_set_flags</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, unsigned long flags)</td></tr>
<tr class="separator:gaaeed4df656979e5f16befea9d29b814b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09318f81c1d4713be907d64748a6f93c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga09318f81c1d4713be907d64748a6f93c">hwloc_topology_get_flags</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology)</td></tr>
<tr class="separator:ga09318f81c1d4713be907d64748a6f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341fc17b5867a4715570baab131f68cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga341fc17b5867a4715570baab131f68cd">hwloc_topology_set_pid</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology, hwloc_pid_t pid)</td></tr>
<tr class="separator:ga341fc17b5867a4715570baab131f68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0ea95d5f2ad78408bc267a0441c7c97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#gac0ea95d5f2ad78408bc267a0441c7c97">hwloc_topology_set_fsroot</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology, const char *restrict fsroot_path)</td></tr>
<tr class="separator:gac0ea95d5f2ad78408bc267a0441c7c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fab186bb6181a00bcf585825fddd38d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga4fab186bb6181a00bcf585825fddd38d">hwloc_topology_set_synthetic</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology, const char *restrict description)</td></tr>
<tr class="separator:ga4fab186bb6181a00bcf585825fddd38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879439b7ee99407ee911b3ac64e9a25e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga879439b7ee99407ee911b3ac64e9a25e">hwloc_topology_set_xml</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology, const char *restrict xmlpath)</td></tr>
<tr class="separator:ga879439b7ee99407ee911b3ac64e9a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2745616b65595e1c1e579ecc7e461fa8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga2745616b65595e1c1e579ecc7e461fa8">hwloc_topology_set_xmlbuffer</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology, const char *restrict buffer, int size)</td></tr>
<tr class="separator:ga2745616b65595e1c1e579ecc7e461fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f15795219e2c3ca6d44ba0db604c4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#gad1f15795219e2c3ca6d44ba0db604c4f">hwloc_topology_set_custom</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology)</td></tr>
<tr class="separator:gad1f15795219e2c3ca6d44ba0db604c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ed5733946b2e9aba90d2e2c1fbfbd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga90ed5733946b2e9aba90d2e2c1fbfbd7">hwloc_topology_set_distance_matrix</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology, <a class="el" href="a00163.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a> type, unsigned nbobjs, unsigned *os_index, float *distances)</td></tr>
<tr class="separator:ga90ed5733946b2e9aba90d2e2c1fbfbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ffdcfd9175cdf40709801092f18017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga68ffdcfd9175cdf40709801092f18017">hwloc_topology_is_thissystem</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology)</td></tr>
<tr class="separator:ga68ffdcfd9175cdf40709801092f18017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c76173c4a8ce1a9a9366012b1388e6"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00276.html">hwloc_topology_support</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#gab8c76173c4a8ce1a9a9366012b1388e6">hwloc_topology_get_support</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict topology)</td></tr>
<tr class="separator:gab8c76173c4a8ce1a9a9366012b1388e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc7b7b155cba58dda203e54f1637b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga2cc7b7b155cba58dda203e54f1637b9c">hwloc_topology_set_userdata</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const void *userdata)</td></tr>
<tr class="separator:ga2cc7b7b155cba58dda203e54f1637b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f992f8d6c4905b2d3c4f43e509c2a3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html#ga91f992f8d6c4905b2d3c4f43e509c2a3">hwloc_topology_get_userdata</a> (<a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology)</td></tr>
<tr class="separator:ga91f992f8d6c4905b2d3c4f43e509c2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Several functions can optionally be called between <a class="el" href="a00165.html#ga03fd4a16d8b9ee1ffc32b25fd2f6bdfa" title="Allocate a topology context. ">hwloc_topology_init()</a> and <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> to configure how the detection should be performed, e.g. to ignore some objects types, define a synthetic topology, etc.</p>
<p>If none of them is called, the default is to detect all the objects of the machine that the caller is allowed to access.</p>
<p>This default behavior may also be modified through environment variables if the application did not modify it already. Setting HWLOC_XMLFILE in the environment enforces the discovery from a XML file as if <a class="el" href="a00166.html#ga879439b7ee99407ee911b3ac64e9a25e" title="Enable XML-file based topology. ">hwloc_topology_set_xml()</a> had been called. HWLOC_FSROOT switches to reading the topology from the specified Linux filesystem root as if <a class="el" href="a00166.html#gac0ea95d5f2ad78408bc267a0441c7c97" title="Change the file-system root path when building the topology from sysfs/procfs. ">hwloc_topology_set_fsroot()</a> had been called. Finally, HWLOC_THISSYSTEM enforces the return value of <a class="el" href="a00166.html#ga68ffdcfd9175cdf40709801092f18017" title="Does the topology context come from this system? ">hwloc_topology_is_thissystem()</a>. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gada025d3ec20b4b420f8038d23d6e7bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada025d3ec20b4b420f8038d23d6e7bde">&#9670;&nbsp;</a></span>hwloc_topology_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00166.html#gada025d3ec20b4b420f8038d23d6e7bde">hwloc_topology_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be set onto a topology context before load. </p>
<p>Flags should be given to <a class="el" href="a00166.html#gaaeed4df656979e5f16befea9d29b814b" title="Set OR&#39;ed flags to non-yet-loaded topology. ">hwloc_topology_set_flags()</a>. They may also be returned by <a class="el" href="a00166.html#ga09318f81c1d4713be907d64748a6f93c" title="Get OR&#39;ed flags of a topology. ">hwloc_topology_get_flags()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea129b4fea1300be22bbaf0bb0958994c8"></a>HWLOC_TOPOLOGY_FLAG_WHOLE_SYSTEM&#160;</td><td class="fielddoc"><p>Detect the whole system, ignore reservations and offline settings. </p>
<p>Gather all resources, even if some were disabled by the administrator. For instance, ignore Linux Cgroup/Cpusets and gather all processors and memory nodes, and ignore the fact that some resources may be offline.</p>
<p>When this flag is not set, PUs that are disallowed are not added to the topology. Parent objects (package, core, cache, etc.) are added only if some of their children are allowed. NUMA nodes are always added but their available memory is set to 0 when disallowed.</p>
<p>If the current topology is exported to XML and reimported later, this flag should be set again in the reimported topology so that disallowed resources are reimported as well. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b"></a>HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM&#160;</td><td class="fielddoc"><p>Assume that the selected backend provides the topology for the system on which we are running. </p>
<p>This forces <a class="el" href="a00166.html#ga68ffdcfd9175cdf40709801092f18017" title="Does the topology context come from this system? ">hwloc_topology_is_thissystem()</a> to return 1, i.e. makes hwloc assume that the selected backend provides the topology for the system on which we are running, even if it is not the OS-specific backend but the XML backend for instance. This means making the binding functions actually call the OS-specific system calls and really do binding, while the XML backend would otherwise provide empty hooks just returning success.</p>
<p>Setting the environment variable HWLOC_THISSYSTEM may also result in the same behavior.</p>
<p>This can be used for efficiency reasons to first detect the topology once, save it to an XML file, and quickly reload it later through the XML backend, but still having binding functions actually do bind. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea46ae25e8896278840b1800ae9ce4de41"></a>HWLOC_TOPOLOGY_FLAG_IO_DEVICES&#160;</td><td class="fielddoc"><p>Detect PCI devices. </p>
<p>By default, I/O devices are ignored. This flag enables I/O device detection using the pci backend. Only the common PCI devices (GPUs, NICs, block devices, ...) and host bridges (objects that connect the host objects to an I/O subsystem) will be added to the topology. Additionally it also enables MemoryModule misc objects. Uncommon devices and other bridges (such as PCI-to-PCI bridges) will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea426b18c349f15d7046bb391d96fa947c"></a>HWLOC_TOPOLOGY_FLAG_IO_BRIDGES&#160;</td><td class="fielddoc"><p>Detect PCI bridges. </p>
<p>This flag should be combined with <a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea46ae25e8896278840b1800ae9ce4de41" title="Detect PCI devices. ">HWLOC_TOPOLOGY_FLAG_IO_DEVICES</a> to enable the detection of both common devices and of all useful bridges (bridges that have at least one device behind them). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea4a41dc181649ef81c2dcd44a54e271b9"></a>HWLOC_TOPOLOGY_FLAG_WHOLE_IO&#160;</td><td class="fielddoc"><p>Detect the whole PCI hierarchy. </p>
<p>This flag enables detection of all I/O devices (even the uncommon ones such as DMA channels) and bridges (even those that have no device behind them) using the pci backend. This implies <a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea46ae25e8896278840b1800ae9ce4de41" title="Detect PCI devices. ">HWLOC_TOPOLOGY_FLAG_IO_DEVICES</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdeaae509a0bed4a7067e0116c75c661178d"></a>HWLOC_TOPOLOGY_FLAG_ICACHES&#160;</td><td class="fielddoc"><p>Detect instruction caches. </p>
<p>This flag enables detection of Instruction caches, instead of only Data and Unified caches. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada025d3ec20b4b420f8038d23d6e7bdea1b66bbd66e900e5c837f71defb32ad89"></a>HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES&#160;</td><td class="fielddoc"><p>Get the set of allowed resources from the local operating system even if the topology was loaded from XML or synthetic description. </p>
<p>If the topology was loaded from XML or from a synthetic string, restrict it by applying the current process restrictions such as Linux Cgroup/Cpuset.</p>
<p>This is useful when the topology is not loaded directly from the local machine (e.g. for performance reason) and it comes with all resources, while the running process is restricted to only parts of the machine.</p>
<p>This flag is ignored unless <a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running...">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> is also set since the loaded topology must match the underlying machine where restrictions will be gathered from.</p>
<p>Setting the environment variable HWLOC_THISSYSTEM_ALLOWED_RESOURCES would result in the same behavior. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga09318f81c1d4713be907d64748a6f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09318f81c1d4713be907d64748a6f93c">&#9670;&nbsp;</a></span>hwloc_topology_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long hwloc_topology_get_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OR'ed flags of a topology. </p>
<p>Get the OR'ed set of <a class="el" href="a00166.html#gada025d3ec20b4b420f8038d23d6e7bde" title="Flags to be set onto a topology context before load. ">hwloc_topology_flags_e</a> of a topology.</p>
<dl class="section return"><dt>Returns</dt><dd>the flags previously set with <a class="el" href="a00166.html#gaaeed4df656979e5f16befea9d29b814b" title="Set OR&#39;ed flags to non-yet-loaded topology. ">hwloc_topology_set_flags()</a>. </dd></dl>

</div>
</div>
<a id="gab8c76173c4a8ce1a9a9366012b1388e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8c76173c4a8ce1a9a9366012b1388e6">&#9670;&nbsp;</a></span>hwloc_topology_get_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="a00276.html">hwloc_topology_support</a>* hwloc_topology_get_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the topology support. </p>
<p>Each flag indicates whether a feature is supported. If set to 0, the feature is not supported. If set to 1, the feature is supported, but the corresponding call may still fail in some corner cases.</p>
<p>These features are also listed by hwloc-info --support </p>

</div>
</div>
<a id="ga91f992f8d6c4905b2d3c4f43e509c2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f992f8d6c4905b2d3c4f43e509c2a3">&#9670;&nbsp;</a></span>hwloc_topology_get_userdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hwloc_topology_get_userdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the topology-specific userdata pointer. </p>
<p>Retrieve the application-given private data pointer that was previously set with <a class="el" href="a00166.html#ga2cc7b7b155cba58dda203e54f1637b9c" title="Set the topology-specific userdata pointer. ">hwloc_topology_set_userdata()</a>. </p>

</div>
</div>
<a id="ga7c9cf147442d65d755c664ccde3bb3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c9cf147442d65d755c664ccde3bb3ef">&#9670;&nbsp;</a></span>hwloc_topology_ignore_all_keep_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_ignore_all_keep_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore all objects that do not bring any structure. </p>
<p>Ignore all objects that do not bring any structure: This is equivalent to calling <a class="el" href="a00166.html#ga1f987bca941d6949faf7b1554dd7bc12" title="Ignore an object type if it does not bring any structure. ">hwloc_topology_ignore_type_keep_structure()</a> for all object types. </p>

</div>
</div>
<a id="gafcf30842e8cb47b4c3dcaebecea31e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf30842e8cb47b4c3dcaebecea31e17">&#9670;&nbsp;</a></span>hwloc_topology_ignore_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_ignore_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00163.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore an object type. </p>
<p>Ignore all objects from the given type. The bottom-level type <a class="el" href="a00163.html#ggacd37bb612667dc437d66bfb175a8dc55abca6887e80cb291353b0a0c1da83f661" title="Processing Unit, or (Logical) Processor. An execution unit (may share a core with some other logical ...">HWLOC_OBJ_PU</a> may not be ignored. The top-level object of the hierarchy will never be ignored, even if this function succeeds. Group objects are always ignored if they do not bring any structure since they are designed to add structure to the topology. I/O objects may not be ignored, topology flags should be used to configure their discovery instead. </p>

</div>
</div>
<a id="ga1f987bca941d6949faf7b1554dd7bc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f987bca941d6949faf7b1554dd7bc12">&#9670;&nbsp;</a></span>hwloc_topology_ignore_type_keep_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_ignore_type_keep_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00163.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore an object type if it does not bring any structure. </p>
<p>Ignore all objects from the given type as long as they do not bring any structure: Each ignored object should have a single children or be the only child of its parent. The bottom-level type <a class="el" href="a00163.html#ggacd37bb612667dc437d66bfb175a8dc55abca6887e80cb291353b0a0c1da83f661" title="Processing Unit, or (Logical) Processor. An execution unit (may share a core with some other logical ...">HWLOC_OBJ_PU</a> may not be ignored. I/O objects may not be ignored, topology flags should be used to configure their discovery instead. </p>

</div>
</div>
<a id="ga68ffdcfd9175cdf40709801092f18017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ffdcfd9175cdf40709801092f18017">&#9670;&nbsp;</a></span>hwloc_topology_is_thissystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_is_thissystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the topology context come from this system? </p>
<dl class="section return"><dt>Returns</dt><dd>1 if this topology context was built using the system running this program. </dd>
<dd>
0 instead (for instance if using another file-system root, a XML topology file, or a synthetic topology). </dd></dl>

</div>
</div>
<a id="gad1f15795219e2c3ca6d44ba0db604c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f15795219e2c3ca6d44ba0db604c4f">&#9670;&nbsp;</a></span>hwloc_topology_set_custom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_custom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the topology for custom assembly. </p>
<p>The topology then contains a single root object. It must then be built by inserting other topologies with <a class="el" href="a00173.html#ga58220f648a972140865d11940bccec81" title="Insert an existing topology inside a custom topology. ">hwloc_custom_insert_topology()</a> or single objects with <a class="el" href="a00173.html#ga60c404d4f0544e1070f549af8be6bd73" title="Insert a new group object inside a custom topology. ">hwloc_custom_insert_group_object_by_parent()</a>. <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> must be called to finalize the new topology as usual.</p>
<dl class="section note"><dt>Note</dt><dd>If nothing is inserted in the topology, <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> will fail with errno set to EINVAL.</dd>
<dd>
The cpuset and nodeset of the root object are NULL because these sets are meaningless when assembling multiple topologies.</dd>
<dd>
On success, the custom component replaces the previously enabled component (if any), but the topology is not actually modified until <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
<a id="ga90ed5733946b2e9aba90d2e2c1fbfbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ed5733946b2e9aba90d2e2c1fbfbd7">&#9670;&nbsp;</a></span>hwloc_topology_set_distance_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_distance_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00163.html#gacd37bb612667dc437d66bfb175a8dc55">hwloc_obj_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbobjs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>os_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a distance matrix. </p>
<p>Provide the matrix of distances between a set of objects of the given type. <code>nbobjs</code> must be at least 2. The set may or may not contain all the existing objects of this type. The objects are specified by their OS/physical index in the <code>os_index</code> array. The <code>distances</code> matrix follows the same order. The distance from object i to object j in the i*nbobjs+j.</p>
<p>A single latency matrix may be defined for each type. If another distance matrix already exists for the given type, either because the user specified it or because the OS offers it, it will be replaced by the given one. If <code>nbobjs</code> is <code>0</code>, <code>os_index</code> is <code>NULL</code> and <code>distances</code> is <code>NULL</code>, the existing distance matrix for the given type is removed.</p>
<dl class="section note"><dt>Note</dt><dd>Distance matrices are ignored in multi-node topologies. </dd></dl>

</div>
</div>
<a id="gaaeed4df656979e5f16befea9d29b814b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeed4df656979e5f16befea9d29b814b">&#9670;&nbsp;</a></span>hwloc_topology_set_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OR'ed flags to non-yet-loaded topology. </p>
<p>Set a OR'ed set of <a class="el" href="a00166.html#gada025d3ec20b4b420f8038d23d6e7bde" title="Flags to be set onto a topology context before load. ">hwloc_topology_flags_e</a> onto a topology that was not yet loaded.</p>
<p>If this function is called multiple times, the last invokation will erase and replace the set of flags that was previously set.</p>
<p>The flags set in a topology may be retrieved with <a class="el" href="a00166.html#ga09318f81c1d4713be907d64748a6f93c" title="Get OR&#39;ed flags of a topology. ">hwloc_topology_get_flags()</a> </p>

</div>
</div>
<a id="gac0ea95d5f2ad78408bc267a0441c7c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0ea95d5f2ad78408bc267a0441c7c97">&#9670;&nbsp;</a></span>hwloc_topology_set_fsroot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_fsroot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fsroot_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the file-system root path when building the topology from sysfs/procfs. </p>
<p>On Linux system, use sysfs and procfs files as if they were mounted on the given <code>fsroot_path</code> instead of the main file-system root. Setting the environment variable HWLOC_FSROOT may also result in this behavior. Not using the main file-system root causes <a class="el" href="a00166.html#ga68ffdcfd9175cdf40709801092f18017" title="Does the topology context come from this system? ">hwloc_topology_is_thissystem()</a> to return 0.</p>
<p>Note that this function does not actually load topology information; it just tells hwloc where to load it from. You'll still need to invoke <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> to actually load the topology information.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 with errno set to ENOSYS on non-Linux and on Linux systems that do not support it. </dd>
<dd>
-1 with the appropriate errno if <code>fsroot_path</code> cannot be used.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For convenience, this backend provides empty binding hooks which just return success. To have hwloc still actually call OS-specific hooks, the <a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running...">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> has to be set to assert that the loaded file is really the underlying system.</dd>
<dd>
On success, the Linux component replaces the previously enabled component (if any), but the topology is not actually modified until <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
<a id="ga341fc17b5867a4715570baab131f68cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga341fc17b5867a4715570baab131f68cd">&#9670;&nbsp;</a></span>hwloc_topology_set_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_pid_t&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change which process the topology is viewed from. </p>
<p>On some systems, processes may have different views of the machine, for instance the set of allowed CPUs. By default, hwloc exposes the view from the current process. Calling <a class="el" href="a00166.html#ga341fc17b5867a4715570baab131f68cd" title="Change which process the topology is viewed from. ">hwloc_topology_set_pid()</a> permits to make it expose the topology of the machine from the point of view of another process.</p>
<dl class="section note"><dt>Note</dt><dd><code>hwloc_pid_t</code> is <code>pid_t</code> on Unix platforms, and <code>HANDLE</code> on native Windows platforms.</dd>
<dd>
-1 is returned and errno is set to ENOSYS on platforms that do not support this feature. </dd></dl>

</div>
</div>
<a id="ga4fab186bb6181a00bcf585825fddd38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fab186bb6181a00bcf585825fddd38d">&#9670;&nbsp;</a></span>hwloc_topology_set_synthetic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_synthetic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable synthetic topology. </p>
<p>Gather topology information from the given <code>description</code>, a space-separated string of numbers describing the arity of each level. Each number may be prefixed with a type and a colon to enforce the type of a level. If only some level types are enforced, hwloc will try to choose the other types according to usual topologies, but it may fail and you may have to specify more level types manually. See also the <a class="el" href="a00330.html">Synthetic topologies</a>.</p>
<p>If <code>description</code> was properly parsed and describes a valid topology configuration, this function returns 0. Otherwise -1 is returned and errno is set to EINVAL.</p>
<p>Note that this function does not actually load topology information; it just tells hwloc where to load it from. You'll still need to invoke <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> to actually load the topology information.</p>
<dl class="section note"><dt>Note</dt><dd>For convenience, this backend provides empty binding hooks which just return success.</dd>
<dd>
On success, the synthetic component replaces the previously enabled component (if any), but the topology is not actually modified until <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
<a id="ga2cc7b7b155cba58dda203e54f1637b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc7b7b155cba58dda203e54f1637b9c">&#9670;&nbsp;</a></span>hwloc_topology_set_userdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hwloc_topology_set_userdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the topology-specific userdata pointer. </p>
<p>Each topology may store one application-given private data pointer. It is initialized to <code>NULL</code>. hwloc will never modify it.</p>
<p>Use it as you wish, after <a class="el" href="a00165.html#ga03fd4a16d8b9ee1ffc32b25fd2f6bdfa" title="Allocate a topology context. ">hwloc_topology_init()</a> and until hwloc_topolog_destroy().</p>
<p>This pointer is not exported to XML. </p>

</div>
</div>
<a id="ga879439b7ee99407ee911b3ac64e9a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879439b7ee99407ee911b3ac64e9a25e">&#9670;&nbsp;</a></span>hwloc_topology_set_xml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_xml </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>xmlpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable XML-file based topology. </p>
<p>Gather topology information from the XML file given at <code>xmlpath</code>. Setting the environment variable HWLOC_XMLFILE may also result in this behavior. This file may have been generated earlier with <a class="el" href="a00174.html#ga2bf166eda4d3605362ac86f77684002a" title="Export the topology into an XML file. ">hwloc_topology_export_xml()</a> or lstopo file.xml.</p>
<p>Note that this function does not actually load topology information; it just tells hwloc where to load it from. You'll still need to invoke <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> to actually load the topology information.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 with errno set to EINVAL on failure to read the XML file.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See also <a class="el" href="a00174.html#ga5ac6917ea7289955fb1ffda4353af9b0" title="Set the application-specific callback for importing userdata. ">hwloc_topology_set_userdata_import_callback()</a> for importing application-specific object userdata.</dd>
<dd>
For convenience, this backend provides empty binding hooks which just return success. To have hwloc still actually call OS-specific hooks, the <a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running...">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> has to be set to assert that the loaded file is really the underlying system.</dd>
<dd>
On success, the XML component replaces the previously enabled component (if any), but the topology is not actually modified until <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
<a id="ga2745616b65595e1c1e579ecc7e461fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2745616b65595e1c1e579ecc7e461fa8">&#9670;&nbsp;</a></span>hwloc_topology_set_xmlbuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_set_xmlbuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> restrict&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable XML based topology using a memory buffer (instead of a file, as with <a class="el" href="a00166.html#ga879439b7ee99407ee911b3ac64e9a25e" title="Enable XML-file based topology. ">hwloc_topology_set_xml()</a>). </p>
<p>Gather topology information from the XML memory buffer given at <code>buffer</code> and of length <code>size</code>. This buffer may have been filled earlier with <a class="el" href="a00174.html#ga7cbf8a2d8579d192911007650366fc8a" title="Export the topology into a newly-allocated XML memory buffer. ">hwloc_topology_export_xmlbuffer()</a>.</p>
<p>Note that this function does not actually load topology information; it just tells hwloc where to load it from. You'll still need to invoke <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a> to actually load the topology information.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 with errno set to EINVAL on failure to read the XML buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See also <a class="el" href="a00174.html#ga5ac6917ea7289955fb1ffda4353af9b0" title="Set the application-specific callback for importing userdata. ">hwloc_topology_set_userdata_import_callback()</a> for importing application-specific object userdata.</dd>
<dd>
For convenience, this backend provides empty binding hooks which just return success. To have hwloc still actually call OS-specific hooks, the <a class="el" href="a00166.html#ggada025d3ec20b4b420f8038d23d6e7bdea6ecb6abc6a0bb75e81564f8bca85783b" title="Assume that the selected backend provides the topology for the system on which we are running...">HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM</a> has to be set to assert that the loaded file is really the underlying system.</dd>
<dd>
On success, the XML component replaces the previously enabled component (if any), but the topology is not actually modified until <a class="el" href="a00165.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology. ">hwloc_topology_load()</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
