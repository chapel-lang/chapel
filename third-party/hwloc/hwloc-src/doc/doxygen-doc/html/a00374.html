<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Topology Attributes: Distances, Memory Attributes and CPU Kinds</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hardware Locality (hwloc)<span id="projectnumber">&#160;2.12.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Topology Attributes: Distances, Memory Attributes and CPU Kinds</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Besides the hierarchy of objects and individual object attributes (see <a class="el" href="a00373.html">Object attributes</a>), hwloc may also expose finer information about the hardware organization.</p>
<h1><a class="anchor" id="topoattrs_distances"></a>
Distances</h1>
<p>A machine with 4 CPUs may have identical links between every pairs of CPUs, or those CPUs could also only be connected through a ring. In the ring case, accessing the memory of nearby CPUs is slower than local memory, but it is also faster than accessing the memory of CPU on the opposite side of the ring. These deep details cannot be exposed in the hwloc hierarchy, that is why hwloc also exposes distances.</p>
<p>Distances are matrices of values between sets of objects, usually latencies or bandwidths. By default, hwloc tries to get a matrix of relative latencies between NUMA nodes when exposed by the hardware.</p>
<p>In the aforementioned ring case, the matrix could report 10 for latency between a NUMA node and itself, 20 for nearby nodes, and 30 for nodes that are opposites on the ring. Those are theoretical values exposed by hardware vendors (in the System Locality Distance Information Table (SLIT) in the ACPI) rather than physical latencies. They are mostly meant for comparing node relative distances.</p>
<p>Distances structures currently created by hwloc are: </p><dl>
<dt>NUMALatency (Linux, Solaris, FreeBSD) </dt>
<dd>This is the matrix of theoretical latencies described above.  </dd>
<dt>XGMIBandwidth (RSMI) </dt>
<dd><p class="startdd">This is the matrix of unidirectional XGMI bandwidths between AMD GPUs (in MB/s). It contains 0 when there is no direct XGMI link between objects. Values on the diagonal are artificially set to very high so that local access always appears faster than remote access.</p>
<p class="interdd">GPUs are identified by RSMI OS devices such as "rsmi0". They may be converted into the corresponding OpenCL or PCI devices using <a class="el" href="a00180.html#gab5df3ad1e8565ea0c2cf06412f6f6233" title="Return an object of a different type with same locality.">hwloc_get_obj_with_same_locality()</a> or the hwloc-annotate tool.</p>
<p class="enddd"><a class="el" href="a00188.html#gabcadd041f3072999d68f2d94e38670f7" title="Apply a transformation to a distances structure.">hwloc_distances_transform()</a> or hwloc-annotate may also be used to transform this matrix into something more convenient, for instance by replacing bandwidths with numbers of links between peers.  </p>
</dd>
<dt>XGMIHops (RSMI) </dt>
<dd>This matrix lists the number of XGMI hops between AMD GPUs. It reports 1 when there is a direct link between two distinct GPUs. If there is no XGMI route between them, the value is 0. The number of hops between a GPU and itself (on the diagonal) is 0 as well.  </dd>
<dt>XeLinkBandwidth (LevelZero) </dt>
<dd><p class="startdd">This is the matrix of unidirectional XeLink bandwidths between Intel GPUs (in MB/s). It contains 0 when there is no direct XeLink between objects. When there are multiple links, their bandwidth is aggregated.</p>
<p class="interdd">Values on the diagonal are artificially set to very high so that local access always appears faster than remote access. This includes bandwidths between a (sub)device and itself, between a subdevice and its parent device, or between two subdevices of the same parent.</p>
<p class="interdd">The matrix interconnects all LevelZero devices and subdevices (if any), even if some of them may have no link at all.</p>
<p class="enddd">The bandwidths of links between subdevices are accumulated in the bandwidth between their parents.  </p>
</dd>
<dt>NVLinkBandwidth (NVML) </dt>
<dd><p class="startdd">This is the matrix of unidirectional NVLink bandwidths between NVIDIA GPUs (in MB/s). It contains 0 when there is no direct NVLink between objects. When there are multiple links, their bandwidth is aggregated. Values on the diagonal are artificially set to very high so that local access always appears faster than remote access.</p>
<p class="interdd">On POWER platforms, NVLinks may also connects GPUs to CPUs. On NVIDIA platforms such as DGX-2, a NVSwitch may interconnect GPUs through NVLinks. In these cases, the distances structure is heterogeneous. GPUs always appear first in the matrix (as NVML OS devices such as "nvml0"), and non-GPU objects may appear at the end (Package for POWER processors, PCI device for NVSwitch).</p>
<p class="interdd">NVML OS devices may be converted into the corresponding CUDA, OpenCL or PCI devices using <a class="el" href="a00180.html#gab5df3ad1e8565ea0c2cf06412f6f6233" title="Return an object of a different type with same locality.">hwloc_get_obj_with_same_locality()</a> or the hwloc-annotate tool.</p>
<p class="interdd"><a class="el" href="a00188.html#gabcadd041f3072999d68f2d94e38670f7" title="Apply a transformation to a distances structure.">hwloc_distances_transform()</a> or hwloc-annotate may also be used to transform this matrix into something more convenient, for instance by removing switches or CPU ports, or by replacing bandwidths with numbers of links between peers.</p>
<p class="enddd">When a NVSwitch interconnects GPUs, only links between one GPU and different NVSwitch ports are reported. They may be merged into a single switch port with <a class="el" href="a00188.html#gabcadd041f3072999d68f2d94e38670f7" title="Apply a transformation to a distances structure.">hwloc_distances_transform()</a> or hwloc-annotate. Or a transitive closure may also be applied to report the bandwidth between GPUs across the NVSwitch. </p>
</dd>
</dl>
<p>Users may also specify their own matrices between any set of objects, even if these objects are of different types (e.g. bandwidths between GPUs and CPUs).</p>
<p>The entire API is located in <a class="el" href="a00107_source.html">hwloc/distances.h</a>. See also <a class="el" href="a00188.html">Retrieve distances between objects</a>, as well as <a class="el" href="a00189.html">Helpers for consulting distance matrices</a> and <a class="el" href="a00190.html">Add distances between objects</a>.</p>
<h1><a class="anchor" id="topoattrs_memattrs"></a>
Memory Attributes</h1>
<p>Machines with heterogeneous memory, for instance high-bandwidth memory (HBM), normal memory (DDR), and/or high-capacity slow memory (such as non-volatile memory DIMMs, NVDIMMs) require applications to allocate buffers in the appropriate target memory depending on performance and capacity needs. Those target nodes may be exposed in the hwloc hierarchy as different memory children but there is a need for performance information to select the appropriate one.</p>
<p>hwloc memory attributes are designed to expose memory information such as latency, bandwidth, etc. Users may also specify their own attributes and values.</p>
<p>The memory attributes API is located in <a class="el" href="a00110_source.html">hwloc/memattrs.h</a>, see <a class="el" href="a00192.html">Comparing memory node attributes for finding where to allocate on</a> and <a class="el" href="a00193.html">Managing memory attributes</a> for details. See also an example in doc/examples/memory-attributes.c in the source tree.</p>
<p>Memory attributes are the low-level solution to selecting target memory. hwloc uses them internally to build Memory Tiers which provide an easy way to distinguish NUMA nodes of different kinds, as explained in <a class="el" href="a00375.html">Heterogeneous Memory</a>.</p>
<h1><a class="anchor" id="topoattrs_cpukinds"></a>
CPU Kinds</h1>
<p>Hybrid CPUs may contain different kinds of cores. The CPU kinds API in <a class="el" href="a00113_source.html">hwloc/cpukinds.h</a> provides a way to list the sets of PUs in each kind and get some optional information about their hardware characteristics and efficiency.</p>
<p>If the operating system provides efficiency information (e.g. Windows 10, MacOS X / Darwin and some Linux kernels), it is used to rank hwloc CPU kinds by efficiency. Otherwise, hwloc implements several heuristics based on frequencies and core types (see HWLOC_CPUKINDS_RANKING in <a class="el" href="a00369.html">Environment Variables</a>).</p>
<p>The ranking shows energy-efficient CPUs first, and high-performance power-hungry cores last.</p>
<p>These CPU kinds may be annotated with the following native attributes: </p><dl>
<dt>FrequencyMaxMHz (Linux) </dt>
<dd>The maximal operating frequency of the core, as reported by <code>cpufreq</code> drivers on Linux.  </dd>
<dt>FrequencyBaseMHz (Linux) </dt>
<dd>The base/nominal operating frequency of the core, as reported by some <code>cpufreq</code> or ACPI drivers on Linux (e.g. <code>cpufreq_cppc</code> or <code>intel_pstate</code>).  </dd>
<dt>CoreType (x86) </dt>
<dd>A string describing the kind of core, currently <code>IntelAtom</code>, <code>IntelCore</code> or <code>IntelLowPower</code>, as reported by the x86 CPUID instruction and Linux PMU on some Intel processors.  </dd>
<dt>LinuxCapacity (Linux) </dt>
<dd>The Linux-specific CPU capacity found in sysfs, as reported by the Linux kernel on some recent platforms. Higher values usually mean that the Linux scheduler considers the core as high-performance rather than energy-efficient.  </dd>
<dt>LinuxCPUType (Linux) </dt>
<dd>The Linux-specific CPU type found in sysfs, such as <code>intel_atom_0</code>, as reported by future Linux kernels on some Intel processors.  </dd>
<dt>DarwinCompatible (Darwin / Mac OS X) </dt>
<dd>The compatibility attribute of the CPUs as found in the IO registry on Darwin / Mac OS X. For instance <code>apple,icestorm;ARM,v8</code> for energy-efficient cores and <code>apple,firestorm;ARM,v8</code> on performance cores on Apple M1 CPU.  </dd>
</dl>
<p>The hwloc-calc tool may be used to query the number of cpukinds or which ones exist in some cores: </p><pre class="fragment">$ hwloc-calc -N cpukind all
2
$ hwloc-calc -I cpukind package:0
0,1
</pre><p>See <a class="el" href="a00194.html">Kinds of CPU cores</a> for details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
