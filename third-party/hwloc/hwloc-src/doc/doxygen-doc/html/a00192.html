<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Comparing memory node attributes for finding where to allocate on</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hardware Locality (hwloc)<span id="projectnumber">&#160;2.12.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Comparing memory node attributes for finding where to allocate on</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00296.html">hwloc_location</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacc82003a8610be554615995f0996c888" id="r_gacc82003a8610be554615995f0996c888"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a></td></tr>
<tr class="separator:gacc82003a8610be554615995f0996c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab4bde745db676fc2ea4b47011cd9a80e" id="r_gab4bde745db676fc2ea4b47011cd9a80e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#gab4bde745db676fc2ea4b47011cd9a80e">hwloc_memattr_id_e</a> { <br />
&#160;&#160;<a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80eaa1cfa3ff3d56ff00ecabf7da4f5642cc">HWLOC_MEMATTR_ID_CAPACITY</a>
, <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80ea9334e3a4c30a67f491c6523255134efe">HWLOC_MEMATTR_ID_LOCALITY</a>
, <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80ea25fe3c7376ae6f9b584bacdb039f8c0f">HWLOC_MEMATTR_ID_BANDWIDTH</a>
, <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80eac34dce925d3dadb7e255391d142b4828">HWLOC_MEMATTR_ID_READ_BANDWIDTH</a>
, <br />
&#160;&#160;<a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80ea44762e8ebe327cfe665cccf1f58f7530">HWLOC_MEMATTR_ID_WRITE_BANDWIDTH</a>
, <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80ead1796413759b8b87b61ad195a9349b19">HWLOC_MEMATTR_ID_LATENCY</a>
, <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80ea52cab56571c7fafea42a694d80ad3dd0">HWLOC_MEMATTR_ID_READ_LATENCY</a>
, <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80eaaf6cd383da87dc9f5e3a608a535a768e">HWLOC_MEMATTR_ID_WRITE_LATENCY</a>
, <br />
&#160;&#160;<b>HWLOC_MEMATTR_ID_MAX</b>
<br />
 }</td></tr>
<tr class="separator:gab4bde745db676fc2ea4b47011cd9a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33099ba58f607fc70925da3777688586" id="r_ga33099ba58f607fc70925da3777688586"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ga33099ba58f607fc70925da3777688586">hwloc_location_type_e</a> { <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174">HWLOC_LOCATION_TYPE_CPUSET</a>
, <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84">HWLOC_LOCATION_TYPE_OBJECT</a>
 }</td></tr>
<tr class="separator:ga33099ba58f607fc70925da3777688586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c963ca37255da71b00d94e1b106f9d" id="r_gab9c963ca37255da71b00d94e1b106f9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#gab9c963ca37255da71b00d94e1b106f9d">hwloc_local_numanode_flag_e</a> { <a class="el" href="a00192.html#ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc">HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</a>
, <a class="el" href="a00192.html#ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57">HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</a>
, <a class="el" href="a00192.html#ggab9c963ca37255da71b00d94e1b106f9da63688752fccbfc4d55b20da28fcb2430">HWLOC_LOCAL_NUMANODE_FLAG_INTERSECT_LOCALITY</a>
, <a class="el" href="a00192.html#ggab9c963ca37255da71b00d94e1b106f9dab5778b34c961a5d56f98f1549edeaed0">HWLOC_LOCAL_NUMANODE_FLAG_ALL</a>
 }</td></tr>
<tr class="separator:gab9c963ca37255da71b00d94e1b106f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga79f44f8e1cfd2f97a19171417a75a137" id="r_ga79f44f8e1cfd2f97a19171417a75a137"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ga79f44f8e1cfd2f97a19171417a75a137">hwloc_memattr_get_by_name</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const char *name, <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> *id)</td></tr>
<tr class="separator:ga79f44f8e1cfd2f97a19171417a75a137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569e80c5be7ef27649b0ef5aa52ffcdc" id="r_ga569e80c5be7ef27649b0ef5aa52ffcdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ga569e80c5be7ef27649b0ef5aa52ffcdc">hwloc_get_local_numanode_objs</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, struct <a class="el" href="a00296.html">hwloc_location</a> *location, unsigned *nr, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *nodes, unsigned long flags)</td></tr>
<tr class="separator:ga569e80c5be7ef27649b0ef5aa52ffcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ff5d6f04d3bb71a3259cf1ff3afaed" id="r_gae7ff5d6f04d3bb71a3259cf1ff3afaed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#gae7ff5d6f04d3bb71a3259cf1ff3afaed">hwloc_topology_get_default_nodeset</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00163.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a> nodeset, unsigned long flags)</td></tr>
<tr class="separator:gae7ff5d6f04d3bb71a3259cf1ff3afaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297e4a9adc2272446a4c7449dacef0df" id="r_ga297e4a9adc2272446a4c7449dacef0df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ga297e4a9adc2272446a4c7449dacef0df">hwloc_memattr_get_value</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> target_node, struct <a class="el" href="a00296.html">hwloc_location</a> *initiator, unsigned long flags, hwloc_uint64_t *value)</td></tr>
<tr class="separator:ga297e4a9adc2272446a4c7449dacef0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884d1f2ad745c2fa69c1583c82d28f10" id="r_ga884d1f2ad745c2fa69c1583c82d28f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ga884d1f2ad745c2fa69c1583c82d28f10">hwloc_memattr_get_best_target</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, struct <a class="el" href="a00296.html">hwloc_location</a> *initiator, unsigned long flags, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *best_target, hwloc_uint64_t *value)</td></tr>
<tr class="separator:ga884d1f2ad745c2fa69c1583c82d28f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b746dd3494772db18eaf760a5dd9c0" id="r_gaf6b746dd3494772db18eaf760a5dd9c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#gaf6b746dd3494772db18eaf760a5dd9c0">hwloc_memattr_get_best_initiator</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> target_node, unsigned long flags, struct <a class="el" href="a00296.html">hwloc_location</a> *best_initiator, hwloc_uint64_t *value)</td></tr>
<tr class="separator:gaf6b746dd3494772db18eaf760a5dd9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c06c1c89ab352c5db8e04a75033513" id="r_gac8c06c1c89ab352c5db8e04a75033513"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#gac8c06c1c89ab352c5db8e04a75033513">hwloc_memattr_get_targets</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, struct <a class="el" href="a00296.html">hwloc_location</a> *initiator, unsigned long flags, unsigned *nr, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *targets, hwloc_uint64_t *values)</td></tr>
<tr class="separator:gac8c06c1c89ab352c5db8e04a75033513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049aaa860dcbbf0792f0fd4251a99ec0" id="r_ga049aaa860dcbbf0792f0fd4251a99ec0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ga049aaa860dcbbf0792f0fd4251a99ec0">hwloc_memattr_get_initiators</a> (<a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> attribute, <a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> target_node, unsigned long flags, unsigned *nr, struct <a class="el" href="a00296.html">hwloc_location</a> *initiators, hwloc_uint64_t *values)</td></tr>
<tr class="separator:ga049aaa860dcbbf0792f0fd4251a99ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Platforms with heterogeneous memory require ways to decide whether a buffer should be allocated on "fast" memory (such as HBM), "normal" memory (DDR) or even "slow" but large-capacity memory (non-volatile memory). These memory nodes are called "Targets" while the CPU accessing them is called the "Initiator". Access performance depends on their locality (NUMA platforms) as well as the intrinsic performance of the targets (heterogeneous platforms).</p>
<p>The following attributes describe the performance of memory accesses from an Initiator to a memory Target, for instance their latency or bandwidth. Initiators performing these memory accesses are usually some PUs or Cores (described as a CPU set). Hence a Core may choose where to allocate a memory buffer by comparing the attributes of different target memory nodes nearby.</p>
<p>There are also some attributes that are system-wide. Their value does not depend on a specific initiator performing an access. The memory node Capacity is an example of such attribute without initiator.</p>
<p>One way to use this API is to start with a cpuset describing the Cores where a program is bound. The best target NUMA node for allocating memory in this program on these Cores may be obtained by passing this cpuset as an initiator to <a class="el" href="a00192.html#ga884d1f2ad745c2fa69c1583c82d28f10" title="Return the best target NUMA node for the given attribute and initiator.">hwloc_memattr_get_best_target()</a> with the relevant memory attribute. For instance, if the code is latency limited, use the Latency attribute.</p>
<p>A more flexible approach consists in getting the list of local NUMA nodes by passing this cpuset to <a class="el" href="a00192.html#ga569e80c5be7ef27649b0ef5aa52ffcdc" title="Return an array of local NUMA nodes.">hwloc_get_local_numanode_objs()</a>. Attribute values for these nodes, if any, may then be obtained with <a class="el" href="a00192.html#ga297e4a9adc2272446a4c7449dacef0df" title="Return an attribute value for a specific target NUMA node.">hwloc_memattr_get_value()</a> and manually compared with the desired criteria.</p>
<p>Memory attributes are also used internally to build Memory Tiers which provide an easy way to distinguish NUMA nodes of different kinds, as explained in <a class="el" href="a00375.html">Heterogeneous Memory</a>.</p>
<p>Beside tiers, hwloc defines a set of "default" nodes where normal memory allocations should be made from (see <a class="el" href="a00192.html#gae7ff5d6f04d3bb71a3259cf1ff3afaed" title="Return the set of default NUMA nodes.">hwloc_topology_get_default_nodeset()</a>). This is also useful for dividing the machine into a set of non-overlapping NUMA domains, for instance for binding tasks per domain.</p>
<dl class="section see"><dt>See also</dt><dd>An example is available in doc/examples/memory-attributes.c in the source tree.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The API also supports specific objects as initiator, but it is currently not used internally by hwloc. Users may for instance use it to provide custom performance values for host memory accesses performed by GPUs.</dd>
<dd>
The interface actually also accepts targets that are not NUMA nodes. </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacc82003a8610be554615995f0996c888" name="gacc82003a8610be554615995f0996c888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc82003a8610be554615995f0996c888">&#9670;&#160;</a></span>hwloc_memattr_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A memory attribute identifier. </p>
<p>hwloc predefines some commonly-used attributes in <a class="el" href="a00192.html#gab4bde745db676fc2ea4b47011cd9a80e" title="Predefined memory attribute IDs. See hwloc_memattr_id_t for the generic definition of IDs for predefi...">hwloc_memattr_id_e</a>. One may then dynamically register custom ones with <a class="el" href="a00193.html#ga770657d1e44b09e93e09f623936c1e5f" title="Register a new memory attribute.">hwloc_memattr_register()</a>, they will be assigned IDs immediately after the predefined ones. See <a class="el" href="a00193.html">Managing memory attributes</a> for more information about existing attribute IDs. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab9c963ca37255da71b00d94e1b106f9d" name="gab9c963ca37255da71b00d94e1b106f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c963ca37255da71b00d94e1b106f9d">&#9670;&#160;</a></span>hwloc_local_numanode_flag_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00192.html#gab9c963ca37255da71b00d94e1b106f9d">hwloc_local_numanode_flag_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for selecting target NUMA nodes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc" name="ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc"></a>HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY&#160;</td><td class="fielddoc"><p>Select NUMA nodes whose locality is larger than the given cpuset. For instance, if a single PU (or its cpuset) is given in <code>initiator</code>, select all nodes close to the package that contains this PU. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57" name="ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57"></a>HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY&#160;</td><td class="fielddoc"><p>Select NUMA nodes whose locality is smaller than the given cpuset. For instance, if a package (or its cpuset) is given in <code>initiator</code>, also select nodes that are attached to only a half of that package. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9da63688752fccbfc4d55b20da28fcb2430" name="ggab9c963ca37255da71b00d94e1b106f9da63688752fccbfc4d55b20da28fcb2430"></a>HWLOC_LOCAL_NUMANODE_FLAG_INTERSECT_LOCALITY&#160;</td><td class="fielddoc"><p>Select NUMA nodes whose locality intersects the given cpuset. This includes larger and smaller localities as well as localities that are partially included. For instance, if the locality is one core of both packages, a NUMA node local to one package is neither larger nor smaller than this locality, but it intersects it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9c963ca37255da71b00d94e1b106f9dab5778b34c961a5d56f98f1549edeaed0" name="ggab9c963ca37255da71b00d94e1b106f9dab5778b34c961a5d56f98f1549edeaed0"></a>HWLOC_LOCAL_NUMANODE_FLAG_ALL&#160;</td><td class="fielddoc"><p>Select all NUMA nodes in the topology. The initiator <code>initiator</code> is ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga33099ba58f607fc70925da3777688586" name="ga33099ba58f607fc70925da3777688586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33099ba58f607fc70925da3777688586">&#9670;&#160;</a></span>hwloc_location_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00192.html#ga33099ba58f607fc70925da3777688586">hwloc_location_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of location. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174" name="gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174"></a>HWLOC_LOCATION_TYPE_CPUSET&#160;</td><td class="fielddoc"><p>Location is given as a cpuset, in the location cpuset union field. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84" name="gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84"></a>HWLOC_LOCATION_TYPE_OBJECT&#160;</td><td class="fielddoc"><p>Location is given as an object, in the location object union field. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab4bde745db676fc2ea4b47011cd9a80e" name="gab4bde745db676fc2ea4b47011cd9a80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4bde745db676fc2ea4b47011cd9a80e">&#9670;&#160;</a></span>hwloc_memattr_id_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00192.html#gab4bde745db676fc2ea4b47011cd9a80e">hwloc_memattr_id_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined memory attribute IDs. See <a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888" title="A memory attribute identifier.">hwloc_memattr_id_t</a> for the generic definition of IDs for predefined or custom attributes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80eaa1cfa3ff3d56ff00ecabf7da4f5642cc" name="ggab4bde745db676fc2ea4b47011cd9a80eaa1cfa3ff3d56ff00ecabf7da4f5642cc"></a>HWLOC_MEMATTR_ID_CAPACITY&#160;</td><td class="fielddoc"><p>The "Capacity" is returned in bytes (local_memory attribute in objects). </p>
<p>Best capacity nodes are nodes with <b>higher capacity</b>.</p>
<p>No initiator is involved when looking at this attribute. The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a>.</p>
<p>Capacity values may not be modified using <a class="el" href="a00193.html#ga960529c08b25cf15825e0f72ecceb504" title="Set an attribute value for a specific target NUMA node.">hwloc_memattr_set_value()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea9334e3a4c30a67f491c6523255134efe" name="ggab4bde745db676fc2ea4b47011cd9a80ea9334e3a4c30a67f491c6523255134efe"></a>HWLOC_MEMATTR_ID_LOCALITY&#160;</td><td class="fielddoc"><p>The "Locality" is returned as the number of PUs in that locality (e.g. the weight of its cpuset). </p>
<p>Best locality nodes are nodes with <b>smaller locality</b> (nodes that are local to very few PUs). Poor locality nodes are nodes with larger locality (nodes that are local to the entire machine).</p>
<p>No initiator is involved when looking at this attribute. The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a>.</p>
<p>Locality values may not be modified using <a class="el" href="a00193.html#ga960529c08b25cf15825e0f72ecceb504" title="Set an attribute value for a specific target NUMA node.">hwloc_memattr_set_value()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea25fe3c7376ae6f9b584bacdb039f8c0f" name="ggab4bde745db676fc2ea4b47011cd9a80ea25fe3c7376ae6f9b584bacdb039f8c0f"></a>HWLOC_MEMATTR_ID_BANDWIDTH&#160;</td><td class="fielddoc"><p>The "Bandwidth" is returned in MiB/s, as seen from the given initiator location. </p>
<p>Best bandwidth nodes are nodes with <b>higher bandwidth</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a> and <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>.</p>
<p>This is the average bandwidth for read and write accesses. If the platform provides individual read and write bandwidths but no explicit average value, hwloc computes and returns the average. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80eac34dce925d3dadb7e255391d142b4828" name="ggab4bde745db676fc2ea4b47011cd9a80eac34dce925d3dadb7e255391d142b4828"></a>HWLOC_MEMATTR_ID_READ_BANDWIDTH&#160;</td><td class="fielddoc"><p>The "ReadBandwidth" is returned in MiB/s, as seen from the given initiator location. </p>
<p>Best bandwidth nodes are nodes with <b>higher bandwidth</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a> and <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea44762e8ebe327cfe665cccf1f58f7530" name="ggab4bde745db676fc2ea4b47011cd9a80ea44762e8ebe327cfe665cccf1f58f7530"></a>HWLOC_MEMATTR_ID_WRITE_BANDWIDTH&#160;</td><td class="fielddoc"><p>The "WriteBandwidth" is returned in MiB/s, as seen from the given initiator location. </p>
<p>Best bandwidth nodes are nodes with <b>higher bandwidth</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5af29e65444a6ed00f5cc246df06f65815" title="The best nodes for this memory attribute are those with the higher values. For instance Bandwidth.">HWLOC_MEMATTR_FLAG_HIGHER_FIRST</a> and <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ead1796413759b8b87b61ad195a9349b19" name="ggab4bde745db676fc2ea4b47011cd9a80ead1796413759b8b87b61ad195a9349b19"></a>HWLOC_MEMATTR_ID_LATENCY&#160;</td><td class="fielddoc"><p>The "Latency" is returned as nanoseconds, as seen from the given initiator location. </p>
<p>Best latency nodes are nodes with <b>smaller latency</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9601b5b0e1e68635e7e9901f28bd93bf" title="The best nodes for this memory attribute are those with the lower values. For instance Latency.">HWLOC_MEMATTR_FLAG_LOWER_FIRST</a> and <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>.</p>
<p>This is the average latency for read and write accesses. If the platform provides individual read and write latencies but no explicit average value, hwloc computes and returns the average. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80ea52cab56571c7fafea42a694d80ad3dd0" name="ggab4bde745db676fc2ea4b47011cd9a80ea52cab56571c7fafea42a694d80ad3dd0"></a>HWLOC_MEMATTR_ID_READ_LATENCY&#160;</td><td class="fielddoc"><p>The "ReadLatency" is returned as nanoseconds, as seen from the given initiator location. </p>
<p>Best latency nodes are nodes with <b>smaller latency</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9601b5b0e1e68635e7e9901f28bd93bf" title="The best nodes for this memory attribute are those with the lower values. For instance Latency.">HWLOC_MEMATTR_FLAG_LOWER_FIRST</a> and <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab4bde745db676fc2ea4b47011cd9a80eaaf6cd383da87dc9f5e3a608a535a768e" name="ggab4bde745db676fc2ea4b47011cd9a80eaaf6cd383da87dc9f5e3a608a535a768e"></a>HWLOC_MEMATTR_ID_WRITE_LATENCY&#160;</td><td class="fielddoc"><p>The "WriteLatency" is returned as nanoseconds, as seen from the given initiator location. </p>
<p>Best latency nodes are nodes with <b>smaller latency</b>.</p>
<p>The corresponding attribute flags are <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9601b5b0e1e68635e7e9901f28bd93bf" title="The best nodes for this memory attribute are those with the lower values. For instance Latency.">HWLOC_MEMATTR_FLAG_LOWER_FIRST</a> and <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga569e80c5be7ef27649b0ef5aa52ffcdc" name="ga569e80c5be7ef27649b0ef5aa52ffcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga569e80c5be7ef27649b0ef5aa52ffcdc">&#9670;&#160;</a></span>hwloc_get_local_numanode_objs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_get_local_numanode_objs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00296.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an array of local NUMA nodes. </p>
<p>By default only select the NUMA nodes whose locality is exactly the given <code>location</code>. More nodes may be selected if additional flags are given as a OR'ed set of <a class="el" href="a00192.html#gab9c963ca37255da71b00d94e1b106f9d" title="Flags for selecting target NUMA nodes.">hwloc_local_numanode_flag_e</a>.</p>
<p>If <code>location</code> is given as an explicit object, its CPU set is used to find NUMA nodes with the corresponding locality. If the object does not have a CPU set (e.g. I/O object), the CPU parent (where the I/O object is attached) is used.</p>
<p>On input, <code>nr</code> points to the number of nodes that may be stored in the <code>nodes</code> array. On output, <code>nr</code> will be changed to the number of stored nodes, or the number of nodes that would have been stored if there were enough room.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some of these NUMA nodes may not have any memory attribute values and hence not be reported as actual targets in other functions.</dd>
<dd>
The number of NUMA nodes in the topology (obtained by <a class="el" href="a00185.html#ga0200466842c0e1f5da75e84dde460b10" title="Compute the &quot;weight&quot; of bitmap bitmap (i.e., number of indexes that are in the bitmap).">hwloc_bitmap_weight()</a> on the root object nodeset) may be used to allocate the <code>nodes</code> array.</dd>
<dd>
When an object CPU set is given as locality, for instance a Package, and when flags contain both <a class="el" href="a00192.html#ggab9c963ca37255da71b00d94e1b106f9da200c6c133bb2125ba36d77ce9ca268cc" title="Select NUMA nodes whose locality is larger than the given cpuset. For instance, if a single PU (or it...">HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</a> and <a class="el" href="a00192.html#ggab9c963ca37255da71b00d94e1b106f9daac9c5e3a2cfb1b193e4acfceaf3bad57" title="Select NUMA nodes whose locality is smaller than the given cpuset. For instance, if a package (or its...">HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</a>, the returned array corresponds to the nodeset of that object. </dd></dl>

</div>
</div>
<a id="gaf6b746dd3494772db18eaf760a5dd9c0" name="gaf6b746dd3494772db18eaf760a5dd9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b746dd3494772db18eaf760a5dd9c0">&#9670;&#160;</a></span>hwloc_memattr_get_best_initiator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_best_initiator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>target_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00296.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>best_initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the best initiator for the given attribute and target NUMA node. </p>
<p>If <code>value</code> is non <code>NULL</code>, the corresponding value is returned there.</p>
<p>If multiple initiators have the same attribute values, only one is returned (and there is no way to clarify how that one is chosen). Applications that want to detect initiators with identical/similar values, or that want to look at values for multiple attributes, should rather get all values using <a class="el" href="a00192.html#ga297e4a9adc2272446a4c7449dacef0df" title="Return an attribute value for a specific target NUMA node.">hwloc_memattr_get_value()</a> and manually select the initiator they consider the best.</p>
<p>The returned initiator should not be modified or freed, it belongs to the topology.</p>
<p><code>target_node</code> cannot be <code>NULL</code>.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 with errno set to <code>ENOENT</code> if there are no matching initiators. </dd>
<dd>
-1 with errno set to <code>EINVAL</code> if the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>). </dd></dl>

</div>
</div>
<a id="ga884d1f2ad745c2fa69c1583c82d28f10" name="ga884d1f2ad745c2fa69c1583c82d28f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga884d1f2ad745c2fa69c1583c82d28f10">&#9670;&#160;</a></span>hwloc_memattr_get_best_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_best_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00296.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *&#160;</td>
          <td class="paramname"><em>best_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the best target NUMA node for the given attribute and initiator. </p>
<p>If the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>), location <code>initiator</code> is ignored and may be <code>NULL</code>.</p>
<p>If <code>value</code> is non <code>NULL</code>, the corresponding value is returned there.</p>
<p>If multiple targets have the same attribute values, only one is returned (and there is no way to clarify how that one is chosen). Applications that want to detect targets with identical/similar values, or that want to look at values for multiple attributes, should rather get all values using <a class="el" href="a00192.html#ga297e4a9adc2272446a4c7449dacef0df" title="Return an attribute value for a specific target NUMA node.">hwloc_memattr_get_value()</a> and manually select the target they consider the best.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 with errno set to <code>ENOENT</code> if there are no matching targets. </dd>
<dd>
-1 with errno set to <code>EINVAL</code> if flags are invalid, or no such attribute exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The initiator <code>initiator</code> should be of type <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174" title="Location is given as a cpuset, in the location cpuset union field.">HWLOC_LOCATION_TYPE_CPUSET</a> when refering to accesses performed by CPU cores. <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84" title="Location is given as an object, in the location object union field.">HWLOC_LOCATION_TYPE_OBJECT</a> is currently unused internally by hwloc, but users may for instance use it to provide custom information about host memory accesses performed by GPUs. </dd></dl>

</div>
</div>
<a id="ga79f44f8e1cfd2f97a19171417a75a137" name="ga79f44f8e1cfd2f97a19171417a75a137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79f44f8e1cfd2f97a19171417a75a137">&#9670;&#160;</a></span>hwloc_memattr_get_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the identifier of the memory attribute with the given name. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 with errno set to <code>EINVAL</code> if no such attribute exists. </dd></dl>

</div>
</div>
<a id="ga049aaa860dcbbf0792f0fd4251a99ec0" name="ga049aaa860dcbbf0792f0fd4251a99ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga049aaa860dcbbf0792f0fd4251a99ec0">&#9670;&#160;</a></span>hwloc_memattr_get_initiators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_initiators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>target_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00296.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>initiators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the initiators that have values for a given attribute for a specific target NUMA node. </p>
<p>Return initiators for the given attribute and target node in the <code>initiators</code> array. If <code>values</code> is not <code>NULL</code>, the corresponding attribute values are stored in the array it points to.</p>
<p>On input, <code>nr</code> points to the number of initiators that may be stored in the array <code>initiators</code> (and <code>values</code>). On output, <code>nr</code> points to the number of initiators (and values) that were actually found, even if some of them couldn't be stored in the array. Initiators that couldn't be stored are ignored, but the function still returns success (<code>0</code>). The caller may find out by comparing the value pointed by <code>nr</code> before and after the function call.</p>
<p>The returned initiators should not be modified or freed, they belong to the topology.</p>
<p><code>target_node</code> cannot be <code>NULL</code>.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<p>If the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>), no initiator is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is meant for tools and debugging (listing internal information) rather than for application queries. Applications should rather select useful NUMA nodes with <a class="el" href="a00192.html#ga569e80c5be7ef27649b0ef5aa52ffcdc" title="Return an array of local NUMA nodes.">hwloc_get_local_numanode_objs()</a> and then look at their attribute values for some relevant initiators. </dd></dl>

</div>
</div>
<a id="gac8c06c1c89ab352c5db8e04a75033513" name="gac8c06c1c89ab352c5db8e04a75033513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8c06c1c89ab352c5db8e04a75033513">&#9670;&#160;</a></span>hwloc_memattr_get_targets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_targets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00296.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a> *&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target NUMA nodes that have some values for a given attribute. </p>
<p>Return targets for the given attribute in the <code>targets</code> array (for the given initiator if any). If <code>values</code> is not <code>NULL</code>, the corresponding attribute values are stored in the array it points to.</p>
<p>On input, <code>nr</code> points to the number of targets that may be stored in the array <code>targets</code> (and <code>values</code>). On output, <code>nr</code> points to the number of targets (and values) that were actually found, even if some of them couldn't be stored in the array. Targets that couldn't be stored are ignored, but the function still returns success (<code>0</code>). The caller may find out by comparing the value pointed by <code>nr</code> before and after the function call.</p>
<p>The returned targets should not be modified or freed, they belong to the topology.</p>
<p>Argument <code>initiator</code> is ignored if the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>). Otherwise <code>initiator</code> may be non <code>NULL</code> to report only targets that have a value for that initiator.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section note"><dt>Note</dt><dd>This function is meant for tools and debugging (listing internal information) rather than for application queries. Applications should rather select useful NUMA nodes with <a class="el" href="a00192.html#ga569e80c5be7ef27649b0ef5aa52ffcdc" title="Return an array of local NUMA nodes.">hwloc_get_local_numanode_objs()</a> and then look at their attribute values.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The initiator <code>initiator</code> should be of type <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174" title="Location is given as a cpuset, in the location cpuset union field.">HWLOC_LOCATION_TYPE_CPUSET</a> when referring to accesses performed by CPU cores. <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84" title="Location is given as an object, in the location object union field.">HWLOC_LOCATION_TYPE_OBJECT</a> is currently unused internally by hwloc, but users may for instance use it to provide custom information about host memory accesses performed by GPUs. </dd></dl>

</div>
</div>
<a id="ga297e4a9adc2272446a4c7449dacef0df" name="ga297e4a9adc2272446a4c7449dacef0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297e4a9adc2272446a4c7449dacef0df">&#9670;&#160;</a></span>hwloc_memattr_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_memattr_get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00192.html#gacc82003a8610be554615995f0996c888">hwloc_memattr_id_t</a>&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00165.html#ga79b8ab56877ef99ac59b833203391c7d">hwloc_obj_t</a>&#160;</td>
          <td class="paramname"><em>target_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00296.html">hwloc_location</a> *&#160;</td>
          <td class="paramname"><em>initiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an attribute value for a specific target NUMA node. </p>
<p>If the attribute does not relate to a specific initiator (it does not have the flag <a class="el" href="a00193.html#gga78aceb4cac4d614c0f5e82dbfeb779e5a9d16523e285b2e22cfc78cc84dce8c96" title="The value returned for this memory attribute depends on the given initiator. For instance Bandwidth a...">HWLOC_MEMATTR_FLAG_NEED_INITIATOR</a>), location <code>initiator</code> is ignored and may be <code>NULL</code>.</p>
<p><code>target_node</code> cannot be <code>NULL</code>. If <code>attribute</code> is <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80eaa1cfa3ff3d56ff00ecabf7da4f5642cc" title="The &quot;Capacity&quot; is returned in bytes (local_memory attribute in objects).">HWLOC_MEMATTR_ID_CAPACITY</a>, <code>target_node</code> must be a NUMA node. If it is <a class="el" href="a00192.html#ggab4bde745db676fc2ea4b47011cd9a80ea9334e3a4c30a67f491c6523255134efe" title="The &quot;Locality&quot; is returned as the number of PUs in that locality (e.g. the weight of its cpuset).">HWLOC_MEMATTR_ID_LOCALITY</a>, <code>target_node</code> must have a CPU set.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 on error, for instance with errno set to <code>EINVAL</code> if flags are invalid or no such attribute exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The initiator <code>initiator</code> should be of type <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586a7135318a86361ad75fd1648e6bf6d174" title="Location is given as a cpuset, in the location cpuset union field.">HWLOC_LOCATION_TYPE_CPUSET</a> when refering to accesses performed by CPU cores. <a class="el" href="a00192.html#gga33099ba58f607fc70925da3777688586af637c39b23d48cff15ddb008644aaa84" title="Location is given as an object, in the location object union field.">HWLOC_LOCATION_TYPE_OBJECT</a> is currently unused internally by hwloc, but users may for instance use it to provide custom information about host memory accesses performed by GPUs. </dd></dl>

</div>
</div>
<a id="gae7ff5d6f04d3bb71a3259cf1ff3afaed" name="gae7ff5d6f04d3bb71a3259cf1ff3afaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ff5d6f04d3bb71a3259cf1ff3afaed">&#9670;&#160;</a></span>hwloc_topology_get_default_nodeset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hwloc_topology_get_default_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00166.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00163.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the set of default NUMA nodes. </p>
<p>In machines with heterogeneous memory, some NUMA nodes are considered the default ones, i.e. where basic allocations should be made from. These are usually DRAM nodes.</p>
<p>Other nodes may be reserved for specific use (I/O device memory, e.g. GPU memory), small but high performance (HBM), large but slow memory (NVM), etc. Buffers should usually not be allocated from there unless explicitly required.</p>
<p>This function fills <code>nodeset</code> with the bits of NUMA nodes considered default.</p>
<p>It is guaranteed that these nodes have non-intersecting CPU sets, i.e. cores may not have multiple local NUMA nodes anymore. Hence this may be used to iterate over the platform divided into separate NUMA localities, for instance for binding one task per NUMA domain.</p>
<p>Any core that had some local NUMA node(s) in the initial topology should still have one in the default nodeset. Corner cases where this would be wrong consist in asymmetric platforms with missing DRAM nodes, or topologies that were already restricted to less NUMA nodes.</p>
<p>The returned nodeset may be passed to <a class="el" href="a00174.html#ga6db81ed13ac0a9d70cc80372ab537815" title="Restrict the topology to the given CPU set or nodeset.">hwloc_topology_restrict()</a> with <a class="el" href="a00174.html#gga9d80f08eb25b7ac22f1b998dc8bf521fae4c5b1b87232f2d8a60559e77ac65a68" title="Restrict by nodeset instead of CPU set. Only keep objects whose nodeset is included or partially incl...">HWLOC_RESTRICT_FLAG_BYNODESET</a> to remove all non-default nodes from the topology. The resulting topology will be easier to use when iterating over (now homogeneous) NUMA nodes.</p>
<p>The heuristics for finding default nodes relies on memory tiers and subtypes (see <a class="el" href="a00375.html">Heterogeneous Memory</a>) as well as the assumption that hardware vendors list default nodes first in hardware tables.</p>
<p><code>flags</code> must be <code>0</code> for now.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned nodeset usually contains all nodes from a single memory tier, likely the DRAM one.</dd>
<dd>
The returned nodeset is included in the list of available nodes returned by <a class="el" href="a00182.html#ga3fd37303e99ace8b0d0ea03f95f8c514" title="Get topology node set.">hwloc_topology_get_topology_nodeset()</a>. It is strictly smaller if the machine has heterogeneous memory.</dd>
<dd>
The heuristics may return a suboptimal set of nodes if hwloc could not guess memory types and/or if some default nodes were removed earlier from the topology (e.g. with <a class="el" href="a00174.html#ga6db81ed13ac0a9d70cc80372ab537815" title="Restrict the topology to the given CPU set or nodeset.">hwloc_topology_restrict()</a>). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
