.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "fi_msg" "3" "2019\-09\-27" "Libfabric Programmer\[aq]s Manual" "Libfabric v1.10.1"
.hy
.SH NAME
.PP
fi_msg \- Message data transfer operations
.TP
.B fi_recv / fi_recvv / fi_recvmsg
Post a buffer to receive an incoming message
.RS
.RE
.PP
fi_send / fi_sendv / fi_sendmsg
.PD 0
.P
.PD
fi_inject / fi_senddata : Initiate an operation to send a message
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <rdma/fi_endpoint.h>

ssize_t\ fi_recv(struct\ fid_ep\ *ep,\ void\ *\ buf,\ size_t\ len,
\ \ \ \ void\ *desc,\ fi_addr_t\ src_addr,\ void\ *context);

ssize_t\ fi_recvv(struct\ fid_ep\ *ep,\ const\ struct\ iovec\ *iov,\ void\ **desc,
\ \ \ \ size_t\ count,\ fi_addr_t\ src_addr,\ void\ *context);

ssize_t\ fi_recvmsg(struct\ fid_ep\ *ep,\ const\ struct\ fi_msg\ *msg,
\ \ \ \ uint64_t\ flags);

ssize_t\ fi_send(struct\ fid_ep\ *ep,\ const\ void\ *buf,\ size_t\ len,
\ \ \ \ void\ *desc,\ fi_addr_t\ dest_addr,\ void\ *context);

ssize_t\ fi_sendv(struct\ fid_ep\ *ep,\ const\ struct\ iovec\ *iov,
\ \ \ \ void\ **desc,\ size_t\ count,\ fi_addr_t\ dest_addr,\ void\ *context);

ssize_t\ fi_sendmsg(struct\ fid_ep\ *ep,\ const\ struct\ fi_msg\ *msg,
\ \ \ \ uint64_t\ flags);

ssize_t\ fi_inject(struct\ fid_ep\ *ep,\ const\ void\ *buf,\ size_t\ len,
\ \ \ \ fi_addr_t\ dest_addr);

ssize_t\ fi_senddata(struct\ fid_ep\ *ep,\ const\ void\ *buf,\ size_t\ len,
\ \ \ \ void\ *desc,\ uint64_t\ data,\ fi_addr_t\ dest_addr,\ void\ *context);

ssize_t\ fi_injectdata(struct\ fid_ep\ *ep,\ const\ void\ *buf,\ size_t\ len,
\ \ \ \ uint64_t\ data,\ fi_addr_t\ dest_addr);
\f[]
.fi
.SH ARGUMENTS
.TP
.B \f[I]ep\f[]
Fabric endpoint on which to initiate send or post receive buffer.
.RS
.RE
.TP
.B \f[I]buf\f[]
Data buffer to send or receive.
.RS
.RE
.TP
.B \f[I]len\f[]
Length of data buffer to send or receive, specified in bytes.
Valid transfers are from 0 bytes up to the endpoint\[aq]s max_msg_size.
.RS
.RE
.TP
.B \f[I]iov\f[]
Vectored data buffer.
.RS
.RE
.TP
.B \f[I]count\f[]
Count of vectored data entries.
.RS
.RE
.TP
.B \f[I]desc\f[]
Descriptor associated with the data buffer.
See \f[C]fi_mr\f[](3).
.RS
.RE
.TP
.B \f[I]data\f[]
Remote CQ data to transfer with the sent message.
.RS
.RE
.TP
.B \f[I]dest_addr\f[]
Destination address for connectionless transfers.
Ignored for connected endpoints.
.RS
.RE
.TP
.B \f[I]src_addr\f[]
Source address to receive from for connectionless transfers.
Applies only to connectionless endpoints with the FI_DIRECTED_RECV
capability enabled, otherwise this field is ignored.
If set to FI_ADDR_UNSPEC, any source address may match.
.RS
.RE
.TP
.B \f[I]msg\f[]
Message descriptor for send and receive operations.
.RS
.RE
.TP
.B \f[I]flags\f[]
Additional flags to apply for the send or receive operation.
.RS
.RE
.TP
.B \f[I]context\f[]
User specified pointer to associate with the operation.
This parameter is ignored if the operation will not generate a
successful completion, unless an op flag specifies the context parameter
be used for required input.
.RS
.RE
.SH DESCRIPTION
.PP
The send functions \-\- fi_send, fi_sendv, fi_sendmsg, fi_inject, and
fi_senddata \-\- are used to transmit a message from one endpoint to
another endpoint.
The main difference between send functions are the number and type of
parameters that they accept as input.
Otherwise, they perform the same general function.
Messages sent using fi_msg operations are received by a remote endpoint
into a buffer posted to receive such messages.
.PP
The receive functions \-\- fi_recv, fi_recvv, fi_recvmsg \-\- post a
data buffer to an endpoint to receive inbound messages.
Similar to the send operations, receive operations operate
asynchronously.
Users should not touch the posted data buffer(s) until the receive
operation has completed.
.PP
An endpoint must be enabled before an application can post send or
receive operations to it.
For connected endpoints, receive buffers may be posted prior to connect
or accept being called on the endpoint.
This ensures that buffers are available to receive incoming data
immediately after the connection has been established.
.PP
Completed message operations are reported to the user through one or
more event collectors associated with the endpoint.
Users provide context which are associated with each operation, and is
returned to the user as part of the event completion.
See fi_cq for completion event details.
.SS fi_send
.PP
The call fi_send transfers the data contained in the user\-specified
data buffer to a remote endpoint, with message boundaries being
maintained.
For connection based endpoints (FI_EP_MSG) the local endpoint must be
connected to a remote endpoint or destination before fi_send is called.
Unless the endpoint has been configured differently, the data buffer
passed into fi_send must not be touched by the application until the
fi_send call completes asynchronously.
.SS fi_sendv
.PP
The fi_sendv call adds support for a scatter\-gather list to fi_send.
The fi_sendv transfers the set of data buffers referenced by the iov
parameter to a remote endpoint as a single message.
.SS fi_sendmsg
.PP
The fi_sendmsg call supports data transfers over both connected and
unconnected endpoints, with the ability to control the send operation
per call through the use of flags.
The fi_sendmsg function takes a \f[C]struct\ fi_msg\f[] as input.
.IP
.nf
\f[C]
struct\ fi_msg\ {
\ \ \ \ const\ struct\ iovec\ *msg_iov;\ /*\ scatter\-gather\ array\ */
\ \ \ \ void\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ **desc;\ \ \ /*\ local\ request\ descriptors\ */
\ \ \ \ size_t\ \ \ \ \ \ \ \ \ \ \ \ \ iov_count;/*\ #\ elements\ in\ iov\ */
\ \ \ \ fi_addr_t\ \ \ \ \ \ \ \ \ \ addr;\ \ \ \ \ /*\ optional\ endpoint\ address\ */
\ \ \ \ void\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *context;\ /*\ user\-defined\ context\ */
\ \ \ \ uint64_t\ \ \ \ \ \ \ \ \ \ \ data;\ \ \ \ \ /*\ optional\ message\ data\ */
};
\f[]
.fi
.SS fi_inject
.PP
The send inject call is an optimized version of fi_send with the
following characteristics.
The data buffer is available for reuse immediately on return from the
call, and no CQ entry will be written if the transfer completes
successfully.
.PP
Conceptually, this means that the fi_inject function behaves as if the
FI_INJECT transfer flag were set, selective completions are enabled, and
the FI_COMPLETION flag is not specified.
Note that the CQ entry will be suppressed even if the default behavior
of the endpoint is to write CQ entries for all successful completions.
See the flags discussion below for more details.
The requested message size that can be used with fi_inject is limited by
inject_size.
.SS fi_senddata
.PP
The send data call is similar to fi_send, but allows for the sending of
remote CQ data (see FI_REMOTE_CQ_DATA flag) as part of the transfer.
.SS fi_injectdata
.PP
The inject data call is similar to fi_inject, but allows for the sending
of remote CQ data (see FI_REMOTE_CQ_DATA flag) as part of the transfer.
.SS fi_recv
.PP
The fi_recv call posts a data buffer to the receive queue of the
corresponding endpoint.
Posted receives are searched in the order in which they were posted in
order to match sends.
Message boundaries are maintained.
The order in which the receives complete is dependent on the endpoint
type and protocol.
For unconnected endpoints, the src_addr parameter can be used to
indicate that a buffer should be posted to receive incoming data from a
specific remote endpoint.
.SS fi_recvv
.PP
The fi_recvv call adds support for a scatter\-gather list to fi_recv.
The fi_recvv posts the set of data buffers referenced by the iov
parameter to a receive incoming data.
.SS fi_recvmsg
.PP
The fi_recvmsg call supports posting buffers over both connected and
unconnected endpoints, with the ability to control the receive operation
per call through the use of flags.
The fi_recvmsg function takes a struct fi_msg as input.
.SH FLAGS
.PP
The fi_recvmsg and fi_sendmsg calls allow the user to specify flags
which can change the default message handling of the endpoint.
Flags specified with fi_recvmsg / fi_sendmsg override most flags
previously configured with the endpoint, except where noted (see
fi_endpoint.3).
The following list of flags are usable with fi_recvmsg and/or
fi_sendmsg.
.TP
.B \f[I]FI_REMOTE_CQ_DATA\f[]
Applies to fi_sendmsg and fi_senddata.
Indicates that remote CQ data is available and should be sent as part of
the request.
See fi_getinfo for additional details on FI_REMOTE_CQ_DATA.
.RS
.RE
.TP
.B \f[I]FI_CLAIM\f[]
Applies to posted receive operations for endpoints configured for
FI_BUFFERED_RECV or FI_VARIABLE_MSG.
This flag is used to retrieve a message that was buffered by the
provider.
See the Buffered Receives section for details.
.RS
.RE
.TP
.B \f[I]FI_COMPLETION\f[]
Indicates that a completion entry should be generated for the specified
operation.
The endpoint must be bound to a completion queue with
FI_SELECTIVE_COMPLETION that corresponds to the specified operation, or
this flag is ignored.
.RS
.RE
.TP
.B \f[I]FI_DISCARD\f[]
Applies to posted receive operations for endpoints configured for
FI_BUFFERED_RECV or FI_VARIABLE_MSG.
This flag is used to free a message that was buffered by the provider.
See the Buffered Receives section for details.
.RS
.RE
.TP
.B \f[I]FI_MORE\f[]
Indicates that the user has additional requests that will immediately be
posted after the current call returns.
Use of this flag may improve performance by enabling the provider to
optimize its access to the fabric hardware.
.RS
.RE
.TP
.B \f[I]FI_INJECT\f[]
Applies to fi_sendmsg.
Indicates that the outbound data buffer should be returned to user
immediately after the send call returns, even if the operation is
handled asynchronously.
This may require that the underlying provider implementation copy the
data into a local buffer and transfer out of that buffer.
This flag can only be used with messages smaller than inject_size.
.RS
.RE
.TP
.B \f[I]FI_MULTI_RECV\f[]
Applies to posted receive operations.
This flag allows the user to post a single buffer that will receive
multiple incoming messages.
Received messages will be packed into the receive buffer until the
buffer has been consumed.
Use of this flag may cause a single posted receive operation to generate
multiple events as messages are placed into the buffer.
The placement of received data into the buffer may be subjected to
provider specific alignment restrictions.
.RS
.RE
.PP
The buffer will be released by the provider when the available buffer
space falls below the specified minimum (see FI_OPT_MIN_MULTI_RECV).
Note that an entry to the associated receive completion queue will
always be generated when the buffer has been consumed, even if other
receive completions have been suppressed (i.e.
the Rx context has been configured for FI_SELECTIVE_COMPLETION).
See the FI_MULTI_RECV completion flag \f[C]fi_cq\f[](3).
.TP
.B \f[I]FI_INJECT_COMPLETE\f[]
Applies to fi_sendmsg.
Indicates that a completion should be generated when the source
buffer(s) may be reused.
.RS
.RE
.TP
.B \f[I]FI_TRANSMIT_COMPLETE\f[]
Applies to fi_sendmsg.
Indicates that a completion should not be generated until the operation
has been successfully transmitted and is no longer being tracked by the
provider.
.RS
.RE
.TP
.B \f[I]FI_DELIVERY_COMPLETE\f[]
Applies to fi_sendmsg.
Indicates that a completion should be generated when the operation has
been processed by the destination.
.RS
.RE
.TP
.B \f[I]FI_FENCE\f[]
Applies to transmits.
Indicates that the requested operation, also known as the fenced
operation, and any operation posted after the fenced operation will be
deferred until all previous operations targeting the same peer endpoint
have completed.
Operations posted after the fencing will see and/or replace the results
of any operations initiated prior to the fenced operation.
.RS
.RE
.PP
The ordering of operations starting at the posting of the fenced
operation (inclusive) to the posting of a subsequent fenced operation
(exclusive) is controlled by the endpoint\[aq]s ordering semantics.
.TP
.B \f[I]FI_MULTICAST\f[]
Applies to transmits.
This flag indicates that the address specified as the data transfer
destination is a multicast address.
This flag must be used in all multicast transfers, in conjunction with a
multicast fi_addr_t.
.RS
.RE
.SH Buffered Receives
.PP
Buffered receives indicate that the networking layer allocates and
manages the data buffers used to receive network data transfers.
As a result, received messages must be copied from the network buffers
into application buffers for processing.
However, applications can avoid this copy if they are able to process
the message in place (directly from the networking buffers).
.PP
Handling buffered receives differs based on the size of the message
being sent.
In general, smaller messages are passed directly to the application for
processing.
However, for large messages, an application will only receive the start
of the message and must claim the rest.
The details for how small messages are reported and large messages may
be claimed are described below.
.PP
When a provider receives a message, it will write an entry to the
completion queue associated with the receiving endpoint.
For discussion purposes, the completion queue is assumed to be
configured for FI_CQ_FORMAT_DATA.
Since buffered receives are not associated with application posted
buffers, the CQ entry op_context will point to a struct fi_recv_context.
.IP
.nf
\f[C]
struct\ fi_recv_context\ {
\ \ \ \ struct\ fid_ep\ *ep;
\ \ \ \ void\ *context;
};
\f[]
.fi
.PP
The \[aq]ep\[aq] field will point to the receiving endpoint or Rx
context, and \[aq]context\[aq] will be NULL.
The CQ entry\[aq]s \[aq]buf\[aq] will point to a provider managed buffer
where the start of the received message is located, and \[aq]len\[aq]
will be set to the total size of the message.
.PP
The maximum sized message that a provider can buffer is limited by an
FI_OPT_BUFFERED_LIMIT.
This threshold can be obtained and may be adjusted by the application
using the fi_getopt and fi_setopt calls, respectively.
Any adjustments must be made prior to enabling the endpoint.
The CQ entry \[aq]buf\[aq] will point to a buffer of received data.
If the sent message is larger than the buffered amount, the CQ entry
\[aq]flags\[aq] will have the FI_MORE bit set.
When the FI_MORE bit is set, \[aq]buf\[aq] will reference at least
FI_OPT_BUFFERED_MIN bytes of data (see fi_endpoint.3 for more info).
.PP
After being notified that a buffered receive has arrived, applications
must either claim or discard the message.
Typically, small messages are processed and discarded, while large
messages are claimed.
However, an application is free to claim or discard any message
regardless of message size.
.PP
To claim a message, an application must post a receive operation with
the FI_CLAIM flag set.
The struct fi_recv_context returned as part of the notification must be
provided as the receive operation\[aq]s context.
The struct fi_recv_context contains a \[aq]context\[aq] field.
Applications may modify this field prior to claiming the message.
When the claim operation completes, a standard receive completion entry
will be generated on the completion queue.
The \[aq]context\[aq] of the associated CQ entry will be set to the
\[aq]context\[aq] value passed in through the fi_recv_context structure,
and the CQ entry flags will have the FI_CLAIM bit set.
.PP
Buffered receives that are not claimed must be discarded by the
application when it is done processing the CQ entry data.
To discard a message, an application must post a receive operation with
the FI_DISCARD flag set.
The struct fi_recv_context returned as part of the notification must be
provided as the receive operation\[aq]s context.
When the FI_DISCARD flag is set for a receive operation, the receive
input buffer(s) and length parameters are ignored.
.PP
IMPORTANT: Buffered receives must be claimed or discarded in a timely
manner.
Failure to do so may result in increased memory usage for network
buffering or communication stalls.
Once a buffered receive has been claimed or discarded, the original CQ
entry \[aq]buf\[aq] or struct fi_recv_context data may no longer be
accessed by the application.
.PP
The use of the FI_CLAIM and FI_DISCARD operation flags is also described
with respect to tagged message transfers in fi_tagged.3.
Buffered receives of tagged messages will include the message tag as
part of the CQ entry, if available.
.PP
The handling of buffered receives follows all message ordering
restrictions assigned to an endpoint.
For example, completions may indicate the order in which received
messages arrived at the receiver based on the endpoint attributes.
.SH Variable Length Messages
.PP
Variable length messages, or simply variable messages, are transfers
where the size of the message is unknown to the receiver prior to the
message being sent.
It indicates that the recipient of a message does not know the amount of
data to expect prior to the message arriving.
It is most commonly used when the size of message transfers varies
greatly, with very large messages interspersed with much smaller
messages, making receive side message buffering difficult to manage.
Variable messages are not subject to max message length restrictions
(i.e.
struct fi_ep_attr::max_msg_size limits), and may be up to the maximum
value of size_t (e.g.
SIZE_MAX) in length.
.PP
Variable length messages support requests that the provider allocate and
manage the network message buffers.
As a result, the application requirements and provider behavior is
identical as those defined for supporting the FI_BUFFERED_RECV mode bit.
See the Buffered Receive section above for details.
The main difference is that buffered receives are limited by the
fi_ep_attr::max_msg_size threshold, whereas variable length messages are
not.
.PP
Support for variable messages is indicated through the FI_VARIABLE_MSG
capability bit.
.SH NOTES
.PP
If an endpoint has been configured with FI_MSG_PREFIX, the application
must include buffer space of size msg_prefix_size, as specified by the
endpoint attributes.
The prefix buffer must occur at the start of the data referenced by the
buf parameter, or be referenced by the first IO vector.
Message prefix space cannot be split between multiple IO vectors.
The size of the prefix buffer should be included as part of the total
buffer length.
.SH RETURN VALUE
.PP
Returns 0 on success.
On error, a negative value corresponding to fabric errno is returned.
Fabric errno values are defined in \f[C]rdma/fi_errno.h\f[].
.PP
See the discussion below for details handling FI_EAGAIN.
.SH ERRORS
.TP
.B \f[I]\-FI_EAGAIN\f[]
Indicates that the underlying provider currently lacks the resources
needed to initiate the requested operation.
The reasons for a provider returning FI_EAGAIN are varied.
However, common reasons include insufficient internal buffering or full
processing queues.
.RS
.RE
.PP
Insufficient internal buffering is often associated with operations that
use FI_INJECT.
In such cases, additional buffering may become available as posted
operations complete.
.PP
Full processing queues may be a temporary state related to local
processing (for example, a large message is being transferred), or may
be the result of flow control.
In the latter case, the queues may remain blocked until additional
resources are made available at the remote side of the transfer.
.PP
In all cases, the operation may be retried after additional resources
become available.
It is strongly recommended that applications check for transmit and
receive completions after receiving FI_EAGAIN as a return value,
independent of the operation which failed.
This is particularly important in cases where manual progress is
employed, as acknowledgements or flow control messages may need to be
processed in order to resume execution.
.SH SEE ALSO
.PP
\f[C]fi_getinfo\f[](3), \f[C]fi_endpoint\f[](3), \f[C]fi_domain\f[](3),
\f[C]fi_cq\f[](3)
.SH AUTHORS
OpenFabrics.
