.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "fi_psm3" "7" "2022\-12\-11" "Libfabric Programmer\[cq]s Manual" "Libfabric v1.17.1"
.hy
.SH NAME
.PP
fi_psm3 - The PSM3 Fabric Provider
.SH OVERVIEW
.PP
The \f[I]psm3\f[R] provider implements a Performance Scaled Messaging
capability which supports most verbs UD and sockets devices.
Additional features and optimizations can be enabled when running over
Intel\[cq]s E810 Ethernet NICs and/or using Intel\[cq]s rendezvous
kernel module (\f[C]rv\f[R]).
PSM 3.x fully integrates the OFI provider and the underlying PSM3
protocols/implementation and only exports the OFI APIs.
.SH SUPPORTED FEATURES
.PP
The \f[I]psm3\f[R] provider supports a subset of all the features
defined in the libfabric API.
.TP
Endpoint types
Supports non-connection based types \f[I]FI_DGRAM\f[R] and
\f[I]FI_RDM\f[R].
.TP
Endpoint capabilities
Endpoints can support any combination of data transfer capabilities
\f[I]FI_TAGGED\f[R], \f[I]FI_MSG\f[R], \f[I]FI_ATOMICS\f[R], and
\f[I]FI_RMA\f[R].
These capabilities can be further refined by \f[I]FI_SEND\f[R],
\f[I]FI_RECV\f[R], \f[I]FI_READ\f[R], \f[I]FI_WRITE\f[R],
\f[I]FI_REMOTE_READ\f[R], and \f[I]FI_REMOTE_WRITE\f[R] to limit the
direction of operations.
.PP
\f[I]FI_MULTI_RECV\f[R] is supported for non-tagged message queue only.
.PP
Scalable endpoints are supported if the underlying PSM3 library supports
multiple endpoints.
This condition must be satisfied both when the provider is built and
when the provider is used.
See the \f[I]Scalable endpoints\f[R] section for more information.
.PP
Other supported capabilities include \f[I]FI_TRIGGER\f[R],
\f[I]FI_REMOTE_CQ_DATA\f[R], \f[I]FI_RMA_EVENT\f[R],
\f[I]FI_SOURCE\f[R], and \f[I]FI_SOURCE_ERR\f[R].
Furthermore, \f[I]FI_NAMED_RX_CTX\f[R] is supported when scalable
endpoints are enabled.
.TP
Modes
\f[I]FI_CONTEXT\f[R] is required for the \f[I]FI_TAGGED\f[R] and
\f[I]FI_MSG\f[R] capabilities.
That means, any request belonging to these two categories that generates
a completion must pass as the operation context a valid pointer to type
\f[I]struct fi_context\f[R], and the space referenced by the pointer
must remain untouched until the request has completed.
If none of \f[I]FI_TAGGED\f[R] and \f[I]FI_MSG\f[R] is asked for, the
\f[I]FI_CONTEXT\f[R] mode is not required.
.TP
Progress
The \f[I]psm3\f[R] provider performs optimal with manual progress.
By default, the application is expected to call \f[I]fi_cq_read\f[R] or
\f[I]fi_cntr_read\f[R] function from time to time when no other
libfabric function is called to ensure progress is made in a timely
manner.
The provider does support auto progress mode.
However, the performance can be significantly impacted if the
application purely depends on the provider to make auto progress.
.TP
Scalable endpoints
Scalable endpoints support depends on the multi-EP feature of the
\f[I]PSM3\f[R] library.
If the \f[I]PSM3\f[R] library supports this feature, the availability is
further controlled by an environment variable \f[I]PSM3_MULTI_EP\f[R].
The \f[I]psm3\f[R] provider automatically sets this variable to 1 if it
is not set.
The feature can be disabled explicitly by setting
\f[I]PSM3_MULTI_EP\f[R] to 0.
.PP
When creating a scalable endpoint, the exact number of contexts
requested should be set in the \[lq]fi_info\[rq] structure passed to the
\f[I]fi_scalable_ep\f[R] function.
This number should be set in \[lq]fi_info->ep_attr->tx_ctx_cnt\[rq] or
\[lq]fi_info->ep_attr->rx_ctx_cnt\[rq] or both, whichever greater is
used.
The \f[I]psm3\f[R] provider allocates all requested contexts upfront
when the scalable endpoint is created.
The same context is used for both Tx and Rx.
.PP
For optimal performance, it is advised to avoid having multiple threads
accessing the same context, either directly by posting
send/recv/read/write request, or indirectly by polling associated
completion queues or counters.
.PP
Using the scalable endpoint as a whole in communication functions is not
supported.
Instead, individual tx context or rx context of the scalable endpoint
should be used.
Similarly, using the address of the scalable endpoint as the source
address or destination address doesn\[cq]t collectively address all the
tx/rx contexts.
It addresses only the first tx/rx context, instead.
.SH LIMITATIONS
.PP
The \f[I]psm3\f[R] provider doesn\[cq]t support all the features defined
in the libfabric API.
Here are some of the limitations not listed above:
.TP
Unsupported features
These features are unsupported: connection management, passive endpoint,
and shared receive context.
.SH RUNTIME PARAMETERS
.PP
The \f[I]psm3\f[R] provider checks for the following environment
variables:
.TP
\f[I]FI_PSM3_UUID\f[R]
PSM requires that each job has a unique ID (UUID).
All the processes in the same job need to use the same UUID in order to
be able to talk to each other.
The PSM reference manual advises to keep UUID unique to each job.
In practice, it generally works fine to reuse UUID as long as (1) no two
jobs with the same UUID are running at the same time; and (2) previous
jobs with the same UUID have exited normally.
If running into \[lq]resource busy\[rq] or \[lq]connection failure\[rq]
issues with unknown reason, it is advisable to manually set the UUID to
a value different from the default.
.PP
The default UUID is 00FF00FF-0000-0000-0000-00FF0F0F00FF.
.PP
It is possible to create endpoints with UUID different from the one set
here.
To achieve that, set `info->ep_attr->auth_key' to the uuid value and
`info->ep_attr->auth_key_size' to its size (16 bytes) when calling
fi_endpoint() or fi_scalable_ep().
It is still true that an endpoint can only communicate with endpoints
with the same UUID.
.TP
\f[I]FI_PSM3_NAME_SERVER\f[R]
The \f[I]psm3\f[R] provider has a simple built-in name server that can
be used to resolve an IP address or host name into a transport address
needed by the \f[I]fi_av_insert\f[R] call.
The main purpose of this name server is to allow simple client-server
type applications (such as those in \f[I]fabtests\f[R]) to be written
purely with libfabric, without using any out-of-band communication
mechanism.
For such applications, the server would run first to allow endpoints be
created and registered with the name server, and then the client would
call \f[I]fi_getinfo\f[R] with the \f[I]node\f[R] parameter set to the
IP address or host name of the server.
The resulting \f[I]fi_info\f[R] structure would have the transport
address of the endpoint created by the server in the \f[I]dest_addr\f[R]
field.
Optionally the \f[I]service\f[R] parameter can be used in addition to
\f[I]node\f[R].
Notice that the \f[I]service\f[R] number is interpreted by the provider
and is not a TCP/IP port number.
.PP
The name server is on by default.
It can be turned off by setting the variable to 0.
This may save a small amount of resource since a separate thread is
created when the name server is on.
.PP
The provider detects OpenMPI and MPICH runs and changes the default
setting to off.
.TP
\f[I]FI_PSM3_TAGGED_RMA\f[R]
The RMA functions are implemented on top of the PSM Active Message
functions.
The Active Message functions have limit on the size of data can be
transferred in a single message.
Large transfers can be divided into small chunks and be pipe-lined.
However, the bandwidth is sub-optimal by doing this way.
.PP
The \f[I]psm3\f[R] provider use PSM tag-matching message queue functions
to achieve higher bandwidth for large size RMA.
It takes advantage of the extra tag bits available in PSM3 to separate
the RMA traffic from the regular tagged message queue.
.PP
The option is on by default.
To turn it off set the variable to 0.
.TP
\f[I]FI_PSM3_DELAY\f[R]
Time (seconds) to sleep before closing PSM endpoints.
This is a workaround for a bug in some versions of PSM library.
.PP
The default setting is 0.
.TP
\f[I]FI_PSM3_TIMEOUT\f[R]
Timeout (seconds) for gracefully closing PSM endpoints.
A forced closing will be issued if timeout expires.
.PP
The default setting is 5.
.TP
\f[I]FI_PSM3_CONN_TIMEOUT\f[R]
Timeout (seconds) for establishing connection between two PSM endpoints.
.PP
The default setting is 5.
.TP
\f[I]FI_PSM3_PROG_INTERVAL\f[R]
When auto progress is enabled (asked via the hints to
\f[I]fi_getinfo\f[R]), a progress thread is created to make progress
calls from time to time.
This option set the interval (microseconds) between progress calls.
.PP
The default setting is 1 if affinity is set, or 1000 if not.
See \f[I]FI_PSM3_PROG_AFFINITY\f[R].
.TP
\f[I]FI_PSM3_PROG_AFFINITY\f[R]
When set, specify the set of CPU cores to set the progress thread
affinity to.
The format is
\f[C]<start>[:<end>[:<stride>]][,<start>[:<end>[:<stride>]]]*\f[R],
where each triplet \f[C]<start>:<end>:<stride>\f[R] defines a block of
core_ids.
Both \f[C]<start>\f[R] and \f[C]<end>\f[R] can be either the
\f[C]core_id\f[R] (when >=0) or \f[C]core_id - num_cores\f[R] (when <0).
.PP
By default affinity is not set.
.TP
\f[I]FI_PSM3_INJECT_SIZE\f[R]
Maximum message size allowed for fi_inject and fi_tinject calls.
This is an experimental feature to allow some applications to override
default inject size limitation.
When the inject size is larger than the default value, some inject calls
might block.
.PP
The default setting is 64.
.TP
\f[I]FI_PSM3_LOCK_LEVEL\f[R]
When set, dictate the level of locking being used by the provider.
Level 2 means all locks are enabled.
Level 1 disables some locks and is suitable for runs that limit the
access to each PSM3 context to a single thread.
Level 0 disables all locks and thus is only suitable for single threaded
runs.
.PP
To use level 0 or level 1, wait object and auto progress mode cannot be
used because they introduce internal threads that may break the
conditions needed for these levels.
.PP
The default setting is 2.
.TP
\f[I]FI_PSM3_LAZY_CONN\f[R]
There are two strategies on when to establish connections between the
PSM3 endpoints that OFI endpoints are built on top of.
In eager connection mode, connections are established when addresses are
inserted into the address vector.
In lazy connection mode, connections are established when addresses are
used the first time in communication.
Eager connection mode has slightly lower critical path overhead but lazy
connection mode scales better.
.PP
This option controls how the two connection modes are used.
When set to 1, lazy connection mode is always used.
When set to 0, eager connection mode is used when required conditions
are all met and lazy connection mode is used otherwise.
The conditions for eager connection mode are: (1) multiple endpoint (and
scalable endpoint) support is disabled by explicitly setting
PSM3_MULTI_EP=0; and (2) the address vector type is FI_AV_MAP.
.PP
The default setting is 0.
.TP
\f[I]FI_PSM3_DISCONNECT\f[R]
The provider has a mechanism to automatically send disconnection
notifications to all connected peers before the local endpoint is
closed.
As the response, the peers call \f[I]psm3_ep_disconnect\f[R] to clean up
the connection state at their side.
This allows the same PSM3 epid be used by different dynamically started
processes (clients) to communicate with the same peer (server).
This mechanism, however, introduce extra overhead to the finalization
phase.
For applications that never reuse epids within the same session such
overhead is unnecessary.
.PP
This option controls whether the automatic disconnection notification
mechanism should be enabled.
For client-server application mentioned above, the client side should
set this option to 1, but the server should set it to 0.
.PP
The default setting is 0.
.TP
\f[I]FI_PSM3_TAG_LAYOUT\f[R]
Select how the 96-bit PSM3 tag bits are organized.
Currently three choices are available: \f[I]tag60\f[R] means 32-4-60
partitioning for CQ data, internal protocol flags, and application tag.
\f[I]tag64\f[R] means 4-28-64 partitioning for internal protocol flags,
CQ data, and application tag.
\f[I]auto\f[R] means to choose either \f[I]tag60\f[R] or \f[I]tag64\f[R]
based on the hints passed to fi_getinfo \[en] \f[I]tag60\f[R] is used if
remote CQ data support is requested explicitly, either by passing
non-zero value via \f[I]hints->domain_attr->cq_data_size\f[R] or by
including \f[I]FI_REMOTE_CQ_DATA\f[R] in \f[I]hints->caps\f[R],
otherwise \f[I]tag64\f[R] is used.
If \f[I]tag64\f[R] is the result of automatic selection,
\f[I]fi_getinfo\f[R] also returns a second instance of the provider with
\f[I]tag60\f[R] layout.
.PP
The default setting is \f[I]auto\f[R].
.PP
Notice that if the provider is compiled with macro
\f[I]PSMX3_TAG_LAYOUT\f[R] defined to 1 (means \f[I]tag60\f[R]) or 2
(means \f[I]tag64\f[R]), the choice is fixed at compile time and this
runtime option will be disabled.
.SH SEE ALSO
.PP
\f[C]fabric\f[R](7), \f[C]fi_provider\f[R](7), \f[C]fi_psm\f[R](7),
\f[C]fi_psm2\f[R](7),
.SH AUTHORS
OpenFabrics.
