.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "fi_gni" "7" "2022\-12\-11" "Libfabric Programmer\[cq]s Manual" "Libfabric v1.17.1"
.hy
.SH NAME
.PP
fi_gni - The GNI Fabric Provider
.SH OVERVIEW
.PP
The GNI provider runs on Cray XC (TM) systems utilizing the user-space
Generic Network Interface (uGNI) which provides low-level access to the
Aries interconnect.
The Aries interconnect is designed for low-latency one-sided messaging
and also includes direct hardware support for common atomic operations
and optimized collectives.
.SH REQUIREMENTS
.PP
The GNI provider runs on Cray XC systems running CLE 5.2 UP04 or higher
using gcc version 4.9 or higher.
.PP
When using the fi_mr_regattr() and fi_mr_regv() functions to register
multiple region, users must register the memory region with 4K page
alignment.
Any other page address alignment will result in a return value of
-FI_EINVAL.
.PP
When using the scalable memory registration mode, applications must make
registration requests on 4K page alignment boundaries.
Any other value will result in a return value of -FI_EINVAL.
.SH SUPPORTED FEATURES
.PP
The GNI provider supports the following features defined for the
libfabric API:
.TP
\f[I]Endpoint types\f[R]
The provider supports the \f[I]FI_EP_RDM\f[R], \f[I]FI_EP_DGRAM\f[R],
\f[I]FI_EP_MSG\f[R] endpoint types, including scalable endpoints.
.TP
\f[I]Address vectors\f[R]
The provider implements both the \f[I]FI_AV_MAP\f[R] and
\f[I]FI_AV_TABLE\f[R] address vector types.
FI_EVENT is unsupported.
.TP
\f[I]Memory registration modes\f[R]
The provider implements basic and scalable memory registration modes.
.TP
\f[I]Data transfer operations\f[R]
The following data transfer interfaces are supported for all endpoint
types: \f[I]FI_ATOMIC\f[R], \f[I]FI_MSG\f[R], \f[I]FI_RMA\f[R],
\f[I]FI_TAGGED\f[R].
See DATA TRANSFER OPERATIONS below for more details.
.TP
\f[I]Completion events\f[R]
The GNI provider supports \f[I]FI_CQ_FORMAT_CONTEXT\f[R],
\f[I]FI_CQ_FORMAT_MSG\f[R], \f[I]FI_CQ_FORMAT_DATA\f[R] and
\f[I]FI_CQ_FORMAT_TAGGED\f[R] with wait objects of type
\f[I]FI_WAIT_NONE\f[R], \f[I]FI_WAIT_UNSPEC\f[R], \f[I]FI_WAIT_SET\f[R].
.TP
\f[I]Modes\f[R]
The GNI provider does not require any operation modes.
.TP
\f[I]Progress\f[R]
For both control and data progress, the GNI provider supports both
\f[I]FI_PROGRESS_AUTO\f[R] and \f[I]FI_PROGRESS_MANUAL\f[R], with a
default set to \f[I]FI_PROGRESS_AUTO\f[R].
Note that for data progress, progression is only performed when data
transfers use the rendezvous protocol.
.TP
\f[I]Wait Objects\f[R]
The GNI provider specifically supports wait object types
\f[I]FI_WAIT_UNSPEC\f[R], and \f[I]FI_WAIT_SET\f[R].
A wait object must be used when calling fi_cntr_wait, fi_cq_sread/from,
fi_eq_sread/from, fi_wait.
The GNI provider spawns an internal wait progress thread that is woken
up when clients utilize the wait system (e.g., calling fi_wait).
.TP
\f[I]Additional Features\f[R]
The GNI provider also supports the following capabilities and features:
- \f[I]FI_MULTI_RECV\f[R] - \f[I]FI_SOURCE\f[R] - \f[I]FI_FENCE\f[R] -
\f[I]FI_RM_ENABLED\f[R] - \f[I]FI_RMA_EVENT\f[R] -
\f[I]FI_REMOTE_CQ_DATA\f[R] - \f[I]FABRIC_DIRECT\f[R] compilation mode -
\f[I]FI_MORE\f[R] (For FI_RMA)
.SH DATA TRANSFER OPERATIONS
.SS FI_ATOMIC
.PP
Currently, the GNI provider only supports atomic operations supported
directly by the Aries NIC.
These include operations on 32- and 64-bit, signed and unsigned integer
and floating point values.
Specifically,
.SS Basic (fi_atomic, etc.)
.IP \[bu] 2
\f[I]FI_MIN\f[R], \f[I]FI_MAX\f[R] (no unsigned)
.IP \[bu] 2
\f[I]FI_SUM\f[R] (no 64-bit floating point)
.IP \[bu] 2
\f[I]FI_BOR\f[R], \f[I]FI_BAND\f[R], \f[I]FI_BXOR\f[R] (no floating
point)
.IP \[bu] 2
\f[I]FI_ATOMIC_WRITE\f[R]
.SS Fetching (fi_fetch_atomic, etc.)
.IP \[bu] 2
All of the basic operations as above
.IP \[bu] 2
FI_ATOMIC_READ
.SS Comparison (fi_compare_atomic, etc.)
.IP \[bu] 2
FI_CSWAP
.IP \[bu] 2
FI_MSWAP
.SS FI_MSG
.PP
All \f[I]FI_MSG\f[R] operations are supported.
.SS FI_RMA
.PP
All \f[I]FI_RMA\f[R] operations are supported.
.SS FI_TAGGED
.PP
All \f[I]FI_TAGGED\f[R] operations are supported except
\f[C]fi_tinjectdata\f[R].
.SH GNI EXTENSIONS
.PP
The GNI provider exposes low-level tuning parameters via domain,
endpoint and fabric level \f[C]fi_open_ops\f[R] interfaces.
The domain extensions have been named \f[I]FI_GNI_DOMAIN_OPS_1\f[R].
The endpoint extensions have been named \f[I]FI_GNI_EP_OPS_1\f[R].
The fabric extensions have been named \f[I]FI_GNI_FABRIC_OPS_1\f[R] and
\f[I]FI_GNI_FABRIC_OPS_2\f[R].
The flags parameter is currently ignored.
The fi_open_ops function takes a \f[C]struct fi_gni_ops_domain\f[R] or a
\f[C]struct fi_gni_ops_ep\f[R] parameter respectively and populates it
with the following:
.IP
.nf
\f[C]
struct fi_gni_ops_fab {
    int (*set_val)(struct fid *fid, fab_ops_val_t t, void *val);
    int (*get_val)(struct fid *fid, fab_ops_val_t t, void *val);
};

struct fi_gni_auth_key_ops_fab {
    int (*set_val)(uint8_t *auth_key, size_t auth_keylen, gnix_auth_key_opt_t opt, void *val);
    int (*get_val)(uint8_t *auth_key, size_t auth_keylen, gnix_auth_key_opt_t opt, void *val);
};

struct fi_gni_ops_domain {
    int (*set_val)(struct fid *fid, dom_ops_val_t t, void *val);
    int (*get_val)(struct fid *fid, dom_ops_val_t t, void *val);
    int (*flush_cache)(struct fid *fid);
};

struct fi_gni_ops_ep {
    int (*set_val)(struct fid *fid, dom_ops_val_t t, void *val);
    int (*get_val)(struct fid *fid, dom_ops_val_t t, void *val);
        size_t (*native_amo)(struct fid_ep *ep, const void *buf,
                             size_t count,void *desc,
                             fi_addr_t dest_addr, uint64_t addr,
                             uint64_t key, enum fi_datatype datatype,
                             enum gnix_fab_req_type req_type,
                             void *context);
};
\f[R]
.fi
.PP
The \f[C]set_val\f[R] function sets the value of a given parameter; the
\f[C]get_val\f[R] function returns the current value.
.PP
For \f[I]FI_GNI_FABRIC_OPS_1\f[R], the currently supported values are:
.TP
\f[I]GNI_WAIT_THREAD_SLEEP\f[R]
Time in seconds for which the progress thread will sleep between periods
of inactivity.
.TP
\f[I]GNI_DEFAULT_USER_REGISTRATION_LIMIT\f[R]
The number of user registrations that an authorization key is limited to
when using the scalable memory mode, if not specified by the user during
init.
.TP
\f[I]GNI_DEFAULT_PROV_REGISTRATION_LIMIT\f[R]
The number of provider registration that an authorization key is limited
to when using the scalable memory mode, if not specified by the user
during init.
.TP
\f[I]GNI_WAIT_SHARED_MEMORY_TIMEOUT\f[R]
The number of seconds that the provider should wait when attempting to
open mmap\[cq]d shared memory files for internal mappings.
.PP
For \f[I]FI_GNI_FABRIC_OPS_2\f[R], the currently supported values are:
.TP
\f[I]GNIX_USER_KEY_LIMIT\f[R]
The number of user registrations that an authorization key is limited to
when using the scalable memory mode.
This may only be set prior to the first use of an authorization key in
the initialization of a domain, endpoint, or memory registration.
.TP
\f[I]GNIX_PROV_KEY_LIMIT\f[R]
The number of provider registrations that an authorization key is
limited to when using the scalable memory mode.
This may only be set prior to the first use of an authorization key in
the initialization of a domain, endpoint, or memory registration.
.PP
For \f[I]FI_GNI_DOMAIN_OPS_1\f[R], the currently supported values are:
.TP
\f[I]GNI_MSG_RENDEZVOUS_THRESHOLD\f[R]
Threshold message size at which a rendezvous protocol is used for
\f[I]FI_MSG\f[R] data transfers.
The value is of type uint32_t.
.TP
\f[I]GNI_RMA_RDMA_THRESHOLD\f[R]
Threshold message size at which RDMA is used for \f[I]FI_RMA\f[R] data
transfers.
The value is of type uint32_t.
.TP
\f[I]GNI_CONN_TABLE_INITIAL_SIZE\f[R]
Initial size of the internal table data structure used to manage
connections.
The value is of type uint32_t.
.TP
\f[I]GNI_CONN_TABLE_MAX_SIZE\f[R]
Maximum size of the internal table data structure used to manage
connections.
The value is of type uint32_t.
.TP
\f[I]GNI_CONN_TABLE_STEP_SIZE\f[R]
Step size for increasing the size of the internal table data structure
used to manage internal GNI connections.
The value is of type uint32_t.
.TP
\f[I]GNI_VC_ID_TABLE_CAPACITY\f[R]
Size of the virtual channel (VC) table used for managing remote
connections.
The value is of type uint32_t.
.TP
\f[I]GNI_MBOX_PAGE_SIZE\f[R]
Page size for GNI SMSG mailbox allocations.
The value is of type uint32_t.
.TP
\f[I]GNI_MBOX_NUM_PER_SLAB\f[R]
Number of GNI SMSG mailboxes per allocation slab.
The value is of type uint32_t.
.TP
\f[I]GNI_MBOX_MAX_CREDIT\f[R]
Maximum number of credits per GNI SMSG mailbox.
The value is of type uint32_t.
.TP
\f[I]GNI_MBOX_MSG_MAX_SIZE\f[R]
Maximum size of GNI SMSG messages.
The value is of type uint32_t.
.TP
\f[I]GNI_RX_CQ_SIZE\f[R]
Recommended GNI receive CQ size.
The value is of type uint32_t.
.TP
\f[I]GNI_TX_CQ_SIZE\f[R]
Recommended GNI transmit CQ size.
The value is of type uint32_t.
.TP
\f[I]GNI_MAX_RETRANSMITS\f[R]
Maximum number of message retransmits before failure.
The value is of type uint32_t.
.TP
\f[I]GNI_MR_CACHE_LAZY_DEREG\f[R]
Enable or disable lazy deregistration of memory.
The value is of type int32_t.
.TP
\f[I]GNI_MR_CACHE\f[R]
Select the type of cache that the domain will use.
Valid choices are the following: `internal', `udreg', or `none'.
`internal' refers to the GNI provider internal registration cache.
`udreg' refers to a user level dreg library based cache.
Lastly, `none' refers to device direct registration without a provider
cache.
.TP
\f[I]GNI_MR_HARD_REG_LIMIT\f[R]
Maximum number of registrations.
Applies only to the GNI provider cache.
The value is of type int32_t (-1 for no limit).
.TP
\f[I]GNI_MR_SOFT_REG_LIMIT\f[R]
Soft cap on the registration limit.
Applies only to the GNI provider cache.
The value is of type int32_t (-1 for no limit).
.TP
\f[I]GNI_MR_HARD_STALE_REG_LIMIT\f[R]
Maximum number of stale registrations to be held in cache.
This applies to the GNI provider cache and the udreg cache.
The value is of type int32_t (-1 for no limit for the GNI provider cache
and udreg cache values must be greater than 0).
.TP
\f[I]GNI_MR_UDREG_LIMIT\f[R]
Maximum number of registrations.
Applies only to the udreg cache.
The value is of type int32_t.
The value must be greater than 0.
.TP
\f[I]GNI_XPMEM_ENABLE\f[R]
Enable or disable use of XPMEM for on node messages using the GNI
provider internal rendezvous protocol.
The value is of type bool.
.TP
\f[I]GNI_DGRAM_PROGRESS_TIMEOUT\f[R]
Controls timeout value in milliseconds for the control progress thread.
The value is of type uint32_t.
.PP
The \f[C]flush_cache\f[R] function allows the user to flush any stale
registration cache entries from the cache.
This has the effect of removing registrations from the cache that have
been deregistered with the provider, but still exist in case that they
may be reused in the near future.
Flushing the stale registrations forces hardware-level deregistration of
the stale memory registrations and frees any memory related to those
stale registrations.
Only the provider-level registration struct is freed, not the user
buffer associated with the registration.
The parameter for \f[C]flush_cache\f[R] is a struct fid pointer to a
fi_domain.
The memory registration cache is tied to the domain, so issuing a
\f[C]flush_cache\f[R] to the domain will flush the registration cache of
the domain.
.PP
For \f[I]FI_GNI_EP_OPS_1\f[R], the currently supported values are:
\f[I]GNI_HASH_TAG_IMPL\f[R] : Use a hashlist for the tag list
implementation.
The value is of type uint32_t.
.PP
The \f[C]native_amo\f[R] function allows the user to call GNI native
atomics that are not implemented in the libfabric API.
The parameters for native_amo are the same as the fi_atomic function but
adds the following parameter:
.TP
\f[I]enum gnix_fab_req_type req_type\f[R]
The req_type\[cq]s supported with this call are GNIX_FAB_RQ_NAMO_AX (AND
and XOR), and GNIX_FAB_RQ_NAMO_AX_S (AND and XOR 32 bit),
GNIX_FAB_RQ_NAMO_FAX (Fetch AND and XOR) and GNIX_FAB_RQ_NAMO_FAX_S
(Fetch AND and XOR 32 bit).
.SH NOTES
.PP
The default address format is FI_ADDR_GNI.
This is the only address format used within the GNI provider for message
passing.
FI_ADDR_STR is always parsed and converted to FI_ADDR_GNI for use within
the GNI provider.
.PP
\f[I]FI_ADDR_STR\f[R] is formatted as follows:
gni;node;service;GNIX_AV_STR_ADDR_VERSION;device_addr;cdm_id;name_type;cm_nic_cdm_id;cookie;rx_ctx_cnt;key_offset
.PP
The GNI provider sets the domain attribute \f[I]cntr_cnt\f[R] to the CQ
limit divided by 2.
.PP
The GNI provider sets the domain attribute \f[I]cq_cnt\f[R] to the CQ
limit divided by 2.
.PP
The GNI provider sets the domain attribute \f[I]ep_cnt\f[R] to SIZE_MAX.
.PP
Completion queue events may report unknown source address information
when using \f[I]FI_SOURCE\f[R].
If \f[I]FI_SOURCE_ERR\f[R] is also specified, the source address
information will be reported in the err_data member of the struct
fi_cq_err_entry populated by fi_cq_readerr.
The err_data member will contain the source address information in the
FI_ADDR_GNI address format.
In order to populate the remote peer\[cq]s address vector with this
mechanism, the application must call fi_cq_readerr to get the source
address followed by fi_av_insert on the populated err_data member.
.PP
For FI_MULTI_RECV, the GNI provider generates a separate FI_MULTI_RECV
CQ event once the receive buffer has been consumed.
Also, owing to the out-or-order nature of the Cray network, the CQ
events associated with individual messages arriving in the receive
buffer may be generated out of order with respect to the offset into the
buffer into which the messages were received.
.PP
The GNI provider can use a maximum of 4K memory registrations per
\f[I]node\f[R] when using scalable memory registration.
Please consider this limitation when placing multiple processes on each
node.
.PP
The GNI provider sets the default user registration limit to 192 when
using scalable memory registration, and sets the default provider
registration limit to 64.
These limits are directly associated with the authorization key in use
when creating the registration.
If no authorization key is used when creating the registration, the
registration is automatically bound to the same authorization key as the
domain to which the registration belongs.
.PP
When using scalable memory registration, the provider may make
registrations which consume some of the registrations set aside for the
provider.
This impacts the performance of FI_LOCAL_MR, which relies on
provider-created registrations.
.PP
All memory registrations are associated with an authorization key,
whether it is the provider default key(keylen=0) or a user-acquired key
(key!=NULL, keylen!=0).
Each authorization key is associated with a unique GNI network key.
A GNI network key can only accommodate a single memory mode, whether it
is basic, or scalable memory registration.
If a user attempts to open multiple domains using different memory modes
with the same authorization key, the provider will return -FI_EINVAL.
.PP
When using scalable memory registration, the user may request keys
beginning at 0, and ending at the user registration limit for a given
authorization key.
.PP
When using scalable memory registration and fi_mr_refresh(), only
refresh the updated pages, not the entire registration.
If the entire registration is refreshed and some of the pages are not
mapped, then refresh will return -FI_EFAULT.
.PP
Registration IDs for scalable memory registration are local to the node.
This means that the application is responsible for handing the
coordination of key selection.
.PP
The location of the authorization key mapping file can be controlled
through two environment variables, TMPDIR and GNIX_AK_FILENAME.
Setting TMPDIR to a non-NULL value with change the directory for the
authorization key mapping file, and setting GNIX_AK_FILENAME to a
non-NULL value will change the filename.
The default path for the authorization key mapping file is
`/tmp/gnix_vmdh_info'.
The recommendation is that the user should not change these environment
variables unless necessary.
.SH KNOWN BUGS
.PP
The GNI provider currently treats the fi_shutdown() interface as a
strictly local operation.
That is, fi_shutdown() causes the local endpoint to be shut down, and a
shutdown event to be generated on the local EQ.
However, a connected remote peer endpoint is not notified of a call to
fi_shutdown().
.PP
The GNI provider does not currently handle the case when
FI_OPT_MULTI_RECV is set to 0 and will return -FI_EINVAL if an
application attempts to set this value to zero.
.SH SEE ALSO
.PP
\f[C]fabric\f[R](7), \f[C]fi_open_ops\f[R](3), \f[C]fi_provider\f[R](7),
\f[C]fi_getinfo\f[R](3) \f[C]fi_atomic\f[R](3)
.PP
For more information on uGNI, see \f[I]Using the GNI and DMAPP APIs\f[R]
(S-2446-3103, Cray Inc.).
For more information on the GNI provider, see \f[I]An Implementation of
OFI libfabric in Support of Multithreaded PGAS Solutions\f[R] (PGAS
\[cq]15).
.SH AUTHORS
OpenFabrics.
