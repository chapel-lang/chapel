.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "fi_provider" "7" "2022\-12\-11" "Libfabric Programmer\[cq]s Manual" "Libfabric v1.17.1"
.hy
.SH NAME
.PP
fi_provider - Fabric Interface Providers
.SH OVERVIEW
.PP
Conceptually, a fabric provider may be viewed as a local hardware NIC
driver, though a provider is not limited by this definition.
The first component of libfabric is a general purpose framework that is
capable of handling different types of fabric hardware.
All fabric hardware devices and their software drivers are required to
support this framework.
Devices and the drivers that plug into the libfabric framework are
referred to as fabric providers, or simply providers.
.PP
This distribution of libfabric contains the following providers
(although more may be available via run-time plug-ins):
.SS Core providers
.TP
\f[I]GNI\f[R]
A provider for the Aries interconnect in Cray XC(TM) systems utilizing
the user-space \f[I]Generic Networking Interface\f[R].
See \f[C]fi_gni\f[R](7) for more information.
.TP
\f[I]PSM\f[R]
High-speed InfiniBand networking from Intel.
See \f[C]fi_psm\f[R](7) for more information.
.TP
\f[I]PSM2\f[R]
High-speed Omni-Path networking from Intel.
See \f[C]fi_psm2\f[R](7) for more information.
.TP
\f[I]PSM3\f[R]
High-speed Ethernet networking from Intel.
See \f[C]fi_psm3\f[R](7) for more information.
.TP
\f[I]OPX\f[R]
High-speed Omni-Path networking from Cornelis Networks.
See \f[C]fi_opx\f[R](7) for more information.
.TP
\f[I]Sockets\f[R]
A general purpose provider that can be used on any network that supports
TCP/UDP sockets.
This provider is not intended to provide performance improvements over
regular TCP/UDP sockets, but rather to allow developers to write, test,
and debug application code even on platforms that do not have high-speed
networking.
See \f[C]fi_sockets\f[R](7) for more information.
.TP
\f[I]usNIC\f[R]
Ultra low latency Ethernet networking over Cisco userspace VIC adapters.
See \f[C]fi_usnic\f[R](7) for more information.
.TP
\f[I]Verbs\f[R]
This provider uses the Linux Verbs API for network transport.
Application performance is, obviously expected to be similar to that of
the native Linux Verbs API.
Analogous to the Sockets provider, the Verbs provider is intended to
enable developers to write, test, and debug application code on
platforms that only have Linux Verbs-based networking.
See \f[C]fi_verbs\f[R](7) for more information.
.TP
\f[I]Blue Gene/Q\f[R]
See \f[C]fi_bgq\f[R](7) for more information.
.TP
\f[I]EFA\f[R]
A provider for the Amazon EC2 Elastic Fabric Adapter
(EFA) (https://aws.amazon.com/hpc/efa/), a custom-built OS bypass
hardware interface for inter-instance communication on EC2.
See \f[C]fi_efa\f[R](7) for more information.
.TP
\f[I]SHM\f[R]
A provider for intranode communication using shared memory.
The provider makes use of the Linux kernel feature Cross Memory Attach
(CMA) which allows processes to have full access to another process\[cq]
address space.
See \f[C]fi_shm\f[R](7) for more information.
.SS Utility providers
.TP
\f[I]RxM\f[R]
The RxM provider (ofi_rxm) is an utility provider that supports RDM
endpoints emulated over MSG endpoints of a core provider.
See \f[C]fi_rxm\f[R](7) for more information.
.TP
\f[I]RxD\f[R]
The RxD provider (ofi_rxd) is a utility provider that supports RDM
endpoints emulated over DGRAM endpoints of a core provider.
See \f[C]fi_rxd\f[R](7) for more information.
.SS Special providers
.TP
\f[I]Hook\f[R]
The hook provider is a special type of provider that can layer over any
other provider, unless FI_FABRIC_DIRECT is used.
The hook provider is always available, but has no impact unless enabled.
When enabled, the hook provider will intercept all calls to the
underlying core or utility provider(s).
The hook provider is useful for capturing performance data or providing
debugging information, even in release builds of the library.
See \f[C]fi_hook\f[R](7) for more information.
.SH CORE VERSUS UTILITY PROVIDERS
.PP
Core providers implement the libfabric interfaces directly over
low-level hardware and software interfaces.
They are designed to support a specific class of hardware, and may be
limited to supporting a single NIC.
Core providers often only support libfabric features and interfaces that
map efficiently to their underlying hardware.
.PP
Utility providers are distinct from core providers in that they are not
associated with specific classes of devices.
They instead work with core providers to expand their features, and
interact with core providers through libfabric interfaces internally.
Utility providers are often used to support a specific endpoint type
over a simpler endpoint type.
For example, the RXD provider implements reliability over unreliable
datagram endpoints.
The utility providers will not layer over the sockets provider unless it
is explicitly requested.
.PP
Utility providers show up as a component in the core provider\[cq]s
component list.
See \f[C]fi_fabric\f[R](3).
Utility providers are enabled automatically for core providers that do
not support the feature set requested by an application.
.SH PROVIDER REQUIREMENTS
.PP
Libfabric provides a general framework for supporting multiple types of
fabric objects and their related interfaces.
Fabric providers have a large amount of flexibility in selecting which
components they are able and willing to support, based on specific
hardware constraints.
Provider developers should refer to docs/provider for information on
functionality supplied by the framework to assist in provider
implementation.
To assist in the development of applications, libfabric specifies the
following requirements that must be met by any fabric provider, if
requested by an application.
.PP
Note that the instantiation of a specific fabric object is subject to
application configuration parameters and need not meet these
requirements.
.IP \[bu] 2
A fabric provider must support at least one endpoint type.
.IP \[bu] 2
All endpoints must support the message queue data transfer interface
(fi_ops_msg).
.IP \[bu] 2
An endpoint that advertises support for a specific endpoint capability
must support the corresponding data transfer interface.
.RS 2
.IP \[bu] 2
FI_ATOMIC - fi_ops_atomic
.IP \[bu] 2
FI_RMA - fi_ops_rma
.IP \[bu] 2
FI_TAGGED - fi_ops_tagged
.RE
.IP \[bu] 2
Endpoints must support all transmit and receive operations for any data
transfer interface that they support.
.RS 2
.IP \[bu] 2
Exception: If an operation is only usable for an operation that the
provider does not support, and support for that operation is conveyed
using some other mechanism, the operation may return
.RS 2
.IP \[bu] 2
FI_ENOSYS.
For example, if the provider does not support injected data, it can set
the attribute inject_size = 0, and fail all fi_inject operations.
.RE
.IP \[bu] 2
The framework supplies wrappers around the `msg' operations that can be
used.
For example, the framework implements the sendv() msg operation by
calling sendmsg().
Providers may reference the general operation, and supply on the
sendmsg() implementation.
.RE
.IP \[bu] 2
Providers must set all operations to an implementation.
Function pointers may not be left NULL or uninitialized.
The framework supplies empty functions that return -FI_ENOSYS which can
be used for this purpose.
.IP \[bu] 2
Endpoints must support the CM interface as follows:
.RS 2
.IP \[bu] 2
FI_EP_MSG endpoints must support all CM operations.
.IP \[bu] 2
FI_EP_DGRAM endpoints must support CM getname and setname.
.IP \[bu] 2
FI_EP_RDM endpoints must support CM getname and setname.
.RE
.IP \[bu] 2
Providers that support connectionless endpoints must support all AV
operations (fi_ops_av).
.IP \[bu] 2
Providers that support memory registration, must support all MR
operations (fi_ops_mr).
.IP \[bu] 2
Providers should support both completion queues and counters.
.RS 2
.IP \[bu] 2
If FI_RMA_EVENT is not supported, counter support is limited to local
events only.
.IP \[bu] 2
Completion queues must support the FI_CQ_FORMAT_CONTEXT and
FI_CQ_FORMAT_MSG.
.IP \[bu] 2
Providers that support FI_REMOTE_CQ_DATA shall support
FI_CQ_FORMAT_DATA.
.IP \[bu] 2
Providers that support FI_TAGGED shall support FI_CQ_FORMAT_TAGGED.
.RE
.IP \[bu] 2
A provider is expected to be forward compatible, and must be able to be
compiled against expanded \f[C]fi_xxx_ops\f[R] structures that define
new functions added after the provider was written.
Any unknown functions must be set to NULL.
.IP \[bu] 2
Providers shall document in their man page which features they support,
and any missing requirements.
.PP
Future versions of libfabric will automatically enable a more complete
set of features for providers that focus their implementation on a
narrow subset of libfabric capabilities.
.SH LOGGING INTERFACE
.PP
Logging is performed using the FI_ERR, FI_LOG, and FI_DEBUG macros.
.SS DEFINITIONS
.IP
.nf
\f[C]
#define FI_ERR(prov_name, subsystem, ...)

#define FI_LOG(prov_name, prov, level, subsystem, ...)

#define FI_DEBUG(prov_name, subsystem, ...)
\f[R]
.fi
.SS ARGUMENTS
.TP
\f[I]prov_name\f[R]
String representing the provider name.
.TP
\f[I]prov\f[R]
Provider context structure.
.TP
\f[I]level\f[R]
Log level associated with log statement.
.TP
\f[I]subsystem\f[R]
Subsystem being logged from.
.SS DESCRIPTION
.TP
\f[I]FI_ERR\f[R]
Always logged.
.TP
\f[I]FI_LOG\f[R]
Logged if the intended provider, log level, and subsystem parameters
match the user supplied values.
.TP
\f[I]FI_DEBUG\f[R]
Logged if configured with the \[en]enable-debug flag.
.SH SEE ALSO
.PP
\f[C]fi_gni\f[R](7), \f[C]fi_hook\f[R](7), \f[C]fi_psm\f[R](7),
\f[C]fi_sockets\f[R](7), \f[C]fi_usnic\f[R](7), \f[C]fi_verbs\f[R](7),
\f[C]fi_bgq\f[R](7), \f[C]fi_opx\f[R](7),
.SH AUTHORS
OpenFabrics.
