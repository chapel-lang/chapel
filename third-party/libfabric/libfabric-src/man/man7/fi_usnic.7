.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "fi_usnic" "7" "2022\-12\-11" "Libfabric Programmer\[cq]s Manual" "Libfabric v1.17.1"
.hy
.SH NAME
.PP
fi_usnic - The usNIC Fabric Provider
.SH OVERVIEW
.PP
The \f[I]usnic\f[R] provider is designed to run over the Cisco VIC
(virtualized NIC) hardware on Cisco UCS servers.
It utilizes the Cisco usNIC (userspace NIC) capabilities of the VIC to
enable ultra low latency and other offload capabilities on Ethernet
networks.
.SH RELEASE NOTES
.IP \[bu] 2
The \f[I]usnic\f[R] libfabric provider requires the use of the
\[lq]libnl\[rq] library.
.RS 2
.IP \[bu] 2
There are two versions of libnl generally available: v1 and v3; the
usnic provider can use either version.
.IP \[bu] 2
If you are building libfabric/the usnic provider from source, you will
need to have the libnl header files available (e.g., if you are
installing libnl from RPM or other packaging system, install the
\[lq]-devel\[rq] versions of the package).
.IP \[bu] 2
If you have libnl (either v1 or v3) installed in a non-standard location
(e.g., not in /usr/lib or /usr/lib64), you may need to tell
libfabric\[cq]s configure where to find libnl via the
\f[C]--with-libnl=DIR\f[R] command line option (where DIR is the
installation prefix of the libnl package).
.RE
.IP \[bu] 2
The most common way to use the libfabric usnic provider is via an MPI
implementation that uses libfabric (and the usnic provider) as a lower
layer transport.
MPI applications do not need to know anything about libfabric or usnic
in this use case \[en] the MPI implementation hides all these details
from the application.
.IP \[bu] 2
If you are writing applications directly to the libfabric API:
.RS 2
.IP \[bu] 2
\f[I]FI_EP_DGRAM\f[R] endpoints are the best supported method of
utilizing the usNIC interface.
Specifically, the \f[I]FI_EP_DGRAM\f[R] endpoint type has been
extensively tested as the underlying layer for Open MPI\[cq]s
\f[I]usnic\f[R] BTL.
.IP \[bu] 2
\f[I]FI_EP_MSG\f[R] and \f[I]FI_EP_RDM\f[R] endpoints are implemented,
but are only lightly tested.
It is likely that there are still some bugs in these endpoint types.
In particular, there are known bugs in RDM support in the presence of
congestion or packet loss (issue 1621).
RMA is not yet supported.
.IP \[bu] 2
\f[C]fi_provider\f[R](7) lists requirements for all providers.
The following limitations exist in the \f[I]usnic\f[R] provider:
.RS 2
.IP \[bu] 2
multicast operations are not supported on \f[I]FI_EP_DGRAM\f[R] and
\f[I]FI_EP_RDM\f[R] endpoints.
.IP \[bu] 2
\f[I]FI_EP_MSG\f[R] endpoints only support connect, accept, and getname
CM operations.
.IP \[bu] 2
Passive endpoints only support listen, setname, and getname CM
operations.
.IP \[bu] 2
\f[I]FI_EP_DGRAM\f[R] endpoints support \f[C]fi_sendmsg()\f[R] and
\f[C]fi_recvmsg()\f[R], but some flags are ignored.
\f[C]fi_sendmsg()\f[R] supports \f[C]FI_INJECT\f[R] and
\f[C]FI_COMPLETION\f[R].
\f[C]fi_recvmsg()\f[R] supports \f[C]FI_MORE\f[R].
.IP \[bu] 2
Address vectors only support \f[C]FI_AV_MAP\f[R].
.IP \[bu] 2
No counters are supported.
.IP \[bu] 2
The tag matching interface is not supported.
.IP \[bu] 2
\f[I]FI_MSG_PREFIX\f[R] is only supported on \f[I]FI_EP_DGRAM\f[R] and
usage is limited to releases 1.1 and beyond.
.IP \[bu] 2
fi_control with FI_GETWAIT may only be used on CQs that have been bound
to an endpoint.
If fi_control is used on an unbound CQ, it will return -FI_EOPBADSTATE.
.IP \[bu] 2
There is limited support for data returned as part of an erroneous
asynchronous operation.
EQs will return error data for CM operations, CQs do not support
returning error data.
.IP \[bu] 2
As of 1.5, usNIC supports fi_mr_regv, and fi_mr_regattr.
Support is limited to a single iov.
.IP \[bu] 2
Atomic operations are not supported.
.RE
.IP \[bu] 2
Resource management is not supported.
The application is responsible for resource protection.
.IP \[bu] 2
The usnic libfabric provider supports extensions that provide
information and functionality beyond the standard libfabric interface.
See the \[lq]USNIC EXTENSIONS\[rq] section, below.
.RE
.SH USNIC EXTENSIONS
.PP
The usnic libfabric provider exports extensions for additional VIC,
usNIC, and Ethernet capabilities not provided by the standard libfabric
interface.
.PP
These extensions are available via the \[lq]fi_ext_usnic.h\[rq] header
file.
.SS Fabric Extension: getinfo
.PP
Version 2 of the \[lq]fabric getinfo\[rq] extension was introduced in
Libfabric release v1.3.0 and can be used to retrieve IP and SR-IOV
information about a usNIC device obtained from the
\f[C]fi_getinfo\f[R](3) function.
.PP
The \[lq]fabric getinfo\[rq] extension is obtained by calling
\f[C]fi_open_ops\f[R] and requesting \f[C]FI_USNIC_FABRIC_OPS_1\f[R] to
get the usNIC fabric extension operations.
The \f[C]getinfo\f[R] function accepts a version parameter that can be
used to select different versions of the extension.
The information returned by the \[lq]fabric getinfo\[rq] extension is
accessible through a \f[C]fi_usnic_info\f[R] struct that uses a version
tagged union.
The accessed union member must correspond with the requested version.
It is recommended that applications explicitly request a version rather
than using the header provided \f[C]FI_EXT_USNIC_INFO_VERSION\f[R].
Although there is a version 1 of the extension, its use is discouraged,
and it may not be available in future releases.
.SS Compatibility issues
.PP
The addition of version 2 of the extension caused an alignment issue
that could lead to invalid data in the v1 portion of the structure.
This means that the alignment difference manifests when an application
using v1 of the extension is compiled with Libfabric v1.1.x or v1.2.x,
but then runs with Libfabric.so that is v1.3.x or higher (and vice
versa).
.PP
The v1.4.0 release of Libfabric introduced a padding field to explicitly
maintain compatibility with the v1.3.0 release.
If the issue is encountered, then it is recommended that you upgrade to
a release containing version 2 of the extension, or recompile with a
patched version of an older release.
.IP
.nf
\f[C]
#include <rdma/fi_ext_usnic.h>

struct fi_usnic_info {
    uint32_t ui_version;
    uint8_t ui_pad0[4];
    union {
        struct fi_usnic_info_v1 v1;
        struct fi_usnic_info_v2 v2;
    } ui;
} __attribute__((packed));

int getinfo(uint32_t version, struct fid_fabric *fabric,
        struct fi_usnic_info *info);
\f[R]
.fi
.TP
\f[I]version\f[R]
Version of getinfo to be used
.TP
\f[I]fabric\f[R]
Fabric descriptor
.TP
\f[I]info\f[R]
Upon successful return, this parameter will contain information about
the fabric.
.IP \[bu] 2
Version 2
.IP
.nf
\f[C]
struct fi_usnic_cap {
    const char *uc_capability;
    int uc_present;
} __attribute__((packed));

struct fi_usnic_info_v2 {
    uint32_t        ui_link_speed;
    uint32_t        ui_netmask_be;
    char            ui_ifname[IFNAMSIZ];
    unsigned        ui_num_vf;
    unsigned        ui_qp_per_vf;
    unsigned        ui_cq_per_vf;

    char            ui_devname[FI_EXT_USNIC_MAX_DEVNAME];
    uint8_t         ui_mac_addr[6];

    uint8_t         ui_pad0[2];

    uint32_t        ui_ipaddr_be;
    uint32_t        ui_prefixlen;
    uint32_t        ui_mtu;
    uint8_t         ui_link_up;

    uint8_t         ui_pad1[3];

    uint32_t        ui_vendor_id;
    uint32_t        ui_vendor_part_id;
    uint32_t        ui_device_id;
    char            ui_firmware[64];

    unsigned        ui_intr_per_vf;
    unsigned        ui_max_cq;
    unsigned        ui_max_qp;

    unsigned        ui_max_cqe;
    unsigned        ui_max_send_credits;
    unsigned        ui_max_recv_credits;

    const char      *ui_nicname;
    const char      *ui_pid;

    struct fi_usnic_cap **ui_caps;
} __attribute__((packed));
\f[R]
.fi
.IP \[bu] 2
Version 1
.IP
.nf
\f[C]
struct fi_usnic_info_v1 {
    uint32_t ui_link_speed;
    uint32_t ui_netmask_be;
    char ui_ifname[IFNAMSIZ];

    uint32_t ui_num_vf;
    uint32_t ui_qp_per_vf;
    uint32_t ui_cq_per_vf;
} __attribute__((packed));
\f[R]
.fi
.PP
Version 1 of the \[lq]fabric getinfo\[rq] extension can be used by
explicitly requesting it in the call to \f[C]getinfo\f[R] and accessing
the \f[C]v1\f[R] portion of the \f[C]fi_usnic_info.ui\f[R] union.
Use of version 1 is not recommended and it may be removed from future
releases.
.PP
The following is an example of how to utilize version 2 of the usnic
\[lq]fabric getinfo\[rq] extension.
.IP
.nf
\f[C]
#include <stdio.h>
#include <rdma/fabric.h>

/* The usNIC extensions are all in the
   rdma/fi_ext_usnic.h header */
#include <rdma/fi_ext_usnic.h>

int main(int argc, char *argv[]) {
    struct fi_info *info;
    struct fi_info *info_list;
    struct fi_info hints = {0};
    struct fi_ep_attr ep_attr = {0};
    struct fi_fabric_attr fabric_attr = {0};

    fabric_attr.prov_name = \[dq]usnic\[dq];
    ep_attr.type = FI_EP_DGRAM;

    hints.caps = FI_MSG;
    hints.mode = FI_LOCAL_MR | FI_MSG_PREFIX;
    hints.addr_format = FI_SOCKADDR;
    hints.ep_attr = &ep_attr;
    hints.fabric_attr = &fabric_attr;

    /* Find all usnic providers */
    fi_getinfo(FI_VERSION(1, 0), NULL, 0, 0, &hints, &info_list);

    for (info = info_list; NULL != info; info = info->next) {
        /* Open the fabric on the interface */
        struct fid_fabric *fabric;
        fi_fabric(info->fabric_attr, &fabric, NULL);

        /* Pass FI_USNIC_FABRIC_OPS_1 to get usnic ops
           on the fabric */
        struct fi_usnic_ops_fabric *usnic_fabric_ops;
        fi_open_ops(&fabric->fid, FI_USNIC_FABRIC_OPS_1, 0,
                (void **) &usnic_fabric_ops, NULL);

        /* Now use the returned usnic ops structure to call
           usnic extensions.  The following extension queries
           some IP and SR-IOV characteristics about the
           usNIC device. */
        struct fi_usnic_info usnic_info;

        /* Explicitly request version 2. */
        usnic_fabric_ops->getinfo(2, fabric, &usnic_info);

        printf(\[dq]Fabric interface %s is %s:\[rs]n\[dq]
               \[dq]\[rs]tNetmask:  0x%08x\[rs]n\[rs]tLink speed: %d\[rs]n\[dq]
               \[dq]\[rs]tSR-IOV VFs: %d\[rs]n\[rs]tQPs per SR-IOV VF: %d\[rs]n\[dq]
               \[dq]\[rs]tCQs per SR-IOV VF: %d\[rs]n\[dq],
               info->fabric_attr->name,
               usnic_info.ui.v2.ui_ifname,
               usnic_info.ui.v2.ui_netmask_be,
               usnic_info.ui.v2.ui_link_speed,
               usnic_info.ui.v2.ui_num_vf,
               usnic_info.ui.v2.ui_qp_per_vf,
               usnic_info.ui.v2.ui_cq_per_vf);

        fi_close(&fabric->fid);
    }

    fi_freeinfo(info_list);
    return 0;
}
\f[R]
.fi
.SS Adress Vector Extension: get_distance
.PP
The \[lq]address vector get_distance\[rq] extension was introduced in
Libfabric release v1.0.0 and can be used to retrieve the network
distance of an address.
.PP
The \[lq]get_distance\[rq] extension is obtained by calling
\f[C]fi_open_ops\f[R] and requesting \f[C]FI_USNIC_AV_OPS_1\f[R] to get
the usNIC address vector extension operations.
.IP
.nf
\f[C]
int get_distance(struct fid_av *av, void *addr, int *metric);
\f[R]
.fi
.TP
\f[I]av\f[R]
Address vector
.TP
\f[I]addr\f[R]
Destination address
.TP
\f[I]metric\f[R]
On output this will contain \f[C]-1\f[R] if the destination host is
unreachable, \f[C]0\f[R] is the destination host is locally connected,
and \f[C]1\f[R] otherwise.
.PP
See fi_ext_usnic.h for more details.
.SH VERSION DIFFERENCES
.SS New naming convention for fabric/domain starting with libfabric v1.4
.PP
The release of libfabric v1.4 introduced a new naming convention for
fabric and domain.
However the usNIC provider remains backward compatible with applications
supporting the old scheme and decides which one to use based on the
version passed to \f[C]fi_getinfo\f[R]:
.IP \[bu] 2
When \f[C]FI_VERSION(1,4)\f[R] or higher is used:
.RS 2
.IP \[bu] 2
fabric name is the network address with the CIDR notation (i.e.,
\f[C]a.b.c.d/e\f[R])
.IP \[bu] 2
domain name is the usNIC Linux interface name (i.e., \f[C]usnic_X\f[R])
.RE
.IP \[bu] 2
When a lower version number is used, like \f[C]FI_VERSION(1, 3)\f[R], it
follows the same behavior the usNIC provider exhibited in libfabric <=
v1.3:
.RS 2
.IP \[bu] 2
fabric name is the usNIC Linux interface name (i.e., \f[C]usnic_X\f[R])
.IP \[bu] 2
domain name is \f[C]NULL\f[R]
.RE
.SH SEE ALSO
.PP
\f[C]fabric\f[R](7), \f[C]fi_open_ops\f[R](3), \f[C]fi_provider\f[R](7),
.SH AUTHORS
OpenFabrics.
