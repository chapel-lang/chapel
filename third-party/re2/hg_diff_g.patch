diff --git a/Makefile b/Makefile
index 88bf943..48088a8 100644
--- a/Makefile
+++ b/Makefile
@@ -49,6 +49,7 @@ INSTALL_HFILES=\
 	re2/set.h\
 	re2/stringpiece.h\
 	re2/variadic_function.h\
+	re2/file_strings.h\
 
 HFILES=\
 	util/arena.h\
@@ -81,6 +82,7 @@ HFILES=\
 	re2/unicode_groups.h\
 	re2/variadic_function.h\
 	re2/walker-inl.h\
+	re2/file_strings.h\
 
 OFILES=\
 	obj/util/arena.o\
@@ -93,6 +95,7 @@ OFILES=\
 	obj/re2/bitstate.o\
 	obj/re2/compile.o\
 	obj/re2/dfa.o\
+	obj/re2/file_strings.o\
 	obj/re2/filtered_re2.o\
 	obj/re2/mimics_pcre.o\
 	obj/re2/nfa.o\
@@ -250,6 +253,7 @@ install: obj/libre2.a obj/so/libre2.so
 	$(INSTALL_DATA) $(INSTALL_HFILES) $(DESTDIR)$(includedir)/re2
 	$(INSTALL) obj/libre2.a $(DESTDIR)$(libdir)/libre2.a
 	$(INSTALL) obj/so/libre2.so $(DESTDIR)$(libdir)/libre2.so.$(SONAME).0.0
+	if [ -n "`command -v install_name_tool`" ]; then install_name_tool -id $(DESTDIR)$(libdir)/libre2.so.$(SONAME).0.0 $(DESTDIR)$(libdir)/libre2.so.$(SONAME).0.0; fi
 	ln -sf libre2.so.$(SONAME).0.0 $(DESTDIR)$(libdir)/libre2.so.$(SONAME)
 	ln -sf libre2.so.$(SONAME).0.0 $(DESTDIR)$(libdir)/libre2.so
 
diff --git a/libre2.symbols b/libre2.symbols
index fa066ae..9575fef 100644
--- a/libre2.symbols
+++ b/libre2.symbols
@@ -6,6 +6,9 @@
 		# re2::StringPiece*
 		_ZN3re211StringPiece*;
 		_ZNK3re211StringPiece*;
+		# re2::FilePiece*
+		_ZN3re211FilePiece*;
+		_ZNK3re211FilePiece*;
 		# operator<<(std::ostream&, re2::StringPiece const&)
 		_ZlsRSoRKN3re211StringPieceE;
 		# re2::FilteredRE2*
diff --git a/re2/nfa.cc b/re2/nfa.cc
index 8c4f761..685c750 100644
--- a/re2/nfa.cc
+++ b/re2/nfa.cc
@@ -31,10 +31,14 @@
 
 namespace re2 {
 
+template<typename StrPiece>
 class NFA {
  public:
-  NFA(Prog* prog);
-  ~NFA();
+  typedef typename StrPiece::ptr_type ptr_type;
+  typedef typename StrPiece::ptr_rd_type ptr_rd_type;
+
+  //NFA(Prog* prog);
+  //~NFA();
 
   // Searches for a matching string.
   //   * If anchored is true, only considers matches starting at offset.
@@ -47,9 +51,9 @@ class NFA {
   // Submatch[0] is the entire match.  When there is a choice in
   // which text matches each subexpression, the submatch boundaries
   // are chosen to match what a backtracking implementation would choose.
-  bool Search(const StringPiece& text, const StringPiece& context,
-              bool anchored, bool longest,
-              StringPiece* submatch, int nsubmatch);
+  //bool Search(const StrPiece& text, const StrPiece& context,
+  //            bool anchored, bool longest,
+  //            StrPiece* submatch, int nsubmatch);
 
   static const int Debug = 0;
 
@@ -59,20 +63,20 @@ class NFA {
       int id;
       Thread* next;  // when on free list
     };
-    const char** capture;
+    ptr_type* capture;
   };
 
   // State for explicit stack in AddToThreadq.
   struct AddState {
     int id;           // Inst to process
     int j;
-    const char* cap_j;  // if j>=0, set capture[j] = cap_j before processing ip
+    ptr_type cap_j;  // if j>=0, set capture[j] = cap_j before processing ip
 
     AddState()
-      : id(0), j(-1), cap_j(NULL) {}
+      : id(0), j(-1), cap_j(StrPiece::null_ptr()) {}
     explicit AddState(int id)
-      : id(id), j(-1), cap_j(NULL) {}
-    AddState(int id, const char* cap_j, int j)
+      : id(id), j(-1), cap_j(StrPiece::null_ptr()) {}
+    AddState(int id, ptr_type cap_j, int j)
       : id(id), j(j), cap_j(cap_j) {}
   };
 
@@ -80,14 +84,15 @@ class NFA {
   // in which Perl would explore that particular state -- the earlier
   // choices appear earlier in the list.
   typedef SparseArray<Thread*> Threadq;
+  typedef typename Threadq::iterator Threadq_iterator;
 
-  inline Thread* AllocThread();
-  inline void FreeThread(Thread*);
+  //inline Thread* AllocThread();
+  //inline void FreeThread(Thread*);
 
   // Add id (or its children, following unlabeled arrows)
   // to the workqueue q with associated capture info.
-  void AddToThreadq(Threadq* q, int id, int flag,
-                    const char* p, const char** capture);
+  //void AddToThreadq(Threadq* q, int id, int flag,
+  //                  const char* p, const char** capture);
 
   // Run runq on byte c, appending new states to nextq.
   // Updates matched_ and match_ as new, better matches are found.
@@ -95,26 +100,26 @@ class NFA {
   // in the input string, used when processing capturing parens.
   // flag is the bitwise or of Bol, Eol, etc., specifying whether
   // ^, $ and \b match the current input point (after c).
-  inline int Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p);
+  //inline int Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p);
 
   // Returns text version of capture information, for debugging.
-  string FormatCapture(const char** capture);
+  //string FormatCapture(const char** capture);
 
-  inline void CopyCapture(const char** dst, const char** src);
+  //inline void CopyCapture(const char** dst, const char** src);
 
   // Computes whether all matches must begin with the same first
   // byte, and if so, returns that byte.  If not, returns -1.
-  int ComputeFirstByte();
+  //int ComputeFirstByte();
 
   Prog* prog_;          // underlying program
   int start_;           // start instruction in program
   int ncapture_;        // number of submatches to track
   bool longest_;        // whether searching for longest match
   bool endmatch_;       // whether match must end at text.end()
-  const char* btext_;   // beginning of text being matched (for FormatSubmatch)
-  const char* etext_;   // end of text being matched (for endmatch_)
+  ptr_type btext_;   // beginning of text being matched (for FormatSubmatch)
+  ptr_type etext_;   // end of text being matched (for endmatch_)
   Threadq q0_, q1_;     // pre-allocated for Search.
-  const char** match_;  // best match so far
+  ptr_type* match_;  // best match so far
   bool matched_;        // any match so far?
   AddState* astack_;    // pre-allocated for AddToThreadq
   int nastack_;
@@ -123,16 +128,17 @@ class NFA {
   Thread* free_threads_;  // free list
 
   DISALLOW_EVIL_CONSTRUCTORS(NFA);
-};
 
-NFA::NFA(Prog* prog) {
+  // Begin member function definitions.
+ public:
+NFA(Prog* prog) {
   prog_ = prog;
   start_ = prog->start();
   ncapture_ = 0;
   longest_ = false;
   endmatch_ = false;
-  btext_ = NULL;
-  etext_ = NULL;
+  btext_ = StrPiece::null_ptr();
+  etext_ = StrPiece::null_ptr();
   q0_.resize(prog_->size());
   q1_.resize(prog_->size());
   nastack_ = 2*prog_->size();
@@ -143,7 +149,7 @@ NFA::NFA(Prog* prog) {
   first_byte_ = ComputeFirstByte();
 }
 
-NFA::~NFA() {
+~NFA() {
   delete[] match_;
   delete[] astack_;
   Thread* next;
@@ -154,25 +160,29 @@ NFA::~NFA() {
   }
 }
 
-void NFA::FreeThread(Thread *t) {
+ private:
+inline
+void FreeThread(Thread *t) {
   if (t == NULL)
     return;
   t->next = free_threads_;
   free_threads_ = t;
 }
 
-NFA::Thread* NFA::AllocThread() {
+inline
+Thread* AllocThread() {
   Thread* t = free_threads_;
   if (t == NULL) {
     t = new Thread;
-    t->capture = new const char*[ncapture_];
+    t->capture = new ptr_type[ncapture_];
     return t;
   }
   free_threads_ = t->next;
   return t;
 }
 
-void NFA::CopyCapture(const char** dst, const char** src) {
+inline
+void CopyCapture(ptr_type* dst, ptr_type* src) {
   for (int i = 0; i < ncapture_; i+=2) {
     dst[i] = src[i];
     dst[i+1] = src[i+1];
@@ -183,8 +193,8 @@ void NFA::CopyCapture(const char** dst, const char** src) {
 // The bits in flag (Bol, Eol, etc.) specify whether ^, $ and \b match.
 // The pointer p is the current input position, and m is the
 // current set of match boundaries.
-void NFA::AddToThreadq(Threadq* q, int id0, int flag,
-                       const char* p, const char** capture) {
+void AddToThreadq(Threadq* q, int id0, int flag,
+                  ptr_type p, ptr_type* capture) {
   if (id0 == 0)
     return;
 
@@ -289,10 +299,11 @@ void NFA::AddToThreadq(Threadq* q, int id0, int flag,
 // ^, $ and \b match the current input point (after c).
 // Frees all the threads on runq.
 // If there is a shortcut to the end, returns that shortcut.
-int NFA::Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p) {
+inline
+int Step(Threadq* runq, Threadq* nextq, int c, int flag, ptr_type p) {
   nextq->clear();
 
-  for (Threadq::iterator i = runq->begin(); i != runq->end(); ++i) {
+  for (Threadq_iterator i = runq->begin(); i != runq->end(); ++i) {
     Thread* t = i->second;
     if (t == NULL)
       continue;
@@ -324,7 +335,7 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p) {
           break;
         // The match is ours if we want it.
         if (ip->greedy(prog_) || longest_) {
-          CopyCapture((const char**)match_, t->capture);
+          CopyCapture(match_, t->capture);
           FreeThread(t);
           for (++i; i != runq->end(); ++i)
             FreeThread(i->second);
@@ -340,7 +351,7 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p) {
         if (endmatch_ && p != etext_)
           break;
 
-        const char* old = t->capture[1];  // previous end pointer
+        ptr_type old = t->capture[1];  // previous end pointer
         t->capture[1] = p;
         if (longest_) {
           // Leftmost-longest mode: save this match only if
@@ -348,11 +359,11 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p) {
           // point but longer than an existing match.
           if (!matched_ || t->capture[0] < match_[0] ||
               (t->capture[0] == match_[0] && t->capture[1] > match_[1]))
-            CopyCapture((const char**)match_, t->capture);
+            CopyCapture(match_, t->capture);
         } else {
           // Leftmost-biased mode: this match is by definition
           // better than what we've already found (see next line).
-          CopyCapture((const char**)match_, t->capture);
+          CopyCapture(match_, t->capture);
 
           // Cut off the threads that can only find matches
           // worse than the one we just found: don't run the
@@ -375,7 +386,7 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, int flag, const char* p) {
   return 0;
 }
 
-string NFA::FormatCapture(const char** capture) {
+string FormatCapture(ptr_type* capture) {
   string s;
 
   for (int i = 0; i < ncapture_; i+=2) {
@@ -392,27 +403,29 @@ string NFA::FormatCapture(const char** capture) {
 }
 
 // Returns whether haystack contains needle's memory.
-static bool StringPieceContains(const StringPiece haystack, const StringPiece needle) {
+static bool StringPieceContains(const StrPiece haystack, const StrPiece needle) {
   return haystack.begin() <= needle.begin() &&
-         haystack.end() >= needle.end();
+         needle.end() <= haystack.end();
 }
 
-bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
+ public:
+bool Search(const StrPiece& text, const StrPiece& const_context,
             bool anchored, bool longest,
-            StringPiece* submatch, int nsubmatch) {
+            StrPiece* submatch, int nsubmatch) {
   if (start_ == 0)
     return false;
 
-  StringPiece context = const_context;
+  StrPiece context = const_context;
   if (context.begin() == NULL)
     context = text;
 
   if (!StringPieceContains(context, text)) {
-    LOG(FATAL) << "Bad args: context does not contain text "
+    LOG(FATAL) << "Bad args: context does not contain text ";
+    /* Not sure how to get these?
                 << reinterpret_cast<const void*>(context.begin())
                 << "+" << context.size() << " "
                 << reinterpret_cast<const void*>(text.begin())
-                << "+" << text.size();
+                << "+" << text.size();*/
     return false;
   }
 
@@ -443,7 +456,7 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
     ncapture_ = 2;
   }
 
-  match_ = new const char*[ncapture_];
+  match_ = new ptr_type[ncapture_];
   matched_ = false;
   memset(match_, 0, ncapture_*sizeof match_[0]);
 
@@ -462,17 +475,18 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
   runq->clear();
   nextq->clear();
   memset(&match_[0], 0, ncapture_*sizeof match_[0]);
-  const char* bp = context.begin();
+  ptr_type bp = context.begin();
+  ptr_rd_type p = text.begin_reading();
   int c = -1;
   int wasword = 0;
 
   if (text.begin() > context.begin()) {
-    c = text.begin()[-1] & 0xFF;
+    c = p[-1] & 0xFF;
     wasword = Prog::IsWordChar(c);
   }
 
   // Loop over the text, stepping the machine.
-  for (const char* p = text.begin();; p++) {
+  for (;; p++) {
     // Check for empty-width specials.
     int flag = 0;
 
@@ -500,12 +514,12 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
 
     if (Debug) {
       fprintf(stderr, "%c[%#x/%d/%d]:", p > text.end() ? '$' : p == bp ? '^' : c, flag, isword, wasword);
-      for (Threadq::iterator i = runq->begin(); i != runq->end(); ++i) {
+      for (Threadq_iterator i = runq->begin(); i != runq->end(); ++i) {
         Thread* t = i->second;
         if (t == NULL)
           continue;
         fprintf(stderr, " %d%s", t->id,
-                FormatCapture((const char**)t->capture).c_str());
+                FormatCapture(t->capture).c_str());
       }
       fprintf(stderr, "\n");
     }
@@ -568,12 +582,12 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
       // use memchr to search for the byte quickly.
       if (!anchored && first_byte_ >= 0 && runq->size() == 0 &&
           p < text.end() && (p[0] & 0xFF) != first_byte_) {
-        p = reinterpret_cast<const char*>(memchr(p, first_byte_,
-                                                 text.end() - p));
-        if (p == NULL) {
+        ptr_type got = text.find_c(p, text.end(), first_byte_);
+        if (got == NULL) {
           p = text.end();
           isword = 0;
         } else {
+          p = got;
           isword = Prog::IsWordChar(p[0] & 0xFF);
         }
         flag = Prog::EmptyFlags(context, p);
@@ -583,7 +597,7 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
       // temporarily to hold match boundaries for new thread.
       match_[0] = p;
       AddToThreadq(runq, start_, flag, p, match_);
-      match_[0] = NULL;
+      match_[0] = StrPiece::null_ptr();
     }
 
     // If all the threads have died, stop early.
@@ -600,14 +614,70 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
     wasword = isword;
 
     // Will run step(runq, nextq, c, ...) on next iteration.  See above.
+
+    // Occasionally compute the minimum match position in
+    // runq and let e.g. a FILE* know that it can drop
+    // buffers from earlier portions.
+    if ( text.can_discard(p - bp) ) {
+      ptr_type min_start = p;
+      ptr_type min_end = p;
+      ptr_type min_cap = p;
+
+      if( matched_ ) {
+        if( match_[0] - min_start < 0 ) min_start = match_[0];
+        if( match_[1] - min_end < 0 ) min_end = match_[1];
+        for (int k = 2; k < ncapture_; k+=2 ) {
+          if( match_[k] - min_cap < 0 ) min_cap = match_[k];
+        }
+      } else if( anchored ) {
+        min_start = bp;
+        min_cap = bp; // we havn't matched yet.
+      }
+
+      // Go through the currently-under-simulation NFA states
+      // and update min_start and min_cap. These states do not
+      // update min_end because if min_end was definately less
+      // than p we would have alrady removed that state from
+      // simulation (since it already ended).
+      for (Threadq_iterator i = runq->begin(); i != runq->end(); ++i) {
+        Thread* t = i->second;
+        if (t == NULL)
+          continue;
+
+        if (Debug) {
+          for( int k = 0; k < ncapture_; k++ ) {
+            printf("%i cap[%i] = %i\n", (int) t->id, (int) k,
+                   (int) (t->capture[k] - bp));
+          }
+        }
+
+        //if ( t->capture[0] - min_start < 0 ) { // ie start < min_start
+        if ( t->capture[0] < min_start ) { // ie start < min_start
+          min_start = t->capture[0];
+        }
+        /*
+        if ( t->capture[1] - t->capture[0] >= 0 && // end >= beginning
+             t->capture[1] - min_end < 0 ) { // ie end < min_end
+          min_end = t->capture[1];
+        }*/
+
+        for (int k = 2; k < ncapture_; k+=2 ) {
+          if ( t->capture[k] - min_cap < 0 ) { // ie start < min
+            min_cap = t->capture[k];
+          }
+        }
+      }
+      // Let e.g. a FILE* know of the minimum starting position.
+      text.discard(matched_, min_start, min_end, min_cap);
+    }
   }
 
-  for (Threadq::iterator i = runq->begin(); i != runq->end(); ++i)
+  for (Threadq_iterator i = runq->begin(); i != runq->end(); ++i)
     FreeThread(i->second);
 
   if (matched_) {
     for (int i = 0; i < nsubmatch; i++)
-      submatch[i].set(match_[2*i], match_[2*i+1] - match_[2*i]);
+      submatch[i].set_ptr_end(match_[2*i], match_[2*i+1]);
     if (Debug)
       fprintf(stderr, "match (%d,%d)\n",
               static_cast<int>(match_[0] - btext_),
@@ -618,9 +688,10 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
   return false;
 }
 
+ private:
 // Computes whether all successful matches have a common first byte,
 // and if so, returns that byte.  If not, returns -1.
-int NFA::ComputeFirstByte() {
+int ComputeFirstByte() {
   if (start_ == 0)
     return -1;
 
@@ -682,15 +753,18 @@ int NFA::ComputeFirstByte() {
   return b;
 }
 
-bool
-Prog::SearchNFA(const StringPiece& text, const StringPiece& context,
-                Anchor anchor, MatchKind kind,
-                StringPiece* match, int nmatch) {
-  if (NFA::Debug)
+
+}; // end NFA class body
+
+template<typename StrPiece>
+bool Prog::SearchNFA(const StrPiece& text, const StrPiece& context,
+                     Anchor anchor, MatchKind kind,
+                     StrPiece* match, int nmatch) {
+  if (NFA<StrPiece>::Debug)
     Dump();
 
-  NFA nfa(this);
-  StringPiece sp;
+  NFA<StrPiece> nfa(this);
+  StrPiece sp;
   if (kind == kFullMatch) {
     anchor = kAnchored;
     if (nmatch == 0) {
@@ -705,5 +779,19 @@ Prog::SearchNFA(const StringPiece& text, const StringPiece& context,
   return true;
 }
 
+template
+bool
+Prog::SearchNFA<StringPiece>(
+     const StringPiece& text, const StringPiece& context,
+     Anchor anchor, MatchKind kind,
+     StringPiece* match, int nmatch);
+
+template
+bool
+Prog::SearchNFA<FilePiece>(
+    const FilePiece& text, const FilePiece& context,
+    Anchor anchor, MatchKind kind,
+    FilePiece* match, int nmatch);
+
 }  // namespace re2
 
diff --git a/re2/onepass.cc b/re2/onepass.cc
index 1c49988..907c90c 100644
--- a/re2/onepass.cc
+++ b/re2/onepass.cc
@@ -179,7 +179,8 @@ void OnePass_Checks() {
                  kMaxCap_disagrees_with_kMaxOnePassCapture);
 }
 
-static bool Satisfy(uint32 cond, const StringPiece& context, const char* p) {
+template<typename StrPiece>
+static bool Satisfy(uint32 cond, const StrPiece& context, typename StrPiece::ptr_rd_type p) {
   uint32 satisfied = Prog::EmptyFlags(context, p);
   if (cond & kEmptyAllFlags & ~satisfied)
     return false;
@@ -188,8 +189,9 @@ static bool Satisfy(uint32 cond, const StringPiece& context, const char* p) {
 
 // Apply the capture bits in cond, saving p to the appropriate
 // locations in cap[].
-static void ApplyCaptures(uint32 cond, const char* p,
-                          const char** cap, int ncap) {
+template<typename ptr_rd_type, typename ptr_type>
+static void ApplyCaptures(uint32 cond, ptr_rd_type p,
+                          ptr_type* cap, int ncap) {
   for (int i = 2; i < ncap; i++)
     if (cond & (1 << kCapShift << i))
       cap[i] = p;
@@ -204,10 +206,14 @@ static inline OneState* IndexToNode(volatile uint8* nodes, int statesize,
     const_cast<uint8*>(nodes + statesize*nodeindex));
 }
 
-bool Prog::SearchOnePass(const StringPiece& text,
-                         const StringPiece& const_context,
+template<typename StrPiece>
+bool Prog::SearchOnePass(const StrPiece& text,
+                         const StrPiece& const_context,
                          Anchor anchor, MatchKind kind,
-                         StringPiece* match, int nmatch) {
+                         StrPiece* match, int nmatch) {
+  typedef typename StrPiece::ptr_type ptr_type;
+  typedef typename StrPiece::ptr_rd_type ptr_rd_type;
+
   if (anchor != kAnchored && kind != kFullMatch) {
     LOG(DFATAL) << "Cannot use SearchOnePass for unanchored matches.";
     return false;
@@ -219,16 +225,16 @@ bool Prog::SearchOnePass(const StringPiece& text,
   if (ncap < 2)
     ncap = 2;
 
-  const char* cap[kMaxCap];
+  ptr_type cap[kMaxCap];
   for (int i = 0; i < ncap; i++)
-    cap[i] = NULL;
+    cap[i] = StrPiece::null_ptr();
 
-  const char* matchcap[kMaxCap];
+  ptr_type matchcap[kMaxCap];
   for (int i = 0; i < ncap; i++)
-    matchcap[i] = NULL;
+    matchcap[i] = StrPiece::null_ptr();
 
-  StringPiece context = const_context;
-  if (context.begin() == NULL)
+  StrPiece context = const_context;
+  if (context.begin() == StrPiece::null_ptr())
     context = text;
   if (anchor_start() && context.begin() != text.begin())
     return false;
@@ -245,14 +251,14 @@ bool Prog::SearchOnePass(const StringPiece& text,
   volatile uint8* nodes = onepass_nodes_;
   volatile uint32 statesize = onepass_statesize_;
   uint8* bytemap = bytemap_;
-  const char* bp = text.begin();
-  const char* ep = text.end();
-  const char* p;
+  ptr_type bp = text.begin();
+  ptr_type ep = text.end();
+  ptr_rd_type p = text.begin_reading();
   bool matched = false;
   matchcap[0] = bp;
   cap[0] = bp;
   uint32 nextmatchcond = state->matchcond;
-  for (p = bp; p < ep; p++) {
+  for (; p < ep; p++) {
     int c = bytemap[*p & 0xFF];
     uint32 matchcond = nextmatchcond;
     uint32 cond = state->action[c];
@@ -289,7 +295,8 @@ bool Prog::SearchOnePass(const StringPiece& text,
     // (e.g., HTTPPartialMatchRE2) it slows the loop by
     // about 10%, but when it avoids work (e.g., DotMatchRE2),
     // it cuts the loop execution by about 45%.
-    if ((cond & kMatchWins) == 0 && (nextmatchcond & kEmptyAllFlags) == 0)
+    if ((cond & kMatchWins) == 0 && (nextmatchcond & kEmptyAllFlags) == 0 &&
+        text.can_discard(p-bp) )
       goto skipmatch;
 
     // Finally, the match conditions must be satisfied.
@@ -300,7 +307,6 @@ bool Prog::SearchOnePass(const StringPiece& text,
         ApplyCaptures(matchcond, p, matchcap, ncap);
       matchcap[1] = p;
       matched = true;
-
       // If we're in longest match mode, we have to keep
       // going and see if we find a longer match.
       // In first match mode, we can stop if the match
@@ -315,6 +321,29 @@ bool Prog::SearchOnePass(const StringPiece& text,
       goto done;
     if ((cond & kCapMask) && nmatch > 1)
       ApplyCaptures(cond, p, cap, ncap);
+
+    // Occasionally compute the minimum match position in
+    // and let e.g. a FILE* know that it can drop
+    // buffers from earlier portions.
+    if ( text.can_discard(p-bp) ) {
+      ptr_type min_start;
+      ptr_type min_end;
+      ptr_type min_cap;
+      // Optimization above might not set matched if there is a certain
+      // match at the next byte.
+      //bool match_or_nextmatch = matched |
+     //   ((cond & kMatchWins) == 0 && (nextmatchcond & kEmptyAllFlags) == 0);
+      min_start = cap[0];
+      if( cap[1] >= cap[0] ) min_end = cap[1];
+      else min_end = p;
+      min_cap = p;
+      for (int k = 2; k < 2*nmatch; k+=2 ) {
+        if ( cap[k] < min_cap ) min_cap = cap[k];
+      }
+      // Let e.g. a FILE* know of the minimum starting position.
+      text.discard(matched, min_start, min_end, min_cap);
+    }
+
   }
 
   // Look for match at end of input.
@@ -335,10 +364,23 @@ done:
   if (!matched)
     return false;
   for (int i = 0; i < nmatch; i++)
-    match[i].set(matchcap[2*i], matchcap[2*i+1] - matchcap[2*i]);
+    match[i].set_ptr_end(matchcap[2*i], matchcap[2*i+1]);
   return true;
 }
 
+template
+bool Prog::SearchOnePass<StringPiece>(
+                         const StringPiece& text,
+                         const StringPiece& const_context,
+                         Anchor anchor, MatchKind kind,
+                         StringPiece* match, int nmatch);
+
+template
+bool Prog::SearchOnePass<FilePiece>(
+                         const FilePiece& text,
+                         const FilePiece& const_context,
+                         Anchor anchor, MatchKind kind,
+                         FilePiece* match, int nmatch);
 
 // Analysis to determine whether a given regexp program is one-pass.
 
diff --git a/re2/prog.cc b/re2/prog.cc
index f326ffd..1f00c2b 100644
--- a/re2/prog.cc
+++ b/re2/prog.cc
@@ -260,7 +260,8 @@ static bool IsMatch(Prog* prog, Prog::Inst* ip) {
   }
 }
 
-uint32 Prog::EmptyFlags(const StringPiece& text, const char* p) {
+template<typename StrPiece>
+uint32 Prog::EmptyFlags(const StrPiece& text, typename StrPiece::ptr_rd_type p) {
   int flags = 0;
 
   // ^ and \A
@@ -294,6 +295,12 @@ uint32 Prog::EmptyFlags(const StringPiece& text, const char* p) {
   return flags;
 }
 
+template
+uint32 Prog::EmptyFlags<StringPiece>(const StringPiece& text, const char* p);
+
+template
+uint32 Prog::EmptyFlags<FilePiece>(const FilePiece& text, FilePiece::ptr_rd_type p);
+
 void Prog::MarkByteRange(int lo, int hi) {
   DCHECK_GE(lo, 0);
   DCHECK_GE(hi, 0);
diff --git a/re2/prog.h b/re2/prog.h
index 2cf65bc..bbcb479 100644
--- a/re2/prog.h
+++ b/re2/prog.h
@@ -228,7 +228,9 @@ class Prog {
 
   // Returns the set of kEmpty flags that are in effect at
   // position p within context.
-  static uint32 EmptyFlags(const StringPiece& context, const char* p);
+  //static uint32 EmptyFlags(const StringPiece& context, const char* p);
+  template<typename StrPiece>
+  static uint32 EmptyFlags(const StrPiece& text, typename StrPiece::ptr_rd_type p);
 
   // Returns whether byte c is a word character: ASCII only.
   // Used by the implementation of \b and \B.
@@ -259,9 +261,10 @@ class Prog {
   // match anything.  Either way, match[i] == NULL.
 
   // Search using NFA: can find submatches but kind of slow.
-  bool SearchNFA(const StringPiece& text, const StringPiece& context,
+  template<typename StrPiece>
+  bool SearchNFA(const StrPiece& text, const StrPiece& context,
                  Anchor anchor, MatchKind kind,
-                 StringPiece* match, int nmatch);
+                 StrPiece* match, int nmatch);
 
   // Search using DFA: much faster than NFA but only finds
   // end of match and can use a lot more memory.
@@ -290,9 +293,11 @@ class Prog {
   // but much faster than NFA (competitive with PCRE)
   // for those expressions.
   bool IsOnePass();
-  bool SearchOnePass(const StringPiece& text, const StringPiece& context,
+
+  template<typename StrPiece>
+  bool SearchOnePass(const StrPiece& text, const StrPiece& context,
                      Anchor anchor, MatchKind kind,
-                     StringPiece* match, int nmatch);
+                     StrPiece* match, int nmatch);
 
   // Bit-state backtracking.  Fast on small cases but uses memory
   // proportional to the product of the program size and the text size.
diff --git a/re2/re2.cc b/re2/re2.cc
index d67ef45..4110e52 100644
--- a/re2/re2.cc
+++ b/re2/re2.cc
@@ -188,6 +188,8 @@ void RE2::Init(const StringPiece& pattern, const Options& options) {
   named_groups_ = NULL;
   group_names_ = NULL;
   num_captures_ = -1;
+  min_match_length_ = 0;
+  max_match_length_ = -1;
 
   RegexpStatus status;
   entire_regexp_ = Regexp::Parse(
@@ -214,6 +216,8 @@ void RE2::Init(const StringPiece& pattern, const Options& options) {
   else
     suffix_regexp_ = entire_regexp_->Incref();
 
+  entire_regexp_->PossibleMatchLength(&min_match_length_, &max_match_length_);
+
   // Two thirds of the memory goes to the forward Prog,
   // one third to the reverse prog, because the forward
   // Prog has two DFAs but the reverse prog has one.
@@ -510,8 +514,9 @@ bool RE2::PossibleMatchRange(string* min, string* max, int maxlen) const {
 
 // Avoid possible locale nonsense in standard strcasecmp.
 // The string a is known to be all lowercase.
-static int ascii_strcasecmp(const char* a, const char* b, int len) {
-  const char *ae = a + len;
+template<typename ptr_type>
+static int ascii_strcasecmp(const char* a, ptr_type b, int len) {
+  const char* ae = a + len;
 
   for (; a < ae; a++, b++) {
     uint8 x = *a;
@@ -784,6 +789,142 @@ bool RE2::Match(const StringPiece& text,
   return true;
 }
 
+bool RE2::MatchFile(FilePiece& text,
+                    const StringPiece& buffer,
+                    Anchor re_anchor,
+                    FilePiece* submatch,
+                    int nsubmatch) const {
+  if (!ok() || suffix_regexp_ == NULL) {
+    if (options_.log_errors())
+      LOG(ERROR) << "Invalid RE2: " << *error_;
+    return false;
+  }
+
+  FilePiece subtext = text;
+
+  // First, we can try an in-memory search with whatever is in the
+  // current buffer. To do that, we just call the other
+  // Match function... If we find a match, we will skip to
+  // the position of the match and continue searching with NFA
+  // or one-pass. If we don't find a match, we will skip
+  // to the first possible position that hasn't been ruled out yet.
+  StringPiece vec[1];
+  int nvec = 1;
+
+  if( nsubmatch == 0 ) nvec = 0;
+
+  int skip = 0;
+
+  if( FilePiece::allow_buffer_search() && re_anchor == UNANCHORED ) {
+    bool found = Match(buffer, 0, buffer.size(), re_anchor, vec, nvec);
+    if( found ) {
+      // If we found a match and that's all we wanted to know...
+      if( nsubmatch == 0 ) return true;
+      // Otherwise, we could be doing a greedy search
+      // that could continue past the end of that buffer.
+      // So advance to that position and then continue.
+      skip = vec[0].begin() - buffer.begin();
+      // we have some kind of match here!
+      re_anchor = ANCHOR_START;
+    } else {
+      // There was no match.
+      // Given the minimum and maximum match lengths...
+      // compute a skip.
+      if( max_match_length_ != -1 &&
+          buffer.size() > max_match_length_ ) {
+        skip = buffer.size() - max_match_length_ - 1;
+      }
+    }
+  }
+
+  if( skip < 0 ) skip = 0;
+  subtext.remove_prefix(skip);
+
+  // The rest of this doesn't use DFA search.
+  //
+  FilePiece match;
+  FilePiece* matchp = &match;
+  if (nsubmatch == 0)
+    matchp = NULL;
+
+  int ncap = 1 + NumberOfCapturingGroups();
+  if (ncap > nsubmatch)
+    ncap = nsubmatch;
+
+  // If the regexp is anchored explicitly, update re_anchor
+  // so that we can potentially fall into a faster case below.
+  if (prog_->anchor_start() && prog_->anchor_end())
+    re_anchor = ANCHOR_BOTH;
+  else if (prog_->anchor_start() && re_anchor != ANCHOR_BOTH)
+    re_anchor = ANCHOR_START;
+
+  // Check for the required prefix, if any.
+  int64_t prefixlen = 0;
+  if (!prefix_.empty()) {
+    prefixlen = prefix_.size();
+    if (prefixlen > subtext.size())
+      return false;
+    if (prefix_foldcase_) {
+      if (ascii_strcasecmp(&prefix_[0], subtext.begin_reading(), prefixlen) != 0)
+        return false;
+    } else {
+      if (re2_memcmp(&prefix_[0], subtext.begin_reading(), prefixlen) != 0)
+        return false;
+    }
+    subtext.remove_prefix(prefixlen);
+    // If there is a required prefix, the anchor must be at least ANCHOR_START.
+    if (re_anchor != ANCHOR_BOTH)
+      re_anchor = ANCHOR_START;
+  }
+
+  Prog::Anchor anchor = Prog::kUnanchored;
+  Prog::MatchKind kind = Prog::kFirstMatch;
+  if (options_.longest_match())
+    kind = Prog::kLongestMatch;
+
+  bool can_one_pass = (is_one_pass_ && ncap <= Prog::kMaxOnePassCapture);
+
+  switch (re_anchor) {
+    default:
+    case UNANCHORED:
+      break;
+    case ANCHOR_BOTH:
+    case ANCHOR_START:
+      if (re_anchor == ANCHOR_BOTH)
+        kind = Prog::kFullMatch;
+      anchor = Prog::kAnchored;
+  }
+
+  {
+    FilePiece subtext1 = subtext;
+    if (can_one_pass && anchor != Prog::kUnanchored) {
+      if (FLAGS_trace_re2)
+        LOG(INFO) << "Match " << trunc(pattern_)
+                  << " using OnePass.";
+      if (!prog_->SearchOnePass(subtext1, text, anchor, kind, submatch, ncap)) {
+        return false;
+      }
+    } else {
+      if (FLAGS_trace_re2)
+        LOG(INFO) << "Match " << trunc(pattern_)
+                  << " using NFA.";
+      if (!prog_->SearchNFA(subtext1, text, anchor, kind, submatch, ncap)) {
+        return false;
+      }
+    }
+  }
+
+  // Adjust overall match for required prefix that we stripped off.
+  if (prefixlen > 0 && nsubmatch > 0)
+    submatch[0].set_ptr_end(submatch[0].begin() - prefixlen,
+                            submatch[0].end());
+
+  // Zero submatches that don't exist in the regexp.
+  for (int i = ncap; i < nsubmatch; i++)
+    submatch[i].clear();
+  return true;
+}
+
 // Internal matcher - like Match() but takes Args not StringPieces.
 bool RE2::DoMatch(const StringPiece& text,
                   Anchor anchor,
diff --git a/re2/re2.h b/re2/re2.h
index 1aabcbc..ba9d4e2 100644
--- a/re2/re2.h
+++ b/re2/re2.h
@@ -298,6 +298,13 @@ class RE2 {
   // to know about prefix_ and prefix_foldcase_.
   re2::Regexp* Regexp() const { return entire_regexp_; }
 
+  // Return the size in bytes of the prefix
+  int prefix_length_bytes() const { return prefix_.size(); }
+  // Return the minimum number of matched bytes
+  int min_match_length_bytes() const { return min_match_length_; }
+  // Return the maximum number of matched bytes or -1 for unbounded
+  int max_match_length_bytes() const { return max_match_length_; }
+
   /***** The useful part: the matching interface *****/
 
   // Matches "text" against "pattern".  If pointer arguments are
@@ -479,6 +486,22 @@ class RE2 {
              StringPiece *match,
              int nmatch) const;
 
+  // Look for a match in something other than a string
+  // (e.g. a FILE*). This function requires a bunch of
+  // support custom to its use in special_strings.h;
+  // consumers of this interface need to update that file
+  // appropriately and link with a modified RE2.
+  //
+  // text is the StringPiece stand-in (e.g. a FILE*).
+  // buffer might be empty, (ie have .data() == NULL). If not,
+  // we assume it is a cached copy of some portion of text,
+  // but not necessarily all of text.
+  bool MatchFile(FilePiece& text,
+                 const StringPiece& buffer,
+                 Anchor anchor,
+                 FilePiece *match,
+                 int nmatch) const;
+
   // Check that the given rewrite string is suitable for use with this
   // regular expression.  It checks that:
   //   * The regular expression has enough parenthesized subexpressions
@@ -739,6 +762,9 @@ class RE2 {
   // Map from capture indices to names
   mutable const map<int, string>* group_names_;
 
+  int           min_match_length_; // min possible match len
+  int           max_match_length_; // max possible match len, -1=unbounded
+
   //DISALLOW_EVIL_CONSTRUCTORS(RE2);
   RE2(const RE2&);
   void operator=(const RE2&);
diff --git a/re2/regexp.cc b/re2/regexp.cc
index a74ceec..4aae773 100644
--- a/re2/regexp.cc
+++ b/re2/regexp.cc
@@ -10,6 +10,9 @@
 #include "re2/stringpiece.h"
 #include "re2/walker-inl.h"
 
+#include <limits>
+#include <algorithm>
+
 namespace re2 {
 
 // Constructor.  Allocates vectors as appropriate for operator.
@@ -928,4 +931,203 @@ CharClass* CharClassBuilder::GetCharClass() {
   return cc;
 }
 
+// Walker for computing min/max match length.
+#define RINF (std::numeric_limits<uint32_t>::max())
+struct Range {
+  uint32_t min;
+  uint32_t max;
+  Range() : min(0), max(RINF) { }
+  Range(uint32_t a, uint32_t b) : min(a), max(b) { }
+};
+// saturating add and multiply
+static inline
+uint32_t radd(uint32_t x, uint32_t y)
+{
+  uint64_t sum;
+  sum = ((uint64_t) x) + ((uint64_t) y);
+  if( sum >= (uint64_t)RINF ) sum = RINF;
+  return (uint32_t) sum;
+}
+static inline
+uint32_t rmult(uint32_t x, int y)
+{
+  uint64_t prod;
+  prod = ((uint64_t) x) * ((uint64_t) y);
+  if( prod >= (uint64_t)RINF ) prod = RINF;
+  return (uint32_t) prod;
+}
+
+static inline
+Range concatRange(Range a, Range b)
+{
+  return Range(radd(a.min,b.min), radd(a.max,b.max));
+}
+static inline
+Range alternateRange(Range a, Range b)
+{
+  return Range(std::min(a.min,b.min), std::max(a.max,b.max));
+}
+// max == -1 means unbounded repeats
+static inline
+Range multiplyRange(Range a, int min, int max)
+{
+  if( max == -1 ) {
+    return Range(rmult(a.min, min), RINF);
+  } else {
+    return Range(rmult(a.min, min), rmult(a.max, max));
+  }
+}
+
+static inline
+Range runeRangeInt(Regexp* re, Rune r)
+{
+  //char str[10];
+  int len;
+  if( (re->parse_flags() & Regexp::Latin1) || r < Runeself ) {
+    len = 1;
+  } else {
+    // len = runetochar(str, &r); but that was causing linker errors.
+    // It's arguably better to inline in any case.
+    if( r <= 0x7F ) len = 1;
+    else if( r <= 0x7FF ) len = 2;
+    else if( r <= 0xFFFF ) len = 3;
+    else len = 4;
+  }
+  return Range(len, len);
+}
+static inline
+Range runeRange(Regexp* re, Rune r)
+{
+  if( (re->parse_flags() & Regexp::FoldCase) && 'a' <= r && r <= 'z' ) {
+    if ('a' <= r && r <= 'z') r += 'A' - 'a';
+    // Do it for both uppercase and lowercase.
+    return alternateRange(runeRangeInt(re, r), runeRangeInt(re, r + 'a' - 'A'));
+  } else {
+    return runeRangeInt(re, r);
+  }
+}
+
+
+class SizeWalker : public Regexp::Walker<Range> {
+ public:
+  SizeWalker() { }
+  Range PostVisit(Regexp* re, Range parent_arg, Range pre_arg,
+                  Range* child_args, int nchild_args);
+
+  Range ShortVisit(Regexp* re, Range a) {
+    Range ret;
+    return ret;
+  }
+
+ private:
+  DISALLOW_EVIL_CONSTRUCTORS(SizeWalker);
+};
+
+// Visits re after children are processed.
+// For childless regexps, all the work is done here.
+// For regexps with children, append any unary suffixes or ).
+Range SizeWalker::PostVisit(Regexp* re, Range parent_arg, Range pre_arg,
+                            Range* child_args, int nchild_args) {
+  switch (re->op()) {
+    case kRegexpNoMatch:
+      return Range(0,0);
+
+    case kRegexpEmptyMatch:
+      return Range(0,1);
+
+    case kRegexpLiteral:
+      return runeRange(re, re->rune());
+
+    case kRegexpLiteralString: {
+      Range ret(0,0);
+      for (int i = 0; i < re->nrunes(); i++)
+        ret = concatRange(ret, runeRange(re, re->runes()[i]));
+      return ret;
+    }
+
+    case kRegexpConcat: {
+      Range ret = child_args[0];
+      for (int i = 1; i < nchild_args; i++ )
+        ret = concatRange(ret, child_args[i]);
+      return ret;
+    }
+
+    case kRegexpAlternate: {
+      Range ret = child_args[0];
+      for (int i = 1; i < nchild_args; i++ )
+        ret = alternateRange(ret, child_args[i]);
+      return ret;
+    }
+
+    case kRegexpStar:
+      return Range(0, RINF);
+
+    case kRegexpPlus:
+      return multiplyRange(child_args[0], 1, -1);
+
+    case kRegexpQuest:
+      return Range(0, child_args[0].max);
+
+    case kRegexpRepeat:
+      return multiplyRange(child_args[0], re->min(), re->max());
+
+    case kRegexpAnyChar:
+      if( (re->parse_flags() & Regexp::Latin1) ) return Range(1,1);
+      else return Range(1,UTFmax);
+
+    case kRegexpAnyByte:
+      return Range(1,1);
+
+    case kRegexpBeginLine:
+      return Range(0,1);
+
+    case kRegexpEndLine:
+      return Range(0,1);
+
+    case kRegexpBeginText:
+      return Range(0,1);
+
+    case kRegexpEndText:
+      return Range(0,1);
+
+    case kRegexpWordBoundary:
+      return Range(0,1);
+
+    case kRegexpNoWordBoundary:
+      return Range(0,1);
+
+    case kRegexpCharClass: {
+      Range ret(1,1);
+      for (CharClass::iterator i = re->cc()->begin(); i != re->cc()->end(); ++i) {
+        ret = alternateRange(ret,
+                 alternateRange(runeRange(re, i->lo), runeRange(re, i->hi)));
+      }
+      return ret;
+    }
+
+    case kRegexpCapture:
+      // Just grouping.
+      return child_args[0];
+
+    case kRegexpHaveMatch:
+      return Range(0,0);
+  }
+
+  return Range();
+}
+
+void Regexp::PossibleMatchLength(int *min, int *max) {
+  SizeWalker w;
+  Range top;
+  Range r = w.WalkExponential(this, top, 10000);
+  if (w.stopped_early()) {
+    *min = 0;
+    *max = -1;
+  } else {
+    *min = r.min;
+    if( r.max >= std::numeric_limits<int>::max() ) *max = -1;
+    else *max = r.max;
+  }
+}
+
 }  // namespace re2
diff --git a/re2/regexp.h b/re2/regexp.h
index 331c017..dc1d0bc 100644
--- a/re2/regexp.h
+++ b/re2/regexp.h
@@ -429,6 +429,9 @@ class Regexp {
   // follows it.
   bool RequiredPrefix(string* prefix, bool *foldcase, Regexp** suffix);
 
+  // Computes the minimum and maximum match length.
+  // -1 to mean unbounded, and min might be 0.
+  void PossibleMatchLength(int *min, int *max);
  private:
   // Constructor allocates vectors as appropriate for operator.
   explicit Regexp(RegexpOp op, ParseFlags parse_flags);
diff --git a/re2/stringpiece.h b/re2/stringpiece.h
index ab9297c..abca2a5 100644
--- a/re2/stringpiece.h
+++ b/re2/stringpiece.h
@@ -24,6 +24,7 @@
 #include <iosfwd>
 #include <string>
 
+
 namespace re2 {
 
 class StringPiece {
@@ -32,6 +33,15 @@ class StringPiece {
   int           length_;
 
  public:
+  // This for supporting other StringPiece-like things
+  // (e.g. match on a FILE*)
+  typedef const char* ptr_type;
+  typedef const char* ptr_rd_type;
+  static bool can_discard(long diff) { return false; }
+  static int discard_check_period() { return 0; }
+  void discard(bool match, ptr_type match_start, ptr_type match_end, ptr_type min_cap) const { }
+  static const char* null_ptr() { return NULL; }
+
   // We provide non-explicit singleton constructors so users can pass
   // in a "const char*" or a "string" wherever a "StringPiece" is
   // expected.
@@ -53,6 +63,9 @@ class StringPiece {
 
   void clear() { ptr_ = NULL; length_ = 0; }
   void set(const char* data, int len) { ptr_ = data; length_ = len; }
+  void set_ptr_end(const char* data, const char* end) {
+    set(data, end - data);
+  }
   void set(const char* str) {
     ptr_ = str;
     if (str != NULL)
@@ -112,6 +125,13 @@ class StringPiece {
             (memcmp(ptr_ + (length_-x.length_), x.ptr_, x.length_) == 0));
   }
 
+  // Find the position where c occurs (ie memchr)
+  // uses begin, end pointers
+  const char* find_c(const char* s, const char* end, int c) const
+  {
+    return reinterpret_cast<const char*>(memchr(s, c, end - s));
+  }
+
   // standard STL container boilerplate
   typedef char value_type;
   typedef const char* pointer;
@@ -125,6 +145,8 @@ class StringPiece {
   typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
   typedef std::reverse_iterator<iterator> reverse_iterator;
   iterator begin() const { return ptr_; }
+  // Also define begin_reading
+  iterator begin_reading() const { return ptr_; }
   iterator end() const { return ptr_ + length_; }
   const_reverse_iterator rbegin() const {
     return const_reverse_iterator(ptr_ + length_);
@@ -174,9 +196,17 @@ inline bool operator>=(const StringPiece& x, const StringPiece& y) {
   return !(x < y);
 }
 
+/*inline const char* re2_memrchr(const char* s, int c, size_t n)
+{
+  return reinterpret_cast<const char*>(memrchr(s, c, n));
+}
+*/
+
 }  // namespace re2
 
 // allow StringPiece to be logged
 extern std::ostream& operator<<(std::ostream& o, const re2::StringPiece& piece);
 
+#include "file_strings.h"
+
 #endif  // STRINGS_STRINGPIECE_H__
diff --git a/util/sparse_array.h b/util/sparse_array.h
index 3e33f89..400946f 100644
--- a/util/sparse_array.h
+++ b/util/sparse_array.h
@@ -270,13 +270,15 @@ void SparseArray<Value>::resize(int new_max_size) {
   DebugCheckInvariants();
   if (new_max_size > max_size_) {
     int* a = new int[new_max_size];
+
+    // Don't need to zero the memory but appease Valgrind.
+    if (valgrind_) {
+      for (int i = max_size_; i < new_max_size; i++)
+        a[i] = 0xababababU;
+    }
+
     if (sparse_to_dense_) {
-      memmove(a, sparse_to_dense_, max_size_*sizeof a[0]);
-      // Don't need to zero the memory but appease Valgrind.
-      if (valgrind_) {
-        for (int i = max_size_; i < new_max_size; i++)
-          a[i] = 0xababababU;
-      }
+      memcpy(a, sparse_to_dense_, max_size_*sizeof a[0]);
       delete[] sparse_to_dense_;
     }
     sparse_to_dense_ = a;
