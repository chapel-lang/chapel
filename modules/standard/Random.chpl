/*
 * Copyright 2020-2024 Hewlett Packard Enterprise Development LP
 * Copyright 2004-2019 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
    Support for pseudorandom number generation.

    This module provides the :record:`randomStream` type that represents a
    conceptual stream of random numbers of a particular scalar type. Individual
    numbers can be generated with :proc:`randomStream.next`, or an iterable
    sequence of numbers can be generated by providing a domain argument to
    ``next``. The stream's position in its sequence can be updated with
    :proc:`randomStream.skipTo`. Additionally, there are several methods for
    generating random numbers from arrays, domains, and ranges.

    This module also contains a few top-level procedures for doing common tasks
    with pseudorandom numbers:

    * :proc:`fillRandom` fills an array with random numbers in parallel
    * :proc:`shuffle` randomly re-arranges the elements of an array
    * :proc:`permute` create a random permutation of an array, domain, or range
    * :proc:`choose` randomly selects an element from an array, domain, or range
    * :proc:`sample` randomly samples elements from an array, domain, or range

    These procedures will create a temporary ``randomStream`` and then call the
    corresponding method on it. For repeated use of one or more of the above
    operations, it is recommended to create a :record:``randomStream`` and call
    the relevant method on it repeatedly.

    Seed Generation
    ---------------

    The :record:`randomStream` type can be initialized with a seed value. Any
    two ``randomStream``'s initialized with the same seed value will produce
    identical sequences of random numbers.

    When not provided explicitly, a seed value will be generated in an
    implementation specific manner which is designed to minimize the chance
    that two distinct ``randomStream``'s will have the same seed.

    Future Work
    -----------

    In a future release, we intend to use Chapel's interface features to
    define one or more interfaces for random streams. At that point, the
    :record:`randomStream` type will be an implementation of the interface(s)
    for generating a seedable stream of random numbers.

    We'd also like to experiment with adding a thread-safe and type-agnostic
    random number generator that can be used as a "global" random number
    generator.

    Random Procedures and Types
    ---------------------------
*/
module Random {

  private use IO;
  private use Math;
  private use PCGRandomLib;

  private proc isNumericOrBoolType(type t) param do
    return isNumericType(t) || isBoolType(t);

  private proc is1DRectangularDomain(d) param do
    return d.isRectangular() && d.rank == 1;

  private proc randomishSeed(): int {
    import Time, IO, CTypes;
    extern proc chpl_task_getId(): chpl_taskID_t;
    extern proc getpid(): CTypes.c_int;

    const sWho = chpl_task_getId().hash():int,
          sWhat = (getpid():int).hash():int,
          sWhen = Time.timeSinceEpoch().totalSeconds().hash():int,
          sWhere = here.hash():int;

    var randomBits: int = 0;
    // TODO: separate the "`/dev/urandom` doesn't exist" error handling from the
    //        readBits error handling
    try {
      IO.openReader("/dev/urandom", region=0..<8, locking=false).readBits(randomBits, 64);
    } catch {
      // may not be able to open /dev/urandom, ignore this step
    }

    return sWho ^ sWhat ^ sWhen ^ sWhere ^ randomBits;
  }

  /*
    Fill a rectangular array of numeric values with pseudorandom values in
    parallel using a new :record:`randomStream`. The first `arr.size` values
    from the stream will be assigned to the array's elements in row-major
    order. The parallelization strategy is determined by the array.

    :arg arr: An array of numeric values
    :arg seed: The seed to use to create the ``randomStream``

  */
  proc fillRandom(ref arr: [] ?t, seed: int)
    where isNumericOrBoolType(t) && arr.isRectangular()
  {
    var rs = new randomStream(t, seed);
    rs.fill(arr);
  }

  /*
    Fill a rectangular array of numeric values with pseudorandom values in
    parallel using a new :record:`randomStream`. The first `arr.size` values
    from the stream will be assigned to the array's elements in row-major
    order. The parallelization strategy is determined by the array.

    .. note:: a seed will be generated in an implementation specific manner
              that depends on the current time.

    :arg arr: An array of numeric values
  */
  proc fillRandom(ref arr: [] ?t)
    where isNumericOrBoolType(t) && arr.isRectangular()
  {
    var rs = new randomStream(t);
    rs.fill(arr);
  }

  @chpldoc.nodoc
  proc fillRandom(ref arr: [], seed: int) {
    compilerError("'fillRandom' does not support non-rectangular arrays or arrays of non-numeric values");
  }

  @chpldoc.nodoc
  proc fillRandom(ref arr: []) {
    compilerError("'fillRandom' does not support non-rectangular arrays or arrays of non-numeric values");
  }

  /*
    Fill a rectangular array of numeric values with pseudorandom values in
    the range [``min``, ``max``] (inclusive) in parallel using a new
    :record:`randomStream`. The first `arr.size` values from the stream
    will be assigned to the array's elements in row-major order. The
    parallelization strategy is determined by the array.

    :arg arr: An array of numeric values
    :arg min: The (inclusive) lower bound for the random values
    :arg max: The (inclusive) upper bound for the random values
    :arg seed: The seed to use to create the ``randomStream``
  */
  proc fillRandom(ref arr: [] ?t, min: t, max: t, seed: int)
    where isNumericOrBoolType(t) && arr.isRectangular()
  {
    var rs = new randomStream(t, seed);
    rs.fill(arr, min, max);
  }

  /*
    Fill a rectangular array of numeric values with pseudorandom values in
    the range [``min``, ``max``] (inclusive) in parallel using a new
    :record:`randomStream`. The first `arr.size` values from the stream
    will be assigned to the array's elements in row-major order. The
    parallelization strategy is determined by the array.

    .. note:: a seed will be generated in an implementation specific manner
              that depends on the current time.

    :arg arr: An array of numeric values
    :arg min: The (inclusive) lower bound for the random values
    :arg max: The (inclusive) upper bound for the random values
  */
  proc fillRandom(ref arr: [] ?t, min: t, max: t)
    where isNumericOrBoolType(t) && arr.isRectangular()
  {
    var rs = new randomStream(t);
    rs.fill(arr, min, max);
  }

  @chpldoc.nodoc
  proc fillRandom(ref arr: [] ?t, min: t, max: t, seed: int) {
    compilerError("'fillRandom' does not support non-rectangular arrays or arrays of non-numeric values");
  }

  @chpldoc.nodoc
  proc fillRandom(ref arr: [] ?t, min: t, max: t) {
    compilerError("'fillRandom' does not support non-rectangular arrays or arrays of non-numeric values");
  }

  /*
    Use a new :record:`randomStream` to shuffle an array in place.

    :arg arr: A rectangular array to shuffle
    :arg seed: The seed to initialize a ``randomStream`` with
  */
  proc shuffle(ref arr: [?d], seed: int) where d.isRectangular() {
    var rs = new randomStream(d.idxType, seed);
    rs.shuffle(arr);
  }

  /*
    Use a new :record:`randomStream` to shuffle an array in place.

    :arg arr:  A rectangular array to shuffle
  */
  proc shuffle(ref arr: [?d]) where d.isRectangular() {
    var rs = new randomStream(d.idxType);
    rs.shuffle(arr);
  }

  @chpldoc.nodoc
  proc shuffle(ref arr: [], seed: int) {
    compilerError("'shuffle' only supports rectangular arrays");
  }

  @chpldoc.nodoc
  proc shuffle(ref arr: []) {
    compilerError("'shuffle' only supports rectangular arrays");
  }

  /*
    Produce a random permutation of an array's elements

    :arg arr: A rectangular array
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A new array containing each of the values from ``arr`` in a
             pseudo-random order.
  */
  proc permute(const ref arr: [?d] ?t, seed: int): [] t
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType, seed);
    return rs.permute(arr);
  }

  /*
    Produce a random permutation of an array's elements

    :arg arr: A rectangular array

    :return: A new array containing each of the values from ``arr`` in a
             pseudo-random order.
  */
  proc permute(const ref arr: [?d] ?t): [] t
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType);
    return rs.permute(arr);
  }

  @chpldoc.nodoc
  proc permute(const ref arr: [?d] ?t, seed: int): [] t
    do compilerError("'permute' only supports rectangular arrays");

  @chpldoc.nodoc
  proc permute(const ref arr: [?d] ?t): [] t
    do compilerError("'permute' only supports rectangular arrays");

  /*
    Produce a random permutation of the indices in a domain.

    :arg d: A rectangular domain
    :arg seed: The seed to use when creating the ``randomStream``

    :return: An array containing each of the indices from ``d`` in a
             pseudo-random order.
  */
  proc permute(d: domain(?), seed: int): [] d.fullIdxType
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType, seed);
    return rs.permute(d);
  }

  /*
    Produce a random permutation of the indices in a domain.

    :arg d: A rectangular domain

    :return: An array containing each of the indices from ``d`` in a
             pseudo-random order.
  */
  proc permute(d: domain(?)): [] d.fullIdxType
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType);
    return rs.permute(d);
  }

  /*
    Produce a random permutation of the values in a range.

    :arg r: A fully bounded range
    :arg seed: The seed to use when creating the ``randomStream``

    :return: An array containing each of the values from ``r`` in a
              pseudo-random order.
  */
  proc permute(r: range(bounds=boundKind.both, ?), seed: int): [] r.idxType {
    var rs = new randomStream(r.idxType, seed);
    return rs.permute(r);
  }
  /*
    Produce a random permutation of the values in a range.

    :arg r: A fully bounded range

    :return: An array containing each of the values from ``r`` in a
              pseudo-random order.
  */
  proc permute(r: range(bounds=boundKind.both, ?)): [] r.idxType {
    var rs = new randomStream(r.idxType);
    return rs.permute(r);
  }

  /*
    Choose a random element from an array.

    :arg arr: The rectangular array to choose from

    :return: A random element from the array
  */
  proc choose(const ref arr: [?d] ?t): t
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType);
    return rs.choose(arr);
  }

  /*
    Choose a random element from an array.

    :arg arr: The rectangular array to choose from
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A random element from the array
  */
  proc choose(const ref arr: [?d] ?t, seed: int): t
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType, seed);
    return rs.choose(arr);
  }

  @chpldoc.nodoc
  proc choose(const ref arr: [] ?t): t
    do compilerError("'choose' only supports rectangular arrays");

  @chpldoc.nodoc
  proc choose(const ref arr: [] ?t, seed: int): t
    do compilerError("'choose' only supports rectangular arrays");

  /*
    Choose a random index from a domain.

    :arg d: The rectangular domain to choose from

    :return: A random index from the domain
  */
  proc choose(d: domain(?)): d.fullIdxType
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType);
    return rs.choose(d);
  }

  /*
    Choose a random index from a domain.

    :arg d: The rectangular domain to choose from
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A random index from the domain
  */
  proc choose(d: domain(?), seed: int): d.fullIdxType
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType, seed);
    return rs.choose(d);
  }

  /*
    Choose a random value from a range.

    :arg r: A fully bounded range to choose from

    :return: A random value from the range
  */
  proc choose(r: range(bounds=boundKind.both, ?)): r.idxType {
    var rs = new randomStream(r.idxType);
    return rs.choose({r});
  }

  /*
    Choose a random value from a range.

    :arg r: A fully bounded range to choose from
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A random value from the range
  */
  proc choose(r: range(bounds=boundKind.both, ?), seed: int): r.idxType {
    var rs = new randomStream(r.idxType, seed);
    return rs.choose({r});
  }

  /*
    Randomly sample ``n`` elements from an array.

    :arg arr: The rectangular array to sample from
    :arg n: The number of elements to sample
    :arg withReplacement: Whether or not to sample with replacement

    :return: A zero-based 1D array of ``n`` random elements sampled from the array

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                  ``withReplacement=false``. If ``arr`` is
                                  empty.
  */
  proc sample(const ref arr: [?d] ?t, n: int, withReplacement=false): [] t throws
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType);
    return rs.sample(arr, n, withReplacement);
  }

  /*
    Randomly sample ``n`` elements from an array.

    :arg arr: The rectangular array to sample from
    :arg n: The number of elements to sample
    :arg withReplacement: Whether or not to sample with replacement
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A zero-based 1D array of ``n`` random elements sampled from the array

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                  ``withReplacement=false``. If ``arr`` is
                                  empty.
  */
  proc sample(const ref arr: [?d] ?t, n: int, withReplacement=false, seed: int): [] t throws
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType, seed);
    return rs.sample(arr, n, withReplacement);
  }

  /*
    Randomly sample ``n`` elements from an array, where each array element has
    a corresponding weight.

    Elements with relatively larger weights are more likely to be sampled.

    :arg arr: The 1D rectangular array to sample from
    :arg n: The number of elements to sample
    :arg weights: An array of real-valued weights corresponding to the elements in ``arr``
    :arg withReplacement: Whether or not to sample with replacement

    :return: A zero-based 1D array of ``n`` random elements sampled from the array

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                  ``withReplacement=false``. If ``arr`` is
                                  empty. If ``weights`` does not have the same
                                  size as ``arr``.
  */
  proc sample(
    const ref arr: [?d] ?t,
    n: int,
    const ref weights: [?dw] ?wt,
    withReplacement=false
  ): [] t throws
    where is1DRectangularDomain(d) && is1DRectangularDomain(dw) && isRealType(wt)
  {
    if weights.size != arr.size then
      throw new IllegalArgumentError("weights array must have the same size as the array");

    var rs = new randomStream(wt);
    return rs.sample(arr, n, weights, withReplacement);
  }

  /*
    Randomly sample ``n`` elements from an array, where each array element has
    a corresponding weight.

    Elements with relatively larger weights are more likely to be sampled.

    :arg arr: The 1D rectangular array to sample from
    :arg n: The number of elements to sample
    :arg weights: An array of real-valued weights corresponding to the elements in ``arr``
    :arg withReplacement: Whether or not to sample with replacement
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A zero-based 1D array of ``n`` random elements sampled from the array

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                  ``withReplacement=false``. If ``arr`` is
                                  empty. If ``weights`` does not have the same
                                  size as ``arr``.
  */
  proc sample(
    const ref arr: [?d] ?t,
    n: int,
    const ref weights: [?dw] ?wt,
    withReplacement=false,
    seed: int
  ): [] t throws
    where is1DRectangularDomain(d) && is1DRectangularDomain(dw) && isRealType(wt)
  {
    if weights.size != arr.size then
      throw new IllegalArgumentError("weights array must have the same size as the array");

    var rs = new randomStream(wt, seed);
    return rs.sample(arr, n, weights, withReplacement);
  }

  /*
    Randomly sample ``n`` indices from a domain.

    :arg d: The rectangular domain to sample from
    :arg n: The number of indices to sample
    :arg withReplacement: Whether or not to sample with replacement

    :return: A zero-based 1D array of ``n`` random indices sampled from the domain

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                  ``withReplacement=false``. If ``d`` is
                                  empty.
  */
  proc sample(d: domain(?), n: int, withReplacement=false): [] d.fullIdxType throws
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType);
    return rs.sample(d, n, withReplacement);
  }

  /*
    Randomly sample ``n`` indices from a domain.

    :arg d: The rectangular domain to sample from
    :arg n: The number of indices to sample
    :arg withReplacement: Whether or not to sample with replacement
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A zero-based 1D array of ``n`` random indices sampled from the domain

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                  ``withReplacement=false``. If ``d`` is
                                  empty.
  */
  proc sample(d: domain(?), n: int, withReplacement=false, seed: int): [] d.fullIdxType throws
    where d.isRectangular()
  {
    var rs = new randomStream(d.idxType, seed);
    return rs.sample(d, n, withReplacement);
  }

  /*
    Randomly sample ``n`` indices from a domain, where each index has a
    corresponding weight.

    Indices with relatively larger weights are more likely to be sampled.

    :arg d: The 1D rectangular domain to sample from
    :arg n: The number of indices to sample
    :arg weights: An array of real-valued weights corresponding to the indices in ``d``
    :arg withReplacement: Whether or not to sample with replacement

    :return: A zero-based 1D array of ``n`` random indices sampled from the domain

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > d.size`` and
                                  ``withReplacement=false``. If ``d`` is
                                  empty. If ``weights`` does not have the same
                                  size as ``d``.
  */
  proc sample(
    d: domain(?),
    n: int,
    const ref weights: [?dw] ?wt,
    withReplacement=false
  ): [] d.idxType throws
    where is1DRectangularDomain(d) && is1DRectangularDomain(dw) && isRealType(wt)
  {
    if weights.size != d.size then
      throw new IllegalArgumentError("weights array must have the same size as the domain");

    var rs = new randomStream(wt);
    return rs.sample(d, n, weights, withReplacement);
  }

  /*
    Randomly sample ``n`` indices from a domain, where each index has a
    corresponding weight.

    Indices with relatively larger weights are more likely to be sampled.

    :arg d: The 1D rectangular domain to sample from
    :arg n: The number of elements to sample
    :arg weights: An array of real-valued weights corresponding to the elements in ``d``
    :arg withReplacement: Whether or not to sample with replacement
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A zero-based 1D array of ``n`` random indices sampled from the domain

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > d.size`` and
                                  ``withReplacement=false``. If ``d`` is
                                  empty. If ``weights`` does not have the same
                                  size as ``d``.
  */
  proc sample(
    d: domain(?),
    n: int,
    const ref weights: [?dw] ?wt,
    withReplacement=false,
    seed: int
  ): [] d.idxType throws
    where is1DRectangularDomain(d) && is1DRectangularDomain(dw) && isRealType(wt)
  {
    if weights.size != d.size then
      throw new IllegalArgumentError("weights array must have the same size as the domain");

    var rs = new randomStream(wt, seed);
    return rs.sample(d, n, weights, withReplacement);
  }

  /*
    Randomly sample ``n`` values from a range.

    :arg r: A fully bounded range to sample from
    :arg n: The number of values to sample
    :arg withReplacement: Whether or not to sample with replacement

    :return: A zero-based array of ``n`` random values sampled from the range

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > r.size`` and
                                  ``withReplacement=false``. If ``r`` is
                                  empty.
  */
  proc sample(r: range(bounds=boundKind.both, ?), n: int, withReplacement=false): [] r.idxType throws {
    var rs = new randomStream(r.idxType);
    return rs.sample(r, n, withReplacement);
  }

  /*
    Randomly sample ``n`` values from a range.

    :arg r: A fully bounded range to sample from
    :arg n: The number of values to sample
    :arg withReplacement: Whether or not to sample with replacement
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A zero-based array of ``n`` random values sampled from the range

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > r.size`` and
                                  ``withReplacement=false``. If ``r`` is
                                  empty.
  */
  proc sample(r: range(bounds=boundKind.both, ?), n: int, withReplacement=false, seed: int): [] r.idxType throws {
    var rs = new randomStream(r.idxType, seed);
    return rs.sample(r, n, withReplacement);
  }

  /*
    Randomly sample ``n`` values from a range, where each value has a
    corresponding weight.

    Values with relatively larger weights are more likely to be sampled.

    :arg r: A fully bounded range to sample from
    :arg n: The number of values to sample
    :arg weights: An array of real-valued weights corresponding to the values in ``r``
    :arg withReplacement: Whether or not to sample with replacement

    :return: A zero-based array of ``n`` random values sampled from the range

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > r.size`` and
                                  ``withReplacement=false``. If ``r`` is
                                  empty. If ``weights`` does not have the same
                                  size as ``r``.
  */
  proc sample(
    r: range(bounds=boundKind.both, ?),
    n: int,
    const ref weights: [?dw] ?wt,
    withReplacement=false
  ): [] r.idxType throws
    where is1DRectangularDomain(dw) && isRealType(wt)
  {
    if weights.size != r.size then
      throw new IllegalArgumentError("weights array must have the same size as the range");

    var rs = new randomStream(wt);
    return rs.sample(r, n, weights, withReplacement);
  }

  /*
    Randomly sample ``n`` values from a range, where each value has a
    corresponding weight.

    Values with relatively larger weights are more likely to be sampled.

    :arg r: A fully bounded range to sample from
    :arg n: The number of values to sample
    :arg weights: An array of real-valued weights corresponding to the values in ``r``
    :arg withReplacement: Whether or not to sample with replacement
    :arg seed: The seed to use when creating the ``randomStream``

    :return: A zero-based array of ``n`` random values sampled from the range

    :throws IllegalArgumentError: If ``n < 1`` or if ``n > r.size`` and
                                  ``withReplacement=false``. If ``r`` is
                                  empty. If ``weights`` does not have the same
                                  size as ``r``.
  */
  proc sample(
    r: range(bounds=boundKind.both, ?),
    n: int,
    const ref weights: [?dw] ?wt,
    withReplacement=false,
    seed: int
  ): [] r.idxType throws
    where is1DRectangularDomain(dw) && isRealType(wt)
  {
    if weights.size != r.size then
      throw new IllegalArgumentError("weights array must have the same size as the range");

    var rs = new randomStream(wt, seed);
    return rs.sample(r, n, weights, withReplacement);
  }

  /*
    A :record:`randomStream` represents a stream of pseudorandom numbers of a
    particular type. Numeric and bool types are supported.

    Conceptually it can be thought of as an indexed sequence of numbers ranging
    from 0 to infinity. Each index in the sequence corresponds to a random
    number of the specified type. This allows for the generation of random
    numbers in parallel, where each task involved in the parallel iteration can
    request random numbers within a particular range and traverse that range of
    the sequence independently of other tasks (see :proc:`randomStream.next`).

    Although parallel iteration is supported, the type itself is not
    thread-safe. In particular, it is not safe to call methods such as
    :proc:`next` or :proc:`fill` on the same ``randomStream`` from multiple
    tasks concurrently. When multiple tasks need to generate random numbers
    concurrently, a couple of approaches can be taken (other than using a
    parallel safe lock to protect the ``randomStream``):

    * Use the randomStream's parallel iteration methods:

    .. code-block:: chapel

      var A: [1..n] int;
      var rs = new randomStream(int);

      forall (r, a) in zip(rs.next(A.domain), A) do a = r;

    * Create a random stream for each task using task-private variables:

    .. code-block:: chapel

      var A: [1..n] int;

      forall a in A with (var rs = new randomStream(int)) do a = rs.next();


    The ``randomStream`` provides several methods to generate random numbers or
    to manipulate arrays using random numbers:

        * :proc:`randomStream.fill`: fill an array with random numbers
        * :proc:`randomStream.shuffle`: randomly re-arrange the elements of
          an array
        * :proc:`randomStream.permute`: create a random permutation of an
          array, domain, or range
        * :proc:`randomStream.choose` randomly sample an element from an array,
          domain or range
        * :proc:`randomStream.sample` randomly sample elements from an array,
          domain, or range (with or without replacement)

    Note that the module provides top-level counterparts to these methods that
    internally create a ``randomStream`` and then call the corresponding method
    on it — convenient for one-off uses. To generate many random numbers, it is
    generally more efficient to create a ``randomStream`` and call the relevant
    method on it repeatedly.

    An individual random number can be generated using
    :proc:`randomStream.next` which will advance the stream to the next
    position and return the value at that position. The position of the stream
    can also be manipulated directly using :proc:`randomStream.skipTo`.

    When copied, the ``randomStream``'s seed, state, and position in the stream
    will also be copied. This means that the copy and original will produce the
    same sequence of random numbers without affecting each others state.

    .. note:: **Implementation Details:**

      This stream is implemented using the PCG random number generator algorithm.
      See http://www.pcg-random.org/ and the paper, `PCG: A Family
      of Simple Fast Space-Efficient Statistically Good Algorithms for Random
      Number Generation` by M.E. O'Neill.

      This record builds upon the :record:`~PCGRandomLib.pcg_setseq_64_xsh_rr_32_rng`
      PCG RNG which has 64 bits of state and 32 bits of output.

      While the PCG RNG used here is believed to have good statistical
      properties, it is not suitable for generating key material for encryption
      since the output of this RNG may be predictable.
      Additionally, if statistical properties of the random numbers are very
      important, another strategy may be required.

      We have good confidence that the random numbers generated by this record
      match the C PCG reference implementation and have specifically verified
      equal output given the same seed. However, this implementation differs
      from the C PCG reference implementation in how it produces random integers
      within particular bounds (with :proc:`randomStream.next` using ``min``
      and ``max`` arguments). In addition, this implementation directly supports
      the generation of random ``real`` values, unlike the C PCG implementation.

      Smaller numbers, such as ``uint(8)`` or ``uint(16)``, are generated from
      the high-order bits of the 32-bit output.

      To generate larger numbers, several 32-bit-output RNGs are composed
      together. Each of these 32-bit RNGs has a different sequence constant and
      so will be independent and uncorrelated. For example, to generate 128-bit
      complex numbers, this RNG will use four 32-bit PCG RNGs with different
      sequence constants. One impact of this approach is that this implementation
      will only generate 2**64 different complex numbers with a given seed
      (for example).

      This record also supports generating integers within particular bounds.
      When that is required, it uses a strategy different from the PCG
      reference implementation to support efficient parallel iteration. In
      particular, when more than 1 random value is required as part of
      generating a value in a range, conceptually it uses more composed
      RNGs (as with the 32x2 strategy). Each new value beyond the first that
      is computed will be computed with a different RNG. This strategy is meant
      to avoid statistical bias. While we have tested this strategy to our
      satisfaction, it has not been subject to rigorous analysis and may
      have undesirable statistical properties.

      When generating a real, imaginary, or complex number, this implementation
      uses the strategy of generating a 64-bit unsigned integer and then
      multiplying it by 2.0**-64 in order to convert it to a floating point
      number. While this does construct a uniform distribution on rounded
      floating point values, it leaves out many possible real values (for
      example, 2**-128). We believe that this strategy has reasonable
      statistical properties. One side effect of this strategy is that the real
      number 1.0 can be generated because of rounding. The real number 0.0 can
      be generated because PCG can produce the value 0 as a random integer.

      We have tested this implementation with TestU01 (available at
      http://simul.iro.umontreal.ca/testu01/tu01.html ).  We measured our
      implementation with TestU01 1.2.3 and the Crush suite, which consists of
      144 statistical tests. The results were:

       * no failures for generating uniform reals
       * 1 failure for generating 32-bit values (which is also true for the
         reference version of PCG with the same configuration)
       * 0 failures for generating 64-bit values (which we provided to TestU01
         as 2 different 32-bit values since it only accepts 32 bits at a time)
       * 0 failures for generating bounded integers (which we provided to
         TestU01 by requesting values in [0..,2**31+2**30+1) until we
         had two values < 2**31, removing the top 0 bit, and then combining
         the top 16 bits into the value provided to TestU01).


  */
  record randomStream: writeSerializable {
    /*
      Specifies the type of value generated by the random stream. Currently,
      numeric and bool types are supported.
    */
    type eltType;

    /*
      The seed value for the PCG random number generator.
    */
    const seed: int;

    @chpldoc.nodoc
    var PCGRandomStreamPrivate_rngs: numGenerators(eltType) * pcg_setseq_64_xsh_rr_32_rng;

    @chpldoc.nodoc
    var PCGRandomStreamPrivate_count: int(64) = 1;

    /*
      Create a new ``randomStream`` using the specified seed.
    */
    proc init(type eltType, seed: int) where isNumericOrBoolType(eltType) {
      this.eltType = eltType;
      this.seed = seed;

      init this;
      for param i in 0..<numGenerators(eltType) {
        param inc = pcg_getvalid_inc(i+1);
        PCGRandomStreamPrivate_rngs[i].srandom(seed:uint(64), inc);
      }
      PCGRandomStreamPrivate_count = 1;
    }

    /*
      Create a new ``randomStream``.

      A seed value will be generated in an implementation specific manner
      designed to minimize the chance that two distinct invocations of this
      initializer will produce the same seed.
    */
    proc init(type eltType) where isNumericOrBoolType(eltType) {
      this.init(eltType, randomishSeed());
    }

    @chpldoc.nodoc
    proc init(type eltType, seed: int) {
      this.eltType = eltType;
      compilerError("'randomStream' only supports numeric or bool types");
    }

    @chpldoc.nodoc
    proc init(type eltType) {
      this.eltType = eltType;
      compilerError("'randomStream' only supports numeric or bool types");
    }

    /*
      Fill the array with pseudorandom values sampled from this stream in
      parallel.

      :arg arr: The rectangular array to be filled
    */
    proc ref fill(ref arr: [?d]) where arr.isRectangular() {
      forall (x, r) in zip(arr, this.next(d)) do
        x = r;
    }

    /*
      Fill the array with pseudorandom values within a particular range in
      parallel. Each array element is set to a number in [``min``, ``max``]
      (inclusive) sampled from this stream.

      :arg arr: The rectangular array to be filled
      :arg min: The minimum value to sample
      :arg max: The maximum value to sample
    */
    proc ref fill(ref arr: [?d] ?t, min: t, max: t) where arr.isRectangular() {
      forall (x, r) in zip(arr, this.next(d, min, max)) do
        x = r;
    }

    /*
      Randomly rearrange an array using values from this random stream.

      :arg arr: The array to shuffle. Its domain's ``idxType`` should be
                coercible from this stream's :type:`eltType`.
    */
    proc ref shuffle(ref arr: [?d]) where d.isRectangular() && isCoercible(this.eltType, d.idxType) {
      // Fisher-Yates shuffle
      for i in 0..#d.size by -1 {
        const ki = this.next(0:this.eltType, i:this.eltType),
              k = d.orderToIndex(ki),
              j = d.orderToIndex(i);

        arr[k] <=> arr[j];
      }
    }

    /*
      Produce a random permutation of an array's elements

      :arg arr: A rectangular array whose domain's ``idxType``
                must be coercible from this stream's ``eltType``.

      :return: A new array (defined over the domain ``d``) containing each of
               the values from ``arr`` in a pseudo-random order.
    */
    proc ref permute(const ref arr: [?d] ?t): [] t
      where d.isRectangular() && isCoercible(this.eltType, d.idxType)
    {
      const dp = this.permute(d);
      var res: [d] t;
      forall (i, ip) in zip(d, dp) do res[i] = arr[ip];
      return res;
    }

    /*
      Produce a random permutation of the indices in a domain.

      :arg d: A rectangular domain whose ``idxType`` must be coercible
              from this stream's ``eltType``.

      :return: An array (defined over the domain ``d``) containing each of the
               indices from ``d`` in a pseudo-random order.
    */
    proc ref permute(d: domain(?)): [] d.fullIdxType
      where d.isRectangular() && isCoercible(this.eltType, d.idxType)
    {
      var indices: [d] d.fullIdxType,
          count: d.idxType = 0;

      for i in d {
        const j = d.orderToIndex(this.next(0, count));
        count += 1;
        indices[i] = indices[j];
        indices[j] = i;
      }

      return indices;
    }

    /*
      Produce a random permutation of the values in a range.

      :arg r: A fully bounded range whose ``idxType`` must be coercible from
              this stream's ``eltType``.

      :return: An array (defined over the domain ``{r}``) containing each of
               the values from ``r`` in a pseudo-random order.
    */
    proc ref permute(r: range(bounds=boundKind.both, ?)): [] r.idxType
      where isCoercible(this.eltType, r.idxType)
        do return this.permute({r});

    /*
      Choose a random element from an array.

      :arg arr: The rectangular array to choose from. Its domain's ``idxType``
                should be coercible from this stream's ``eltType``.

      :return: A random element from the array
    */
    proc ref choose(const ref arr: [?d] ?t): t
      where d.isRectangular() && isCoercible(this.eltType, d.idxType)
    {
      return arr[this.choose(d)];
    }

    /*
      Choose a random index from a domain.

      :arg d: The rectangular domain to choose from. Its ``idxType`` should
              be coercible from this stream's ``eltType``.

      :return: A random index from the domain
    */
    proc ref choose(d: domain(?)): d.fullIdxType
      where d.isRectangular() && isCoercible(this.eltType, d.idxType)
    {
      return d.orderToIndex(this.next(0:this.eltType, (d.size-1):this.eltType));
    }

    /*
      Choose a random value from a range.

      :arg r: The fully bounded range to choose from. Its ``idxType`` should
              be coercible from this stream's ``eltType``.

      :return: A random value from the range
    */
    proc ref choose(r: range(bounds=boundKind.both, ?)): r.idxType
      where isCoercible(this.eltType, r.idxType)
    {
      return this.choose({r});
    }

    /*
      Sample ``n`` random elements from an array.

      :arg arr: The rectangular array to sample from. Its domain's ``idxType``
                should be coercible from this stream's ``eltType``.
      :arg n: The number of elements to sample
      :arg withReplacement: Whether or not to sample with replacement

      :return: A zero-based 1D array of ``n`` random elements sampled from the array

      :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                    ``withReplacement=false``. If ``arr`` is
                                    empty.
    */
    proc ref sample(const ref arr: [?d] ?t, n: int, withReplacement=false): [] t throws
      where d.isRectangular() && isCoercible(this.eltType, d.idxType)
    {
      if d.size < 1 then
        throw new IllegalArgumentError("Cannot sample from an empty array");

      if n < 1 || (n > d.size && !withReplacement) then
        throw new IllegalArgumentError("Number of samples must be >= 1 and <= arr.size when withReplacement=false");

      const ds = this.sample(d, n, withReplacement);
      var res: [0..<n] t;
      forall (i, di) in zip(res.domain, ds) do res[i] = arr[di];
      return res;
    }

    /*
      Sample ``n`` random elements from an array, where each array element has
      a corresponding weight.

      Elements with relatively larger weights are more likely to be sampled.

      :arg arr: The 1D rectangular array to sample from. Its domain's ``idxType``
                should be coercible from this stream's ``eltType``.
      :arg n: The number of elements to sample
      :arg weights: An array of weights corresponding to the elements in ``arr``
      :arg withReplacement: Whether or not to sample with replacement

      :return: A zero-based 1D array of ``n`` random elements sampled from the array

      :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                    ``withReplacement=false``. If ``arr`` is
                                    empty. If ``weights`` does not have the same
                                    size as ``arr``.
    */
    proc ref sample(
      const ref arr: [?d] ?t,
      n: int,
      const ref weights: [?dw] ?wt,
      withReplacement=false
    ): [] t throws
      where is1DRectangularDomain(d) && isCoercible(this.eltType, wt)
    {
      if d.size < 1 then
        throw new IllegalArgumentError("Cannot sample from an empty array");

      if n < 1 || (n > d.size && !withReplacement) then
        throw new IllegalArgumentError("Number of samples must be >= 1 and <= arr.size when withReplacement=false");

      if d.size != dw.size then
        throw new IllegalArgumentError("'weights' must have the same size as 'arr'");

      const ds = this.sample(d, n, weights, withReplacement);
      var res: [0..<n] t;
      forall (i, di) in zip(res.domain, ds) do res[i] = arr[di];
      return res;
    }

    /*
      Sample ``n`` random indices from a domain.

      :arg d: The rectangular domain to sample from. Its ``idxType`` should
              be coercible from this stream's ``eltType``.
      :arg n: The number of indices to sample
      :arg withReplacement: Whether or not to sample with replacement

      :return: A zero-based 1D array of ``n`` random indices sampled from the domain

      :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                    ``withReplacement=false``. If ``d`` is
                                    empty.
    */
    proc ref sample(d: domain, n: int, withReplacement=false): [] d.fullIdxType throws
      where d.isRectangular() && isCoercible(this.eltType, d.idxType)
    {
      if d.size < 1 then
        throw new IllegalArgumentError("Cannot sample from an empty domain");

      if n < 1 || (n > d.size && !withReplacement) then
        throw new IllegalArgumentError("Number of samples must be >= 1 and <= d.size when withReplacement=false");

      // create an array of n indices
      const dOut = {0..<n};
      var samples: [dOut] d.fullIdxType;

      if withReplacement {
        for s in samples do s = this.choose(d);
      } else {
        if n < log2(d.size) {
          // for a sufficiently small number of indices,
          // use a set to fill 'samples' with n unique values
          var indices: domain(d.fullIdxType, parSafe=false),
              i = 0;
          while i < n {
            const sample = this.choose(d);
            if !indices.contains(sample) {
              samples[i] = sample;
              indices.add(sample);
              i += 1;
            }
          }
        } else {
          // otherwise, shuffle an array of all
          // indices and take the first n of them
          var indices = [idx in d] idx;
          this.shuffle(indices);
          forall i in dOut
            do samples[i] = indices[d.orderToIndex(i)];
        }
      }

      return samples;
    }

    /*
      Sample ``n`` random indices from a domain, where each index has a
      corresponding weight.

      Indices with relatively larger weights are more likely to be sampled.

      :arg d: The 1D rectangular domain to sample from. Its ``idxType`` should
              be coercible from this stream's ``eltType``.
      :arg n: The number of indices to sample
      :arg weights: An array of weights corresponding to the indices in ``d``
      :arg withReplacement: Whether or not to sample with replacement

      :return: A zero-based array of ``n`` random indices sampled from the domain

      :throws IllegalArgumentError: If ``n < 1`` or if ``n > d.size`` and
                                    ``withReplacement=false``. If ``d`` is
                                    empty. If ``weights`` does not have the same
                                    size as ``d``.
    */
    proc ref sample(d: domain, n: int, const ref weights: [?dw] ?wt, withReplacement=false): [] d.idxType throws
      where is1DRectangularDomain(d) && is1DRectangularDomain(dw) && isCoercible(this.eltType, wt)
    {
      import Sort;
      import Search;

      if d.size < 1 then
        throw new IllegalArgumentError("Cannot sample from an empty domain");

      if n < 1 || (n > d.size && !withReplacement) then
        throw new IllegalArgumentError("Number of samples must be >= 1 and <= d.size when withReplacement=false");

      if d.size != dw.size then
        throw new IllegalArgumentError("'weights' must have the same size as 'd'");

      // compute cumulative weights
      var cwn = + scan weights;

      if !Sort.isSorted(cwn) then
        throw new IllegalArgumentError("'weights' cannot contain negative values");

      if abs(cwn[d.size-1]) <= 1e-15 then
        throw new IllegalArgumentError("'weights' must contain at least one non-zero value");

      // normalize for real weights
      if isRealType(wt) then cwn /= cwn[d.size-1];

      const dOut = {0..<n};
      var samples: [dOut] d.idxType,
          sampleHi = if isRealType(wt) then 1.0:eltType else cwn[d.size-1]:eltType;

      if withReplacement {
        for i in dOut {
          const r = this.next(0, sampleHi);
          var ii = 0;
            if isRealType(wt)
              then (_, ii) = Search.binarySearch(cwn, r);
              else ii = binarySearchFirst(cwn, r);
          samples[i] = d.orderToIndex(ii);
        }
      } else {
        var weightsCopy = weights,
            indices: domain(int, parSafe=false),
            i = 0,
            ii = 0;

        while i < n {
          // sample an index that hasn't been sampled yet
          do {
            const r = this.next(0, sampleHi);
            if isRealType(wt)
              then (_, ii) = Search.binarySearch(cwn, r);
              else ii = binarySearchFirst(cwn, r);
          } while indices.contains(ii);

          weightsCopy[ii] = 0;
          indices += ii;
          samples[i] = d.orderToIndex(ii);
          i += 1;

          // recompute cumulative weights
          cwn = + scan weightsCopy;
          if isRealType(wt) then cwn /= cwn[d.size-1];
          sampleHi = if isRealType(wt) then 1.0:eltType else cwn[d.size-1]:eltType;
        }
      }

      return samples;
    }

    /*
      Sample ``n`` random values from a range.

      :arg r: The fully bounded range to sample from. Its ``idxType`` should
              be coercible from this stream's ``eltType``.
      :arg n: The number of values to sample
      :arg withReplacement: Whether or not to sample with replacement

      :return: A zero-based array of ``n`` random values sampled from the range

      :throws IllegalArgumentError: If ``n < 1`` or if ``n > arr.size`` and
                                    ``withReplacement=false``. If ``r`` is
                                    empty.
    */
    proc ref sample(r: range(bounds=boundKind.both, ?), n: int, withReplacement=false): [] r.idxType throws
      where isCoercible(this.eltType, r.idxType)
    {
      if r.size < 1 then
        throw new IllegalArgumentError("Cannot sample from an empty range");

      if n < 1 || (n > r.size && !withReplacement) then
        throw new IllegalArgumentError("Number of samples must be >= 1 and <= r.size when withReplacement=false");

      return this.sample({r}, n, withReplacement);
    }

    /*
      Sample ``n`` random values from a range where each value has a
      corresponding weight.

      Values with relatively larger weights are more likely to be sampled.

      :arg r: The fully bounded range to sample from. Its ``idxType`` should
              be coercible from this stream's ``eltType``.
      :arg n: The number of values to sample
      :arg weights: An array of weights corresponding to the values in ``r``
      :arg withReplacement: Whether or not to sample with replacement

      :return: A zero-based array of ``n`` random values sampled from the range

      :throws IllegalArgumentError: If ``n < 1`` or if ``n > r.size`` and
                                    ``withReplacement=false``. If ``r`` is
                                    empty. If ``weights`` does not have the same
                                    size as ``r``.
    */
    proc ref sample(r: range(bounds=boundKind.both, ?), n: int, const ref weights: [?dw] ?wt, withReplacement=false): [] r.idxType throws
      where is1DRectangularDomain(dw) && isCoercible(this.eltType, wt)
    {
      if r.size < 1 then
        throw new IllegalArgumentError("Cannot sample from an empty range");

      if n < 1 || (n > r.size && !withReplacement) then
        throw new IllegalArgumentError("Number of samples must be >= 1 and <= r.size when withReplacement=false");

      if r.size != dw.size then
        throw new IllegalArgumentError("'weights' must have the same size as 'r'");

      return this.sample({r}, n, weights, withReplacement);
    }

    /*
      Get the next value in the random stream and advance its position by one.

      Generated ``real`` values are in the range ``[0,1]``. Analogously, ``imag``
      and ``complex`` numbers are in the range ``[0i,1i]`` and ``[0+0i,1+1i]``
      respectively.

      Generated integers cover the full range of the type.
    */
    proc ref next(): eltType {
      PCGRandomStreamPrivate_count += 1;
      return randlc(this.eltType, this.PCGRandomStreamPrivate_rngs);
    }

    /*
      Get the next random value from the stream within a given range. Returns
      a number in [``min``, ``max``] (inclusive).

      This method will halt if checks are enabled and ``min > max``.

      .. note::

        For integers, this type uses a strategy for generating a value
        in a particular range that has not been subject to rigorous
        study and may have statistical problems.

        For real numbers, this type generates a random value in [max, min]
        by computing a random value in [0,1] and scaling and shifting that
        value. Note that not all possible floating point values in
        the interval [`min`, `max`] can be constructed in this way.

      :arg min: The minimum value to sample
      :arg max: The maximum value to sample
    */
    proc ref next(min: eltType, max: eltType): eltType {
      use HaltWrappers;
      if boundsChecking && min > max then
        HaltWrappers.boundsCheckHalt("Cannot generate random numbers within empty range: [" + min:string + ", " + max:string +  "]");

      PCGRandomStreamPrivate_count += 1;
      return randlc_bounded(this.eltType, this.PCGRandomStreamPrivate_rngs,
                            this.seed, this.PCGRandomStreamPrivate_count-1, min, max);
    }

    /*
      Return an iterable object yielding values from the random stream.

      For example, a rectangular array ``A`` could be filled with random values using:

      .. code-block:: chapel

        var rs = new randomStream(int),
            A: [1..1000] int;

        forall (a, r) in zip(A, rs.next(A.domain)) do
          a = r;

      *Note that :proc:`randomStream.fill` also serves the same purpose.*

      :arg d: domain associated with the iteration. ``d.size`` values will be yielded
              by the iterator. When ``d`` is the first argument in a zippered iteration,
              its parallelization strategy will be used.
    */
    pragma "fn returns iterator"
    proc ref next(d: domain) {
      const start = this.PCGRandomStreamPrivate_count;
      this.PCGRandomStreamPrivate_count += d.sizeAs(int);
      this.skipTo(this.PCGRandomStreamPrivate_count-1);
      return PCGRandomPrivate_iterate(this.eltType, d, this.seed, start);
    }

    pragma "fn returns iterator"
    @chpldoc.nodoc
    proc next(d: domain, param tag: iterKind)
      where tag == iterKind.leader
    {
      // Note that proc iterate() for the serial case (i.e. the one above)
      // is going to be invoked as well, so we should not be taking
      // any actions here other than the forwarding.
      const start = this.PCGRandomStreamPrivate_count;
      return PCGRandomPrivate_iterate(this.eltType, d, this.seed, start, tag);
    }

    /*
      Return an iterable object yielding values from the random stream within
      a given range.

      :arg d: domain associated with the iteration. ``d.size`` values will be yielded
              by the iterator. When ``d`` is the first argument in a zippered iteration,
              its parallelization strategy will be used.
      :arg min: The minimum value to sample
      :arg max: The maximum value to sample
    */
    pragma "fn returns iterator"
    proc ref next(d: domain, min: eltType, max: eltType) {
      const start = this.PCGRandomStreamPrivate_count;
      this.PCGRandomStreamPrivate_count += d.sizeAs(int);
      this.skipTo(this.PCGRandomStreamPrivate_count-1);

      return PCGRandomPrivate_iterate_bounded(this.eltType, d, this.seed, start,
                                              min, max);
    }

    pragma "fn returns iterator"
    @chpldoc.nodoc
    proc next(d: domain, min: eltType, max: eltType, param tag: iterKind)
      where tag == iterKind.leader
    {
      // Note that proc iterate() for the serial case (i.e. the one above)
      // is going to be invoked as well, so we should not be taking
      // any actions here other than the forwarding.
      const start = this.PCGRandomStreamPrivate_count;
      return PCGRandomPrivate_iterate_bounded(this.eltType, d, this.seed, start,
                                              min, max, tag);
    }

    /*
      Advance or rewind the random stream to the ``n``-th position in the
      pseudorandom sequence (where ``n=0`` is the starting position)

      This method will halt for negative arguments if checks are enabled.

      :arg n: The position to skip to
    */
    proc ref skipTo(n: int) {
      if boundsChecking then
        if n < 0 then halt("cannot skip to a negative position: " + n:string + " in the random stream");

      this.PCGRandomStreamPrivate_count = n+1;
      this.PCGRandomStreamPrivate_rngs = randlc_skipto(this.eltType, this.seed, n+1);
    }

    /*
      serialize the ``randomStream`` as a record with two fields: ``eltType`` and ``seed``.
    */
    proc serialize(writer, ref serializer) throws {
      var ser = serializer.startRecord(writer, "randomStream", 2);
      ser.writeField("eltType", this.eltType:string);
      ser.writeField("seed", this.seed);
      ser.endRecord();
    }
  }

  // Do a binary search of 'a' for the first occurrence of 'x'
  // returns the index of the first occurrence of 'x' in 'a' between 'start' and 'stop'
  // or the index where 'x' should be inserted to maintain sorted order
  // TODO: consider adding this functionality to the Search module
  private proc binarySearchFirst(
    const ref a: [?d] ?t,
    x: t,
    start: d.idxType = d.low,
    stop: d.idxType = d.high
  ): d.idxType
    where isIntegralType(t)
  {
    if start >= stop then return stop;
    const mid = (start + stop) / 2;

    if a[mid] == x then return linSearchLeft(a, x, mid);
    if a[mid] < x then return binarySearchFirst(a, x, mid + 1, stop);
                  else return binarySearchFirst(a, x, start, mid - 1);
  }

  private proc linSearchLeft(const ref a: [?d] ?t, x: t, start: d.idxType): d.idxType {
    var i = start;
    while i > d.low && a[i-1] == x do i -= 1;
    return i;
  }

  // how many generators are needed to support a given element type
  private proc numGenerators(type t) param {
    if isBoolType(t) then return 1;
    else return (numBits(t)+31) / 32;
  }

  //
  // Return a value for the cursor so that the next call to randlc will
  // return the same value as the nth call to randlc
  //
  // resultType is used to compute the size required.
  private proc randlc_skipto(type resultType, seed: int(64), n: integral) {
    var states: numGenerators(resultType) * pcg_setseq_64_xsh_rr_32_rng;

    for param i in 0..states.size-1 {
      param inc = pcg_getvalid_inc(i+1);
      states[i].srandom(seed:uint(64), inc);
      states[i].advance(inc, (n - 1):uint(64));
    }
    return states;
  }

  // Generate a random number of the given type using the provided states
  private inline
  proc randlc(type resultType, ref states) {

    checkSufficientBitsAndAdvanceOthers(resultType, states);

    if resultType == complex(128) {
      return (randToReal64(rand64_1(states)),
              randToReal64(rand64_2(states))):complex(128);
    } else if resultType == complex(64) {
      return (randToReal32(rand32_1(states)),
              randToReal32(rand32_2(states))):complex(64);
    } else if resultType == imag(64) {
      return _r2i(randToReal64(rand64_1(states)));
    } else if resultType == imag(32) {
      return _r2i(randToReal32(rand32_1(states)));
    } else if resultType == real(64) {
      return randToReal64(rand64_1(states));
    } else if resultType == real(32) {
      return randToReal32(rand32_1(states));
    } else if resultType == uint(64) || resultType == int(64) {
      return rand64_1(states):resultType;
    } else if resultType == uint(32) || resultType == int(32) {
      return rand32_1(states):resultType;
    } else if(resultType == uint(16) ||
              resultType == int(16)) {
      return (rand32_1(states) >> 16):resultType;
    } else if(resultType == uint(8) ||
              resultType == int(8)) {
      return (rand32_1(states) >> 24):resultType;
    } else if isBoolType(resultType) {
      return (rand32_1(states) >> 31) != 0;
    }
  }

  // returns x with min <= x <= max (for integers)
  // and min <= x < max (for real/complex/imag)
  // seed should be the initial seed of the RNG
  // count should be the current count value
  private inline
  proc randlc_bounded(type resultType,
                      ref states, seed:int(64), count:int(64),
                      min, max) {

    checkSufficientBitsAndAdvanceOthers(resultType, states);

    if resultType == complex(128) {
      return (randToReal64(rand64_1(states), min.re, max.re),
              randToReal64(rand64_2(states), min.im, max.im)):complex(128);
    } else if resultType == complex(64) {
      return (randToReal32(rand32_1(states), min.re, max.re),
              randToReal32(rand32_2(states), min.im, max.im)):complex(64);
    } else if resultType == imag(64) {
      return _r2i(randToReal64(rand64_1(states), _i2r(min), _i2r(max)));
    } else if resultType == imag(32) {
      return _r2i(randToReal32(rand32_1(states), _i2r(min), _i2r(max)));
    } else if resultType == real(64) {
      return randToReal64(rand64_1(states), min, max);
    } else if resultType == real(32) {
      return randToReal32(rand32_1(states), min, max);
    } else if resultType == uint(64) || resultType == int(64) {
      return (boundedrand64_1(states, seed, count, (max-min):uint(64)) + min:uint(64)):resultType;
    } else if resultType == uint(32) || resultType == int(32) {
      return (boundedrand32_1(states, seed, count, (max-min):uint(32)) + min:uint(32)):resultType;
    } else if(resultType == uint(16) ||
              resultType == int(16)) {
      return (boundedrand32_1(states, seed, count, (max-min):uint(32)) + min:uint(32)):resultType;
    } else if(resultType == uint(8) ||
              resultType == int(8)) {
      return (boundedrand32_1(states, seed, count, (max-min):uint(32)) + min:uint(32)):resultType;
    } else if isBoolType(resultType) {
      compilerError("bounded rand with boolean type");
      return false;
    }
  }

  // returns a random number in [0, 1]
  // where the number is a multiple of 2**-64
  private inline
  proc randToReal64(x: uint(64)):real(64)
  {
    return ldExp(x:real(64), -64);
  }
  // returns a random number in [min, max]
  // by scaling a multiple of 2**-64 by (max-min)
  private inline
  proc randToReal64(x: uint(64), min:real(64), max:real(64)):real(64)
  {
    var normalized = randToReal64(x);
    return (max-min)*normalized + min;
  }

  // returns a random number in [0, 1]
  // where the number is a rounded multiple of 2**-24
  private inline
  proc randToReal32(x: uint(32))
  {
    return ldExp(x:real(32), -32);
  }

  // returns a random number in [min, max)
  // where the number is a multiple of 2**-24
  private inline
  proc randToReal32(x: uint(32), min:real(32), max:real(32)):real(32)
  {
    var normalized = randToReal32(x);
    return (max-min)*normalized + min;
  }


  // These would form the RNG interface.
  private inline
  proc rand32_1(ref states):uint(32) {
    return states[0].random(pcg_getvalid_inc(1));
  }
  private inline
  proc rand32_2(ref states):uint(32) {
    return states[1].random(pcg_getvalid_inc(2));
  }
  // returns x with 0 <= x <= bound
  // count is 1-based
  private inline
  proc boundedrand32_1(ref states, seed:int(64), count:int(64),
                        bound:uint(32)):uint(32) {
    // just get 32 random bits if bound+1 is not representable.
    if bound == max(uint(32)) then return rand32_1(states);
    else return states[0].bounded_random_vary_inc(
        pcg_getvalid_inc(1), bound + 1,
        seed:uint(64), (count - 1):uint(64),
        101, 4);
  }
  // returns x with 0 <= x <= bound
  // count is 1-based
  private inline
  proc boundedrand32_2(ref states, seed:int(64), count:int(64),
                        bound:uint(32)):uint(32) {
    // just get 32 random bits if bound+1 is not representable.
    if bound == max(uint(32)) then return rand32_2(states);
    else return states[1].bounded_random_vary_inc(
        pcg_getvalid_inc(2), bound + 1,
        seed:uint(64), (count - 1):uint(64),
        102, 4);
  }

  private inline
  proc rand64_1(ref states):uint(64) {
    var ret:uint(64) = 0;
    ret |= states[0].random(pcg_getvalid_inc(1));
    ret <<= 32;
    ret |= states[1].random(pcg_getvalid_inc(2));
    return ret;
  }
  private inline
  proc rand64_2(ref states):uint(64) {
    var ret:uint(64) = 0;
    ret |= states[2].random(pcg_getvalid_inc(3));
    ret <<= 32;
    ret |= states[3].random(pcg_getvalid_inc(4));
    return ret;
  }

  // Returns an unsigned integer x with 0 <= x <= bound
  // count is 1-based
  private proc boundedrand64_1(ref states, seed:int(64), count:int(64),
                                bound:uint):uint
  {
    if bound > max(uint(32)):uint {
      var toprand = 0:uint;
      var botrand = 0:uint;

      // compute the bounded number in two calls to a 32-bit RNG
      toprand = boundedrand32_1(states, seed, count, (bound >> 32):uint(32));
      botrand = boundedrand32_2(states, seed, count, (bound & max(uint(32))):uint(32));
      return (toprand << 32) | botrand;
    } else {
      // Generate a # with RNG 1 but ignore it, to keep the
      // stepping consistent.
      rand32_1(states);
      return boundedrand32_2(states, seed, count, bound:uint(32));
    }
  }

  private
  proc checkSufficientBitsAndAdvanceOthers(type resultType, ref states) {
    // Note - this error could be eliminated if we used
    // the same strategy as bounded_rand_vary_inc and
    // just computed the RNGs at the later incs
    param numGenForResultType = numGenerators(resultType);
    param numGen = states.size;
    if numGenForResultType > numGen then
      compilerError("PCGRandomStream cannot produce " +
                    resultType:string +
                    " (requiring " +
                    (32*numGenForResultType):string +
                    " bits) from a stream configured for " +
                    (32*numGen):string +
                    " bits of output");

    // Step each RNG that is not involved in the output.
    for i in numGenForResultType+1..numGen {
      states[i-1].random(pcg_getvalid_inc(i:uint));
    }
  }

  //
  // iterate over outer ranges in tuple of ranges
  //
  private iter outer(ranges, param dim: int = 0) {
    if dim + 2 == ranges.size {
      foreach i in ranges(dim) do
        yield (i,);
    } else if dim + 2 < ranges.size {
      foreach i in ranges(dim) do
        foreach j in outer(ranges, dim+1) do
          yield (i, (...j));
    } else {
      yield 0; // 1D case is a noop
    }
  }

  //
  // PCGRandomStream iterator implementation
  //
  @chpldoc.nodoc
  iter PCGRandomPrivate_iterate(type resultType, D: domain, seed: int(64),
                                start: int(64)) {
    var cursor = randlc_skipto(resultType, seed, start);
    for D do
      yield randlc(resultType, cursor);
  }

  @chpldoc.nodoc
  iter PCGRandomPrivate_iterate(type resultType, D: domain, seed: int(64),
                                start: int(64), param tag: iterKind)
        where tag == iterKind.leader {
    for block in D.these(tag=iterKind.leader) do
      yield block;
  }

  @chpldoc.nodoc
  iter PCGRandomPrivate_iterate(type resultType, D: domain, seed: int(64),
                                start: int(64), param tag: iterKind,
                                followThis)
        where tag == iterKind.follower {
    use DSIUtil;
    param multiplier = 1;
    const ZD = computeZeroBasedDomain(D);
    const innerRange = followThis(ZD.rank-1);
    for outer in outer(followThis) {
      var myStart = start;
      if ZD.rank > 1 then
        myStart += multiplier * ZD.indexOrder(((...outer), innerRange.lowBound)).safeCast(int(64));
      else
        myStart += multiplier * ZD.indexOrder(innerRange.lowBound).safeCast(int(64));
      if innerRange.hasUnitStride() {
        var cursor = randlc_skipto(resultType, seed, myStart);
        for innerRange do
          yield randlc(resultType, cursor);
      } else {
        myStart -= innerRange.lowBound.safeCast(int(64));
        for i in innerRange {
          var cursor = randlc_skipto(resultType, seed, myStart + i.safeCast(int(64)) * multiplier);
          yield randlc(resultType, cursor);
        }
      }
    }
  }

  @chpldoc.nodoc
  iter PCGRandomPrivate_iterate_bounded(type resultType, D: domain,
                                        seed: int(64), start: int(64),
                                        min: resultType, max: resultType) {
    var cursor = randlc_skipto(resultType, seed, start);
    var count = start;
    for D {
      yield randlc_bounded(resultType, cursor, seed, count, min, max);
      count += 1;
    }
  }

  @chpldoc.nodoc
  iter PCGRandomPrivate_iterate_bounded(type resultType, D: domain,
                                        seed: int(64),
                                        start: int(64),
                                        min: resultType, max: resultType,
                                        param tag: iterKind)
        where tag == iterKind.leader {
    for block in D.these(tag=iterKind.leader) do
      yield block;
  }

  @chpldoc.nodoc
  iter PCGRandomPrivate_iterate_bounded(type resultType, D: domain,
                                        seed: int(64), start: int(64),
                                        min: resultType, max: resultType,
                                        param tag: iterKind, followThis)
        where tag == iterKind.follower {
    use DSIUtil;
    param multiplier = 1;
    const ZD = computeZeroBasedDomain(D);
    const innerRange = followThis(ZD.rank-1);
    for outer in outer(followThis) {
      var myStart = start;
      if ZD.rank > 1 then
        myStart += multiplier * ZD.indexOrder(((...outer), innerRange.lowBound)).safeCast(int(64));
      else
        myStart += multiplier * ZD.indexOrder(innerRange.lowBound).safeCast(int(64));
      if innerRange.hasUnitStride() {
        var cursor = randlc_skipto(resultType, seed, myStart);
        var count = myStart;
        for innerRange {
          yield randlc_bounded(resultType, cursor, seed, count, min, max);
          count += 1;
        }
      } else {
        myStart -= innerRange.lowBound.safeCast(int(64));
        for i in innerRange {
          var count = myStart + i.safeCast(int(64)) * multiplier;
          var cursor = randlc_skipto(resultType, seed, count);
          yield randlc_bounded(resultType, cursor, seed, count, min, max);
        }
      }
    }
  }

  /*

   Low-level PCG RNG implementation.

   This module includes a number of low-level PCG random functions.
   See http://www.pcg-random.org/
   and the paper, `PCG: A Family of Simple Fast Space-Efficient Statistically
   Good Algorithms for Random Number Generation` by M.E. O'Neill.

   This module provides the following low-level PCG RNGs:

     * :record:`pcg_setseq_64_xsh_rr_32_rng` (the default PCG RNG)
     * :record:`pcg_setseq_64_rxs_m_xs_64_rng`
     * :record:`pcg_setseq_32_rxs_m_xs_32_rng`
     * :record:`pcg_setseq_16_rxs_m_xs_16_rng`
     * :record:`pcg_setseq_8_rxs_m_xs_8_rng`
     * :record:`pcg_setseq_N_rxs_m_xs_N_rng` which is a generalization of the
       above

   These names come from the PCG paper and reference implementations.  The
   first integer is the number of state bits, and the last integer is the
   number of output bits. The other parts describe the permutation function in
   the LCG.

   Conceptually, a PCG RNG consists of three things:

     * the algorithm variant (e.g. pcg_setseq_64_xsh_rr_32_rng)
     * the current state
     * the RNG sequence constant

   Note that the sequence constant must be odd for this generator to
   function correctly. The function :proc:`pcg_getvalid_inc` is available
   to construct an odd number based upon an arbitrary input.

   When using these low-level interfaces, the sequence constant is not
   actually stored inside the RNG. Instead, users of this interface
   must pass the same sequence constant used in `srandom` to each of
   the other calls for that RNG object.

   Besides storing the RNG state in the record, each of these PCG RNGs
   include at least the following methods:

     * `srandom` to initialize the state from a seed
     * `random` to produce the next random value
     * `advance` to skip ahead some number of steps in RNG generation

   */
  @unstable("the 'PCGRandomLib' module is unstable and may be removed or moved in the future")
  module PCGRandomLib {

    // Translated from PCG-C-basic-0.9
    // Keeping the same function names in order to simplify maintenance
    // These functions correspond to pcg32_random_r in that version.

    // each RNG has a state and an inc value.
    // the inc value does not change as the RNG iterates, but it must always
    // be odd.
    // the state changes and can be any value.


    private
    param PCG_DEFAULT_MULTIPLIER_8 = 141;

    private
    param PCG_DEFAULT_MULTIPLIER_16 = 12829;

    private
    param PCG_DEFAULT_MULTIPLIER_32 = 747796405;

    private
    param PCG_DEFAULT_MULTIPLIER_64 = 6364136223846793005;

    private inline
    proc pcg_setseq_8_step_r(ref state:uint(8), inc:uint(8))
    {
      state = state * PCG_DEFAULT_MULTIPLIER_8 + inc;
    }

    private inline
    proc pcg_setseq_16_step_r(ref state:uint(16), inc:uint(16))
    {
      state = state * PCG_DEFAULT_MULTIPLIER_16 + inc;
    }


    private inline
    proc pcg_setseq_32_step_r(ref state:uint(32), inc:uint(32))
    {
      state = state * PCG_DEFAULT_MULTIPLIER_32 + inc;
    }

    private inline
    proc pcg_setseq_64_step_r(ref state:uint(64), inc:uint(64))
    {
      state = state * PCG_DEFAULT_MULTIPLIER_64 + inc;
    }

    private inline
    proc pcg_rotr_32(value:uint(32), rot:uint(32)):uint(32)
    {
      // having trouble using BitOps...
      pragma "fn synchronization free"
      pragma "codegen for CPU and GPU"
      extern proc chpl_bitops_rotr_32(x: uint(32), n: uint(32)) : uint(32);

      var ret = chpl_bitops_rotr_32(value, rot);
      //writef("\n rotr %i of %xu is %xu\n", rot, value, ret);
      return ret;
    }

    private inline
    proc pcg_output_xsh_rr_64_32(state:uint(64)):uint(32)
    {
      const xorshifted:uint(32) = (((state >> 18) ^ state) >> 27):uint(32);
      const rot:uint(32) = (state >> 59):uint(32);
      const ret = pcg_rotr_32(xorshifted, rot);
      // writef("\n returning r %xu\n", ret);
      return ret;
    }


    private inline
    proc pcg_output_rxs_m_xs_8_8(state:uint(8)):uint(8)
    {
      const word:uint(8) = ((state >> ((state >> 6) + 2)) ^ state) * 217;
      return (word >> 6) ^ word;
    }

    private inline
    proc pcg_output_rxs_m_xs_16_16(state:uint(16)):uint(16)
    {
      const word:uint(16) = ((state >> ((state >> 13) + 3)) ^ state) * 62169;
      return (word >> 11) ^ word;
    }

    private inline
    proc pcg_output_rxs_m_xs_32_32(state:uint(32)):uint(32)
    {
      const word:uint(32) = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
      return (word >> 22) ^ word;
    }

    private inline
    proc pcg_output_rxs_m_xs_64_64(state:uint(64)):uint(64)
    {
      const word:uint(64) = ((state >> ((state >> 59) + 5)) ^ state)
                              * 12605985483714917081;
      return (word >> 43) ^ word;
    }


    /*
       Low-level PCG random number generation interface (64-bits of state,
       32-bits output).

       This record implements the same RNG as pcg32_random_r does in
       PCG-C-0.94.

       This RNG has 64-bits of internal state and outputs 32-bits at a time.

       This RNG will iterate through all possible 64-bit values of state.
       The sequence constant chooses between 2**63 random sequences that the
       RNG is iterating through.

     */
    record pcg_setseq_64_xsh_rr_32_rng {
      /* The RNG state */
      var state:uint(64);

      /* Seed the random number generator.
         This function corresponds to pcg32_srandom_r.

         :arg seed: The initial internal state.
         :arg inc: The sequence constant.
       */
      inline proc ref srandom(seed:uint(64), inc:uint(64))
      {
        // this is pcg_setseq_64_srandom_r

        //state = 0;
        //inc = pcg_getvalid_inc(initseq);
        //pcg_setseq_64_step_r(state, inc); // this just sets state = inc.
        //state += initstate;
        state = inc + seed;
        pcg_setseq_64_step_r(state, inc);
      }

      /* Get the next 32-bit random number.
         This function corresponds to pcg32_random_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :returns: 32 bits generated by the RNG.
       */
      inline proc ref random(inc:uint(64)):uint(32)
      {
        // this is pcg_setseq_64_xsh_rr_32_random_r
        const oldstate:uint(64) = state;
        //writef("\n state=%xu inc=%xu\n", state, inc);
        pcg_setseq_64_step_r(state, inc);
        return pcg_output_xsh_rr_64_32(oldstate);
      }

      /* Generate a random number in [0,bound).

         This function corresponds to pcg32_boundedrand_r and can
         call the random-number generator more than once.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg bound: The returned value will be < `bound`.
         :returns: a random number in [0,bound).
       */
      inline
      proc ref bounded_random(inc:uint(64), bound:uint(32))
      {
            // This comment is from pcg32_boundedrand_r:
            // To avoid bias, we need to make the range of the RNG a multiple of
            // bound, which we do by dropping output less than a threshold.
            // A naive scheme to calculate the threshold would be to do
            //
            //     uint32_t threshold = 0x100000000ull % bound;
            //
            // but 64-bit div/mod is slower than 32-bit div/mod (especially on
            // 32-bit platforms).  In essence, we do
            //
            //     uint32_t threshold = (0x100000000ull-bound) % bound;
            //
            // because this version will calculate the same modulus, but the LHS
            // value is less than 2^32.

        const negbound:uint(32) = ( -(bound:int(32)) ):uint(32);
        const threshold:uint(32) = negbound % bound;
        var tmprng:pcg_setseq_64_xsh_rr_32_rng;
        var tmpinc:uint(64);
        var r:uint(32);

        // Keep trying until we get a random number that is within the bounds.
        while true {
          r = random(inc);
          if r >= threshold then
            return r % bound;
        }

        // never reached.
        return 0;
      }


      /* Generate a random number in [0,bound).

         This function corresponds to pcg32_boundedrand_r, but has one
         difference. Because parallel random number generation relies
         upon advancing to a known position, this function only advances
         the RNG state once per call. Where the pcg32_boundedrand_r would
         advance the RNG state multiple times, this function creates
         a new RNGs with the same initial seed but different sequence
         numbers and uses those when more random numbers are needed.
         In this way, this strategy is similar to the strategy
         for generating 64-bit numbers by pairing 32-bit PCG RNGs.

         .. note::

           The `nextint` and `inc_increment` values need to define a sequence of
           increments that is different from other increments used. Otherwise,
           these streams will not be independent.

         .. note::

           This a strategy for generating a value in a particular range that
           has not been subject to rigorous study and may have statistical
           problems. Additionally, its performance could be improved
           in the case that this function is called many times
           in a row by caching the temporary RNGs at their current position.


         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg bound: The returned value will be < `bound`.
         :arg seed: The seed this RNG started with
         :arg skip: How many numbers, before this one, has this RNG generated?
         :arg nextinc: The first increment to pass to pcg_getvalid_inc and that should be unique for this RNG. Defaults to 100.
         :arg inc_increment: Advance nextinc by inc_increment each time a new value is needed.
         :returns: a random number in [0,bound).
       */
      inline
      proc ref bounded_random_vary_inc(inc:uint(64), bound:uint(32),
                                   seed:uint(64), skip:uint(64),
                                   next_inc:uint(64),
                                   inc_increment:uint(64))
      {
        // unlike the PCG-C version, this version advances the RNG only
        // one iteration - if more iterations are necessary, it computes
        // a paired RNG with different inc each time a new value is needed.

            // This comment is from pcg32_boundedrand_r:
            // To avoid bias, we need to make the range of the RNG a multiple of
            // bound, which we do by dropping output less than a threshold.
            // A naive scheme to calculate the threshold would be to do
            //
            //     uint32_t threshold = 0x100000000ull % bound;
            //
            // but 64-bit div/mod is slower than 32-bit div/mod (especially on
            // 32-bit platforms).  In essence, we do
            //
            //     uint32_t threshold = (0x100000000ull-bound) % bound;
            //
            // because this version will calculate the same modulus, but the LHS
            // value is less than 2^32.

        const negbound:uint(32) = ( -(bound:int(32)) ):uint(32);
        const threshold:uint(32) = negbound % bound;
        var r:uint(32);

        // First, try getting a random number that is within the bounds.
        r = random(inc);

        if r >= threshold then
          return r % bound;

        // not the same as in PCG:
        // If we didn't get the answer we wanted, make a different RNG
        // with the same position and initial seed but with a different
        // inc.

        var newinc:uint(64);
        for newinc in next_inc.. by inc_increment {
          var tmprng:pcg_setseq_64_xsh_rr_32_rng;
          var tmpinc:uint(64);

          tmpinc = pcg_getvalid_inc(newinc);

          // Seed the tmp RNG with the provided seed
          tmprng.srandom(seed, tmpinc);
          // Advance the tmp RNG to the right offset
          tmprng.advance(tmpinc, skip);

          // Get a number from the RNG at that inc.
          r = tmprng.random(tmpinc);

          if r >= threshold then
            return r % bound;
        }

        // never reached.
        return 0;
      }

      /* Advance the RNG. Adjusts the state of the RNG to be the
         same as if `delta` calls were made to `random`.

         This function corresponds to pcg32_advance_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg delta: The number of steps to jump ahead
       */
      inline
      proc ref advance(inc:uint(64), delta:uint(64))
      {
        // this is pcg_setseq_64_advance_r
        state = pcg_advance_lcg(64, state, delta, PCG_DEFAULT_MULTIPLIER_64, inc);
      }
    }

    /*
       Low-level PCG random number generation interface (64-bits of state,
       64-bits output).

       This record implements the same RNG as pcg64i_random_r does
       in PCG-C-0.94.

       This RNG has 64-bits of internal state and outputs 64-bits at a time.

       This generator produces each 64-bit value exactly once.

       This generator should be considered insecure since it reveals
       its entire internal state with each output.

     */
    record pcg_setseq_64_rxs_m_xs_64_rng {
      /* The RNG state */
      var state:uint(64);

      /* Seed the random number generator.
         This function corresponds to pcg64i_srandom_r.

         :arg seed: The initial internal state.
         :arg inc: The sequence constant.
       */
      inline proc srandom(seed:uint(64), inc:uint(64))
      {
        // this is pcg_setseq_64_srandom_r

        state = inc + seed;
        pcg_setseq_64_step_r(state, inc);
      }

      /* Get the next 64-bit random number.
         This function corresponds to pcg64i_random_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :returns: 64 bits generated by the RNG.
       */
      inline proc random(inc:uint(64)):uint(64)
      {
        // this is pcg_setseq_64_rxs_m_xs_64_random_r
        const oldstate:uint(64) = state;
        pcg_setseq_64_step_r(state, inc);
        return pcg_output_rxs_m_xs_64_64(oldstate);
      }

      /* Advance the RNG. Adjusts the state of the RNG to be the
         same as if `delta` calls were made to `random`.

         This function corresponds to pcg64i_advance_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg delta: The number of steps to jump ahead
       */
      inline
      proc advance(inc:uint(64), delta:uint(64))
      {
        // this is pcg_setseq_64_advance_r
        state = pcg_advance_lcg(64, state, delta, PCG_DEFAULT_MULTIPLIER_64, inc);
      }
    }

    /*
       Low-level PCG random number generation interface (32-bits of state,
       32-bits output).

       This record implements the same RNG as pcg32i_random_r does
       in PCG-C-0.94.

       This RNG has 32-bits of internal state and outputs 32-bits at a time.

       This generator produces each 32-bit value exactly once.

       This generator should be considered insecure since it reveals
       its entire internal state with each output.

     */
    record pcg_setseq_32_rxs_m_xs_32_rng {
      /* The RNG state */
      var state:uint(32);

      /* Seed the random number generator.
         This function corresponds to pcg32i_srandom_r.

         :arg seed: The initial internal state.
         :arg inc: The sequence constant
       */
      inline proc srandom(seed:uint(32), inc:uint(32))
      {
        // this is pcg_setseq_32_srandom_r

        state = inc + seed;
        pcg_setseq_32_step_r(state, inc);
      }

      /* Get the next 32-bit random number.
         This function corresponds to pcg32i_random_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :returns: 32 bits generated by the RNG.
       */
      inline proc random(inc:uint(32)):uint(32)
      {
        // this is pcg_setseq_32_rxs_m_xs_32_random_r
        const oldstate:uint(32) = state;
        pcg_setseq_32_step_r(state, inc);
        return pcg_output_rxs_m_xs_32_32(oldstate);
      }

      /* Advance the RNG. Adjusts the state of the RNG to be the
         same as if `delta` calls were made to `random`.

         This function corresponds to pcg32i_advance_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg delta: The number of steps to jump ahead
       */
      inline
      proc advance(inc:uint(32), delta:uint(32))
      {
        // this is pcg_setseq_32_advance_r
        state = pcg_advance_lcg(32, state, delta, PCG_DEFAULT_MULTIPLIER_32, inc);
      }
    }

    /*
       Low-level PCG random number generation interface (16-bits of state,
       16-bits output).

       This record implements the same RNG as pcg16i_random_r does
       in PCG-C-0.94.

       This RNG has 16-bits of internal state and outputs 16-bits at a time.

       This generator produces each 16-bit value exactly once.

       This generator should be considered insecure since it reveals
       its entire internal state with each output.

     */
    record pcg_setseq_16_rxs_m_xs_16_rng {
      /* The RNG state */
      var state:uint(16);

      /* Seed the random number generator.
         This function corresponds to pcg16i_srandom_r.

         :arg seed: The initial internal state.
         :arg inc: The sequence constant
       */
      inline proc srandom(seed:uint(16), inc:uint(16))
      {
        // this is pcg_setseq_16_srandom_r

        state = inc + seed;
        pcg_setseq_16_step_r(state, inc);
      }

      /* Get the next 16-bit random number.
         This function corresponds to pcg16i_random_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :returns: 16 bits generated by the RNG.
       */
      inline proc random(inc:uint(16)):uint(16)
      {
        // this is pcg_setseq_16_rxs_m_xs_16_random_r
        const oldstate:uint(16) = state;
        pcg_setseq_16_step_r(state, inc);
        return pcg_output_rxs_m_xs_16_16(oldstate);
      }

      /* Advance the RNG. Adjusts the state of the RNG to be the
         same as if `delta` calls were made to `random`.

         This function corresponds to pcg16i_advance_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg delta: The number of steps to jump ahead
       */
      inline
      proc advance(inc:uint(16), delta:uint(16))
      {
        // this is pcg_setseq_16_advance_r
        state = pcg_advance_lcg(16, state, delta, PCG_DEFAULT_MULTIPLIER_16, inc);
      }
    }

    /*
       Low-level PCG random number generation interface (8-bits of state,
       8-bits output).

       This record implements the same RNG as pcg8i_random_r does
       in PCG-C-0.94.

       This RNG has 8-bits of internal state and outputs 8-bits at a time.

       This generator produces each 8-bit value exactly once.

       This generator should be considered insecure since it reveals
       its entire internal state with each output.

     */
    record pcg_setseq_8_rxs_m_xs_8_rng {
      /* The RNG state */
      var state:uint(8);

      /* Seed the random number generator.
         This function corresponds to pcg16i_srandom_r.

         :arg seed: The initial internal state.
         :arg inc: The sequence constant
       */
      inline proc ref srandom(seed:uint(8), inc:uint(8))
      {
        // this is pcg_setseq_8_srandom_r

        state = inc + seed;
        pcg_setseq_8_step_r(state, inc);
      }

      /* Get the next 16-bit random number.
         This function corresponds to pcg16i_random_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :returns: 16 bits generated by the RNG.
       */
      inline proc ref random(inc:uint(8)):uint(8)
      {
        // this is pcg_setseq_8_rxs_m_xs_8_random_r
        const oldstate:uint(8) = state;
        pcg_setseq_8_step_r(state, inc);
        return pcg_output_rxs_m_xs_8_8(oldstate);
      }

      /* Advance the RNG. Adjusts the state of the RNG to be the
         same as if `delta` calls were made to `random`.

         This function corresponds to pcg16i_advance_r.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg delta: The number of steps to jump ahead
       */
      inline
      proc advance(inc:uint(8), delta:uint(8))
      {
        // this is pcg_setseq_8_advance_r
        state = pcg_advance_lcg(8, state, delta, PCG_DEFAULT_MULTIPLIER_8, inc);
      }
    }


    private
    proc uint_with_bits(param nbits) type {
      if nbits <= 8 then return uint(8);
      else if nbits <= 16 then return uint(16);
      else if nbits <= 32 then return uint(32);
      else return uint(64);
    }

    // zero all but the bottom nbits of x
    private inline
    proc normalize(nbits:int, x:uint) {
      var oldx = x;
      var shiftamt = 64 - nbits;
      oldx <<= shiftamt;
      return oldx >> shiftamt;
    }


    private
    proc pcg_output_rxs_m_xs_N_mine(nbits:int, state_in)
    {
      // no sense it trying to get randomness for really small examples.
      if nbits < 8 then return state_in;

      if nbits == 8 then return pcg_output_rxs_m_xs_8_8(state_in:uint(8));
      if nbits == 16 then return pcg_output_rxs_m_xs_16_16(state_in:uint(16));
      if nbits == 32 then return pcg_output_rxs_m_xs_32_32(state_in:uint(32));
      if nbits == 64 then return pcg_output_rxs_m_xs_64_64(state_in:uint(64));

      // Generic output function, adapted for a different number of bits.
      {
        var shiftamt = nbits - 4;
        var state = state_in:uint;
        var word:uint = ((state >> ((state >> shiftamt) + 2)) ^ state) * 217;
        word = normalize(nbits, word);
        return (word >> shiftamt) ^ word;
      }
    }


    /*
       Low-level PCG random number generation interface for N bits of
       state, N bits output. This generator can be useful for generating
       a permutation since it produces each N-bit output exactly once
       and N is variable.

       This record implements an N-bit random number generator based upon
       :record:`pcg_setseq_64_rxs_m_xs_64_rng`,
       :record:`pcg_setseq_32_rxs_m_xs_32_rng`,
       :record:`pcg_setseq_16_rxs_m_xs_16_rng`,
       :record:`pcg_setseq_8_rxs_m_xs_8_rng`, and a custom generalization of
       these generators. This generator always truncates its internal state to N
       bits.

       This generator should be considered insecure since it reveals its
       entire internal state with each output.  It produces each N-bit value
       exactly once.

     */
    record pcg_setseq_N_rxs_m_xs_N_rng {
      /* the number of bits in state and in each output random number */
      const N;
      /* The RNG state */
      var state:uint;

      // zero all but the bottom N bits of state
      @chpldoc.nodoc
      inline
      proc ref mask_state() {
        state = normalize(N, state);
      }

      /* Seed the random number generator.

         :arg seed: The initial internal state.
         :arg inc: The sequence constant
       */
      inline proc ref srandom(seed:uint, inc:uint)
      {
        state = inc + seed;
        if N <= 8 {
          var tmpstate = state:uint(8);
          pcg_setseq_8_step_r(tmpstate, inc:uint(8));
          state = tmpstate;
        } else if N <= 16 {
          var tmpstate = state:uint(16);
          pcg_setseq_16_step_r(tmpstate, inc:uint(16));
          state = tmpstate;
        } else if N <= 32 {
          var tmpstate = state:uint(32);
          pcg_setseq_32_step_r(tmpstate, inc:uint(32));
          state = tmpstate;
        } else if N <= 64 {
          pcg_setseq_64_step_r(state, inc);
        }
        mask_state();
      }

      /* Get the next N-bit random number.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :returns: N bits generated by the RNG.
       */
      inline proc ref random(inc:uint):uint
      {
        if N <= 8 {
          var tmpstate = state:uint(8);
          var oldstate = tmpstate;
          pcg_setseq_8_step_r(tmpstate, inc:uint(8));
          state = tmpstate;
          mask_state();
          return normalize(N, pcg_output_rxs_m_xs_N_mine(N, oldstate));
        } else if N <= 16 {
          var tmpstate = state:uint(16);
          var oldstate = tmpstate;
          pcg_setseq_16_step_r(tmpstate, inc:uint(16));
          state = tmpstate;
          mask_state();
          return normalize(N, pcg_output_rxs_m_xs_N_mine(N, oldstate));
        } else if N <= 32 {
          var tmpstate = state:uint(32);
          var oldstate = tmpstate;
          pcg_setseq_32_step_r(tmpstate, inc:uint(32));
          state = tmpstate;
          mask_state();
          return normalize(N, pcg_output_rxs_m_xs_N_mine(N, oldstate));
        } else if N <= 64 {
          var oldstate = state;
          pcg_setseq_64_step_r(state, inc);
          mask_state();
          return normalize(N, pcg_output_rxs_m_xs_N_mine(N, oldstate));
        }
        return 0;
      }

      /* Advance the RNG. Adjusts the state of the RNG to be the
         same as if `delta` calls were made to `random`.

         :arg inc: The sequence constant (same as passed to `srandom`)
         :arg delta: The number of steps to jump ahead
       */
      inline
      proc advance(inc:uint, delta:uint)
      {
        if N <= 8 {
          state = pcg_advance_lcg(8, state:uint(8), delta:uint(8),
                                  PCG_DEFAULT_MULTIPLIER_8, inc:uint(8));
          mask_state();
        } else if N <= 16 {
          state = pcg_advance_lcg(16, state:uint(16), delta:uint(16),
                                  PCG_DEFAULT_MULTIPLIER_16, inc:uint(16));
          mask_state();
        } else if N <= 32 {
          state = pcg_advance_lcg(32, state:uint(32), delta:uint(32),
                                  PCG_DEFAULT_MULTIPLIER_32, inc:uint(32));
          mask_state();
        } else if N <= 64 {
          state = pcg_advance_lcg(64, state, delta, PCG_DEFAULT_MULTIPLIER_64, inc);
          mask_state();
        }
      }
    }

    /* The `inc` field in the PCG RNG must be odd.
       This function arranges for that to be the case given any input.
     */
    inline
    proc pcg_getvalid_inc(initseq:uint(64)):uint(64) do return (initseq<<1) | 1;
    @chpldoc.nodoc // documented in the not param version
    inline
    proc pcg_getvalid_inc(param initseq:uint(64)) param do return (initseq<<1) | 1;


    // pcg_advance_lcg_8/16/32/64
    private
    proc pcg_advance_lcg(param bits,
                         state:uint_with_bits(bits),
                         in delta:uint_with_bits(bits),
                         in cur_mult:uint_with_bits(bits),
                         in cur_plus:uint_with_bits(bits)):uint_with_bits(bits)
    {
      var acc_mult:uint_with_bits(bits) = 1;
      var acc_plus:uint_with_bits(bits) = 0;
      while delta > 0 {
        if (delta & 1) != 0 {
          acc_mult *= cur_mult;
          acc_plus = acc_plus * cur_mult + cur_plus;
        }
        cur_plus = (cur_mult + 1) * cur_plus;
        cur_mult *= cur_mult;
        delta /= 2;
      }
      return acc_mult * state + acc_plus;
    }

  } // end PCGRandomLib

} // close module Random
