#!/usr/bin/env python3
import os
import subprocess as sp
import sys
import re
from typing import Any, Dict, List, Tuple

import parse_dwarf_dump as pdd


class Verifier:
    def __init__(self, target, llvm_dwarfdump, chplenv):
        self.target = target
        self.source = f"{target}.chpl"
        self.llvm_dwarfdump = llvm_dwarfdump
        self.chplenv = chplenv
        self.dwarfDumpTarget = target
        if chplenv["CHPL_LAUNCHER"] != "none":
            self.dwarfDumpTarget += "_real"
        if chplenv["CHPL_TARGET_PLATFORM"] == "darwin":
            self.dwarfDumpTarget += ".dSYM"

    def verify(self):

        if self.chplenv["CHPL_TARGET_PLATFORM"] != "darwin":
            # TODO: skip the verify check on non-macOS platforms for now
            # on non-macOS platforms we may have linked against system
            # libraries ike glibc with debug info and it causes --verify to hang
            return None

        try:
            sp.check_call(
                [
                    self.llvm_dwarfdump,
                    "--debug-info",
                    "--verify",
                    self.dwarfDumpTarget,
                ],
                stdout=sp.PIPE,
                stderr=sp.STDOUT,
            )
        except sp.CalledProcessError as e:
            return e.output.decode().strip()
        return None

    def dump_symbol(self, name, skip_subprograms=True):
        try:
            cmd = [
                self.llvm_dwarfdump,
                self.dwarfDumpTarget,
                "--debug-info",
                "--name",
                name,
                "--show-children",
                "--diff",
            ]
            blocks = pdd.parse_dwarf_dump(sp.check_output(cmd).decode().strip())

            # remove any line with DW_AT_location
            blocks = pdd.filter_per_line(
                blocks, condition=lambda line: "DW_AT_location" not in line
            )

            # replace anything that looks like CHPL_HOME with CHPL_HOME
            chpl_home = self.chplenv.get("CHPL_HOME", "")
            blocks = pdd.filter_per_line(
                blocks,
                modify=lambda line: re.sub(
                    re.escape(chpl_home), "$CHPL_HOME", line
                ),
            )

            # replace anything that looks like `$CHPL_HOME/runtime/src/comm/<>`
            # with `$CHPL_HOME/runtime/src/comm/COMM_IMPL`
            blocks = pdd.filter_per_line(
                blocks,
                modify=lambda line: re.sub(
                    r"\$CHPL_HOME/runtime/src/comm/[^/\s]+",
                    "$CHPL_HOME/runtime/src/comm/COMM_IMPL",
                    line,
                ),
            )

            # sanitize linkage names ending with _chpl\d+
            blocks = pdd.filter_per_line(
                blocks,
                modify=lambda line: re.sub(
                    r'DW_AT_linkage_name\s+\("(.+)_chpl\d+"\)',
                    'DW_AT_linkage_name ("\\1_chplN")',
                    line,
                ),
            )

            # remove DW_AT_APPLE
            blocks = pdd.filter_per_line(
                blocks, condition=lambda line: "DW_AT_APPLE" not in line
            )
            # remove DW_AT_frame_base
            blocks = pdd.filter_per_line(
                blocks, condition=lambda line: "DW_AT_frame_base" not in line
            )
            # remove DW_AT_object_pointer
            blocks = pdd.filter_per_line(
                blocks, condition=lambda line: "DW_AT_object_pointer" not in line
            )

            # filter out internal module line numbers
            def sanitize_internal_lineno(
                block: pdd.DwarfTagBlock,
            ) -> pdd.DwarfTagBlock:
                if block.get_entry(r"\$CHPL_HOME/modules") is not None:
                    # remove lineno info
                    block.filter_entries(
                        modify=lambda line: re.sub(
                            r"DW_AT_decl_line\s+\([0-9]+\)",
                            "DW_AT_decl_line (INTERNAL_LINENO)",
                            line,
                        )
                    )
                return block

            blocks = pdd.filter_per_block(
                blocks, modify=sanitize_internal_lineno
            )

            if skip_subprograms:
                # filter out all DW_TAG_subprogram blocks
                blocks = pdd.filter_per_block(
                    blocks,
                    condition=lambda block: block.tag() != "DW_TAG_subprogram",
                )

            blocks = pdd.deduplicate_blocks(blocks)

            # expand blocks back into output
            output = pdd.dump_blocks(blocks).strip()
            return True, output
        except sp.CalledProcessError as e:
            return (
                False,
                f"Error dumping symbol {name}: {e.output.decode().strip()}",
            )
        except Exception as e:
            return False, f"Error dumping symbol {name}: {str(e)}"

    def find_symbols_to_dump(self):
        symbols: List[Tuple[str, Dict[str, Any]]] = []
        with open(self.source, "r") as f:
            lines = f.readlines()
            for line in lines:
                match = re.search(r"//\s*DWARFDUMP(.*)$", line)
                if match:
                    txt = match.group(1).strip()
                    if txt.startswith(":"):
                        symbol_name = txt[1:].strip()
                        symbols.append((symbol_name, dict()))
                    elif txt.startswith("("):
                        # parse options
                        opt_match = re.match(r"\(([^)]+)\):\s*(.+)$", txt)
                        if opt_match:
                            options_str = opt_match.group(1).strip()
                            symbol_name = opt_match.group(2).strip()
                            options = dict()
                            for opt in options_str.split(","):
                                opt = opt.strip().split("=", maxsplit=1)
                                if len(opt) == 2:
                                    options[opt[0].strip()] = eval(opt[1].strip())
                                else:
                                    options[opt[0].strip()] = True
                            symbols.append((symbol_name, options))
                    else:
                        continue
        return symbols

    def test(self, outfile):
        with open(outfile, "a") as f:
            print("Running DWARF verification...", file=f)
            verify_errors = self.verify()
            if verify_errors:
                print("DWARF verification failed:", file=f)
                print(verify_errors, file=f)
                print("FAIL", file=f)
                sys.exit(1)
            else:
                print("Success!!", file=f)
            print("Running DWARF dump checks...", file=f)
            errors = False
            symbols = self.find_symbols_to_dump()
            for name, opts in symbols:
                lhs = (80 - len(name)) // 2
                rhs = 80 - lhs - len(name)
                print(f"{'='*lhs}{name}{'='*rhs}", file=f)
                success, output = self.dump_symbol(name, **opts)
                errors |= not success
                print(output, file=f)
                print("=" * 80, file=f)
            if errors:
                print("FAIL", file=f)
            else:
                print("Success!!", file=f)


if __name__ == "__main__":
    target = sys.argv[1]
    output_file = sys.argv[2]
    chplenv_lines = (
        sp.check_output(
            [
                os.environ["CHPL_HOME"] + "/util/printchplenv",
                "--all",
                "--internal",
                "--simple",
            ]
        )
        .decode()
        .splitlines()
    )

    chplenv = {k: v for k, v in [line.split("=", 1) for line in chplenv_lines]}
    llvm_bin = (
        sp.check_output([chplenv["CHPL_LLVM_CONFIG"], "--bindir"])
        .decode()
        .strip()
    )
    llvm_dwarfdump = llvm_bin + "/llvm-dwarfdump"

    dwarfDumpTarget = target

    # On OSX we should have built a '.dSYM' archive.
    if chplenv["CHPL_TARGET_PLATFORM"] == "darwin":
        dwarfDumpTarget += ".dSYM"
    if chplenv["CHPL_LAUNCHER"] != "none":
        dwarfDumpTarget += "_real"

    verifier = Verifier(target, llvm_dwarfdump, chplenv)
    verifier.test(output_file)
