AST dump for ChapelRange after pass scopeResolve.
Module use list: ChapelBase SysBasic HaltWrappers Math 

{
  unknown debugChapelRange[66071] "config" "no doc" "param" 0
  unknown useOptimizedRangeIterators[66075] "config" "no doc" "param" 1
  type BoundedRangeType[66087] def bounded[66079]:BoundedRangeType[66087] def boundedLow[66081]:BoundedRangeType[66087] def boundedHigh[66083]:BoundedRangeType[66087] def boundedNone[66085]:BoundedRangeType[66087]
  {
  }
  function range[66183](?).strType[66161](arg _mt[66187]:_MT[227], arg this[66185]:range[66183](?)) type : _unknown[43] "method" "primary method" "no parens"
  {
    (66167 return(66166 call chpl__rangeStrideType(340940 call . this[66185] c"idxType")))
  }
  function range[66183](?).chpl__promotionType[66174](arg _mt[66191]:_MT[227], arg this[66189]:range[66183](?)) type : _unknown[43] "method" "primary method"
  {
    (66177 return(340945 call . this[66189] c"idxType"))
  }
  type range[66183](?) unknown idxType[66094] "type variable" int(64)[13] unknown boundedType[66104] "param" bounded[66079] BoundedRangeType[66087] unknown stridable[66109] "param" 0 bool[10] unknown _low[66116](66115 call chpl__idxTypeToIntIdxType idxType[66094]) unknown _high[66123](66122 call chpl__idxTypeToIntIdxType idxType[66094]) unknown _stride[66135](66132 IfExpr  stridable[66109] then
  { scopeless
    (66130 call chpl__rangeStrideType idxType[66094])
  } else
  { scopeless
    nothing[7]
  } ) unknown _alignment[66147](66144 IfExpr  stridable[66109] then
  { scopeless
    (66142 call chpl__idxTypeToIntIdxType idxType[66094])
  } else
  { scopeless
    nothing[7]
  } ) unknown _aligned[66156](66153 IfExpr  stridable[66109] then
  { scopeless
    bool[10]
  } else
  { scopeless
    nothing[7]
  } )
  function range[66183](?).intIdxType[66197](arg _mt[66202]:_MT[227], arg this[66199]:range[66183](?) :
  range[66183](?)) type : _unknown[43] "method" "no parens"
  {
    (66208 return(66207 call chpl__idxTypeToIntIdxType(340950 call . this[66199] c"idxType")))
  }
  function range[66183](?).init[66220](arg _mt[66285]:_MT[227], arg this[66282]:range[66183](?) :
  range[66183](?), arg idxType[66217]:_any[170](?) =
  int(64)[13], param arg boundedType[66227] :
  BoundedRangeType[66087] =
  bounded[66079], param arg stridable[66233] :
  bool[10] =
  0, arg _low[66243] :
  idxType[66217] =
  (66242 call chpl__intToIdx idxType[66217] 1), arg _high[66253] :
  idxType[66217] =
  (66252 call chpl__intToIdx idxType[66217] 0), arg _stride[66262] :
  (66260 call chpl__rangeStrideType idxType[66217]) =
  1, arg _alignment[66272] :
  idxType[66217] =
  (66271 call chpl__intToIdx idxType[66217] 0), arg _aligned[66278] :
  bool[10] =
  0) : _unknown[43] "method" "no doc" "no return value for void"
  {
    (66292 call =(66288 call . this[66282] c"idxType") idxType[66217])
    (66303 call =(66299 call . this[66282] c"boundedType") boundedType[66227])
    (66311 call =(66307 call . this[66282] c"stridable") stridable[66233])
    (66324 call =(66317 call . this[66282] c"_low")(66323 call chpl__idxToInt _low[66243]))
    (66337 call =(66330 call . this[66282] c"_high")(66336 call chpl__idxToInt _high[66253]))
    (66345 call(66341 call . this[66282] c"complete"))
    if(66382 call _cond_test stridable[66233])
    {
      (66355 call =(66351 call . this[66282] c"_stride") _stride[66262])
      (66369 call =(66362 call . this[66282] c"_alignment")(66368 call chpl__idxToInt _alignment[66272]))
      (66379 call =(66375 call . this[66282] c"_aligned") _aligned[66278])
    }
    if(66400 call _cond_test(66390 call &&(66387 call ! stridable[66233]) 1))
    {
      (66398 call assert(66395 call == _stride[66262] 1))
    }
  }
  function _isAnyNothing[66413](arg args[66410]:_any[170](?) ...) param : _unknown[43] "private"
  {
    {
      unknown i[66440] 0
      unknown tmp[66441] "maybe param" "temp"
      (66453 'move' tmp[66441](66451 call chpl_compute_low_param_loop_bound 1(66418 call . args[66410] c"size")))
      unknown tmp[66442] "maybe param" "temp"
      (66463 'move' tmp[66442](66461 call chpl_compute_high_param_loop_bound 1(66458 call . args[66410] c"size")))
      unknown tmp[66443] "maybe param" "temp"
      (66466 'move' tmp[66443] 1)
      ParamForLoop
      { i[66440] tmp[66441] tmp[66442] tmp[66443]
        {
          if(66434 call _cond_test(66430 call isNothingType(66428 'typeof'(66427 call args[66410] i[66440]))))
          {
            (66432 return 1)
          }
        }
      }
      label _unused_continueLabel[66445]
      label _breakLabel[66444]
    }
    (66479 return 0)
  }
  { scopeless type
    bool[10]
  }
  function range[66183](?).init[66491](arg _mt[66537]:_MT[227], arg this[66534]:range[66183](?) :
  range[66183](?), arg idxType[66488]:_any[170](?) =
  int(64)[13], param arg boundedType[66498] :
  BoundedRangeType[66087] =
  bounded[66079], param arg stridable[66504] :
  bool[10] =
  0, arg _low[66514] :
  idxType[66488] =
  (66513 call chpl__intToIdx idxType[66488] 1), arg _high[66524] :
  idxType[66488] =
  (66523 call chpl__intToIdx idxType[66488] 0), arg _stride[66528]:_any[170](?), arg _alignment[66530]:_any[170](?), arg _aligned[66532]:_any[170](?)) : _unknown[43] "method" "no doc" "no return value for void"
  {
    (66550 call =(66546 call . this[66534] c"idxType") idxType[66488])
    (66559 call =(66555 call . this[66534] c"boundedType") boundedType[66498])
    (66567 call =(66563 call . this[66534] c"stridable") stridable[66504])
    (66578 call =(66571 call . this[66534] c"_low")(66577 call chpl__idxToInt _low[66514]))
    (66589 call =(66582 call . this[66534] c"_high")(66588 call chpl__idxToInt _high[66524]))
    (66597 call(66593 call . this[66534] c"complete"))
    if(66620 call _cond_test stridable[66504])
    {
      (66618 call compilerError "non-stridable range initializer called with stridable=true")
    }
  }
  where {
    (66544 call _isAnyNothing _stride[66528] _alignment[66530] _aligned[66532])
  }
  function range[66183](?).init=[66643](arg _mt[66648]:_MT[227], arg this[66645]:range[66183](?) :
  range[66183](?), arg other[66640] :
  (66639 call range[66183](?) unknown i[66632] unknown b[66635] unknown s[66637])) : _unknown[43] "method" "no doc" "no return value for void"
  {
    unknown idxType[66667] "type variable"(66664 IfExpr (66656 call ==(66652 call .(66651 'typeof' this[66645]) c"idxType") ?[249]) then
    { scopeless
      i[66632]
    } else
    { scopeless
      (66661 call .(66660 'typeof' this[66645]) c"idxType")
    } )
    unknown boundedType[66688] "param"(66685 IfExpr (66677 call ==(66673 call .(66672 'typeof' this[66645]) c"boundedType") ?[249]) then
    { scopeless
      b[66635]
    } else
    { scopeless
      (66682 call .(66681 'typeof' this[66645]) c"boundedType")
    } )
    unknown stridable[66708] "param"(66705 IfExpr (66697 call ==(66693 call .(66692 'typeof' this[66645]) c"stridable") ?[249]) then
    { scopeless
      s[66637]
    } else
    { scopeless
      (66702 call .(66701 'typeof' this[66645]) c"stridable")
    } )
    if(66788 call _cond_test(66713 call != boundedType[66688] b[66635]))
    {
      (66785 call compilerError(66782 call +(66764 call +(66758 call +(66740 call + "range(boundedType="(66738 call _cast string[24](66734 call .(66733 'typeof' this[66645]) c"boundedType"))) ") cannot be initialized from range(boundedType=")(66762 call _cast string[24] b[66635])) ")"))
    }
    if(66818 call _cond_test(66796 call &&(66793 call ! stridable[66708]) s[66637]))
    {
      (66816 call compilerError "cannot initialize a non-stridable range from a stridable range")
    }
    const str[66841] "const"(66838 IfExpr (66825 call && stridable[66708] s[66637]) then
    { scopeless
      (66828 call . other[66640] c"stride")
    } else
    { scopeless
      (66836 call _cast(66835 call chpl__rangeStrideType idxType[66667]) 1)
    } )
    (66888 call(66845 call . this[66645] c"init") idxType[66667] boundedType[66688] stridable[66708](66859 call chpl__intToIdx idxType[66667](66856 call . other[66640] c"_low"))(66867 call chpl__intToIdx idxType[66667](66864 call . other[66640] c"_high")) str[66841](66881 call chpl__intToIdx idxType[66667](66880 call chpl__idxToInt(66876 call . other[66640] c"alignment")))(66885 call . other[66640] c"aligned"))
  }
  function range[66183](?).displayRepresentation[66916](arg _mt[66921]:_MT[227], arg this[66918]:range[66183](?) :
  range[66183](?), arg msg[66912] :
  string[24] =
  "") : _unknown[43] "method" "no doc" "no return value for void"
  {
    (67013 call chpl_debug_writeln msg[66912] "("(66945 call _cast string[24](341043 call . this[66918] c"idxType")) ","(341048 call . this[66918] c"boundedType") ","(341053 call . this[66918] c"stridable") " : "(341057 call . this[66918] c"low") ","(341061 call . this[66918] c"high") ","(341065 call . this[66918] c"stride") ","(67009 IfExpr (341069 call . this[66918] c"aligned") then
    { scopeless
      (66991 call _cast string[24](341073 call . this[66918] c"alignment"))
    } else
    { scopeless
      "\?"
    } ) ")")
  }
  { scopeless type
    void[4]
  }
  function chpl_build_bounded_range[67029](arg low[67026] :
  (67025 call int(64)[13] unknown w[67022]), arg high[67035] :
  (67034 call int(64)[13] w[67022])) : _unknown[43]
  {
    (67050 return(67049 'new'(67048 call range[66183](?)(67042 call int(64)[13] w[67022])(_low = low[67026])(_high = high[67035]))))
  }
  function chpl_build_bounded_range[67065](arg low[67062] :
  (67061 call uint(64)[107] unknown w[67058]), arg high[67071] :
  (67070 call uint(64)[107] w[67058])) : _unknown[43]
  {
    (67086 return(67085 'new'(67084 call range[66183](?)(67078 call uint(64)[107] w[67058])(_low = low[67062])(_high = high[67071]))))
  }
  function chpl_build_bounded_range[67097](arg low[67094] :
  enumerated[179](?), arg high[67100] :
  enumerated[179](?)) : _unknown[43]
  {
    if(67129 call _cond_test(67107 call !=(67104 'typeof' low[67094])(67106 'typeof' high[67100])))
    {
      (67127 call compilerError "ranges of enums must use a single enum type")
    }
    (67145 return(67144 'new'(67143 call range[66183](?)(67137 'typeof' low[67094])(_low = low[67094])(_high = high[67100]))))
  }
  function chpl_build_bounded_range[67155](arg low[67152] :
  bool[10], arg high[67158] :
  bool[10]) : _unknown[43]
  {
    (67170 return(67169 'new'(67168 call range[66183](?) bool[10](_low = low[67152])(_high = high[67158]))))
  }
  function chpl_build_bounded_range[67179](arg low[67177]:_any[170](?), arg high[67181]:_any[170](?)) : _unknown[43] "no return value for void"
  {
    (67201 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_build_low_bounded_range[67212](arg low[67209] :
  integral[188](?)) : _unknown[43]
  {
    (67226 return(67225 'new'(67224 call range[66183](?)(67216 'typeof' low[67209]) boundedLow[66081](_low = low[67209]))))
  }
  function chpl_build_low_bounded_range[67237](arg low[67234] :
  enumerated[179](?)) : _unknown[43]
  {
    (67251 return(67250 'new'(67249 call range[66183](?)(67241 'typeof' low[67234]) boundedLow[66081](_low = low[67234]))))
  }
  function chpl_build_low_bounded_range[67262](arg low[67259] :
  bool[10]) : _unknown[43]
  {
    (67276 return(67275 'new'(67274 call range[66183](?)(67266 'typeof' low[67259]) boundedLow[66081](_low = low[67259]))))
  }
  function chpl_build_low_bounded_range[67285](arg low[67283]:_any[170](?)) : _unknown[43] "no return value for void"
  {
    (67305 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_build_high_bounded_range[67316](arg high[67313] :
  integral[188](?)) : _unknown[43]
  {
    (67330 return(67329 'new'(67328 call range[66183](?)(67320 'typeof' high[67313]) boundedHigh[66083](_high = high[67313]))))
  }
  function chpl_build_high_bounded_range[67341](arg high[67338] :
  enumerated[179](?)) : _unknown[43]
  {
    (67355 return(67354 'new'(67353 call range[66183](?)(67345 'typeof' high[67338]) boundedHigh[66083](_high = high[67338]))))
  }
  function chpl_build_high_bounded_range[67366](arg high[67363] :
  bool[10]) : _unknown[43]
  {
    (67380 return(67379 'new'(67378 call range[66183](?)(67370 'typeof' high[67363]) boundedHigh[66083](_high = high[67363]))))
  }
  function chpl_build_high_bounded_range[67389](arg high[67387]:_any[170](?)) : _unknown[43] "no return value for void"
  {
    (67409 call compilerError "Bound of '..high' must be an integer.")
  }
  function chpl_build_unbounded_range[67416]() : _unknown[43]
  {
    (67429 return(67428 'new'(67427 call range[66183](?) int(64)[13] boundedNone[66085])))
  }
  function chpl_compute_low_param_loop_bound[67444](param arg low[67441] :
  (67440 call int(64)[13] unknown w[67437]), param arg high[67450] :
  (67449 call int(64)[13] w[67437])) param : _unknown[43]
  {
    (67454 return low[67441])
  }
  function chpl_compute_high_param_loop_bound[67469](param arg low[67466] :
  (67465 call int(64)[13] unknown w[67462]), param arg high[67475] :
  (67474 call int(64)[13] w[67462])) param : _unknown[43]
  {
    (67479 return high[67475])
  }
  function chpl_compute_low_param_loop_bound[67494](param arg low[67491] :
  (67490 call uint(64)[107] unknown w[67487]), param arg high[67500] :
  (67499 call uint(64)[107] w[67487])) param : _unknown[43]
  {
    (67504 return low[67491])
  }
  function chpl_compute_high_param_loop_bound[67519](param arg low[67516] :
  (67515 call uint(64)[107] unknown w[67512]), param arg high[67525] :
  (67524 call uint(64)[107] w[67512])) param : _unknown[43]
  {
    (67529 return high[67525])
  }
  function chpl_compute_low_param_loop_bound[67540](param arg low[67537] :
  bool[10], param arg high[67543] :
  bool[10]) param : _unknown[43]
  {
    (67547 return low[67537])
  }
  function chpl_compute_high_param_loop_bound[67558](param arg low[67555] :
  bool[10], param arg high[67561] :
  bool[10]) param : _unknown[43]
  {
    (67565 return high[67561])
  }
  function chpl_compute_low_param_loop_bound[67574](param arg low[67572]:_any[170](?), param arg high[67576]:_any[170](?)) param : _unknown[43] "last resort" "no return value for void"
  {
    (67596 call compilerError "Range bounds must be integers of compatible types")
  }
  function chpl_compute_low_param_loop_bound[67605](arg low[67603]:_any[170](?), arg high[67607]:_any[170](?)) : _unknown[43] "last resort" "no return value for void"
  {
    (67627 call compilerError "param for loop must be defined over a bounded param range")
  }
  function isRangeType[67636](arg t[67634]:_any[170](?)) param : _unknown[43]
  {
    function isRangeHelp[67647](arg t[67644] :
    (67643 call range[66183](?) ?[249])) param : _unknown[43]
    {
      (67650 return 1)
    }
    function isRangeHelp[67660](arg t[67658]:_any[170](?)) param : _unknown[43]
    {
      (67663 return 0)
    }
    (67672 return(67671 call isRangeHelp t[67634]))
  }
  function isRangeValue[67685](arg r[67682] :
  (67681 call range[66183](?) ?[249])) param : _unknown[43] "no doc"
  {
    (67688 return 1)
  }
  function isRangeValue[67697](arg r[67695]:_any[170](?)) param : _unknown[43] "no doc"
  {
    (67700 return 0)
  }
  function isBoundedRange[67709](arg r[67707]:_any[170](?)) param : _unknown[43] "no doc"
  {
    (67712 return 0)
  }
  function isBoundedRange[67726](arg r[67723] :
  (67722 call range[66183](?) ?[249])) param : _unknown[43]
  {
    (67735 return(67734 call isBoundedRange(67730 call . r[67723] c"boundedType")))
  }
  function isBoundedRange[67746](param arg B[67743] :
  BoundedRangeType[66087]) param : _unknown[43] "no doc"
  {
    (67755 return(67753 call == B[67743] bounded[66079]))
  }
  function range[66183](?).hasLowBound[67763](arg _mt[67768]:_MT[227], arg this[67765]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method"
  {
    (67786 return(67784 call ||(67775 call ==(341147 call . this[67765] c"boundedType") bounded[66079])(67782 call ==(341153 call . this[67765] c"boundedType") boundedLow[66081])))
  }
  function range[66183](?).hasHighBound[67794](arg _mt[67799]:_MT[227], arg this[67796]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method"
  {
    (67817 return(67815 call ||(67806 call ==(341159 call . this[67796] c"boundedType") bounded[66079])(67813 call ==(341165 call . this[67796] c"boundedType") boundedHigh[66083])))
  }
  function range[66183](?).stride[67825](arg _mt[67830]:_MT[227], arg this[67827]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (67834 return(341176 call . this[67827] c"_stride"))
  }
  where {
    (341171 call . this[67827] c"stridable")
  }
  function range[66183](?).stride[67843](arg _mt[67848]:_MT[227], arg this[67845]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method" "no doc" "no parens"
  {
    (67857 return(67855 call _cast(341185 call . this[67845] c"strType") 1))
  }
  where {
    (67851 call !(341181 call . this[67845] c"stridable"))
  }
  function range[66183](?).alignment[67866](arg _mt[67871]:_MT[227], arg this[67868]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (67878 return(67877 call(341194 call . this[67868] c"chpl_intToIdx")(341199 call . this[67868] c"_alignment")))
  }
  where {
    (341190 call . this[67868] c"stridable")
  }
  function range[66183](?).alignment[67887](arg _mt[67892]:_MT[227], arg this[67889]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc" "no parens"
  {
    (67903 return(341212 call . this[67889] c"low"))
  }
  where {
    (67900 call &&(67895 call !(341204 call . this[67889] c"stridable"))(67899 call(341208 call . this[67889] c"hasLowBound")))
  }
  function range[66183](?).alignment[67912](arg _mt[67917]:_MT[227], arg this[67914]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc" "no parens"
  {
    (67923 return(67922 call(341216 call . this[67914] c"chpl_intToIdx") 0))
  }
  function range[66183](?).aligned[67931](arg _mt[67936]:_MT[227], arg this[67933]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (67940 return(341226 call . this[67933] c"_aligned"))
  }
  where {
    (341221 call . this[67933] c"stridable")
  }
  function range[66183](?).aligned[67949](arg _mt[67954]:_MT[227], arg this[67951]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method" "no doc" "no parens"
  {
    (67978 return 1)
  }
  where {
    (67975 call &&(67957 call !(341231 call . this[67951] c"stridable"))(67973 call ||(67964 call ==(341236 call . this[67951] c"boundedType") bounded[66079])(67971 call ==(341242 call . this[67951] c"boundedType") boundedLow[66081])))
  }
  function range[66183](?).aligned[67987](arg _mt[67992]:_MT[227], arg this[67989]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method" "no doc" "no parens"
  {
    (67995 return 0)
  }
  function range[66183](?).first[68003](arg _mt[68008]:_MT[227], arg this[68005]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68019 return(68018 call(341247 call . this[68005] c"chpl_intToIdx")(68014 call . this[68005] c"firstAsInt")))
  }
  function range[66183](?).firstAsInt[68027](arg _mt[68032]:_MT[227], arg this[68029]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc" "no parens"
  {
    if(68061 call _cond_test(68035 call !(341253 call . this[68029] c"stridable")))
    {
      (68038 return(341258 call . this[68029] c"_low"))
    }
    {
      (68059 return(68056 IfExpr (68042 call >(341263 call . this[68029] c"_stride") 0) then
      { scopeless
        (68047 call . this[68029] c"alignedLowAsInt")
      } else
      { scopeless
        (68053 call . this[68029] c"alignedHighAsInt")
      } ))
    }
  }
  function range[66183](?).last[68073](arg _mt[68078]:_MT[227], arg this[68075]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68089 return(68088 call(341269 call . this[68075] c"chpl_intToIdx")(68084 call . this[68075] c"lastAsInt")))
  }
  function range[66183](?).lastAsInt[68097](arg _mt[68102]:_MT[227], arg this[68099]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc" "no parens"
  {
    if(68127 call _cond_test(68105 call !(341275 call . this[68099] c"stridable")))
    {
      (68108 return(341280 call . this[68099] c"_high"))
    }
    {
      (68125 return(68122 IfExpr (68112 call >(341284 call . this[68099] c"stride") 0) then
      { scopeless
        (68115 call . this[68099] c"alignedHighAsInt")
      } else
      { scopeless
        (68119 call . this[68099] c"alignedLowAsInt")
      } ))
    }
  }
  function range[66183](?).low[68139](arg _mt[68144]:_MT[227], arg this[68141]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68150 return(68149 call(341290 call . this[68141] c"chpl_intToIdx")(341295 call . this[68141] c"_low")))
  }
  function range[66183](?).high[68158](arg _mt[68163]:_MT[227], arg this[68160]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68169 return(68168 call(341299 call . this[68160] c"chpl_intToIdx")(341304 call . this[68160] c"_high")))
  }
  function range[66183](?).alignedLow[68177](arg _mt[68182]:_MT[227], arg this[68179]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68192 return(68191 call(341313 call . this[68179] c"chpl_intToIdx")(68187 call . this[68179] c"alignedLowAsInt")))
  }
  { scopeless type
    (341309 call . this[68179] c"idxType")
  }
  function range[66183](?).alignedLowAsInt[68201](arg _mt[68206]:_MT[227], arg this[68203]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc" "no parens"
  {
    if(68225 call _cond_test(68209 call !(341319 call . this[68203] c"stridable")))
    {
      (68212 return(341324 call . this[68203] c"_low"))
    }
    {
      (68223 return(68221 call +(341329 call . this[68203] c"_low")(68220 call chpl__diffMod(341334 call . this[68203] c"_alignment")(341339 call . this[68203] c"_low")(341343 call . this[68203] c"stride"))))
    }
  }
  function range[66183](?).alignedHigh[68237](arg _mt[68242]:_MT[227], arg this[68239]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68252 return(68251 call(341352 call . this[68239] c"chpl_intToIdx")(68247 call . this[68239] c"alignedHighAsInt")))
  }
  { scopeless type
    (341348 call . this[68239] c"idxType")
  }
  function range[66183](?).alignedHighAsInt[68261](arg _mt[68266]:_MT[227], arg this[68263]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc" "no parens"
  {
    if(68285 call _cond_test(68269 call !(341358 call . this[68263] c"stridable")))
    {
      (68272 return(341363 call . this[68263] c"_high"))
    }
    {
      (68283 return(68281 call -(341368 call . this[68263] c"_high")(68280 call chpl__diffMod(341373 call . this[68263] c"_high")(341378 call . this[68263] c"_alignment")(341382 call . this[68263] c"stride"))))
    }
  }
  function range[66183](?).isEmpty[68297](arg _mt[68302]:_MT[227], arg this[68299]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method"
  {
    if(68353 call _cond_test(68308 call && 1(68307 call(341387 call . this[68299] c"isAmbiguous"))))
    {
      (68333 call boundsCheckHalt module=[244] HaltWrappers[197622] "isEmpty() is invoked on an ambiguously-aligned range")
    }
    {
      (68351 return(68349 call &&(68338 call isBoundedRange this[68299])(68347 call >(68340 call . this[68299] c"alignedLow")(68344 call . this[68299] c"alignedHigh"))))
    }
  }
  function range[66183](?).size[68365](arg _mt[68370]:_MT[227], arg this[68367]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no parens"
  {
    (68377 return(68374 call . this[68367] c"length"))
  }
  { scopeless type
    (341395 call . this[68367] c"intIdxType")
  }
  function range[66183](?).length[68386](arg _mt[68391]:_MT[227], arg this[68388]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no parens"
  {
    if(68420 call _cond_test(68398 call !(68397 call isBoundedRange this[68388])))
    {
      (68418 call compilerError "length is not defined on unbounded ranges")
    }
    const ah[68430] "const"(68427 call . this[68388] c"alignedHighAsInt")
    const al[68437] "const"(68434 call . this[68388] c"alignedLowAsInt")
    if(68450 call _cond_test(68442 call > al[68437] ah[68430]))
    {
      (68448 return(68446 call _cast(341409 call . this[68388] c"intIdxType") 0))
    }
    const s[68465] "const"(68463 call _cast(341414 call . this[68388] c"intIdxType")(68461 call abs(68457 call . this[68388] c"stride")))
    (68481 return(68479 call +(68473 call /(68470 call - ah[68430] al[68437]) s[68465])(68477 call _cast(341421 call . this[68388] c"intIdxType") 1)))
  }
  { scopeless type
    (341400 call . this[68388] c"intIdxType")
  }
  function range[66183](?).hasFirst[68489](arg _mt[68494]:_MT[227], arg this[68491]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method"
  {
    (68509 return(68508 call(341434 call . this[68491] c"hasLowBound")))
  }
  where {
    (68504 call &&(68497 call !(341426 call . this[68491] c"stridable"))(68502 call !(68501 call(341430 call . this[68491] c"hasHighBound"))))
  }
  function range[66183](?).hasFirst[68518](arg _mt[68523]:_MT[227], arg this[68520]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (68550 return(68547 IfExpr (68531 call ||(68527 call(341438 call . this[68520] c"isAmbiguous"))(68530 call(341442 call . this[68520] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(68544 IfExpr (68536 call >(341446 call . this[68520] c"stride") 0) then
      { scopeless
        (68540 call(341450 call . this[68520] c"hasLowBound"))
      } else
      { scopeless
        (68543 call(341454 call . this[68520] c"hasHighBound"))
      } )
    } ))
  }
  function range[66183](?).hasLast[68558](arg _mt[68563]:_MT[227], arg this[68560]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method"
  {
    (68578 return(68577 call(341467 call . this[68560] c"hasHighBound")))
  }
  where {
    (68573 call &&(68566 call !(341459 call . this[68560] c"stridable"))(68571 call !(68570 call(341463 call . this[68560] c"hasLowBound"))))
  }
  function range[66183](?).hasLast[68587](arg _mt[68592]:_MT[227], arg this[68589]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (68619 return(68616 IfExpr (68600 call ||(68596 call(341471 call . this[68589] c"isAmbiguous"))(68599 call(341475 call . this[68589] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(68613 IfExpr (68605 call >(341479 call . this[68589] c"stride") 0) then
      { scopeless
        (68609 call(341483 call . this[68589] c"hasHighBound"))
      } else
      { scopeless
        (68612 call(341487 call . this[68589] c"hasLowBound"))
      } )
    } ))
  }
  function range[66183](?).isNaturallyAligned[68627](arg _mt[68632]:_MT[227], arg this[68629]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method"
  {
    if(68660 call _cond_test(68649 call >(341498 call . this[68629] c"stride") 0))
    {
      (68658 return(68656 call ==(68652 call . this[68629] c"alignedLowAsInt")(341504 call . this[68629] c"_low")))
    }
    if(68679 call _cond_test(68668 call <(341508 call . this[68629] c"stride") 0))
    {
      (68677 return(68675 call ==(68671 call . this[68629] c"alignedHighAsInt")(341514 call . this[68629] c"_high")))
    }
    (68685 return 0)
  }
  where {
    (68645 call &&(341492 call . this[68629] c"stridable")(68643 call ==(68636 call . this[68629] c"boundedType") bounded[66079]))
  }
  function range[66183](?).isNaturallyAligned[68693](arg _mt[68698]:_MT[227], arg this[68695]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "inline" "method" "no doc"
  {
    (68716 return 1)
  }
  where {
    (68713 call &&(68701 call !(341519 call . this[68695] c"stridable"))(68711 call ==(68704 call . this[68695] c"boundedType") bounded[66079]))
  }
  function range[66183](?).isNaturallyAligned[68725](arg _mt[68730]:_MT[227], arg this[68727]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (68754 return(68752 call ==(68748 call . this[68727] c"alignedLowAsInt")(341534 call . this[68727] c"_low")))
  }
  where {
    (68745 call &&(68733 call !(341526 call . this[68727] c"stridable"))(68743 call ==(68736 call . this[68727] c"boundedType") boundedLow[66081]))
  }
  function range[66183](?).isNaturallyAligned[68763](arg _mt[68768]:_MT[227], arg this[68765]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (68796 return(68794 call &&(68785 call >(341545 call . this[68765] c"stride") 0)(68792 call ==(68788 call . this[68765] c"alignedLowAsInt")(341551 call . this[68765] c"_low"))))
  }
  where {
    (68781 call &&(341539 call . this[68765] c"stridable")(68779 call ==(68772 call . this[68765] c"boundedType") boundedLow[66081]))
  }
  function range[66183](?).isNaturallyAligned[68805](arg _mt[68810]:_MT[227], arg this[68807]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "inline" "method" "no doc"
  {
    (68840 return 0)
  }
  where {
    (68837 call ||(68820 call ==(68813 call . this[68807] c"boundedType") boundedNone[66085])(68835 call &&(68823 call !(341558 call . this[68807] c"stridable"))(68833 call ==(68826 call . this[68807] c"boundedType") boundedHigh[66083])))
  }
  function range[66183](?).isNaturallyAligned[68849](arg _mt[68854]:_MT[227], arg this[68851]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (68882 return(68880 call &&(68871 call <(341571 call . this[68851] c"stride") 0)(68878 call ==(68874 call . this[68851] c"alignedHighAsInt")(341577 call . this[68851] c"_high"))))
  }
  where {
    (68867 call &&(341565 call . this[68851] c"stridable")(68865 call ==(68858 call . this[68851] c"boundedType") boundedHigh[66083]))
  }
  function range[66183](?).isAmbiguous[68891](arg _mt[68896]:_MT[227], arg this[68893]:range[66183](?) :
  range[66183](?)) param : _unknown[43] "method"
  {
    (68902 return 0)
  }
  where {
    (68899 call !(341582 call . this[68893] c"stridable"))
  }
  function range[66183](?).isAmbiguous[68911](arg _mt[68916]:_MT[227], arg this[68913]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc"
  {
    (68936 return(68934 call &&(68920 call !(341591 call . this[68913] c"aligned"))(68932 call ||(68924 call >(341595 call . this[68913] c"stride") 1)(68930 call <(341599 call . this[68913] c"stride")(68928 call - 1)))))
  }
  where {
    (341587 call . this[68913] c"stridable")
  }
  function range[66183](?).contains[68949](arg _mt[68954]:_MT[227], arg this[68951]:range[66183](?) :
  range[66183](?), arg ind[68946] :
  (341604 call . this[68951] c"idxType")) : _unknown[43] "inline" "method"
  {
    if(68967 call _cond_test(68963 call(68959 call . this[68951] c"isAmbiguous")))
    {
      (68965 return 0)
    }
    const i[68977] "const"(68976 call chpl__idxToInt ind[68946])
    if(68996 call _cond_test(68982 call(341610 call . this[68951] c"hasHighBound")))
    {
      if(68990 call _cond_test(68985 call > i[68977](341616 call . this[68951] c"_high")))
      {
        (68988 return 0)
      }
    }
    if(69016 call _cond_test(69002 call(341620 call . this[68951] c"hasLowBound")))
    {
      if(69010 call _cond_test(69005 call < i[68977](341626 call . this[68951] c"_low")))
      {
        (69008 return 0)
      }
    }
    if(69049 call _cond_test(341631 call . this[68951] c"stridable"))
    {
      unknown s[69028](69026 call _cast(341640 call . this[68951] c"intIdxType")(69024 call abs(341636 call . this[68951] c"_stride")))
      if(69044 call _cond_test(69039 call !=(69037 call chpl__diffMod i[68977](341646 call . this[68951] c"_alignment") s[69028]) 0))
      {
        (69042 return 0)
      }
    }
    (69054 return 1)
  }
  function range[66183](?).contains[69068](arg _mt[69073]:_MT[227], arg this[69070]:range[66183](?) :
  range[66183](?), arg other[69065] :
  (69064 call range[66183](?) ?[249])) : _unknown[43] "inline" "method"
  {
    if(69092 call _cond_test(69087 call ||(69080 call(69076 call . this[69070] c"isAmbiguous"))(69086 call(69082 call . other[69065] c"isAmbiguous"))))
    {
      (69090 return 0)
    }
    if(69160 call _cond_test(341655 call . this[69070] c"stridable"))
    {
      if(69134 call _cond_test(69125 call ||(69110 call &&(69101 call >(341659 call . this[69070] c"stride") 0)(69108 call <(69104 call . other[69065] c"stride") 0))(69123 call &&(69114 call <(341664 call . this[69070] c"stride") 0)(69121 call >(69117 call . other[69065] c"stride") 0))))
      {
        (69132 return(69131 call _containsHelp this[69070] other[69065]))
      }
    }
    {
      if(69154 call _cond_test(69145 call <(69141 call . other[69065] c"stride") 0))
      {
        (69152 return(69151 call _containsHelp this[69070] other[69065]))
      }
    }
    (69171 return(69169 call == other[69065](69168 call this[69070] other[69065])))
  }
  function range[66183](?).member[69182](arg _mt[69187]:_MT[227], arg this[69184]:range[66183](?) :
  range[66183](?), arg ind[69179] :
  (341678 call . this[69184] c"idxType")) : _unknown[43] "inline" "method"
  {
    (69227 call compilerWarning(69224 call + "range.member is deprecated - " "please use range.contains instead"))
    (69239 return(69238 call(69233 call . this[69184] c"contains") ind[69179]))
  }
  function range[66183](?).member[69253](arg _mt[69258]:_MT[227], arg this[69255]:range[66183](?) :
  range[66183](?), arg other[69250] :
  (69249 call range[66183](?) ?[249])) : _unknown[43] "inline" "method"
  {
    (69266 call compilerWarning(69263 call + "range.member is deprecated - " "please use range.contains instead"))
    (69276 return(69275 call(69270 call . this[69255] c"contains") other[69250]))
  }
  function _containsHelp[69289](in arg arg1[69286] :
  (69285 call range[66183](?) ?[249]), in arg arg2[69295] :
  (69294 call range[66183](?) ?[249])) : _unknown[43] "inline" "private"
  {
    if(69328 call _cond_test(69299 call . arg2[69295] c"stridable"))
    {
      (69312 call =(69303 call . arg2[69295] c"_stride")(69310 call -(69307 call . arg2[69295] c"_stride")))
    }
    {
      (69325 call =(69316 call . arg1[69286] c"_stride")(69323 call -(69320 call . arg1[69286] c"_stride")))
    }
    (69342 return(69340 call == arg2[69295](69339 call arg1[69286] arg2[69295])))
  }
  function ==[69355](arg r1[69352] :
  (69351 call range[66183](?) ?[249]), arg r2[69361] :
  (69360 call range[66183](?) ?[249])) param : _unknown[43]
  {
    (69375 return 0)
  }
  where {
    (69372 call !=(69365 call . r1[69352] c"boundedType")(69369 call . r2[69361] c"boundedType"))
  }
  function ==[69390](arg r1[69387] :
  (69386 call range[66183](?) ?[249]), arg r2[69396] :
  (69395 call range[66183](?) ?[249])) : _unknown[43]
  {
    if(69427 call _cond_test(69422 call !=(69415 call(69411 call . r1[69387] c"isAmbiguous"))(69421 call(69417 call . r2[69396] c"isAmbiguous"))))
    {
      (69425 return 0)
    }
    if(69446 call _cond_test(69438 call(69434 call . r1[69387] c"isAmbiguous")))
    {
      (69444 return(69443 call ident r1[69387] r2[69396]))
    }
    if(69627 call _cond_test(69454 call isBoundedRange r1[69387]))
    {
      const len[69459] "const"(69456 call . r1[69387] c"length")
      const l2[69466] "const"(69463 call . r2[69396] c"length")
      if(69477 call _cond_test(69472 call != len[69459] l2[69466]))
      {
        (69475 return 0)
      }
      if(69489 call _cond_test(69484 call == len[69459] 0))
      {
        (69487 return 1)
      }
      if(69509 call _cond_test(69504 call !=(69497 call . r1[69387] c"first")(69501 call . r2[69396] c"first")))
      {
        (69507 return 0)
      }
      if(69521 call _cond_test(69516 call == len[69459] 1))
      {
        (69519 return 1)
      }
      if(69539 call _cond_test(69534 call !=(69527 call . r1[69387] c"stride")(69531 call . r2[69396] c"stride")))
      {
        (69537 return 0)
      }
      (69545 return 1)
    }
    {
      if(69560 call _cond_test(69555 call !=(69548 call . r1[69387] c"stride")(69552 call . r2[69396] c"stride")))
      {
        (69558 return 0)
      }
      if(69590 call _cond_test(69571 call(69567 call . r1[69387] c"hasLowBound")))
      {
        if(69585 call _cond_test(69580 call !=(69573 call . r1[69387] c"alignedLow")(69577 call . r2[69396] c"alignedLow")))
        {
          (69583 return 0)
        }
      }
      if(69619 call _cond_test(69600 call(69596 call . r1[69387] c"hasHighBound")))
      {
        if(69614 call _cond_test(69609 call !=(69602 call . r1[69387] c"alignedHigh")(69606 call . r2[69396] c"alignedHigh")))
        {
          (69612 return 0)
        }
      }
      (69625 return 1)
    }
  }
  where {
    (69408 call ==(69401 call . r1[69387] c"boundedType")(69405 call . r2[69396] c"boundedType"))
  }
  { scopeless type
    bool[10]
  }
  function !=[69644](arg r1[69641] :
  (69640 call range[66183](?) ?[249]), arg r2[69650] :
  (69649 call range[66183](?) ?[249])) : _unknown[43]
  {
    (69659 return(69657 call !(69655 call == r1[69641] r2[69650])))
  }
  function ident[69673](arg r1[69670] :
  (69669 call range[66183](?) ?[249]), arg r2[69679] :
  (69678 call range[66183](?) ?[249])) : _unknown[43]
  {
    if(69729 call _cond_test(69724 call !=(69717 call . r1[69670] c"_low")(69721 call . r2[69679] c"_low")))
    {
      (69727 return 0)
    }
    if(69748 call _cond_test(69743 call !=(69736 call . r1[69670] c"_high")(69740 call . r2[69679] c"_high")))
    {
      (69746 return 0)
    }
    if(69825 call _cond_test(69754 call . r1[69670] c"stridable"))
    {
      if(69820 call _cond_test(69758 call . r2[69679] c"stridable"))
      {
        if(69774 call _cond_test(69769 call !=(69762 call . r1[69670] c"_stride")(69766 call . r2[69679] c"_stride")))
        {
          (69772 return 0)
        }
        if(69793 call _cond_test(69788 call !=(69781 call . r1[69670] c"_alignment")(69785 call . r2[69679] c"_alignment")))
        {
          (69791 return 0)
        }
        if(69811 call _cond_test(69806 call !=(69799 call . r1[69670] c"_aligned")(69803 call . r2[69679] c"_aligned")))
        {
          (69809 return 0)
        }
      }
      {
        (69817 return 0)
      }
    }
    (69830 return 1)
  }
  where {
    (69714 call &&(69702 call &&(69690 call ==(69683 call . r1[69670] c"idxType")(69687 call . r2[69679] c"idxType"))(69700 call ==(69693 call . r1[69670] c"boundedType")(69697 call . r2[69679] c"boundedType")))(69712 call ==(69705 call . r1[69670] c"stridable")(69709 call . r2[69679] c"stridable")))
  }
  function ident[69844](arg r1[69841] :
  (69840 call range[66183](?) ?[249]), arg r2[69850] :
  (69849 call range[66183](?) ?[249])) param : _unknown[43] "no doc"
  {
    (69854 return 0)
  }
  function range[66183](?).safeCast[69864](arg _mt[69869]:_MT[227], arg this[69866]:range[66183](?) :
  range[66183](?), arg t[69862]:_any[170](?)) : _unknown[43] "method" "no doc"
  {
    unknown tmp[69876] t[69862]
    if(69941 call _cond_test(69888 call !=(69881 call . tmp[69876] c"boundedType")(69885 call . this[69866] c"boundedType")))
    {
      (69938 call compilerError "cannot cast range from "(69913 call _cast string[24](69909 call . this[69866] c"boundedType")) " to "(69936 call _cast string[24](69932 call . tmp[69876] c"boundedType")))
    }
    if(70034 call _cond_test(69946 call . tmp[69876] c"stridable"))
    {
      (69957 call =(69950 call . tmp[69876] c"_stride")(69954 call . this[69866] c"stride"))
      (69983 call =(69962 call . tmp[69876] c"_alignment")(69982 call(69972 call .(69971 call chpl__idxToInt(69967 call . this[69866] c"alignment")) c"safeCast")(69978 call . tmp[69876] c"intIdxType")))
      (69994 call =(69987 call . tmp[69876] c"_aligned")(69991 call . this[69866] c"aligned"))
    }
    {
      if(70030 call _cond_test(70002 call !=(69998 call . this[69866] c"stride") 1))
      {
        (70027 call safeCastCheckHalt module=[244] HaltWrappers[197622] "illegal safeCast from non-unit stride range to unstridable range")
      }
    }
    (70056 call =(70040 call . tmp[69876] c"_low")(70055 call(70047 call .(70044 call . this[69866] c"_low") c"safeCast")(70051 call . tmp[69876] c"intIdxType")))
    (70076 call =(70060 call . tmp[69876] c"_high")(70075 call(70067 call .(70064 call . this[69866] c"_high") c"safeCast")(70071 call . tmp[69876] c"intIdxType")))
    (70080 return tmp[69876])
  }
  where {
    (69874 call isRangeType t[69862])
  }
  function _cast[70089](arg t[70087]:_any[170](?), arg r[70095] :
  (70094 call range[66183](?) ?[249])) : _unknown[43] "no doc"
  {
    unknown tmp[70103] t[70087]
    if(70138 call _cond_test(70115 call !=(70108 call . tmp[70103] c"boundedType")(70112 call . r[70095] c"boundedType")))
    {
      (70135 call compilerError "cannot cast range from "(70125 call _cast string[24](70121 call . r[70095] c"boundedType")) " to "(70133 call _cast string[24](70129 call . tmp[70103] c"boundedType")))
    }
    if(70186 call _cond_test(70143 call . tmp[70103] c"stridable"))
    {
      (70154 call =(70147 call . tmp[70103] c"_stride")(70151 call . r[70095] c"_stride"))
      (70172 call =(70159 call . tmp[70103] c"_alignment")(70170 call _cast(70167 call . tmp[70103] c"intIdxType")(70163 call . r[70095] c"_alignment")))
      (70183 call =(70176 call . tmp[70103] c"_aligned")(70180 call . r[70095] c"_aligned"))
    }
    (70204 call =(70191 call . tmp[70103] c"_low")(70202 call _cast(70199 call . tmp[70103] c"intIdxType")(70195 call . r[70095] c"low")))
    (70221 call =(70208 call . tmp[70103] c"_high")(70219 call _cast(70216 call . tmp[70103] c"intIdxType")(70212 call . r[70095] c"high")))
    (70225 return tmp[70103])
  }
  where {
    (70101 call isRangeType t[70087])
  }
  function range[66183](?).boundsCheck[70245](arg _mt[70250]:_MT[227], arg this[70247]:range[66183](?) :
  range[66183](?), arg other[70242] :
  (70241 call range[66183](?) unknown e[70234] unknown b[70237] unknown s[70239])) : _unknown[43] "inline" "method"
  {
    if(70276 call _cond_test(70271 call ||(70264 call(70260 call . this[70247] c"isAmbiguous"))(70270 call(70266 call . other[70242] c"isAmbiguous"))))
    {
      (70274 return 0)
    }
    (70283 return 1)
  }
  where {
    (70257 call == b[70237] boundedNone[66085])
  }
  function range[66183](?).boundsCheck[70303](arg _mt[70308]:_MT[227], arg this[70305]:range[66183](?) :
  range[66183](?), arg other[70300] :
  (70299 call range[66183](?) unknown e[70292] unknown b[70295] unknown s[70297])) : _unknown[43] "inline" "method" "no doc"
  {
    if(70327 call _cond_test(70322 call ||(70315 call(70311 call . this[70305] c"isAmbiguous"))(70321 call(70317 call . other[70300] c"isAmbiguous"))))
    {
      (70325 return 0)
    }
    unknown boundedOther[70386](70385 'new'(70384 call range[66183](?)(341810 call . this[70305] c"idxType") bounded[66079](70345 call || s[70297](70342 call . this[70305] c"stridable"))(70358 IfExpr (70352 call(70348 call . other[70300] c"hasLowBound")) then
    { scopeless
      (70354 call . other[70300] c"low")
    } else
    { scopeless
      (341819 call . this[70305] c"low")
    } )(70372 IfExpr (70366 call(70362 call . other[70300] c"hasHighBound")) then
    { scopeless
      (70368 call . other[70300] c"high")
    } else
    { scopeless
      (341825 call . this[70305] c"high")
    } )(70376 call . other[70300] c"stride")(70380 call . other[70300] c"alignment") 1))
    (70402 return(70400 call ||(70394 call ==(70390 call . boundedOther[70386] c"length") 0)(70399 call(341832 call . this[70305] c"contains") boundedOther[70386])))
  }
  function range[66183](?).boundsCheck[70413](arg _mt[70418]:_MT[227], arg this[70415]:range[66183](?) :
  range[66183](?), arg other[70410] :
  (341838 call . this[70415] c"idxType")) : _unknown[43] "inline" "method"
  {
    (70424 return(70423 call(341842 call . this[70415] c"contains") other[70410]))
  }
  function range[66183](?).alignLow[70432](arg _mt[70437]:_MT[227], ref arg this[70434]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc"
  {
    if(70471 call _cond_test(70446 call && 1(70445 call(70441 call . this[70434] c"isAmbiguous"))))
    {
      (70469 call boundsCheckHalt module=[244] HaltWrappers[197622] "alignLow -- Cannot be applied to a range with ambiguous alignment.")
    }
    if(70486 call _cond_test(341851 call . this[70434] c"stridable"))
    {
      (70483 call =(341856 call . this[70434] c"_low")(70480 call . this[70434] c"alignedLowAsInt"))
    }
    (70492 return this[70434])
  }
  function range[66183](?).alignHigh[70499](arg _mt[70504]:_MT[227], ref arg this[70501]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc"
  {
    if(70538 call _cond_test(70513 call && 1(70512 call(70508 call . this[70501] c"isAmbiguous"))))
    {
      (70536 call boundsCheckHalt module=[244] HaltWrappers[197622] "alignHigh -- Cannot be applied to a range with ambiguous alignment.")
    }
    if(70553 call _cond_test(341866 call . this[70501] c"stridable"))
    {
      (70550 call =(341871 call . this[70501] c"_high")(70547 call . this[70501] c"alignedHighAsInt"))
    }
    (70559 return this[70501])
  }
  function range[66183](?).indexOrder[70570](arg _mt[70575]:_MT[227], arg this[70572]:range[66183](?) :
  range[66183](?), arg ind[70567] :
  (341878 call . this[70572] c"idxType")) : _unknown[43] "method"
  {
    if(70609 call _cond_test(70584 call && 1(70583 call(70579 call . this[70572] c"isAmbiguous"))))
    {
      (70607 call boundsCheckHalt module=[244] HaltWrappers[197622] "indexOrder -- Undefined on a range with ambiguous alignment.")
    }
    if(70629 call _cond_test(70619 call !(70618 call(341885 call . this[70572] c"contains") ind[70567])))
    {
      (70627 return(70625 call _cast(341890 call . this[70572] c"intIdxType")(70622 call - 1)))
    }
    if(70699 call _cond_test(70635 call !(341895 call . this[70572] c"stridable")))
    {
      if(70652 call _cond_test(70642 call(70638 call . this[70572] c"hasLowBound")))
      {
        (70650 return(70648 call -(70646 call chpl__idxToInt ind[70567])(341902 call . this[70572] c"_low")))
      }
    }
    {
      if(70693 call _cond_test(70665 call(70661 call . this[70572] c"hasFirst")))
      {
        (70691 return(70689 call _cast(341922 call . this[70572] c"intIdxType")(70686 call /(70683 call -(70671 call _cast(341908 call . this[70572] c"strType")(70669 call chpl__idxToInt ind[70567]))(70681 call _cast(341913 call . this[70572] c"strType")(70679 call chpl__idxToInt(70675 call . this[70572] c"first"))))(341918 call . this[70572] c"_stride"))))
      }
    }
    (70709 return(70707 call _cast(341926 call . this[70572] c"intIdxType")(70704 call - 1)))
  }
  function range[66183](?).orderToIndex[70720](arg _mt[70725]:_MT[227], arg this[70722]:range[66183](?) :
  range[66183](?), arg ord[70717] :
  integral[188](?)) : _unknown[43] "method"
  {
    if(70908 call _cond_test 1)
    {
      if(70757 call _cond_test(70732 call !(70731 call(341937 call . this[70722] c"hasFirst"))))
      {
        (70755 call boundsCheckHalt module=[244] HaltWrappers[197622] "invoking orderToIndex on a range that has no first index")
      }
      if(70789 call _cond_test(70765 call(341942 call . this[70722] c"isAmbiguous")))
      {
        (70787 call boundsCheckHalt module=[244] HaltWrappers[197622] "invoking orderToIndex on a range that is ambiguously aligned")
      }
      if(70829 call _cond_test(70796 call < ord[70717] 0))
      {
        (70827 call boundsCheckHalt module=[244] HaltWrappers[197622](70824 call + "invoking orderToIndex on a negative integer: "(70822 call _cast string[24] ord[70717])))
      }
      if(70903 call _cond_test(70845 call &&(70837 call isBoundedRange this[70722])(70843 call >= ord[70717](70840 call . this[70722] c"length"))))
      {
        (70901 call boundsCheckHalt module=[244] HaltWrappers[197622](70898 call +(70889 call +(70871 call + "invoking orderToIndex on an integer "(70869 call _cast string[24] ord[70717])) " that is larger than the range's number of indices ")(70896 call _cast string[24](70892 call . this[70722] c"length"))))
      }
    }
    (70928 return(70927 call(341956 call . this[70722] c"chpl_intToIdx")(70925 call chpl__addRangeStrides(70916 call . this[70722] c"firstAsInt")(70921 call . this[70722] c"stride") ord[70717])))
  }
  { scopeless type
    (341932 call . this[70722] c"idxType")
  }
  function range[66183](?).translate[70940](arg _mt[70945]:_MT[227], arg this[70942]:range[66183](?) :
  range[66183](?), arg offset[70937] :
  integral[188](?)) : _unknown[43] "inline" "method"
  {
    (70951 return(70949 call + this[70942] offset[70937]))
  }
  function range[66183](?).translate[70961](arg _mt[70966]:_MT[227], arg this[70963]:range[66183](?) :
  range[66183](?), arg i[70959]:_any[170](?)) : _unknown[43] "inline" "method" "no doc" "no return value for void"
  {
    (70986 call compilerError "offsets must be of integral type")
  }
  function range[66183](?)._effAlmt[70994](arg _mt[70999]:_MT[227], arg this[70996]:range[66183](?) :
  range[66183](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (71003 return(341971 call . this[70996] c"alignment"))
  }
  where {
    (341967 call . this[70996] c"stridable")
  }
  function range[66183](?)._effAlmt[71012](arg _mt[71017]:_MT[227], arg this[71014]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc"
  {
    (71026 return(71025 call(341980 call . this[71014] c"chpl_intToIdx") 0))
  }
  where {
    (71020 call !(341976 call . this[71014] c"stridable"))
  }
  function range[66183](?).interior[71039](arg _mt[71044]:_MT[227], arg this[71041]:range[66183](?) :
  range[66183](?), arg offset[71036] :
  integral[188](?)) : _unknown[43] "method" "no doc" "no return value for void"
  {
    (71071 call compilerError "interior is not supported on unbounded ranges")
  }
  where {
    (71051 call !=(341986 call . this[71041] c"boundedType") bounded[66079])
  }
  function range[66183](?).interior[71084](arg _mt[71089]:_MT[227], arg this[71086]:range[66183](?) :
  range[66183](?), arg offset[71081] :
  integral[188](?)) : _unknown[43] "method"
  {
    const i[71098] "const"(71097 call(71092 call . offset[71081] c"safeCast")(341993 call . this[71086] c"intIdxType"))
    if(71131 call _cond_test(71104 call < i[71098] 0))
    {
      (71129 return(71128 'new'(71127 call range[66183](?)(342000 call . this[71086] c"idxType")(342005 call . this[71086] c"boundedType")(342010 call . this[71086] c"stridable")(342014 call . this[71086] c"low")(71121 call(342018 call . this[71086] c"chpl_intToIdx")(71118 call -(71115 call -(342023 call . this[71086] c"_low") 1) i[71098]))(342028 call . this[71086] c"stride")(71125 call(342034 call . this[71086] c"_effAlmt"))(342038 call . this[71086] c"aligned"))))
    }
    if(71165 call _cond_test(71138 call > i[71098] 0))
    {
      (71163 return(71162 'new'(71161 call range[66183](?)(342045 call . this[71086] c"idxType")(342050 call . this[71086] c"boundedType")(342055 call . this[71086] c"stridable")(71154 call(342059 call . this[71086] c"chpl_intToIdx")(71151 call -(71148 call +(342064 call . this[71086] c"_high") 1) i[71098]))(342069 call . this[71086] c"high")(342073 call . this[71086] c"stride")(71159 call(342077 call . this[71086] c"_effAlmt"))(342081 call . this[71086] c"aligned"))))
    }
    (71184 return(71183 'new'(71182 call range[66183](?)(342087 call . this[71086] c"idxType")(342092 call . this[71086] c"boundedType")(342097 call . this[71086] c"stridable")(342101 call . this[71086] c"low")(342105 call . this[71086] c"high")(342109 call . this[71086] c"stride")(71180 call(342113 call . this[71086] c"_effAlmt"))(342117 call . this[71086] c"aligned"))))
  }
  function range[66183](?).exterior[71195](arg _mt[71200]:_MT[227], arg this[71197]:range[66183](?) :
  range[66183](?), arg offset[71192] :
  integral[188](?)) : _unknown[43] "method" "no doc" "no return value for void"
  {
    (71227 call compilerError "exterior is not supported on unbounded ranges")
  }
  where {
    (71207 call !=(342123 call . this[71197] c"boundedType") bounded[66079])
  }
  function range[66183](?).exterior[71240](arg _mt[71245]:_MT[227], arg this[71242]:range[66183](?) :
  range[66183](?), arg offset[71237] :
  integral[188](?)) : _unknown[43] "method"
  {
    const i[71254] "const"(71253 call(71248 call . offset[71237] c"safeCast")(342130 call . this[71242] c"intIdxType"))
    if(71290 call _cond_test(71260 call < i[71254] 0))
    {
      (71288 return(71287 'new'(71286 call range[66183](?)(342137 call . this[71242] c"idxType")(342142 call . this[71242] c"boundedType")(342147 call . this[71242] c"stridable")(71273 call(342151 call . this[71242] c"chpl_intToIdx")(71270 call +(342156 call . this[71242] c"_low") i[71254]))(71280 call(342161 call . this[71242] c"chpl_intToIdx")(71277 call -(342166 call . this[71242] c"_low") 1))(342170 call . this[71242] c"stride")(71284 call(342174 call . this[71242] c"_effAlmt"))(342178 call . this[71242] c"aligned"))))
    }
    if(71327 call _cond_test(71297 call > i[71254] 0))
    {
      (71325 return(71324 'new'(71323 call range[66183](?)(342185 call . this[71242] c"idxType")(342190 call . this[71242] c"boundedType")(342195 call . this[71242] c"stridable")(71310 call(342199 call . this[71242] c"chpl_intToIdx")(71307 call +(342204 call . this[71242] c"_high") 1))(71317 call(342208 call . this[71242] c"chpl_intToIdx")(71314 call +(342213 call . this[71242] c"_high") i[71254]))(342218 call . this[71242] c"stride")(71321 call(342222 call . this[71242] c"_effAlmt"))(342226 call . this[71242] c"aligned"))))
    }
    (71346 return(71345 'new'(71344 call range[66183](?)(342232 call . this[71242] c"idxType")(342237 call . this[71242] c"boundedType")(342242 call . this[71242] c"stridable")(342246 call . this[71242] c"low")(342250 call . this[71242] c"high")(342254 call . this[71242] c"stride")(71342 call(342258 call . this[71242] c"_effAlmt"))(342262 call . this[71242] c"aligned"))))
  }
  function range[66183](?).expand[71357](arg _mt[71362]:_MT[227], arg this[71359]:range[66183](?) :
  range[66183](?), arg offset[71354] :
  integral[188](?)) : _unknown[43] "method" "no doc" "no return value for void"
  {
    (71389 call compilerError "expand() is not supported on unbounded ranges")
  }
  where {
    (71369 call !=(342268 call . this[71359] c"boundedType") bounded[66079])
  }
  function range[66183](?).expand[71402](arg _mt[71407]:_MT[227], arg this[71404]:range[66183](?) :
  range[66183](?), arg offset[71399] :
  integral[188](?)) : _unknown[43] "method"
  {
    const i[71416] "const"(71415 call(71410 call . offset[71399] c"safeCast")(342275 call . this[71404] c"intIdxType"))
    (71444 return(71443 'new'(71442 call range[66183](?)(342281 call . this[71404] c"idxType")(342286 call . this[71404] c"boundedType")(342291 call . this[71404] c"stridable")(71431 call(342295 call . this[71404] c"chpl_intToIdx")(71428 call -(342300 call . this[71404] c"_low") i[71416]))(71438 call(342305 call . this[71404] c"chpl_intToIdx")(71435 call +(342310 call . this[71404] c"_high") i[71416]))(342315 call . this[71404] c"stride")(342319 call . this[71404] c"alignment")(342324 call . this[71404] c"_aligned"))))
  }
  function =[71459](ref arg r1[71456] :
  (71455 call range[66183](?)(stridable = unknown s1[71451])), arg r2[71467] :
  (71466 call range[66183](?)(stridable = unknown s2[71462]))) : _unknown[43] "assignop" "compiler generated" "inline" "no return value for void"
  {
    if(71502 call _cond_test(71478 call !=(71471 call . r1[71456] c"boundedType")(71475 call . r2[71467] c"boundedType")))
    {
      (71500 call compilerError "type mismatch in assignment of ranges with different boundedType parameters")
    }
    if(71569 call _cond_test(71512 call &&(71509 call ! s1[71451]) s2[71462]))
    {
      (71532 call compilerError "type mismatch in assignment of ranges with different stridable parameters")
    }
    {
      if(71563 call _cond_test(71536 call && s1[71451] s2[71462]))
      {
        (71546 call =(71539 call . r1[71456] c"_stride")(71543 call . r2[71467] c"stride"))
      }
      {
        if(71558 call _cond_test s1[71451])
        {
          (71555 call =(71551 call . r1[71456] c"_stride") 1)
        }
      }
    }
    (71583 call =(71576 call . r1[71456] c"_low")(71580 call . r2[71467] c"_low"))
    (71594 call =(71587 call . r1[71456] c"_high")(71591 call . r2[71467] c"_high"))
    if(71624 call _cond_test s1[71451])
    {
      (71609 call =(71599 call . r1[71456] c"_alignment")(71608 call chpl__idxToInt(71604 call . r2[71467] c"alignment")))
      (71621 call =(71614 call . r1[71456] c"_aligned")(71618 call . r2[71467] c"aligned"))
    }
  }
  function +[71644](arg r[71641] :
  (71640 call range[66183](?) unknown e[71633] unknown b[71636] unknown s[71638]), arg offset[71647] :
  integral[188](?)) : _unknown[43] "inline"
  {
    const i[71657] "const"(71655 call _cast(71652 call . r[71641] c"intIdxType") offset[71647])
    unknown strType[71665] "type variable"(71664 call chpl__rangeStrideType e[71633])
    (71730 return(71729 'new'(71728 call range[66183](?) e[71633] b[71636] s[71638](71687 call(71676 call . r[71641] c"chpl_intToIdx")(71684 call +(71680 call . r[71641] c"_low") i[71657]))(71700 call(71689 call . r[71641] c"chpl_intToIdx")(71697 call +(71693 call . r[71641] c"_high") i[71657]))(71706 call _cast strType[71665](71702 call . r[71641] c"stride"))(71723 call(71709 call . r[71641] c"chpl_intToIdx")(71720 call +(71718 call chpl__idxToInt(71714 call . r[71641] c"alignment")) i[71657]))(71725 call . r[71641] c"aligned"))))
  }
  function +[71740](arg i[71737] :
  integral[188](?), arg r[71751] :
  (71750 call range[66183](?) unknown e[71743] unknown b[71746] unknown s[71748])) : _unknown[43] "inline"
  {
    (71758 return(71756 call + r[71751] i[71737]))
  }
  function -[71777](arg r[71774] :
  (71773 call range[66183](?) unknown e[71766] unknown b[71769] unknown s[71771]), arg i[71780] :
  integral[188](?)) : _unknown[43] "inline"
  {
    unknown strType[71787] "type variable"(71786 call chpl__rangeStrideType e[71766])
    (71851 return(71850 'new'(71849 call range[66183](?) e[71766] b[71769] s[71771](71808 call(71797 call . r[71774] c"chpl_intToIdx")(71805 call -(71801 call . r[71774] c"_low") i[71780]))(71821 call(71810 call . r[71774] c"chpl_intToIdx")(71818 call -(71814 call . r[71774] c"_high") i[71780]))(71827 call _cast strType[71787](71823 call . r[71774] c"stride"))(71844 call(71830 call . r[71774] c"chpl_intToIdx")(71841 call -(71839 call chpl__idxToInt(71835 call . r[71774] c"alignment")) i[71780]))(71846 call . r[71774] c"aligned"))))
  }
  function chpl_check_step_integral[71859](arg step[71857]:_any[170](?)) : _unknown[43] "inline" "no return value for void"
  {
    if(71893 call _cond_test(71866 call !(71865 call isIntegral(71863 'typeof' step[71857]))))
    {
      (71891 call compilerError "can't apply 'by' using step of a non-integral type "(71889 call _cast string[24](71887 'typeof' step[71857])))
    }
  }
  function chpl_need_to_check_step[71905](arg step[71903]:_any[170](?), arg strType[71907]:_any[170](?)) param : _unknown[43]
  {
    (71915 call compilerAssert(71913 call isInt strType[71907]))
    (71936 return(71934 call &&(71921 call !=(71919 'typeof' step[71903]) strType[71907])(71932 call >=(71927 call numBits(71925 'typeof' step[71903]))(71931 call numBits strType[71907]))))
  }
  function chpl_range_check_stride[71944](arg step[71942]:_any[170](?), arg idxType[71946]:_any[170](?)) : _unknown[43] "inline" "no return value for void"
  {
    (71951 call chpl_check_step_integral step[71942])
    unknown strType[71958] "type variable"(71957 call chpl__rangeStrideType idxType[71946])
    if(72017 call _cond_test(71970 call >(71965 call numBits(71963 'typeof' step[71942]))(71969 call numBits strType[71958])))
    {
      (72015 call compilerError "can't apply 'by' to a range with idxType "(71992 call _cast string[24] idxType[71946]) " using a step of type "(72013 call _cast string[24](72011 'typeof' step[71942])))
    }
    if(72110 call _cond_test 1)
    {
      if(72050 call _cond_test(72025 call == step[71942] 0))
      {
        (72048 call boundsCheckHalt module=[244] HaltWrappers[197622] "the step argument of the 'by' operator is zero")
      }
      if(72105 call _cond_test(72072 call &&(72060 call chpl_need_to_check_step step[71942] strType[71958])(72070 call > step[71942](72068 call _cast(72067 'typeof' step[71942])(72065 call max strType[71958])))))
      {
        (72103 call boundsCheckHalt module=[244] HaltWrappers[197622](72100 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(72098 call _cast string[24] strType[71958])))
      }
    }
  }
  function chpl_range_check_stride[72120](param arg step[72118]:_any[170](?), arg idxType[72122]:_any[170](?)) : _unknown[43] "inline" "no return value for void"
  {
    (72127 call chpl_check_step_integral step[72118])
    unknown strType[72134] "type variable"(72133 call chpl__rangeStrideType idxType[72122])
    if(72146 call _cond_test(72139 call == step[72118] 0))
    {
      (72144 call compilerError "the step argument of the 'by' operator is zero")
    }
    if(72180 call _cond_test(72167 call &&(72155 call chpl_need_to_check_step step[72118] strType[72134])(72165 call > step[72118](72163 call _cast(72162 'typeof' step[72118])(72160 call max strType[72134])))))
    {
      (72178 call compilerError(72175 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(72173 call _cast string[24] strType[72134])))
    }
  }
  function chpl_by_help[72201](arg r[72198] :
  (72197 call range[66183](?) unknown i[72190] unknown b[72193] unknown s[72195]), arg step[72203]:_any[170](?)) : _unknown[43]
  {
    const lw[72210] "const"(72207 call . r[72198] c"low") i[72190]
    const hh[72218] "const"(72215 call . r[72198] c"high") i[72190]
    const st[72240] "const"(72238 call *(72228 call . r[72198] c"stride")(72236 call _cast(72233 call . r[72198] c"strType") step[72203]))(72224 call . r[72198] c"strType")
    const tmp[72364] "const" "temp"(72361 IfExpr (72259 call(72255 call . r[72198] c"isAmbiguous")) then
    { scopeless(72283 IfExpr (72261 call . r[72198] c"stridable") then
      { scopeless
        (72270 call _build_tuple 0(72266 call . r[72198] c"alignment"))
      } else
      { scopeless
        (72281 call _build_tuple 0(72279 call(72274 call . r[72198] c"chpl_intToIdx") 0))
      } )
    } else
    { scopeless(72358 IfExpr (72296 call &&(72291 call(72287 call . r[72198] c"hasLowBound"))(72294 call > st[72240] 0)) then
      { scopeless
        (72304 call _build_tuple 1(72300 call . r[72198] c"alignedLow"))
      } else
      { scopeless(72355 IfExpr (72316 call &&(72311 call(72307 call . r[72198] c"hasHighBound"))(72314 call < st[72240] 0)) then
        { scopeless
          (72324 call _build_tuple 1(72320 call . r[72198] c"alignedHigh"))
        } else
        { scopeless(72352 IfExpr (72327 call . r[72198] c"stridable") then
          { scopeless
            (72339 call _build_tuple(72331 call . r[72198] c"aligned")(72335 call . r[72198] c"alignment"))
          } else
          { scopeless
            (72350 call _build_tuple 0(72348 call(72343 call . r[72198] c"chpl_intToIdx") 0))
          } )
        } )
      } )
    } )(72252 call _build_tuple bool[10] i[72190])
    (72371 call _check_tuple_var_decl tmp[72364] 2)
    const ald[72244] "const"(72365 call tmp[72364] 1)
    const alt[72246] "const"(72368 call tmp[72364] 2)
    (72388 return(72387 'new'(72386 call range[66183](?) i[72190] b[72193] 1 lw[72210] hh[72218] st[72240] alt[72246] ald[72244])))
  }
  function chpl_by[72396](arg r[72394]:_any[170](?), arg step[72398]:_any[170](?)) : _unknown[43] "inline" "no doc"
  {
    if(72426 call _cond_test(72404 call !(72403 call isRange r[72394])))
    {
      (72424 call compilerError "the first argument of the 'by' operator is not a range")
    }
    (72439 call chpl_range_check_stride step[72398](72436 call . r[72394] c"idxType"))
    (72446 return(72445 call chpl_by_help r[72394] step[72398]))
  }
  function chpl_by[72459](arg r[72456] :
  (72455 call range[66183](?) ?[249]), param arg step[72461]:_any[170](?)) : _unknown[43] "inline" "no doc"
  {
    (72470 call chpl_range_check_stride step[72461](72467 call . r[72456] c"idxType"))
    (72484 return(72483 call chpl_by_help r[72456](72481 call _cast(72478 call . r[72456] c"strType") step[72461])))
  }
  function chpl_align[72502](arg r[72499] :
  (72498 call range[66183](?) unknown i[72491] unknown b[72494] unknown s[72496]), arg algn[72505] :
  i[72491]) : _unknown[43] "inline" "no doc"
  {
    (72541 return(72540 'new'(72539 call range[66183](?) i[72491] b[72494] 1(72522 call(72514 call . r[72499] c"chpl_intToIdx")(72518 call . r[72499] c"_low"))(72532 call(72524 call . r[72499] c"chpl_intToIdx")(72528 call . r[72499] c"_high"))(72534 call . r[72499] c"stride") algn[72505] 1)))
  }
  function chpl_align[72560](arg r[72557] :
  (72556 call range[66183](?) unknown i[72549] unknown b[72552] unknown s[72554]), arg algn[72562]:_any[170](?)) : _unknown[43] "inline" "no doc"
  {
    (72607 call compilerError "can't align a range with idxType "(72584 call _cast string[24] i[72549]) " using a value of type "(72605 call _cast string[24](72603 'typeof' algn[72562])))
    (72611 return r[72557])
  }
  function range[66183](?).offset[72622](arg _mt[72627]:_MT[227], arg this[72624]:range[66183](?) :
  range[66183](?), in arg offset[72619] :
  integral[188](?)) : _unknown[43] "method"
  {
    unknown offs[72636](72635 call(72630 call . offset[72619] c"safeCast")(342485 call . this[72624] c"intIdxType"))
    if(72669 call _cond_test(72641 call !(342490 call . this[72624] c"stridable")))
    {
      (72661 call compilerWarning "invoking 'offset' on an unstrided range has no effect.")
      (72666 call = offs[72636] 0)
    }
    if(72704 call _cond_test(72679 call && 1(72677 call !(72676 call(342496 call . this[72624] c"hasFirst")))))
    {
      (72702 call boundsCheckHalt module=[244] HaltWrappers[197622] "invoking 'offset' on a range without the first index")
    }
    (72730 return(72729 'new'(72728 call range[66183](?)(342503 call . this[72624] c"idxType")(342508 call . this[72624] c"boundedType")(342513 call . this[72624] c"stridable")(342517 call . this[72624] c"low")(342521 call . this[72624] c"high")(342525 call . this[72624] c"stride")(72726 call(342529 call . this[72624] c"chpl_intToIdx")(72723 call +(72719 call . this[72624] c"firstAsInt") offs[72636])) 1)))
  }
  function range[66183](?).this[72744](arg _mt[72749]:_MT[227], const arg this[72746]:range[66183](?) :
  range[66183](?), arg other[72741] :
  (72740 call range[66183](?) ?[249])) : _unknown[43] "method" "no doc"
  {
    unknown ambig[72752] 0
    if(72855 call _cond_test(72768 call ||(72761 call(72757 call . this[72746] c"isAmbiguous"))(72767 call(72763 call . other[72741] c"isAmbiguous"))))
    {
      unknown st1[72777](72776 call abs(72772 call . this[72746] c"stride"))
      unknown st2[72788](72787 call abs(72783 call . other[72741] c"stride"))
      unknown tmp[72801] "no copy" "temp"(72800 call chpl__extendedEuclid st1[72777] st2[72788])
      (72808 call _check_tuple_var_decl tmp[72801] 2)
      unknown g[72791](72802 call tmp[72801] 1)
      unknown x[72793](72805 call tmp[72801] 2)
      if(72845 call _cond_test(72818 call && 1(72816 call > g[72791] 1)))
      {
        (72843 call boundsCheckHalt module=[244] HaltWrappers[197622] "Cannot slice ranges with ambiguous alignments unless their strides are relatively prime.")
      }
      (72852 call = ambig[72752] 1)
    }
    function computeBoundedType[72863](arg r1[72861]:_any[170](?), arg r2[72865]:_any[170](?)) param : _unknown[43]
    {
      unknown low[72881] "param"(72879 call ||(72872 call(72868 call . r1[72861] c"hasLowBound"))(72878 call(72874 call . r2[72865] c"hasLowBound")))
      unknown high[72899] "param"(72897 call ||(72890 call(72886 call . r1[72861] c"hasHighBound"))(72896 call(72892 call . r2[72865] c"hasHighBound")))
      if(72944 call _cond_test(72904 call && low[72881] high[72899]))
      {
        (72910 return bounded[66079])
      }
      {
        if(72938 call _cond_test low[72881])
        {
          (72917 return boundedLow[66081])
        }
        {
          if(72932 call _cond_test high[72899])
          {
            (72924 return boundedHigh[66083])
          }
          {
            (72930 return boundedNone[66085])
          }
        }
      }
    }
    unknown lo1[72966](72963 IfExpr (72954 call(342558 call . this[72746] c"hasLowBound")) then
    { scopeless
      (72956 call . this[72746] c"_low")
    } else
    { scopeless
      (72960 call . other[72741] c"_low")
    } )
    unknown hi1[72983](72980 IfExpr (72971 call(342564 call . this[72746] c"hasHighBound")) then
    { scopeless
      (72973 call . this[72746] c"_high")
    } else
    { scopeless
      (72977 call . other[72741] c"_high")
    } )
    unknown st1[72993](72992 call abs(72988 call . this[72746] c"stride"))
    unknown lo2[73013](73010 IfExpr (73001 call(72997 call . other[72741] c"hasLowBound")) then
    { scopeless
      (73003 call . other[72741] c"_low")
    } else
    { scopeless
      (73007 call . this[72746] c"_low")
    } )
    unknown hi2[73033](73030 IfExpr (73021 call(73017 call . other[72741] c"hasHighBound")) then
    { scopeless
      (73023 call . other[72741] c"_high")
    } else
    { scopeless
      (73027 call . this[72746] c"_high")
    } )
    unknown st2[73043](73042 call abs(73038 call . other[72741] c"stride"))
    if(73065 call _cond_test(73049 call isUintType(342578 call . this[72746] c"intIdxType")))
    {
      if(73059 call _cond_test(73052 call < lo1[72966] 0))
      {
        (73056 call = lo1[72966] 0)
      }
    }
    unknown newStride[73074](73071 call . this[72746] c"stride")(342584 call . this[72746] c"strType")
    unknown lcm[73085](73084 call abs(73080 call . this[72746] c"stride"))(342589 call . this[72746] c"strType")
    unknown tmp[73105] "temp"(73103 call _build_tuple lcm[73085](73100 call _cast(342599 call . this[72746] c"strType") 0))(73095 call * 2(342594 call . this[72746] c"strType"))
    (73112 call _check_tuple_var_decl tmp[73105] 2)
    unknown g[73088](73106 call tmp[73105] 1)
    unknown x[73090](73109 call tmp[73105] 2)
    if(73218 call _cond_test(73139 call &&(73125 call !=(73118 call . this[72746] c"stride")(73122 call . other[72741] c"stride"))(73137 call !=(73128 call . this[72746] c"stride")(73135 call -(73132 call . other[72741] c"stride")))))
    {
      const tmp[73151] "const" "no copy" "temp"(73150 call chpl__extendedEuclid st1[72993] st2[73043])
      (73158 call _check_tuple_var_decl tmp[73151] 2)
      const tg[73141] "const"(73152 call tmp[73151] 1)
      const tx[73143] "const"(73155 call tmp[73151] 2)
      unknown tmp[328458] "expr temp" "maybe param" "maybe type" "temp"
      unknown tmp[328483] "maybe param" "temp"
      (328486 'move' tmp[328483](328484 'addr of' g[73088]))
      unknown tmp[328494] "maybe param" "temp"
      (328497 'move' tmp[328494](328495 'addr of' x[73090]))
      (328459 'move' tmp[328458](73184 call _build_tuple(73175 call(73170 call . tg[73141] c"safeCast")(342612 call . this[72746] c"strType"))(73182 call(73177 call . tx[73143] c"safeCast")(342617 call . this[72746] c"strType"))))
      { scopeless
        if(328475 call _cond_test(328468 call != 2(328465 call . tmp[328458] c"size")))
        {
          (328471 call compilerError "tuple size must match the number of grouped variables" 0)
        }
      }
      (328488 call = tmp[328483](328481 call tmp[328458] 1))
      (328499 call = tmp[328494](328492 call tmp[328458] 2))
      (73197 call = lcm[73085](73195 call *(73192 call / st1[72993] g[73088]) st2[73043]))
      (73215 call = newStride[73074](73212 IfExpr (73206 call >(73202 call . this[72746] c"stride") 0) then
      { scopeless
        lcm[73085]
      } else
      { scopeless
        (73210 call - lcm[73085])
      } ))
    }
    unknown emptyIntersection[73223] bool[10]
    function min[73232](arg x[73229] :
    int(64)[13], arg y[73235] :
    uint(64)[107]) : _unknown[43]
    {
      if(73249 call _cond_test(73243 call > y[73235](73242 call max int(64)[13])))
      {
        (73246 return x[73229])
      }
      (73262 return(73261 call min x[73229](73259 call _cast int(64)[13] y[73235])))
    }
    function min[73272](arg x[73269] :
    uint(64)[107], arg y[73275] :
    int(64)[13]) : _unknown[43]
    {
      if(73291 call _cond_test(73280 call < y[73275] 0))
      {
        (73284 call = emptyIntersection[73223] 1)
        (73289 return x[73269])
      }
      (73304 return(73303 call min x[73269](73301 call _cast uint(64)[107] y[73275])))
    }
    function max[73314](arg x[73311] :
    int(64)[13], arg y[73317] :
    uint(64)[107]) : _unknown[43]
    {
      if(73336 call _cond_test(73325 call > y[73317](73324 call max int(64)[13])))
      {
        (73329 call = emptyIntersection[73223] 1)
        (73334 return x[73311])
      }
      (73349 return(73348 call max x[73311](73346 call _cast int(64)[13] y[73317])))
    }
    function max[73359](arg x[73356] :
    uint(64)[107], arg y[73362] :
    int(64)[13]) : _unknown[43]
    {
      if(73373 call _cond_test(73367 call < y[73362] 0))
      {
        (73370 return x[73356])
      }
      (73386 return(73385 call max x[73356](73383 call _cast uint(64)[107] y[73362])))
    }
    (73392 call = emptyIntersection[73223] 0)
    unknown newlo[73403](73401 call _cast(342650 call . this[72746] c"intIdxType")(73399 call max lo1[72966] lo2[73013]))
    unknown newhi[73414](73412 call _cast(342656 call . this[72746] c"intIdxType")(73410 call min hi1[72983] hi2[73033]))
    if(73429 call _cond_test emptyIntersection[73223])
    {
      (73420 call = newlo[73403] 1)
      (73426 call = newhi[73414] 0)
    }
    unknown result[73481](73480 'new'(73479 call range[66183](?)(342665 call . this[72746] c"idxType")(73440 call computeBoundedType this[72746] other[72741])(73449 call |(73442 call . this[72746] c"stridable")(73446 call . other[72741] c"stridable"))(73454 call(342673 call . this[72746] c"chpl_intToIdx") newlo[73403])(73458 call(342678 call . this[72746] c"chpl_intToIdx") newhi[73414]) newStride[73074](73463 call(342684 call . this[72746] c"chpl_intToIdx") 0)(73477 call &&(73465 call ! ambig[72752])(73475 call ||(73468 call . this[72746] c"aligned")(73472 call . other[72741] c"aligned")))))
    if(73685 call _cond_test(73485 call . result[73481] c"stridable"))
    {
      unknown al1[73504](73502 call _cast int(64)[13](73499 call %(73494 call chpl__idxToInt(73490 call . this[72746] c"alignment"))(73497 call _cast(342694 call . this[72746] c"intIdxType") st1[72993])))
      unknown al2[73527](73525 call _cast int(64)[13](73522 call %(73514 call chpl__idxToInt(73510 call . other[72741] c"alignment"))(73520 call _cast(73517 call . other[72741] c"intIdxType") st2[73043])))
      if(73681 call _cond_test(73538 call !=(73535 call %(73532 call - al2[73527] al1[73504]) g[73088]) 0))
      {
        if(73574 call _cond_test(73547 call && 1(73545 call !(73544 call isBoundedRange result[73481]))))
        {
          (73572 call boundsCheckHalt module=[244] HaltWrappers[197622] "could not represent range slice - it needs to be empty, but the slice type is not bounded")
        }
        (73588 call =(73581 call . result[73481] c"_low")(73586 call _cast(342708 call . this[72746] c"intIdxType") 1))
        (73599 call =(73592 call . result[73481] c"_high")(73597 call _cast(342713 call . this[72746] c"intIdxType") 0))
        (73624 call =(73603 call . result[73481] c"_alignment")(73621 IfExpr (73611 call >(73607 call . this[72746] c"stride") 0) then
        { scopeless
          (73615 call _cast(342719 call . this[72746] c"intIdxType") 1)
        } else
        { scopeless
          (73619 call _cast(342723 call . this[72746] c"intIdxType") 0)
        } ))
      }
      {
        unknown offset[73634](73632 call *(73629 call - al2[73527] al1[73504]) x[73090])
        if(73647 call _cond_test(73640 call < offset[73634] 0))
        {
          (73644 call += offset[73634] lcm[73085])
        }
        (73678 call =(73653 call . result[73481] c"_alignment")(73676 call +(73658 call _cast(342735 call . this[72746] c"intIdxType") al1[73504])(73674 call /(73668 call *(73662 call _cast(342740 call . this[72746] c"intIdxType") offset[73634])(73666 call _cast(342745 call . this[72746] c"intIdxType") st1[72993]))(73672 call _cast(342750 call . this[72746] c"intIdxType") g[73088]))))
      }
    }
    (73690 return result[73481])
  }
  function chpl_count_help[73703](arg r[73700] :
  (73699 call range[66183](?) ?[249]), arg i[73705]:_any[170](?)) : _unknown[43] "no return value for void"
  {
    (73737 call compilerError "count operator is not defined for unbounded ranges")
  }
  where {
    (73715 call ==(73708 call . r[73700] c"boundedType") boundedNone[66085])
  }
  function chpl_count_help[73747](arg r[73745]:_any[170](?), arg count[73750] :
  integral[188](?)) : _unknown[43]
  {
    if(73784 call _cond_test(73760 call && 1(73759 call(73755 call . r[73745] c"isAmbiguous"))))
    {
      (73782 call boundsCheckHalt "count -- Cannot count off elements from a range which is ambiguously aligned.")
    }
    unknown resultType[73794] "type variable"(73791 call . r[73745] c"intIdxType")
    unknown strType[73801] "type variable"(73800 call chpl__rangeStrideType resultType[73794])
    function absSameType[73808](arg str[73806]:_any[170](?)) : _unknown[43]
    {
      if(73839 call _cond_test(73815 call <(73811 call . r[73745] c"stride") 0))
      {
        (73826 return(73824 call _cast resultType[73794](73821 call -(73818 call . r[73745] c"stride"))))
      }
      {
        (73836 return(73834 call _cast resultType[73794](73830 call . r[73745] c"stride")))
      }
    }
    if(74047 call _cond_test(73848 call == count[73750] 0))
    {
      if(74041 call _cond_test(73855 call(73851 call . r[73745] c"hasLowBound")))
      {
        (73930 return(73929 'new'(73928 call range[66183](?)(idxType =(73858 call . r[73745] c"idxType"))(boundedType = bounded[66079])(stridable =(73869 call . r[73745] c"stridable"))(_low =(73883 call chpl__intToIdx(73875 call . r[73745] c"idxType")(73880 call . r[73745] c"_low")))(_high =(73904 call chpl__intToIdx(73887 call . r[73745] c"idxType")(73902 call -(73892 call . r[73745] c"_low")(73901 call absSameType(73897 call . r[73745] c"stride")))))(_stride =(73907 call . r[73745] c"stride"))(_alignment =(73921 call chpl__intToIdx(73913 call . r[73745] c"idxType")(73918 call . r[73745] c"_alignment")))(_aligned =(73924 call . r[73745] c"aligned")))))
      }
      {
        if(74037 call _cond_test(73938 call(73934 call . r[73745] c"hasHighBound")))
        {
          (74013 return(74012 'new'(74011 call range[66183](?)(idxType =(73941 call . r[73745] c"idxType"))(boundedType = bounded[66079])(stridable =(73952 call . r[73745] c"stridable"))(_low =(73975 call chpl__intToIdx(73958 call . r[73745] c"idxType")(73973 call +(73963 call . r[73745] c"_high")(73972 call absSameType(73968 call . r[73745] c"stride")))))(_high =(73987 call chpl__intToIdx(73979 call . r[73745] c"idxType")(73984 call . r[73745] c"_high")))(_stride =(73990 call . r[73745] c"stride"))(_alignment =(74004 call chpl__intToIdx(73996 call . r[73745] c"idxType")(74001 call . r[73745] c"_alignment")))(_aligned =(74007 call . r[73745] c"aligned")))))
        }
        {
          (74034 call halt "Internal error: Unexpected case in chpl_count_help")
        }
      }
    }
    if(74088 call _cond_test(74066 call &&(74060 call && 1(74058 call !(74057 call(74053 call . r[73745] c"hasFirst"))))(74064 call > count[73750] 0)))
    {
      (74086 call boundsCheckHalt "With a positive count, the range must have a first index.")
    }
    if(74132 call _cond_test(74110 call &&(74104 call && 1(74102 call !(74101 call(74097 call . r[73745] c"hasLast"))))(74108 call < count[73750] 0)))
    {
      (74130 call boundsCheckHalt "With a negative count, the range must have a last index.")
    }
    if(74229 call _cond_test(74179 call &&(74148 call && 1(74146 call ==(74139 call . r[73745] c"boundedType") bounded[66079]))(74177 call >(74165 call _cast(74164 call uint(64)[107] 64)(74160 call abs(74157 call _cast(74156 call chpl__maxIntTypeSameSign(74154 'typeof' count[73750])) count[73750])))(74175 call _cast(74174 call uint(64)[107] 64)(74168 call . r[73745] c"length")))))
    {
      (74226 call boundsCheckHalt(74223 call +(74205 call + "bounded range is too small to access "(74203 call _cast string[24](74201 call abs count[73750]))) " elements"))
    }
    function chpl__computeTypeForCountMath[74237](arg t1[74235]:_any[170](?), arg t2[74239]:_any[170](?)) type : _unknown[43]
    {
      if(74295 call _cond_test(74243 call == t1[74235] t2[74239]))
      {
        (74249 return(74248 call chpl__idxTypeToIntIdxType t1[74235]))
      }
      {
        if(74291 call _cond_test(74266 call ||(74257 call ==(74255 call numBits t1[74235]) 64)(74264 call ==(74262 call numBits t2[74239]) 64)))
        {
          (74272 return(74271 call int(64)[13] 64))
        }
        {
          unknown x1[74276] t1[74235]
          unknown x2[74281] t2[74239]
          (74289 return(74288 'typeof'(74286 call + x1[74276] x2[74281])))
        }
      }
    }
    unknown computeType[74309] "type variable"(74308 call chpl__computeTypeForCountMath resultType[73794](74307 'typeof' count[73750]))
    unknown signedComputeType[74316] "type variable"(74315 call chpl__signedType computeType[74309])
    unknown diff[74332](74330 call *(74321 call _cast signedComputeType[74316] count[73750])(74328 call _cast signedComputeType[74316](74324 call . r[73745] c"stride")))
    unknown lo[74365](74362 IfExpr (74338 call > diff[74332] 0) then
    { scopeless
      (74341 call . r[73745] c"_low")
    } else
    { scopeless
      (74361 call chpl__add(74350 call _cast computeType[74309](74346 call . r[73745] c"_high"))(74358 call _cast computeType[74309](74355 call + diff[74332] 1)) resultType[73794])
    } ) resultType[73794]
    unknown hi[74398](74395 IfExpr (74371 call < diff[74332] 0) then
    { scopeless
      (74374 call . r[73745] c"_high")
    } else
    { scopeless
      (74394 call chpl__add(74383 call _cast computeType[74309](74379 call . r[73745] c"_low"))(74391 call -(74388 call _cast computeType[74309] diff[74332]) 1) resultType[73794])
    } ) resultType[73794]
    if(74462 call _cond_test(74402 call . r[73745] c"stridable"))
    {
      if(74428 call _cond_test(74418 call &&(74410 call(74406 call . r[73745] c"hasLowBound"))(74416 call < lo[74365](74413 call . r[73745] c"_low"))))
      {
        (74425 call = lo[74365](74422 call . r[73745] c"_low"))
      }
      if(74457 call _cond_test(74447 call &&(74439 call(74435 call . r[73745] c"hasHighBound"))(74445 call > hi[74398](74442 call . r[73745] c"_high"))))
      {
        (74454 call = hi[74398](74451 call . r[73745] c"_high"))
      }
    }
    (74543 return(74542 'new'(74541 call range[66183](?)(idxType =(74468 call . r[73745] c"idxType"))(boundedType = bounded[66079])(stridable =(74479 call . r[73745] c"stridable"))(_low =(74489 call(74484 call . r[73745] c"chpl_intToIdx") lo[74365]))(_high =(74497 call(74492 call . r[73745] c"chpl_intToIdx") hi[74398]))(_stride =(74511 IfExpr (74500 call . r[73745] c"stridable") then
    { scopeless
      (74508 call _cast strType[73801](74504 call . r[73745] c"stride"))
    } else
    { scopeless
      none[49]
    } ))(_alignment =(74524 IfExpr (74516 call . r[73745] c"stridable") then
    { scopeless
      (74520 call . r[73745] c"alignment")
    } else
    { scopeless
      none[49]
    } ))(_aligned =(74537 IfExpr (74529 call . r[73745] c"stridable") then
    { scopeless
      (74533 call . r[73745] c"aligned")
    } else
    { scopeless
      none[49]
    } )))))
  }
  function #[74557](arg r[74554] :
  (74553 call range[66183](?) unknown i[74550]), arg count[74563] :
  (74562 call chpl__rangeStrideType i[74550])) : _unknown[43]
  {
    (74571 return(74570 call chpl_count_help r[74554] count[74563]))
  }
  function #[74586](arg r[74583] :
  (74582 call range[66183](?) unknown i[74579]), arg count[74592] :
  (74591 call chpl__rangeUnsignedType i[74579])) : _unknown[43]
  {
    (74600 return(74599 call chpl_count_help r[74583] count[74592]))
  }
  function #[74615](arg r[74612] :
  (74611 call range[66183](?) unknown i[74608]), arg count[74617]:_any[170](?)) : _unknown[43]
  {
    (74662 call compilerError "can't apply '#' to a range with idxType "(74639 call _cast string[24] i[74608]) " using a count of type "(74660 call _cast string[24](74658 'typeof' count[74617])))
    (74666 return r[74612])
  }
  function chpl_checkIfRangeIterWillOverflow[74674](arg idxType[74672]:_any[170](?), arg low[74676]:_any[170](?), arg high[74678]:_any[170](?), arg stride[74680]:_any[170](?), arg first[74683] =
  low[74676], arg last[74687] =
  high[74678], arg shouldHalt[74691] =
  1) : _unknown[43]
  {
    if(74702 call _cond_test(74696 call > low[74676] high[74678]))
    {
      (74699 return 0)
    }
    unknown willOverFlow[74708] 0
    if(74892 call _cond_test(74714 call isIntType idxType[74672]))
    {
      if(74781 call _cond_test(74723 call &&(74717 call > last[74687] 0)(74721 call > stride[74680] 0)))
      {
        if(74741 call _cond_test(74733 call > stride[74680](74731 call -(74729 call max idxType[74672]) last[74687])))
        {
          (74737 call = willOverFlow[74708] 1)
        }
      }
      {
        if(74777 call _cond_test(74754 call &&(74748 call < last[74687] 0)(74752 call < stride[74680] 0)))
        {
          if(74772 call _cond_test(74764 call < stride[74680](74762 call -(74760 call min idxType[74672]) last[74687])))
          {
            (74768 call = willOverFlow[74708] 1)
          }
        }
      }
    }
    {
      if(74888 call _cond_test(74790 call isUintType idxType[74672]))
      {
        if(74845 call _cond_test(74793 call > stride[74680] 0))
        {
          if(74811 call _cond_test(74803 call <(74800 call + last[74687](74798 call _cast idxType[74672] stride[74680])) last[74687]))
          {
            (74807 call = willOverFlow[74708] 1)
          }
        }
        {
          if(74841 call _cond_test(74818 call < stride[74680] 0))
          {
            if(74836 call _cond_test(74828 call >(74825 call + last[74687](74823 call _cast idxType[74672] stride[74680])) last[74687]))
            {
              (74832 call = willOverFlow[74708] 1)
            }
          }
        }
      }
      {
        (74885 call compilerError "Iterator overflow checking is only supported " "for integral types")
      }
    }
    if(74925 call _cond_test(74899 call && willOverFlow[74708] shouldHalt[74691]))
    {
      (74922 call boundsCheckHalt module=[244] HaltWrappers[197622] "Iteration over a bounded range may be incorrect due to overflow.")
    }
    (74930 return willOverFlow[74708])
  }
  function range[66183](?).checkIfIterWillOverflow[74941](arg _mt[74946]:_MT[227], arg this[74943]:range[66183](?) :
  range[66183](?), arg shouldHalt[74938] =
  1) : _unknown[43] "method" "no doc"
  {
    (74976 return(74975 call chpl_checkIfRangeIterWillOverflow(74950 call . this[74943] c"intIdxType")(74955 call . this[74943] c"_low")(74959 call . this[74943] c"_high")(74963 call . this[74943] c"stride")(74967 call . this[74943] c"firstAsInt")(74971 call . this[74943] c"lastAsInt") shouldHalt[74938]))
  }
  function chpl_direct_range_iter[74991](arg low[74988] :
  (74987 call int(64)[13] unknown w[74984]), arg high[74997] :
  (74996 call int(64)[13] w[74984]), arg stride[75004] :
  (75003 call int(64)[13] w[74984])) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[75014] "const"(75012 call chpl_by(75009 call chpl_build_bounded_range low[74988] high[74997]) stride[75004])
    {
      unknown _indexOfInterest[75023] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75024] "expr temp" "temp"
      (75033 'move' _iterator[75024](75031 call _getIterator r[75014]))
      Defer
      {
        {
          (75049 call _freeIterator _iterator[75024])
        }
      }
      { scopeless type
        (75038 'move' _indexOfInterest[75023](75035 call iteratorIndex _iterator[75024]))
      }
      ForLoop
      {
        unknown i[75042] "index var" "insert auto destroy"
        (75044 'move' i[75042] _indexOfInterest[75023])
        (75021 yield i[75042])
        label _continueLabel[75028]
        _indexOfInterest[75023]
        _iterator[75024]
      }
      label _breakLabel[75029]
    }
  }
  function chpl_direct_range_iter[75068](arg low[75065] :
  (75064 call uint(64)[107] unknown w[75061]), arg high[75074] :
  (75073 call uint(64)[107] w[75061]), arg stride[75081] :
  (75080 call int(64)[13] w[75061])) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[75091] "const"(75089 call chpl_by(75086 call chpl_build_bounded_range low[75065] high[75074]) stride[75081])
    {
      unknown _indexOfInterest[75100] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75101] "expr temp" "temp"
      (75110 'move' _iterator[75101](75108 call _getIterator r[75091]))
      Defer
      {
        {
          (75126 call _freeIterator _iterator[75101])
        }
      }
      { scopeless type
        (75115 'move' _indexOfInterest[75100](75112 call iteratorIndex _iterator[75101]))
      }
      ForLoop
      {
        unknown i[75119] "index var" "insert auto destroy"
        (75121 'move' i[75119] _indexOfInterest[75100])
        (75098 yield i[75119])
        label _continueLabel[75105]
        _indexOfInterest[75100]
        _iterator[75101]
      }
      label _breakLabel[75106]
    }
  }
  function chpl_direct_range_iter[75141](arg low[75138] :
  enumerated[179](?), arg high[75144] :
  enumerated[179](?), arg stride[75148] :
  integral[188](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[75158] "const"(75156 call chpl_by(75153 call chpl_build_bounded_range low[75138] high[75144]) stride[75148])
    {
      unknown _indexOfInterest[75167] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75168] "expr temp" "temp"
      (75177 'move' _iterator[75168](75175 call _getIterator r[75158]))
      Defer
      {
        {
          (75193 call _freeIterator _iterator[75168])
        }
      }
      { scopeless type
        (75182 'move' _indexOfInterest[75167](75179 call iteratorIndex _iterator[75168]))
      }
      ForLoop
      {
        unknown i[75186] "index var" "insert auto destroy"
        (75188 'move' i[75186] _indexOfInterest[75167])
        (75165 yield i[75186])
        label _continueLabel[75172]
        _indexOfInterest[75167]
        _iterator[75168]
      }
      label _breakLabel[75173]
    }
  }
  function chpl_direct_range_iter[75208](arg low[75205] :
  bool[10], arg high[75211] :
  bool[10], arg stride[75215] :
  integral[188](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[75225] "const"(75223 call chpl_by(75220 call chpl_build_bounded_range low[75205] high[75211]) stride[75215])
    {
      unknown _indexOfInterest[75234] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75235] "expr temp" "temp"
      (75244 'move' _iterator[75235](75242 call _getIterator r[75225]))
      Defer
      {
        {
          (75260 call _freeIterator _iterator[75235])
        }
      }
      { scopeless type
        (75249 'move' _indexOfInterest[75234](75246 call iteratorIndex _iterator[75235]))
      }
      ForLoop
      {
        unknown i[75253] "index var" "insert auto destroy"
        (75255 'move' i[75253] _indexOfInterest[75234])
        (75232 yield i[75253])
        label _continueLabel[75239]
        _indexOfInterest[75234]
        _iterator[75235]
      }
      label _breakLabel[75240]
    }
  }
  function chpl_direct_range_iter[75279](arg low[75276] :
  (75275 call int(64)[13] unknown w[75272]), arg high[75285] :
  (75284 call int(64)[13] w[75272]), param arg stride[75292] :
  (75291 call int(64)[13] w[75272])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[75305] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75306] "expr temp" "temp"
      (75315 'move' _iterator[75306](75313 call _getIterator(75301 call chpl_direct_param_stride_range_iter low[75276] high[75285] stride[75292])))
      Defer
      {
        {
          (75332 call _freeIterator _iterator[75306])
        }
      }
      { scopeless type
        (75321 'move' _indexOfInterest[75305](75318 call iteratorIndex _iterator[75306]))
      }
      ForLoop
      {
        unknown i[75325] "index var" "insert auto destroy"
        (75327 'move' i[75325] _indexOfInterest[75305])
        (75303 yield i[75325])
        label _continueLabel[75310]
        _indexOfInterest[75305]
        _iterator[75306]
      }
      label _breakLabel[75311]
    }
  }
  function chpl_direct_range_iter[75352](arg low[75349] :
  (75348 call uint(64)[107] unknown w[75345]), arg high[75358] :
  (75357 call uint(64)[107] w[75345]), param arg stride[75365] :
  (75364 call int(64)[13] w[75345])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[75378] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75379] "expr temp" "temp"
      (75388 'move' _iterator[75379](75386 call _getIterator(75374 call chpl_direct_param_stride_range_iter low[75349] high[75358] stride[75365])))
      Defer
      {
        {
          (75405 call _freeIterator _iterator[75379])
        }
      }
      { scopeless type
        (75394 'move' _indexOfInterest[75378](75391 call iteratorIndex _iterator[75379]))
      }
      ForLoop
      {
        unknown i[75398] "index var" "insert auto destroy"
        (75400 'move' i[75398] _indexOfInterest[75378])
        (75376 yield i[75398])
        label _continueLabel[75383]
        _indexOfInterest[75378]
        _iterator[75379]
      }
      label _breakLabel[75384]
    }
  }
  function chpl_direct_range_iter[75421](arg low[75418] :
  enumerated[179](?), arg high[75424] :
  enumerated[179](?), param arg stride[75428] :
  integral[188](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    if(75530 call _cond_test(75433 call == stride[75428] 1))
    {
      const r[75439] "const"(75437 call chpl_build_bounded_range low[75418] high[75424])
      {
        unknown _indexOfInterest[75448] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75449] "expr temp" "temp"
        (75458 'move' _iterator[75449](75456 call _getIterator r[75439]))
        Defer
        {
          {
            (75474 call _freeIterator _iterator[75449])
          }
        }
        { scopeless type
          (75463 'move' _indexOfInterest[75448](75460 call iteratorIndex _iterator[75449]))
        }
        ForLoop
        {
          unknown i[75467] "index var" "insert auto destroy"
          (75469 'move' i[75467] _indexOfInterest[75448])
          (75446 yield i[75467])
          label _continueLabel[75453]
          _indexOfInterest[75448]
          _iterator[75449]
        }
        label _breakLabel[75454]
      }
    }
    {
      const r[75488] "const"(75486 call chpl_by(75483 call chpl_build_bounded_range low[75418] high[75424]) stride[75428])
      {
        unknown _indexOfInterest[75497] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75498] "expr temp" "temp"
        (75507 'move' _iterator[75498](75505 call _getIterator r[75488]))
        Defer
        {
          {
            (75523 call _freeIterator _iterator[75498])
          }
        }
        { scopeless type
          (75512 'move' _indexOfInterest[75497](75509 call iteratorIndex _iterator[75498]))
        }
        ForLoop
        {
          unknown i[75516] "index var" "insert auto destroy"
          (75518 'move' i[75516] _indexOfInterest[75497])
          (75495 yield i[75516])
          label _continueLabel[75502]
          _indexOfInterest[75497]
          _iterator[75498]
        }
        label _breakLabel[75503]
      }
    }
  }
  function chpl_direct_range_iter[75543](arg low[75540] :
  bool[10], arg high[75546] :
  bool[10], param arg stride[75550] :
  integral[188](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    if(75652 call _cond_test(75555 call == stride[75550] 1))
    {
      const r[75561] "const"(75559 call chpl_build_bounded_range low[75540] high[75546])
      {
        unknown _indexOfInterest[75570] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75571] "expr temp" "temp"
        (75580 'move' _iterator[75571](75578 call _getIterator r[75561]))
        Defer
        {
          {
            (75596 call _freeIterator _iterator[75571])
          }
        }
        { scopeless type
          (75585 'move' _indexOfInterest[75570](75582 call iteratorIndex _iterator[75571]))
        }
        ForLoop
        {
          unknown i[75589] "index var" "insert auto destroy"
          (75591 'move' i[75589] _indexOfInterest[75570])
          (75568 yield i[75589])
          label _continueLabel[75575]
          _indexOfInterest[75570]
          _iterator[75571]
        }
        label _breakLabel[75576]
      }
    }
    {
      const r[75610] "const"(75608 call chpl_by(75605 call chpl_build_bounded_range low[75540] high[75546]) stride[75550])
      {
        unknown _indexOfInterest[75619] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75620] "expr temp" "temp"
        (75629 'move' _iterator[75620](75627 call _getIterator r[75610]))
        Defer
        {
          {
            (75645 call _freeIterator _iterator[75620])
          }
        }
        { scopeless type
          (75634 'move' _indexOfInterest[75619](75631 call iteratorIndex _iterator[75620]))
        }
        ForLoop
        {
          unknown i[75638] "index var" "insert auto destroy"
          (75640 'move' i[75638] _indexOfInterest[75619])
          (75617 yield i[75638])
          label _continueLabel[75624]
          _indexOfInterest[75619]
          _iterator[75620]
        }
        label _breakLabel[75625]
      }
    }
  }
  function chpl_direct_range_iter[75669](arg low[75666] :
  (75665 call int(64)[13] unknown w[75662]), arg high[75675] :
  (75674 call int(64)[13] w[75662]), arg stride[75682] :
  (75681 call uint(64)[107] w[75662])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[75695] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75696] "expr temp" "temp"
      (75705 'move' _iterator[75696](75703 call _getIterator(75691 call chpl_direct_pos_stride_range_iter low[75666] high[75675] stride[75682])))
      Defer
      {
        {
          (75722 call _freeIterator _iterator[75696])
        }
      }
      { scopeless type
        (75711 'move' _indexOfInterest[75695](75708 call iteratorIndex _iterator[75696]))
      }
      ForLoop
      {
        unknown i[75715] "index var" "insert auto destroy"
        (75717 'move' i[75715] _indexOfInterest[75695])
        (75693 yield i[75715])
        label _continueLabel[75700]
        _indexOfInterest[75695]
        _iterator[75696]
      }
      label _breakLabel[75701]
    }
  }
  function chpl_direct_range_iter[75742](arg low[75739] :
  (75738 call uint(64)[107] unknown w[75735]), arg high[75748] :
  (75747 call uint(64)[107] w[75735]), arg stride[75755] :
  (75754 call uint(64)[107] w[75735])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[75768] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75769] "expr temp" "temp"
      (75778 'move' _iterator[75769](75776 call _getIterator(75764 call chpl_direct_pos_stride_range_iter low[75739] high[75748] stride[75755])))
      Defer
      {
        {
          (75795 call _freeIterator _iterator[75769])
        }
      }
      { scopeless type
        (75784 'move' _indexOfInterest[75768](75781 call iteratorIndex _iterator[75769]))
      }
      ForLoop
      {
        unknown i[75788] "index var" "insert auto destroy"
        (75790 'move' i[75788] _indexOfInterest[75768])
        (75766 yield i[75788])
        label _continueLabel[75773]
        _indexOfInterest[75768]
        _iterator[75769]
      }
      label _breakLabel[75774]
    }
  }
  function chpl_direct_range_iter[75815](arg low[75812] :
  (75811 call int(64)[13] unknown w[75808]), arg high[75821] :
  (75820 call int(64)[13] w[75808]), arg stride[75824]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    (75842 call compilerError "can't apply 'by' to a range with idxType "(75834 call _cast string[24](75832 call int(64)[13] w[75808])) " using a step of type "(75840 call _cast string[24](75838 'typeof' stride[75824])))
  }
  function chpl_direct_range_iter[75857](arg low[75854] :
  (75853 call uint(64)[107] unknown w[75850]), arg high[75863] :
  (75862 call uint(64)[107] w[75850]), arg stride[75866]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    (75884 call compilerError "can't apply 'by' to a range with idxType "(75876 call _cast string[24](75874 call uint(64)[107] w[75850])) " using a step of type "(75882 call _cast string[24](75880 'typeof' stride[75866])))
  }
  function chpl_direct_range_iter[75893](arg low[75891]:_any[170](?), arg high[75895]:_any[170](?), arg stride[75897]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    (75902 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_direct_counted_range_iter[75917](arg low[75914] :
  (75913 call int(64)[13] unknown w[75910]), arg count[75923] :
  (75922 call int(64)[13] w[75910])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[75935] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75936] "expr temp" "temp"
      (75945 'move' _iterator[75936](75943 call _getIterator(75931 call chpl_direct_counted_range_iter_helper low[75914] count[75923])))
      Defer
      {
        {
          (75962 call _freeIterator _iterator[75936])
        }
      }
      { scopeless type
        (75951 'move' _indexOfInterest[75935](75948 call iteratorIndex _iterator[75936]))
      }
      ForLoop
      {
        unknown i[75955] "index var" "insert auto destroy"
        (75957 'move' i[75955] _indexOfInterest[75935])
        (75933 yield i[75955])
        label _continueLabel[75940]
        _indexOfInterest[75935]
        _iterator[75936]
      }
      label _breakLabel[75941]
    }
  }
  function chpl_direct_counted_range_iter[75982](arg low[75979] :
  (75978 call int(64)[13] unknown w[75975]), arg count[75988] :
  (75987 call uint(64)[107] w[75975])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[76000] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76001] "expr temp" "temp"
      (76010 'move' _iterator[76001](76008 call _getIterator(75996 call chpl_direct_counted_range_iter_helper low[75979] count[75988])))
      Defer
      {
        {
          (76027 call _freeIterator _iterator[76001])
        }
      }
      { scopeless type
        (76016 'move' _indexOfInterest[76000](76013 call iteratorIndex _iterator[76001]))
      }
      ForLoop
      {
        unknown i[76020] "index var" "insert auto destroy"
        (76022 'move' i[76020] _indexOfInterest[76000])
        (75998 yield i[76020])
        label _continueLabel[76005]
        _indexOfInterest[76000]
        _iterator[76001]
      }
      label _breakLabel[76006]
    }
  }
  function chpl_direct_counted_range_iter[76047](arg low[76044] :
  (76043 call uint(64)[107] unknown w[76040]), arg count[76053] :
  (76052 call int(64)[13] w[76040])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[76065] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76066] "expr temp" "temp"
      (76075 'move' _iterator[76066](76073 call _getIterator(76061 call chpl_direct_counted_range_iter_helper low[76044] count[76053])))
      Defer
      {
        {
          (76092 call _freeIterator _iterator[76066])
        }
      }
      { scopeless type
        (76081 'move' _indexOfInterest[76065](76078 call iteratorIndex _iterator[76066]))
      }
      ForLoop
      {
        unknown i[76085] "index var" "insert auto destroy"
        (76087 'move' i[76085] _indexOfInterest[76065])
        (76063 yield i[76085])
        label _continueLabel[76070]
        _indexOfInterest[76065]
        _iterator[76066]
      }
      label _breakLabel[76071]
    }
  }
  function chpl_direct_counted_range_iter[76112](arg low[76109] :
  (76108 call uint(64)[107] unknown w[76105]), arg count[76118] :
  (76117 call uint(64)[107] w[76105])) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[76130] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76131] "expr temp" "temp"
      (76140 'move' _iterator[76131](76138 call _getIterator(76126 call chpl_direct_counted_range_iter_helper low[76109] count[76118])))
      Defer
      {
        {
          (76157 call _freeIterator _iterator[76131])
        }
      }
      { scopeless type
        (76146 'move' _indexOfInterest[76130](76143 call iteratorIndex _iterator[76131]))
      }
      ForLoop
      {
        unknown i[76150] "index var" "insert auto destroy"
        (76152 'move' i[76150] _indexOfInterest[76130])
        (76128 yield i[76150])
        label _continueLabel[76135]
        _indexOfInterest[76130]
        _iterator[76131]
      }
      label _breakLabel[76136]
    }
  }
  function chpl_direct_counted_range_iter[76173](arg low[76170] :
  enumerated[179](?), arg count[76180] :
  (76179 call int(64)[13] unknown w[76176])) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[76186] "const"(76184 call chpl_build_low_bounded_range low[76170])
    {
      unknown _indexOfInterest[76198] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76199] "expr temp" "temp"
      (76208 'move' _iterator[76199](76206 call _getIterator(76193 call # r[76186] count[76180])))
      Defer
      {
        {
          (76226 call _freeIterator _iterator[76199])
        }
      }
      { scopeless type
        (76215 'move' _indexOfInterest[76198](76212 call iteratorIndex _iterator[76199]))
      }
      ForLoop
      {
        unknown i[76219] "index var" "insert auto destroy"
        (76221 'move' i[76219] _indexOfInterest[76198])
        (76196 yield i[76219])
        label _continueLabel[76203]
        _indexOfInterest[76198]
        _iterator[76199]
      }
      label _breakLabel[76204]
    }
  }
  function chpl_direct_counted_range_iter[76241](arg low[76238] :
  enumerated[179](?), arg count[76248] :
  (76247 call uint(64)[107] unknown w[76244])) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[76254] "const"(76252 call chpl_build_low_bounded_range low[76238])
    {
      unknown _indexOfInterest[76266] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76267] "expr temp" "temp"
      (76276 'move' _iterator[76267](76274 call _getIterator(76261 call # r[76254] count[76248])))
      Defer
      {
        {
          (76294 call _freeIterator _iterator[76267])
        }
      }
      { scopeless type
        (76283 'move' _indexOfInterest[76266](76280 call iteratorIndex _iterator[76267]))
      }
      ForLoop
      {
        unknown i[76287] "index var" "insert auto destroy"
        (76289 'move' i[76287] _indexOfInterest[76266])
        (76264 yield i[76287])
        label _continueLabel[76271]
        _indexOfInterest[76266]
        _iterator[76267]
      }
      label _breakLabel[76272]
    }
  }
  function chpl_direct_counted_range_iter[76309](arg low[76306] :
  bool[10], arg count[76316] :
  (76315 call int(64)[13] unknown w[76312])) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[76322] "const"(76320 call chpl_build_low_bounded_range low[76306])
    {
      unknown _indexOfInterest[76334] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76335] "expr temp" "temp"
      (76344 'move' _iterator[76335](76342 call _getIterator(76329 call # r[76322] count[76316])))
      Defer
      {
        {
          (76362 call _freeIterator _iterator[76335])
        }
      }
      { scopeless type
        (76351 'move' _indexOfInterest[76334](76348 call iteratorIndex _iterator[76335]))
      }
      ForLoop
      {
        unknown i[76355] "index var" "insert auto destroy"
        (76357 'move' i[76355] _indexOfInterest[76334])
        (76332 yield i[76355])
        label _continueLabel[76339]
        _indexOfInterest[76334]
        _iterator[76335]
      }
      label _breakLabel[76340]
    }
  }
  function chpl_direct_counted_range_iter[76377](arg low[76374] :
  bool[10], arg count[76384] :
  (76383 call uint(64)[107] unknown w[76380])) : _unknown[43] "iterator fn" "no return value for void"
  {
    const r[76390] "const"(76388 call chpl_build_low_bounded_range low[76374])
    {
      unknown _indexOfInterest[76402] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76403] "expr temp" "temp"
      (76412 'move' _iterator[76403](76410 call _getIterator(76397 call # r[76390] count[76384])))
      Defer
      {
        {
          (76430 call _freeIterator _iterator[76403])
        }
      }
      { scopeless type
        (76419 'move' _indexOfInterest[76402](76416 call iteratorIndex _iterator[76403]))
      }
      ForLoop
      {
        unknown i[76423] "index var" "insert auto destroy"
        (76425 'move' i[76423] _indexOfInterest[76402])
        (76400 yield i[76423])
        label _continueLabel[76407]
        _indexOfInterest[76402]
        _iterator[76403]
      }
      label _breakLabel[76408]
    }
  }
  function chpl_direct_counted_range_iter[76445](arg low[76442] :
  integral[188](?), arg count[76447]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    (76463 call compilerError "can't apply '#' to a range with idxType "(76455 call _cast string[24](76453 'typeof' low[76442])) " using a count of type "(76461 call _cast string[24](76459 'typeof' count[76447])))
  }
  function chpl_direct_counted_range_iter[76472](arg low[76470]:_any[170](?), arg count[76474]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    (76479 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_direct_counted_range_iter_helper[76488](arg low[76486]:_any[170](?), arg count[76490]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    if(76514 call _cond_test(76504 call &&(76498 call && 1(76497 call isIntType(76495 'typeof' count[76490])))(76502 call < count[76490] 0)))
    {
      (76512 call boundsCheckHalt module=[244] HaltWrappers[197622] "With a negative count, the range must have a last index.")
    }
    const tmp[76562] "const" "no auto destroy" "no copy" "temp"(76559 IfExpr (76527 call == count[76490] 0) then
    { scopeless
      (76542 call _build_tuple low[76486](76539 call _cast(76538 'typeof' low[76486])(76535 call -(76532 call _cast uint(64)[107] low[76486]) 1)))
    } else
    { scopeless
      (76557 call _build_tuple low[76486](76554 call + low[76486](76552 call -(76549 call _cast(76548 'typeof' low[76486]) count[76490]) 1)))
    } )
    (76569 call _check_tuple_var_decl tmp[76562] 2)
    const start[76520] "const"(76563 call tmp[76562] 1)
    const end[76522] "const"(76566 call tmp[76562] 2)
    {
      unknown _indexOfInterest[76584] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[76585] "expr temp" "temp"
      (76594 'move' _iterator[76585](76592 call _getIterator(76580 call chpl_direct_param_stride_range_iter start[76520] end[76522] 1)))
      Defer
      {
        {
          (76611 call _freeIterator _iterator[76585])
        }
      }
      { scopeless type
        (76600 'move' _indexOfInterest[76584](76597 call iteratorIndex _iterator[76585]))
      }
      ForLoop
      {
        unknown i[76604] "index var" "insert auto destroy"
        (76606 'move' i[76604] _indexOfInterest[76584])
        (76582 yield i[76604])
        label _continueLabel[76589]
        _indexOfInterest[76584]
        _iterator[76585]
      }
      label _breakLabel[76590]
    }
  }
  function chpl_direct_pos_stride_range_iter[76627](arg low[76624] :
  unknown t[76622], arg high[76629]:_any[170](?), arg stride[76631]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    if(76773 call _cond_test useOptimizedRangeIterators[66075])
    {
      (76638 call chpl_range_check_stride stride[76631] t[76622])
      if(76650 call _cond_test 1)
      {
        (76648 call chpl_checkIfRangeIterWillOverflow t[76622] low[76624] high[76629] stride[76631])
      }
      unknown i[76656] t[76622]
      CForLoop
      {
        {
          (76696 yield i[76656])
        }
        label _continueLabel[76716]
        {
          (76701 '=' i[76656] low[76624])
        }
        {
          (76704 '<=' i[76656] high[76629])
        }
        {
          (76707 '+=' i[76656](76710 call _cast t[76622] stride[76631]))
        }
      }
      label _breakLabel[76717]
    }
    {
      {
        unknown _indexOfInterest[76738] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76739] "expr temp" "temp"
        (76748 'move' _iterator[76739](76746 call _getIterator(76734 call(76730 call .(76726 call chpl_by(76723 call chpl_build_bounded_range low[76624] high[76629]) stride[76631]) c"generalIterator"))))
        Defer
        {
          {
            (76765 call _freeIterator _iterator[76739])
          }
        }
        { scopeless type
          (76754 'move' _indexOfInterest[76738](76751 call iteratorIndex _iterator[76739]))
        }
        ForLoop
        {
          unknown i[76758] "index var" "insert auto destroy"
          (76760 'move' i[76758] _indexOfInterest[76738])
          (76736 yield i[76758])
          label _continueLabel[76743]
          _indexOfInterest[76738]
          _iterator[76739]
        }
        label _breakLabel[76744]
      }
    }
  }
  function chpl_direct_param_stride_range_iter[76787](arg low[76784] :
  unknown t[76782], arg high[76789]:_any[170](?), param arg stride[76791]:_any[170](?)) : _unknown[43] "iterator fn" "no return value for void"
  {
    if(76997 call _cond_test useOptimizedRangeIterators[66075])
    {
      (76798 call chpl_range_check_stride stride[76791] t[76782])
      unknown i[76802] t[76782]
      if(76941 call _cond_test(76807 call > stride[76791] 0))
      {
        if(76818 call _cond_test 1)
        {
          (76816 call chpl_checkIfRangeIterWillOverflow t[76782] low[76784] high[76789] stride[76791])
        }
        CForLoop
        {
          {
            (76846 yield i[76802])
          }
          label _continueLabel[76866]
          {
            (76851 '=' i[76802] low[76784])
          }
          {
            (76854 '<=' i[76802] high[76789])
          }
          {
            (76857 '+=' i[76802](76860 call _cast t[76782] stride[76791]))
          }
        }
        label _breakLabel[76867]
      }
      {
        if(76937 call _cond_test(76872 call < stride[76791] 0))
        {
          if(76885 call _cond_test 1)
          {
            (76883 call chpl_checkIfRangeIterWillOverflow t[76782] low[76784] high[76789] stride[76791] high[76789] low[76784])
          }
          CForLoop
          {
            {
              (76913 yield i[76802])
            }
            label _continueLabel[76933]
            {
              (76918 '=' i[76802] high[76789])
            }
            {
              (76921 '>=' i[76802] low[76784])
            }
            {
              (76924 '+=' i[76802](76927 call _cast t[76782] stride[76791]))
            }
          }
          label _breakLabel[76934]
        }
      }
    }
    {
      {
        unknown _indexOfInterest[76962] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76963] "expr temp" "temp"
        (76972 'move' _iterator[76963](76970 call _getIterator(76958 call(76954 call .(76952 call chpl_by(76949 call chpl_build_bounded_range low[76784] high[76789]) stride[76791]) c"generalIterator"))))
        Defer
        {
          {
            (76989 call _freeIterator _iterator[76963])
          }
        }
        { scopeless type
          (76978 'move' _indexOfInterest[76962](76975 call iteratorIndex _iterator[76963]))
        }
        ForLoop
        {
          unknown i[76982] "index var" "insert auto destroy"
          (76984 'move' i[76982] _indexOfInterest[76962])
          (76960 yield i[76982])
          label _continueLabel[76967]
          _indexOfInterest[76962]
          _iterator[76963]
        }
        label _breakLabel[76968]
      }
    }
  }
  function range[66183](?).these[77007](arg _mt[77012]:_MT[227], arg this[77009]:range[66183](?) :
  range[66183](?)) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77048 call _cond_test(77026 call ==(343121 call . this[77009] c"boundedType") boundedNone[66085]))
    {
      (77046 call compilerError "iteration over a range with no bounds")
    }
    if(77126 call _cond_test 1)
    {
      if(77086 call _cond_test(77061 call !(77060 call(77056 call . this[77009] c"hasFirst"))))
      {
        (77084 call boundsCheckHalt module=[244] HaltWrappers[197622] "iteration over range that has no first index")
      }
      if(77121 call _cond_test(77097 call(77093 call . this[77009] c"isAmbiguous")))
      {
        (77119 call boundsCheckHalt module=[244] HaltWrappers[197622] "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    unknown i[77131](343131 call . this[77009] c"intIdxType")
    const start[77141] "const"(77140 call chpl__idxToInt(77136 call . this[77009] c"first"))
    CForLoop
    {
      {
        (77165 yield(77164 call(343136 call . this[77009] c"chpl_intToIdx") i[77131]))
      }
      label _continueLabel[77183]
      {
        (77170 '=' i[77131] start[77141])
      }
      {
        1
      }
      {
        (77174 '+=' i[77131](77177 call _cast(343144 call . this[77009] c"intIdxType")(343148 call . this[77009] c"stride")))
      }
    }
    label _breakLabel[77184]
  }
  where {
    (77019 call !=(343115 call . this[77009] c"boundedType") bounded[66079])
  }
  function range[66183](?).these[77193](arg _mt[77198]:_MT[227], arg this[77195]:range[66183](?) :
  range[66183](?)) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77377 call _cond_test useOptimizedRangeIterators[66075])
    {
      if(77239 call _cond_test 1)
      {
        (77217 call(343167 call . this[77195] c"checkIfIterWillOverflow"))
        if(77234 call _cond_test(77225 call(77221 call . this[77195] c"isAmbiguous")))
        {
          (77232 call boundsCheckHalt module=[244] HaltWrappers[197622] "these -- Attempt to iterate over a range with ambiguous alignment.")
        }
      }
      unknown i[77245](343173 call . this[77195] c"intIdxType")
      const start[77252] "const"(77249 call . this[77195] c"firstAsInt")
      const end[77280] "const"(77277 IfExpr (77264 call >(77257 call . this[77195] c"low")(77261 call . this[77195] c"high")) then
      { scopeless
        start[77252]
      } else
      { scopeless
        (77275 call +(77268 call . this[77195] c"lastAsInt")(77273 call _cast(343190 call . this[77195] c"intIdxType")(343186 call . this[77195] c"stride")))
      } )(343178 call . this[77195] c"intIdxType")
      CForLoop
      {
        {
          (77308 yield(77307 call(343194 call . this[77195] c"chpl_intToIdx") i[77245]))
        }
        label _continueLabel[77328]
        {
          (77313 '=' i[77245] start[77252])
        }
        {
          (77316 '!=' i[77245] end[77280])
        }
        {
          (77319 '+=' i[77245](77322 call _cast(343204 call . this[77195] c"intIdxType")(343208 call . this[77195] c"stride")))
        }
      }
      label _breakLabel[77329]
    }
    {
      {
        unknown _indexOfInterest[77342] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[77343] "expr temp" "temp"
        (77352 'move' _iterator[77343](77350 call _getIterator(77338 call(77334 call . this[77195] c"generalIterator"))))
        Defer
        {
          {
            (77369 call _freeIterator _iterator[77343])
          }
        }
        { scopeless type
          (77358 'move' _indexOfInterest[77342](77355 call iteratorIndex _iterator[77343]))
        }
        ForLoop
        {
          unknown i[77362] "index var" "insert auto destroy"
          (77364 'move' i[77362] _indexOfInterest[77342])
          (77340 yield i[77362])
          label _continueLabel[77347]
          _indexOfInterest[77342]
          _iterator[77343]
        }
        label _breakLabel[77348]
      }
    }
  }
  where {
    (77211 call &&(77205 call ==(343153 call . this[77195] c"boundedType") bounded[66079])(77209 call ==(343159 call . this[77195] c"stridable") 1))
  }
  function range[66183](?).these[77388](arg _mt[77393]:_MT[227], arg this[77390]:range[66183](?) :
  range[66183](?)) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77532 call _cond_test useOptimizedRangeIterators[66075])
    {
      if(77414 call _cond_test 1)
      {
        (77412 call(343227 call . this[77390] c"checkIfIterWillOverflow"))
      }
      unknown i[77421](343231 call . this[77390] c"intIdxType")
      const start[77428] "const"(77425 call . this[77390] c"_low")
      const end[77435] "const"(77432 call . this[77390] c"_high")
      CForLoop
      {
        {
          (77463 yield(77462 call(343237 call . this[77390] c"chpl_intToIdx") i[77421]))
        }
        label _continueLabel[77483]
        {
          (77468 '=' i[77421] start[77428])
        }
        {
          (77471 '<=' i[77421] end[77435])
        }
        {
          (77474 '+=' i[77421](77477 call _cast(343247 call . this[77390] c"intIdxType")(343251 call . this[77390] c"stride")))
        }
      }
      label _breakLabel[77484]
    }
    {
      {
        unknown _indexOfInterest[77497] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[77498] "expr temp" "temp"
        (77507 'move' _iterator[77498](77505 call _getIterator(77493 call(77489 call . this[77390] c"generalIterator"))))
        Defer
        {
          {
            (77524 call _freeIterator _iterator[77498])
          }
        }
        { scopeless type
          (77513 'move' _indexOfInterest[77497](77510 call iteratorIndex _iterator[77498]))
        }
        ForLoop
        {
          unknown i[77517] "index var" "insert auto destroy"
          (77519 'move' i[77517] _indexOfInterest[77497])
          (77495 yield i[77517])
          label _continueLabel[77502]
          _indexOfInterest[77497]
          _iterator[77498]
        }
        label _breakLabel[77503]
      }
    }
  }
  where {
    (77406 call &&(77400 call ==(343215 call . this[77390] c"boundedType") bounded[66079])(77404 call ==(343221 call . this[77390] c"stridable") 0))
  }
  function range[66183](?).generalIterator[77543](arg _mt[77548]:_MT[227], arg this[77545]:range[66183](?) :
  range[66183](?)) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77567 call _cond_test(77557 call && 1(77556 call(77552 call . this[77545] c"isAmbiguous"))))
    {
      (77565 call boundsCheckHalt module=[244] HaltWrappers[197622] "these -- Attempt to iterate over a range with ambiguous alignment.")
    }
    unknown i[77574](343260 call . this[77545] c"intIdxType")
    const start[77581] "const"(77578 call . this[77545] c"first")
    const end[77604] "const"(77601 IfExpr (77592 call >(77585 call . this[77545] c"low")(77589 call . this[77545] c"high")) then
    { scopeless
      start[77581]
    } else
    { scopeless
      (77598 call . this[77545] c"last")
    } )
    CForLoop
    {
      {
        (77629 yield i[77574])
        if(77639 call _cond_test(77634 call == i[77574] end[77604]))
        {
          break _breakLabel[77662] _breakLabel[77662]
        }
      }
      label _continueLabel[77661]
      {
        (77646 '=' i[77574] start[77581])
      }
      {
        (77649 '>='(343274 call . this[77545] c"high")(343278 call . this[77545] c"low"))
      }
      {
        (77652 '+=' i[77574](77655 call _cast(343283 call . this[77545] c"intIdxType")(343287 call . this[77545] c"stride")))
      }
    }
    label _breakLabel[77662]
  }
  function range[66183](?).these[77674](arg _mt[77679]:_MT[227], arg this[77676]:range[66183](?) :
  range[66183](?), param arg tag[77671] :
  iterKind[697]) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77720 call _cond_test(77697 call !(77696 call isBoundedRange this[77676])))
    {
      (77717 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(77743 call _cond_test(77732 call && 1(77731 call(77727 call . this[77676] c"isAmbiguous"))))
    {
      (77740 call boundsCheckHalt module=[244] HaltWrappers[197622] "these -- Attempt to iterate over a range with ambiguous alignment.")
    }
    if(77769 call _cond_test debugChapelRange[66071])
    {
      (77766 call chpl_debug_writeln "*** In range standalone iterator:")
    }
    const len[77777] "const"(77774 call . this[77676] c"length")
    const numChunks[77806] "const"(77803 IfExpr (77797 'task_get_serial') then
    { scopeless
      1
    } else
    { scopeless
      (77802 call _computeNumChunks len[77777])
    } )
    if(77849 call _cond_test debugChapelRange[66071])
    {
      (77846 call chpl_debug_writeln "*** RI: length=" len[77777] " numChunks=" numChunks[77806])
    }
    if(78491 call _cond_test(77855 call <= numChunks[77806] 1))
    {
      {
        unknown _indexOfInterest[77863] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[77864] "expr temp" "temp"
        (77873 'move' _iterator[77864](77871 call _getIterator this[77676]))
        Defer
        {
          {
            (77889 call _freeIterator _iterator[77864])
          }
        }
        { scopeless type
          (77878 'move' _indexOfInterest[77863](77875 call iteratorIndex _iterator[77864]))
        }
        ForLoop
        {
          unknown i[77882] "index var" "insert auto destroy"
          (77884 'move' i[77882] _indexOfInterest[77863])
          {
            (77860 yield i[77882])
          }
          label _continueLabel[77868]
          _indexOfInterest[77863]
          _iterator[77864]
        }
        label _breakLabel[77869]
      }
    }
    {
      {
        unknown tmpIter[78134] "expr temp" "maybe ref" "no copy" "temp"
        (78137 'move' tmpIter[78134](77902 call #(77899 call chpl_build_low_bounded_range 0) numChunks[77806]))
        unknown isRngDomArr[78471] "maybe param" "temp"
        (78486 'move' isRngDomArr[78471](78484 call ||(78473 call isBoundedRange tmpIter[78134])(78482 call ||(78476 call isDomain tmpIter[78134])(78479 call isArray tmpIter[78134]))))
        if isRngDomArr[78471]
        {
          const _coforallCount[78338] "const" "end count" "temp"
          (78407 'move' _coforallCount[78338](78404 call _endCountAlloc 1))
          unknown numTasks[78339] "temp"
          (78391 'move' numTasks[78339](78387 call . tmpIter[78134] c"size"))
          (78382 call _upEndCount _coforallCount[78338] 1 numTasks[78339])
          (78379 call chpl_resetTaskSpawn numTasks[78339])
          unknown _indexOfInterest[78346] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[78347] "expr temp" "temp"
          (78356 'move' _iterator[78347](78354 call _getIterator tmpIter[78134]))
          Defer
          {
            {
              (78372 call _freeIterator _iterator[78347])
            }
          }
          { scopeless type
            (78361 'move' _indexOfInterest[78346](78358 call iteratorIndex _iterator[78347]))
          }
          ForLoop
          {
            unknown chunk[78365] "coforall index var" "index var" "insert auto destroy"
            (78367 'move' chunk[78365] _indexOfInterest[78346])
            {
              {
                if(78141 call _cond_test(343370 call . this[77676] c"stridable"))
                {
                  const tmp[78145] "const" "no copy" "temp"(78147 call _computeBlock len[77777] numChunks[77806] chunk[78365](78152 call - len[77777] 1))
                  (78157 call _check_tuple_var_decl tmp[78145] 2)
                  const lo[78160] "const"(78162 call tmp[78145] 1)
                  const hi[78165] "const"(78167 call tmp[78145] 2)
                  const mylen[78170] "const"(78172 call - hi[78165](78175 call - lo[78160] 1))
                  unknown low[78179](78181 call(343380 call . this[77676] c"orderToIndex") lo[78160])
                  unknown high[78184](78186 call(343385 call . this[77676] c"chpl_intToIdx")(78188 call +(78190 call _cast(343389 call . this[77676] c"strType")(78193 call chpl__idxToInt low[78179]))(78196 call *(343394 call . this[77676] c"stride")(78199 call _cast(343398 call . this[77676] c"strType")(78202 call - mylen[78170] 1)))))
                  if(78207 call _cond_test(78209 call <(343403 call . this[77676] c"stride") 0))
                  {
                    (78215 call <=> low[78179] high[78184])
                  }
                  {
                    unknown _indexOfInterest[78220] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[78222] "expr temp" "temp"
                    (78224 'move' _iterator[78222](78227 call _getIterator(78229 call chpl_direct_range_iter low[78179] high[78184](343411 call . this[77676] c"stride"))))
                    Defer
                    {
                      {
                        (78235 call _freeIterator _iterator[78222])
                      }
                    }
                    { scopeless type
                      (78239 'move' _indexOfInterest[78220](78242 call iteratorIndex _iterator[78222]))
                    }
                    ForLoop
                    {
                      unknown i[78247] "index var" "insert auto destroy"
                      (78249 'move' i[78247] _indexOfInterest[78220])
                      {
                        (78253 yield i[78247])
                      }
                      label _continueLabel[78255]
                      _indexOfInterest[78220]
                      _iterator[78222]
                    }
                    label _breakLabel[78257]
                  }
                }
                {
                  const tmp[78261] "const" "no copy" "temp"(78263 call _computeBlock len[77777] numChunks[77806] chunk[78365](78268 call . this[77676] c"_high")(78272 call . this[77676] c"_low")(78276 call . this[77676] c"_low"))
                  (78281 call _check_tuple_var_decl tmp[78261] 2)
                  const lo[78284] "const"(78286 call tmp[78261] 1)
                  const hi[78289] "const"(78291 call tmp[78261] 2)
                  {
                    unknown _indexOfInterest[78295] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[78297] "expr temp" "temp"
                    (78299 'move' _iterator[78297](78302 call _getIterator(78304 call chpl_direct_range_iter lo[78284] hi[78289] 1)))
                    Defer
                    {
                      {
                        (78310 call _freeIterator _iterator[78297])
                      }
                    }
                    { scopeless type
                      (78314 'move' _indexOfInterest[78295](78317 call iteratorIndex _iterator[78297]))
                    }
                    ForLoop
                    {
                      unknown i[78322] "index var" "insert auto destroy"
                      (78324 'move' i[78322] _indexOfInterest[78295])
                      {
                        (78328 yield(78330 call(343424 call . this[77676] c"chpl_intToIdx") i[78322]))
                      }
                      label _continueLabel[78332]
                      _indexOfInterest[78295]
                      _iterator[78297]
                    }
                    label _breakLabel[78334]
                  }
                }
              }
              (78341 call _downEndCount _coforallCount[78338] nil[38])
              (78340 'coforall loop')
            }
            label _continueLabel[78351]
            _indexOfInterest[78346]
            _iterator[78347]
          }
          label _breakLabel[78352]
          Defer
          {
            {
              (78394 call _endCountFree _coforallCount[78338])
            }
          }
          (78399 call _waitEndCount _coforallCount[78338] 1 numTasks[78339])
        }
        {
          const _coforallCount[78411] "const" "end count" "temp"
          (78468 'move' _coforallCount[78411](78465 call _endCountAlloc 1))
          unknown _indexOfInterest[78419] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[78420] "expr temp" "temp"
          (78429 'move' _iterator[78420](78427 call _getIterator tmpIter[78134]))
          Defer
          {
            {
              (78445 call _freeIterator _iterator[78420])
            }
          }
          { scopeless type
            (78434 'move' _indexOfInterest[78419](78431 call iteratorIndex _iterator[78420]))
          }
          ForLoop
          {
            unknown chunk[78438] "coforall index var" "index var" "insert auto destroy"
            (78440 'move' chunk[78438] _indexOfInterest[78419])
            (78452 call _upEndCount _coforallCount[78411] 1)
            {
              {
                if(78129 call _cond_test(343310 call . this[77676] c"stridable"))
                {
                  const tmp[77920] "const" "no copy" "temp"(77919 call _computeBlock len[77777] numChunks[77806] chunk[78438](77917 call - len[77777] 1))
                  (77927 call _check_tuple_var_decl tmp[77920] 2)
                  const lo[77905] "const"(77921 call tmp[77920] 1)
                  const hi[77907] "const"(77924 call tmp[77920] 2)
                  const mylen[77940] "const"(77938 call - hi[77907](77936 call - lo[77905] 1))
                  unknown low[77947](77946 call(343320 call . this[77676] c"orderToIndex") lo[77905])
                  unknown high[77972](77971 call(343325 call . this[77676] c"chpl_intToIdx")(77968 call +(77956 call _cast(343330 call . this[77676] c"strType")(77954 call chpl__idxToInt low[77947]))(77966 call *(343334 call . this[77676] c"stride")(77964 call _cast(343339 call . this[77676] c"strType")(77961 call - mylen[77940] 1)))))
                  if(77984 call _cond_test(77977 call <(343343 call . this[77676] c"stride") 0))
                  {
                    (77981 call <=> low[77947] high[77972])
                  }
                  {
                    unknown _indexOfInterest[78001] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[78002] "expr temp" "temp"
                    (78011 'move' _iterator[78002](78009 call _getIterator(78020 call chpl_direct_range_iter low[77947] high[77972](343350 call . this[77676] c"stride"))))
                    Defer
                    {
                      {
                        (78036 call _freeIterator _iterator[78002])
                      }
                    }
                    { scopeless type
                      (78025 'move' _indexOfInterest[78001](78022 call iteratorIndex _iterator[78002]))
                    }
                    ForLoop
                    {
                      unknown i[78029] "index var" "insert auto destroy"
                      (78031 'move' i[78029] _indexOfInterest[78001])
                      {
                        (77998 yield i[78029])
                      }
                      label _continueLabel[78006]
                      _indexOfInterest[78001]
                      _iterator[78002]
                    }
                    label _breakLabel[78007]
                  }
                }
                {
                  const tmp[78066] "const" "no copy" "temp"(78065 call _computeBlock len[77777] numChunks[77806] chunk[78438](78054 call . this[77676] c"_high")(78058 call . this[77676] c"_low")(78062 call . this[77676] c"_low"))
                  (78073 call _check_tuple_var_decl tmp[78066] 2)
                  const lo[78043] "const"(78067 call tmp[78066] 1)
                  const hi[78045] "const"(78070 call tmp[78066] 2)
                  {
                    unknown _indexOfInterest[78091] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[78092] "expr temp" "temp"
                    (78101 'move' _iterator[78092](78099 call _getIterator(78106 call chpl_direct_range_iter lo[78043] hi[78045] 1)))
                    Defer
                    {
                      {
                        (78122 call _freeIterator _iterator[78092])
                      }
                    }
                    { scopeless type
                      (78111 'move' _indexOfInterest[78091](78108 call iteratorIndex _iterator[78092]))
                    }
                    ForLoop
                    {
                      unknown i[78115] "index var" "insert auto destroy"
                      (78117 'move' i[78115] _indexOfInterest[78091])
                      {
                        (78088 yield(78087 call(343362 call . this[77676] c"chpl_intToIdx") i[78115]))
                      }
                      label _continueLabel[78096]
                      _indexOfInterest[78091]
                      _iterator[78092]
                    }
                    label _breakLabel[78097]
                  }
                }
              }
              (78414 call _downEndCount _coforallCount[78411] nil[38])
              (78413 'coforall loop')
            }
            label _continueLabel[78424]
            _indexOfInterest[78419]
            _iterator[78420]
          }
          label _breakLabel[78425]
          Defer
          {
            {
              (78456 call _endCountFree _coforallCount[78411])
            }
          }
          (78461 call _waitEndCount _coforallCount[78411] 1)
        }
      }
    }
  }
  where {
    (77691 call &&(77686 call == tag[77671] standalone[695])(77689 call ! localeModelHasSublocales[180486]))
  }
  function range[66183](?).these[78505](arg _mt[78510]:_MT[227], arg this[78507]:range[66183](?) :
  range[66183](?), param arg tag[78502] :
  iterKind[697]) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(78530 call _cond_test(78523 call !(78522 call isBoundedRange this[78507])))
    {
      (78528 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(78553 call _cond_test(78543 call && 1(78542 call(78538 call . this[78507] c"isAmbiguous"))))
    {
      (78551 call boundsCheckHalt module=[244] HaltWrappers[197622] "these -- Attempt to iterate over a range with ambiguous alignment.")
    }
    if(78579 call _cond_test debugChapelRange[66071])
    {
      (78577 call chpl_debug_writeln "*** In range leader:")
    }
    const numSublocs[78592] "const"(78591 call(78587 call .(343436 call here[92085]) c"getChildCount"))
    if(80271 call _cond_test(78600 call && localeModelHasSublocales[180486](78598 call != numSublocs[78592] 0)))
    {
      const len[78606] "const"(78603 call . this[78507] c"length")
      const tasksPerLocale[78611] "const" dataParTasksPerLocale[92471]
      const ignoreRunning[78615] "const" dataParIgnoreRunningTasks[92476]
      const minIndicesPerTask[78619] "const" dataParMinGranularity[92481]
      unknown dptpl[78634](78631 IfExpr (78624 call == tasksPerLocale[78611] 0) then
      { scopeless
        (78627 call .(343445 call here[92085]) c"maxTaskPar")
      } else
      { scopeless
        tasksPerLocale[78611]
      } )
      if(78674 call _cond_test(78638 call ! ignoreRunning[78615]))
      {
        const otherTasks[78651] "const"(78649 call -(78647 call(78643 call .(343449 call here[92085]) c"runningTasks")) 1)
        (78671 call = dptpl[78634](78668 IfExpr (78658 call < otherTasks[78651] dptpl[78634]) then
        { scopeless
          (78665 call _cast int(64)[13](78662 call - dptpl[78634] otherTasks[78651]))
        } else
        { scopeless
          1
        } ))
      }
      const numSublocTasks[78683] "const"(78682 call min numSublocs[78592] dptpl[78634])
      const numChunks[78701] "const"(78698 IfExpr (78688 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (78697 call _computeNumChunks numSublocTasks[78683](ignoreRunning = 1) minIndicesPerTask[78619] len[78606])
      } )
      if(78814 call _cond_test debugDataParNuma[92593])
      {
        (78811 call chpl_debug_writeln "### numSublocs = " numSublocs[78592] "\n" "### numTasksPerSubloc = " numSublocTasks[78683] "\n" "### ignoreRunning = " ignoreRunning[78615] "\n" "### minIndicesPerTask = " minIndicesPerTask[78619] "\n" "### numChunks = " numChunks[78701])
      }
      if(79891 call _cond_test(78820 call == numChunks[78701] 1))
      {
        (78831 yield(78829 call _build_tuple(78827 call chpl_build_bounded_range 0(78825 call - len[78606] 1))))
      }
      {
        {
          unknown tmpIter[79359] "expr temp" "maybe ref" "no copy" "temp"
          (79362 'move' tmpIter[79359](78839 call #(78836 call chpl_build_low_bounded_range 0) numChunks[78701]))
          unknown isRngDomArr[79871] "maybe param" "temp"
          (79886 'move' isRngDomArr[79871](79884 call ||(79873 call isBoundedRange tmpIter[79359])(79882 call ||(79876 call isDomain tmpIter[79359])(79879 call isArray tmpIter[79359]))))
          if isRngDomArr[79871]
          {
            const _coforallCount[79738] "const" "end count" "temp"
            (79807 'move' _coforallCount[79738](79804 call _endCountAlloc 1))
            unknown numTasks[79739] "temp"
            (79791 'move' numTasks[79739](79787 call . tmpIter[79359] c"size"))
            (79782 call _upEndCount _coforallCount[79738] 1 numTasks[79739])
            (79779 call chpl_resetTaskSpawn numTasks[79739])
            unknown _indexOfInterest[79746] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[79747] "expr temp" "temp"
            (79756 'move' _iterator[79747](79754 call _getIterator tmpIter[79359]))
            Defer
            {
              {
                (79772 call _freeIterator _iterator[79747])
              }
            }
            { scopeless type
              (79761 'move' _indexOfInterest[79746](79758 call iteratorIndex _iterator[79747]))
            }
            ForLoop
            {
              unknown chunk[79765] "coforall index var" "index var" "insert auto destroy"
              (79767 'move' chunk[79765] _indexOfInterest[79746])
              {
                {
                  const tmp[79366] "const" "temp"
                  (79368 'move' tmp[79366](79370 'deref'(79371 '_wide_get_locale'(79376 call(79373 call .(343522 call here[92085]) c"getChild") chunk[79765]))))
                  {
                    if(79380 call _cond_test debugDataParNuma[92593])
                    {
                      if(79384 call _cond_test(79386 call != chunk[79765](79389 call chpl_getSubloc)))
                      {
                        (79393 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[79765] ", on "(79398 call chpl_getSubloc) ") ***")
                      }
                    }
                    const tmp[79403] "const" "no copy" "temp"(79405 call _computeBlock len[78606] numChunks[78701] chunk[79765](79410 call - len[78606] 1))
                    (79415 call _check_tuple_var_decl tmp[79403] 2)
                    const lo[79418] "const"(79420 call tmp[79403] 1)
                    const hi[79423] "const"(79425 call tmp[79403] 2)
                    const locRange[79428] "const"(79430 call chpl_build_bounded_range lo[79418] hi[79423])
                    const locLen[79434] "const"(79436 call . locRange[79428] c"length")
                    const numSublocTasks[79440] "const"(79461 IfExpr (79442 call < chunk[79765](79445 call % dptpl[78634] numChunks[78701])) then
                    { scopeless
                      (79450 call +(79452 call / dptpl[78634] numChunks[78701]) 1)
                    } else
                    { scopeless
                      (79458 call / dptpl[78634] numChunks[78701])
                    } )
                    const numTasks[79463] "const"(79465 call _computeNumChunks numSublocTasks[79440](ignoreRunning = 1) minIndicesPerTask[78619] locLen[79434])
                    {
                      unknown tmpIter[79473] "expr temp" "maybe ref" "no copy" "temp"
                      (79475 'move' tmpIter[79473](79478 call #(79480 call chpl_build_low_bounded_range 0) numTasks[79463]))
                      unknown isRngDomArr[79483] "maybe param" "temp"
                      (79485 'move' isRngDomArr[79483](79488 call ||(79490 call isBoundedRange tmpIter[79473])(79493 call ||(79495 call isDomain tmpIter[79473])(79498 call isArray tmpIter[79473]))))
                      if isRngDomArr[79483]
                      {
                        const _coforallCount[79502] "const" "end count" "temp"
                        (79504 'move' _coforallCount[79502](79507 call _endCountAlloc 1))
                        unknown numTasks[79509] "temp"
                        (79511 'move' numTasks[79509](79514 call . tmpIter[79473] c"size"))
                        (79518 call _upEndCount _coforallCount[79502] 1 numTasks[79509])
                        (79523 call chpl_resetTaskSpawn numTasks[79509])
                        unknown _indexOfInterest[79525] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[79527] "expr temp" "temp"
                        (79529 'move' _iterator[79527](79532 call _getIterator tmpIter[79473]))
                        Defer
                        {
                          {
                            (79536 call _freeIterator _iterator[79527])
                          }
                        }
                        { scopeless type
                          (79540 'move' _indexOfInterest[79525](79543 call iteratorIndex _iterator[79527]))
                        }
                        ForLoop
                        {
                          unknown core[79548] "coforall index var" "index var" "insert auto destroy"
                          (79550 'move' core[79548] _indexOfInterest[79525])
                          {
                            {
                              const tmp[79557] "const" "no copy" "temp"(79559 call _computeBlock locLen[79434] numTasks[79463] core[79548] hi[79423] lo[79418] lo[79418])
                              (79568 call _check_tuple_var_decl tmp[79557] 2)
                              const low[79571] "const"(79573 call tmp[79557] 1)
                              const high[79576] "const"(79578 call tmp[79557] 2)
                              if(79582 call _cond_test debugDataParNuma[92593])
                              {
                                (79586 call chpl_debug_writeln "### chunk = " chunk[79765] "  core = " core[79548] "  " "locRange = " locRange[79428] "  coreRange = "(79596 call chpl_build_bounded_range low[79571] high[79576]))
                              }
                              (79600 yield(79602 call _build_tuple(79604 call chpl_build_bounded_range low[79571] high[79576])))
                            }
                            (79608 call _downEndCount _coforallCount[79502] nil[38])
                            (79554 'coforall loop')
                          }
                          label _continueLabel[79611]
                          _indexOfInterest[79525]
                          _iterator[79527]
                        }
                        label _breakLabel[79613]
                        Defer
                        {
                          {
                            (79617 call _endCountFree _coforallCount[79502])
                          }
                        }
                        (79621 call _waitEndCount _coforallCount[79502] 1 numTasks[79509])
                      }
                      {
                        const _coforallCount[79626] "const" "end count" "temp"
                        (79628 'move' _coforallCount[79626](79631 call _endCountAlloc 1))
                        unknown _indexOfInterest[79633] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[79635] "expr temp" "temp"
                        (79637 'move' _iterator[79635](79640 call _getIterator tmpIter[79473]))
                        Defer
                        {
                          {
                            (79644 call _freeIterator _iterator[79635])
                          }
                        }
                        { scopeless type
                          (79648 'move' _indexOfInterest[79633](79651 call iteratorIndex _iterator[79635]))
                        }
                        ForLoop
                        {
                          unknown core[79656] "coforall index var" "index var" "insert auto destroy"
                          (79658 'move' core[79656] _indexOfInterest[79633])
                          (79662 call _upEndCount _coforallCount[79626] 1)
                          {
                            {
                              const tmp[79669] "const" "no copy" "temp"(79671 call _computeBlock locLen[79434] numTasks[79463] core[79656] hi[79423] lo[79418] lo[79418])
                              (79680 call _check_tuple_var_decl tmp[79669] 2)
                              const low[79683] "const"(79685 call tmp[79669] 1)
                              const high[79688] "const"(79690 call tmp[79669] 2)
                              if(79694 call _cond_test debugDataParNuma[92593])
                              {
                                (79698 call chpl_debug_writeln "### chunk = " chunk[79765] "  core = " core[79656] "  " "locRange = " locRange[79428] "  coreRange = "(79708 call chpl_build_bounded_range low[79683] high[79688]))
                              }
                              (79712 yield(79714 call _build_tuple(79716 call chpl_build_bounded_range low[79683] high[79688])))
                            }
                            (79720 call _downEndCount _coforallCount[79626] nil[38])
                            (79666 'coforall loop')
                          }
                          label _continueLabel[79723]
                          _indexOfInterest[79633]
                          _iterator[79635]
                        }
                        label _breakLabel[79725]
                        Defer
                        {
                          {
                            (79729 call _endCountFree _coforallCount[79626])
                          }
                        }
                        (79733 call _waitEndCount _coforallCount[79626] 1)
                      }
                    }
                  }
                }
                (79741 call _downEndCount _coforallCount[79738] nil[38])
                (79740 'coforall loop')
              }
              label _continueLabel[79751]
              _indexOfInterest[79746]
              _iterator[79747]
            }
            label _breakLabel[79752]
            Defer
            {
              {
                (79794 call _endCountFree _coforallCount[79738])
              }
            }
            (79799 call _waitEndCount _coforallCount[79738] 1 numTasks[79739])
          }
          {
            const _coforallCount[79811] "const" "end count" "temp"
            (79868 'move' _coforallCount[79811](79865 call _endCountAlloc 1))
            unknown _indexOfInterest[79819] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[79820] "expr temp" "temp"
            (79829 'move' _iterator[79820](79827 call _getIterator tmpIter[79359]))
            Defer
            {
              {
                (79845 call _freeIterator _iterator[79820])
              }
            }
            { scopeless type
              (79834 'move' _indexOfInterest[79819](79831 call iteratorIndex _iterator[79820]))
            }
            ForLoop
            {
              unknown chunk[79838] "coforall index var" "index var" "insert auto destroy"
              (79840 'move' chunk[79838] _indexOfInterest[79819])
              (79852 call _upEndCount _coforallCount[79811] 1)
              {
                {
                  const tmp[79352] "const" "temp"
                  (79353 'move' tmp[79352](79350 'deref'(79349 '_wide_get_locale'(78849 call(78844 call .(343470 call here[92085]) c"getChild") chunk[79838]))))
                  {
                    if(78919 call _cond_test debugDataParNuma[92593])
                    {
                      if(78913 call _cond_test(78855 call != chunk[79838](78854 call chpl_getSubloc)))
                      {
                        (78911 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[79838] ", on "(78894 call chpl_getSubloc) ") ***")
                      }
                    }
                    const tmp[78939] "const" "no copy" "temp"(78938 call _computeBlock len[78606] numChunks[78701] chunk[79838](78936 call - len[78606] 1))
                    (78946 call _check_tuple_var_decl tmp[78939] 2)
                    const lo[78924] "const"(78940 call tmp[78939] 1)
                    const hi[78926] "const"(78943 call tmp[78939] 2)
                    const locRange[78955] "const"(78953 call chpl_build_bounded_range lo[78924] hi[78926])
                    const locLen[78962] "const"(78959 call . locRange[78955] c"length")
                    const numSublocTasks[78986] "const"(78983 IfExpr (78970 call < chunk[79838](78968 call % dptpl[78634] numChunks[78701])) then
                    { scopeless
                      (78977 call +(78974 call / dptpl[78634] numChunks[78701]) 1)
                    } else
                    { scopeless
                      (78981 call / dptpl[78634] numChunks[78701])
                    } )
                    const numTasks[78997] "const"(78996 call _computeNumChunks numSublocTasks[78986](ignoreRunning = 1) minIndicesPerTask[78619] locLen[78962])
                    {
                      unknown tmpIter[79139] "expr temp" "maybe ref" "no copy" "temp"
                      (79142 'move' tmpIter[79139](79005 call #(79002 call chpl_build_low_bounded_range 0) numTasks[78997]))
                      unknown isRngDomArr[79330] "maybe param" "temp"
                      (79345 'move' isRngDomArr[79330](79343 call ||(79332 call isBoundedRange tmpIter[79139])(79341 call ||(79335 call isDomain tmpIter[79139])(79338 call isArray tmpIter[79139]))))
                      if isRngDomArr[79330]
                      {
                        const _coforallCount[79197] "const" "end count" "temp"
                        (79266 'move' _coforallCount[79197](79263 call _endCountAlloc 1))
                        unknown numTasks[79198] "temp"
                        (79250 'move' numTasks[79198](79246 call . tmpIter[79139] c"size"))
                        (79241 call _upEndCount _coforallCount[79197] 1 numTasks[79198])
                        (79238 call chpl_resetTaskSpawn numTasks[79198])
                        unknown _indexOfInterest[79205] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[79206] "expr temp" "temp"
                        (79215 'move' _iterator[79206](79213 call _getIterator tmpIter[79139]))
                        Defer
                        {
                          {
                            (79231 call _freeIterator _iterator[79206])
                          }
                        }
                        { scopeless type
                          (79220 'move' _indexOfInterest[79205](79217 call iteratorIndex _iterator[79206]))
                        }
                        ForLoop
                        {
                          unknown core[79224] "coforall index var" "index var" "insert auto destroy"
                          (79226 'move' core[79224] _indexOfInterest[79205])
                          {
                            {
                              const tmp[79146] "const" "no copy" "temp"(79148 call _computeBlock locLen[78962] numTasks[78997] core[79224] hi[78926] lo[78924] lo[78924])
                              (79157 call _check_tuple_var_decl tmp[79146] 2)
                              const low[79160] "const"(79162 call tmp[79146] 1)
                              const high[79165] "const"(79167 call tmp[79146] 2)
                              if(79171 call _cond_test debugDataParNuma[92593])
                              {
                                (79175 call chpl_debug_writeln "### chunk = " chunk[79838] "  core = " core[79224] "  " "locRange = " locRange[78955] "  coreRange = "(79185 call chpl_build_bounded_range low[79160] high[79165]))
                              }
                              (79189 yield(79191 call _build_tuple(79193 call chpl_build_bounded_range low[79160] high[79165])))
                            }
                            (79200 call _downEndCount _coforallCount[79197] nil[38])
                            (79199 'coforall loop')
                          }
                          label _continueLabel[79210]
                          _indexOfInterest[79205]
                          _iterator[79206]
                        }
                        label _breakLabel[79211]
                        Defer
                        {
                          {
                            (79253 call _endCountFree _coforallCount[79197])
                          }
                        }
                        (79258 call _waitEndCount _coforallCount[79197] 1 numTasks[79198])
                      }
                      {
                        const _coforallCount[79270] "const" "end count" "temp"
                        (79327 'move' _coforallCount[79270](79324 call _endCountAlloc 1))
                        unknown _indexOfInterest[79278] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[79279] "expr temp" "temp"
                        (79288 'move' _iterator[79279](79286 call _getIterator tmpIter[79139]))
                        Defer
                        {
                          {
                            (79304 call _freeIterator _iterator[79279])
                          }
                        }
                        { scopeless type
                          (79293 'move' _indexOfInterest[79278](79290 call iteratorIndex _iterator[79279]))
                        }
                        ForLoop
                        {
                          unknown core[79297] "coforall index var" "index var" "insert auto destroy"
                          (79299 'move' core[79297] _indexOfInterest[79278])
                          (79311 call _upEndCount _coforallCount[79270] 1)
                          {
                            {
                              const tmp[79021] "const" "no copy" "temp"(79020 call _computeBlock locLen[78962] numTasks[78997] core[79297] hi[78926] lo[78924] lo[78924])
                              (79028 call _check_tuple_var_decl tmp[79021] 2)
                              const low[79007] "const"(79022 call tmp[79021] 1)
                              const high[79009] "const"(79025 call tmp[79021] 2)
                              if(79127 call _cond_test debugDataParNuma[92593])
                              {
                                (79124 call chpl_debug_writeln "### chunk = " chunk[79838] "  core = " core[79297] "  " "locRange = " locRange[78955] "  coreRange = "(79122 call chpl_build_bounded_range low[79007] high[79009]))
                              }
                              (79137 yield(79135 call _build_tuple(79133 call chpl_build_bounded_range low[79007] high[79009])))
                            }
                            (79273 call _downEndCount _coforallCount[79270] nil[38])
                            (79272 'coforall loop')
                          }
                          label _continueLabel[79283]
                          _indexOfInterest[79278]
                          _iterator[79279]
                        }
                        label _breakLabel[79284]
                        Defer
                        {
                          {
                            (79315 call _endCountFree _coforallCount[79270])
                          }
                        }
                        (79320 call _waitEndCount _coforallCount[79270] 1)
                      }
                    }
                  }
                }
                (79814 call _downEndCount _coforallCount[79811] nil[38])
                (79813 'coforall loop')
              }
              label _continueLabel[79824]
              _indexOfInterest[79819]
              _iterator[79820]
            }
            label _breakLabel[79825]
            Defer
            {
              {
                (79856 call _endCountFree _coforallCount[79811])
              }
            }
            (79861 call _waitEndCount _coforallCount[79811] 1)
          }
        }
      }
    }
    {
      unknown v[79899](79896 call . this[78507] c"length")
      const numChunks[79914] "const"(79911 IfExpr (79905 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (79910 call _computeNumChunks v[79899])
      } )
      if(79964 call _cond_test debugChapelRange[66071])
      {
        (79924 call chpl_debug_writeln "*** RI: length=" v[79899] " numChunks=" numChunks[79914])
        (79962 call chpl_debug_writeln "*** RI: Using " numChunks[79914] " chunk(s)")
      }
      if(80266 call _cond_test(79970 call == numChunks[79914] 1))
      {
        (79981 yield(79979 call _build_tuple(79977 call chpl_build_bounded_range 0(79975 call - v[79899] 1))))
      }
      {
        {
          unknown tmpIter[80058] "expr temp" "maybe ref" "no copy" "temp"
          (80061 'move' tmpIter[80058](79988 call #(79985 call chpl_build_low_bounded_range 0) numChunks[79914]))
          unknown isRngDomArr[80246] "maybe param" "temp"
          (80261 'move' isRngDomArr[80246](80259 call ||(80248 call isBoundedRange tmpIter[80058])(80257 call ||(80251 call isDomain tmpIter[80058])(80254 call isArray tmpIter[80058]))))
          if isRngDomArr[80246]
          {
            const _coforallCount[80113] "const" "end count" "temp"
            (80182 'move' _coforallCount[80113](80179 call _endCountAlloc 1))
            unknown numTasks[80114] "temp"
            (80166 'move' numTasks[80114](80162 call . tmpIter[80058] c"size"))
            (80157 call _upEndCount _coforallCount[80113] 1 numTasks[80114])
            (80154 call chpl_resetTaskSpawn numTasks[80114])
            unknown _indexOfInterest[80121] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[80122] "expr temp" "temp"
            (80131 'move' _iterator[80122](80129 call _getIterator tmpIter[80058]))
            Defer
            {
              {
                (80147 call _freeIterator _iterator[80122])
              }
            }
            { scopeless type
              (80136 'move' _indexOfInterest[80121](80133 call iteratorIndex _iterator[80122]))
            }
            ForLoop
            {
              unknown chunk[80140] "coforall index var" "index var" "insert auto destroy"
              (80142 'move' chunk[80140] _indexOfInterest[80121])
              {
                {
                  const tmp[80065] "const" "no copy" "temp"(80067 call _computeBlock v[79899] numChunks[79914] chunk[80140](80072 call - v[79899] 1))
                  (80077 call _check_tuple_var_decl tmp[80065] 2)
                  const lo[80080] "const"(80082 call tmp[80065] 1)
                  const hi[80085] "const"(80087 call tmp[80065] 2)
                  if(80091 call _cond_test debugChapelRange[66071])
                  {
                    (80096 call chpl_debug_writeln "*** RI: tuple = "(80099 call _build_tuple(80101 call chpl_build_bounded_range lo[80080] hi[80085])))
                  }
                  (80105 yield(80107 call _build_tuple(80109 call chpl_build_bounded_range lo[80080] hi[80085])))
                }
                (80116 call _downEndCount _coforallCount[80113] nil[38])
                (80115 'coforall loop')
              }
              label _continueLabel[80126]
              _indexOfInterest[80121]
              _iterator[80122]
            }
            label _breakLabel[80127]
            Defer
            {
              {
                (80169 call _endCountFree _coforallCount[80113])
              }
            }
            (80174 call _waitEndCount _coforallCount[80113] 1 numTasks[80114])
          }
          {
            const _coforallCount[80186] "const" "end count" "temp"
            (80243 'move' _coforallCount[80186](80240 call _endCountAlloc 1))
            unknown _indexOfInterest[80194] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[80195] "expr temp" "temp"
            (80204 'move' _iterator[80195](80202 call _getIterator tmpIter[80058]))
            Defer
            {
              {
                (80220 call _freeIterator _iterator[80195])
              }
            }
            { scopeless type
              (80209 'move' _indexOfInterest[80194](80206 call iteratorIndex _iterator[80195]))
            }
            ForLoop
            {
              unknown chunk[80213] "coforall index var" "index var" "insert auto destroy"
              (80215 'move' chunk[80213] _indexOfInterest[80194])
              (80227 call _upEndCount _coforallCount[80186] 1)
              {
                {
                  const tmp[80005] "const" "no copy" "temp"(80004 call _computeBlock v[79899] numChunks[79914] chunk[80213](80002 call - v[79899] 1))
                  (80012 call _check_tuple_var_decl tmp[80005] 2)
                  const lo[79990] "const"(80006 call tmp[80005] 1)
                  const hi[79992] "const"(80009 call tmp[80005] 2)
                  if(80045 call _cond_test debugChapelRange[66071])
                  {
                    (80043 call chpl_debug_writeln "*** RI: tuple = "(80041 call _build_tuple(80039 call chpl_build_bounded_range lo[79990] hi[79992])))
                  }
                  (80056 yield(80054 call _build_tuple(80052 call chpl_build_bounded_range lo[79990] hi[79992])))
                }
                (80189 call _downEndCount _coforallCount[80186] nil[38])
                (80188 'coforall loop')
              }
              label _continueLabel[80199]
              _indexOfInterest[80194]
              _iterator[80195]
            }
            label _breakLabel[80200]
            Defer
            {
              {
                (80231 call _endCountFree _coforallCount[80186])
              }
            }
            (80236 call _waitEndCount _coforallCount[80186] 1)
          }
        }
      }
    }
  }
  where {
    (78517 call == tag[78502] leader[691])
  }
  function range[66183](?).these[80285](arg _mt[80292]:_MT[227], arg this[80289]:range[66183](?) :
  range[66183](?), param arg tag[80282] :
  iterKind[697], arg followThis[80287]:_any[170](?)) : _unknown[43] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(80318 call _cond_test(80308 call && 1(80307 call(80303 call . this[80289] c"isAmbiguous"))))
    {
      (80316 call boundsCheckHalt module=[244] HaltWrappers[197622] "these -- Attempt to iterate over a range with ambiguous alignment.")
    }
    if(80336 call _cond_test(80329 call ==(343609 call . this[80289] c"boundedType") boundedNone[66085]))
    {
      (80334 call compilerError "iteration over a range with no bounds")
    }
    if(80373 call _cond_test(80351 call &&(80342 call !(343615 call . this[80289] c"stridable"))(80349 call ==(343620 call . this[80289] c"boundedType") boundedHigh[66083])))
    {
      (80371 call compilerError "iteration over a range with no first index")
    }
    if(80405 call _cond_test(80383 call !=(80379 call . followThis[80287] c"size") 1))
    {
      (80403 call compilerError "iteration over a range with multi-dimensional iterator")
    }
    if(80432 call _cond_test debugChapelRange[66071])
    {
      (80430 call chpl_debug_writeln "In range follower code: Following " followThis[80287])
    }
    unknown myFollowThis[80441](80440 call followThis[80287] 1)
    if(80466 call _cond_test debugChapelRange[66071])
    {
      (80464 call chpl_debug_writeln "Range = " myFollowThis[80441])
    }
    if(80539 call _cond_test(80480 call && 1(80478 call !(80477 call(80473 call . this[80289] c"hasFirst")))))
    {
      if(80534 call _cond_test(80487 call(80483 call . this[80289] c"isEmpty")))
      {
        if(80519 call _cond_test(80494 call !(80493 call(80489 call . myFollowThis[80441] c"isEmpty"))))
        {
          (80517 call boundsCheckHalt module=[244] HaltWrappers[197622] "zippered iteration with a range has non-equal lengths")
        }
      }
      {
        (80531 call boundsCheckHalt module=[244] HaltWrappers[197622] "iteration over a range with no first index")
      }
    }
    if(80601 call _cond_test(80552 call && 1(80550 call !(80549 call(80545 call . myFollowThis[80441] c"hasFirst")))))
    {
      if(80595 call _cond_test(80570 call !(80568 call &&(80560 call !(80559 call(80555 call . myFollowThis[80441] c"isAmbiguous")))(80567 call(80563 call . myFollowThis[80441] c"isEmpty")))))
      {
        (80593 call boundsCheckHalt module=[244] HaltWrappers[197622] "zippered iteration over a range with no first index")
      }
    }
    if(81257 call _cond_test(80623 call ||(80615 call &&(80608 call isBoundedRange myFollowThis[80441])(80613 call !(80610 call . myFollowThis[80441] c"stridable")))(80622 call(80618 call . myFollowThis[80441] c"hasLast"))))
    {
      const flwlen[80629] "const"(80626 call . myFollowThis[80441] c"length")
      if(80709 call _cond_test(80640 call && 1(80639 call(80635 call . this[80289] c"hasLast"))))
      {
        if(80703 call _cond_test(80645 call isBoundedRange this[80289]))
        {
          if(80676 call _cond_test(80651 call <(80647 call . this[80289] c"length") flwlen[80629]))
          {
            (80674 call boundsCheckHalt module=[244] HaltWrappers[197622] "zippered iteration over a range with too few indices")
          }
        }
        {
          (80701 call assert 0 "hasFirst && hasLast do not imply isBoundedRange")
        }
      }
      if(81051 call _cond_test(80721 call ||(80714 call . this[80289] c"stridable")(80718 call . myFollowThis[80441] c"stridable")))
      {
        unknown r[80742](80740 call chpl_by(80731 call chpl_build_bounded_range(80726 call(343654 call . this[80289] c"chpl_intToIdx") 1)(80730 call(343658 call . this[80289] c"chpl_intToIdx") 0))(80738 call _cast(80737 call chpl__rangeStrideType(343662 call . this[80289] c"intIdxType")) 1))
        if(80847 call _cond_test(80748 call != flwlen[80629] 0))
        {
          const stride[80760] "const"(80758 call *(80751 call . this[80289] c"stride")(80755 call . myFollowThis[80441] c"stride"))
          unknown low[80774](80773 call(80765 call . this[80289] c"orderToIndex")(80769 call . myFollowThis[80441] c"first"))
          unknown high[80799](80798 call(343671 call . this[80289] c"chpl_intToIdx")(80795 call +(80783 call _cast(343676 call . this[80289] c"strType")(80781 call chpl__idxToInt low[80774]))(80793 call * stride[80760](80791 call _cast(343682 call . this[80289] c"strType")(80788 call - flwlen[80629] 1)))))
          (80817 call assert(80814 call == high[80799](80813 call(80805 call . this[80289] c"orderToIndex")(80809 call . myFollowThis[80441] c"last"))))
          if(80828 call _cond_test(80821 call < stride[80760] 0))
          {
            (80825 call <=> low[80774] high[80799])
          }
          (80844 call = r[80742](80842 call chpl_by(80836 call chpl_build_bounded_range low[80774] high[80799])(80840 call _cast(343696 call . this[80289] c"strType") stride[80760])))
        }
        if(80873 call _cond_test debugChapelRange[66071])
        {
          (80871 call chpl_debug_writeln "Expanded range = " r[80742])
        }
        {
          unknown _indexOfInterest[80883] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80884] "expr temp" "temp"
          (80893 'move' _iterator[80884](80891 call _getIterator r[80742]))
          Defer
          {
            {
              (80909 call _freeIterator _iterator[80884])
            }
          }
          { scopeless type
            (80898 'move' _indexOfInterest[80883](80895 call iteratorIndex _iterator[80884]))
          }
          ForLoop
          {
            unknown i[80902] "index var" "insert auto destroy"
            (80904 'move' i[80902] _indexOfInterest[80883])
            (80881 yield i[80902])
            label _continueLabel[80888]
            _indexOfInterest[80883]
            _iterator[80884]
          }
          label _breakLabel[80889]
        }
      }
      {
        unknown r[80928](80926 call chpl_build_bounded_range(80920 call chpl__intToIdx(343705 call . this[80289] c"idxType") 1)(80925 call chpl__intToIdx(343710 call . this[80289] c"idxType") 0))
        if(80997 call _cond_test(80934 call != flwlen[80629] 0))
        {
          const low[80946] "const"(80945 call(80937 call . this[80289] c"orderToIndex")(80941 call . myFollowThis[80441] c"first"))
          const high[80969] "const"(80968 call(343717 call . this[80289] c"chpl_intToIdx")(80965 call +(80956 call _cast(343722 call . this[80289] c"strType")(80954 call chpl__idxToInt low[80946]))(80963 call _cast(343727 call . this[80289] c"strType")(80960 call - flwlen[80629] 1))))
          (80987 call assert(80984 call == high[80969](80983 call(80975 call . this[80289] c"orderToIndex")(80979 call . myFollowThis[80441] c"last"))))
          (80994 call = r[80928](80992 call chpl_build_bounded_range low[80946] high[80969]))
        }
        if(81008 call _cond_test debugChapelRange[66071])
        {
          (81006 call chpl_debug_writeln "Expanded range = " r[80928])
        }
        {
          unknown _indexOfInterest[81018] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[81019] "expr temp" "temp"
          (81028 'move' _iterator[81019](81026 call _getIterator r[80928]))
          Defer
          {
            {
              (81044 call _freeIterator _iterator[81019])
            }
          }
          { scopeless type
            (81033 'move' _indexOfInterest[81018](81030 call iteratorIndex _iterator[81019]))
          }
          ForLoop
          {
            unknown i[81037] "index var" "insert auto destroy"
            (81039 'move' i[81037] _indexOfInterest[81018])
            (81016 yield i[81037])
            label _continueLabel[81023]
            _indexOfInterest[81018]
            _iterator[81019]
          }
          label _breakLabel[81024]
        }
      }
    }
    {
      if(81091 call _cond_test(81062 call && 1(81061 call(81057 call . this[80289] c"hasLast"))))
      {
        (81089 call zipLengthHalt module=[244] HaltWrappers[197622] "zippered iteration where a bounded range follows an unbounded iterator")
      }
      const first[81107] "const"(81106 call(81098 call . this[80289] c"orderToIndex")(81102 call . myFollowThis[80441] c"first"))
      const stride[81120] "const"(81118 call *(81111 call . this[80289] c"stride")(81115 call . myFollowThis[80441] c"stride"))
      if(81253 call _cond_test(81125 call > stride[81120] 0))
      {
        const r[81136] "const"(81134 call chpl_by(81128 call chpl_build_low_bounded_range first[81107])(81132 call _cast(343751 call . this[80289] c"strType") stride[81120]))
        if(81147 call _cond_test debugChapelRange[66071])
        {
          (81145 call chpl_debug_writeln "Expanded range = " r[81136])
        }
        {
          unknown _indexOfInterest[81157] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[81158] "expr temp" "temp"
          (81167 'move' _iterator[81158](81165 call _getIterator r[81136]))
          Defer
          {
            {
              (81183 call _freeIterator _iterator[81158])
            }
          }
          { scopeless type
            (81172 'move' _indexOfInterest[81157](81169 call iteratorIndex _iterator[81158]))
          }
          ForLoop
          {
            unknown i[81176] "index var" "insert auto destroy"
            (81178 'move' i[81176] _indexOfInterest[81157])
            (81155 yield i[81176])
            label _continueLabel[81162]
            _indexOfInterest[81157]
            _iterator[81158]
          }
          label _breakLabel[81163]
        }
      }
      {
        const r[81199] "const"(81197 call chpl_by(81191 call chpl_build_high_bounded_range first[81107])(81195 call _cast(343761 call . this[80289] c"strType") stride[81120]))
        if(81210 call _cond_test debugChapelRange[66071])
        {
          (81208 call chpl_debug_writeln "Expanded range = " r[81199])
        }
        {
          unknown _indexOfInterest[81220] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[81221] "expr temp" "temp"
          (81230 'move' _iterator[81221](81228 call _getIterator r[81199]))
          Defer
          {
            {
              (81246 call _freeIterator _iterator[81221])
            }
          }
          { scopeless type
            (81235 'move' _indexOfInterest[81220](81232 call iteratorIndex _iterator[81221]))
          }
          ForLoop
          {
            unknown i[81239] "index var" "insert auto destroy"
            (81241 'move' i[81239] _indexOfInterest[81220])
            (81218 yield i[81239])
            label _continueLabel[81225]
            _indexOfInterest[81220]
            _iterator[81221]
          }
          label _breakLabel[81226]
        }
      }
    }
  }
  where {
    (80299 call == tag[80282] follower[693])
  }
  function _cast[81268](arg t[81266]:_any[170](?), arg x[81274] :
  (81273 call range[66183](?) ?[249])) : _unknown[43]
  {
    unknown ret[81282] string[24]
    if(81303 call _cond_test(81291 call(81287 call . x[81274] c"hasLowBound")))
    {
      (81300 call += ret[81282](81298 call _cast string[24](81294 call . x[81274] c"low")))
    }
    (81325 call += ret[81282] "..")
    if(81345 call _cond_test(81333 call(81329 call . x[81274] c"hasHighBound")))
    {
      (81342 call += ret[81282](81340 call _cast string[24](81336 call . x[81274] c"high")))
    }
    if(81386 call _cond_test(81355 call !=(81351 call . x[81274] c"stride") 1))
    {
      (81383 call += ret[81282](81381 call + " by "(81379 call _cast string[24](81375 call . x[81274] c"stride"))))
    }
    unknown alignCheckRange[81392] x[81274]
    (81402 call(81398 call . alignCheckRange[81392] c"normalizeAlignment"))
    if(81453 call _cond_test(81412 call !(81411 call(81407 call . alignCheckRange[81392] c"isNaturallyAligned"))))
    {
      (81450 call += ret[81282](81448 call + " align "(81446 call _cast string[24](81444 call chpl__mod(81438 call chpl__idxToInt(81434 call . x[81274] c"alignment"))(81441 call . x[81274] c"stride")))))
    }
    (81459 return ret[81282])
  }
  where {
    (81279 call == t[81266] string[24])
  }
  function range[66183](?).normalizeAlignment[81467](arg _mt[81472]:_MT[227], ref arg this[81469]:range[66183](?) :
  range[66183](?)) : _unknown[43] "method" "no doc" "no return value for void"
  {
    if(81530 call _cond_test(81478 call &&(343789 call . this[81469] c"stridable")(81476 call !(343793 call . this[81469] c"aligned"))))
    {
      (81526 call =(343798 call . this[81469] c"_alignment")(81523 IfExpr (81484 call isBoundedRange this[81469]) then
      { scopeless(81491 IfExpr (81487 call >(343803 call . this[81469] c"stride") 0) then
        { scopeless
          (343808 call . this[81469] c"_low")
        } else
        { scopeless
          (343813 call . this[81469] c"_high")
        } )
      } else
      { scopeless(81520 IfExpr (81502 call ==(81495 call . this[81469] c"boundedType") boundedLow[66081]) then
        { scopeless
          (343820 call . this[81469] c"_low")
        } else
        { scopeless(81517 IfExpr (81513 call ==(81506 call . this[81469] c"boundedType") boundedHigh[66083]) then
          { scopeless
            (343827 call . this[81469] c"_high")
          } else
          { scopeless
            0
          } )
        } )
      } ))
    }
  }
  function range[66183](?).chpl__unTranslate[81544](arg _mt[81549]:_MT[227], arg this[81546]:range[66183](?) :
  range[66183](?), arg i[81541] :
  (343831 call . this[81546] c"intIdxType")) : _unknown[43] "inline" "method" "no doc"
  {
    (81555 return(81553 call - this[81546] i[81541]))
  }
  function range[66183](?).chpl__unTranslate[81565](arg _mt[81570]:_MT[227], arg this[81567]:range[66183](?) :
  range[66183](?), arg i[81563]:_any[170](?)) : _unknown[43] "inline" "method" "no doc"
  {
    if(81592 call _cond_test(81576 call isIntType(81574 'typeof' i[81563])))
    {
      (81581 return(81579 call - this[81567] i[81563]))
    }
    {
      (81590 return(81588 call + this[81567](81587 call abs i[81563])))
    }
  }
  function chpl__hasAlignment[81610](arg r[81607] :
  (81606 call range[66183](?) ?[249])) : _unknown[43]
  {
    if(81630 call _cond_test(81625 call &&(81617 call(81613 call . r[81607] c"hasLowBound"))(81623 call >=(81619 call . r[81607] c"stride") 2)))
    {
      (81628 return 1)
    }
    if(81656 call _cond_test(81651 call &&(81641 call(81637 call . r[81607] c"hasHighBound"))(81649 call <=(81643 call . r[81607] c"stride")(81647 call - 2))))
    {
      (81654 return 1)
    }
    (81662 return 0)
  }
  function chpl__mod[81672](arg dividend[81669] :
  integral[188](?), arg modulus[81675] :
  integral[188](?)) : _unknown[43]
  {
    const m[81689] "const"(81688 call(81682 call .(81681 call abs modulus[81675]) c"safeCast")(81686 'typeof' dividend[81669]))
    unknown tmp[81697](81695 call % dividend[81669] m[81689])
    if(81718 call _cond_test(81703 call isInt dividend[81669]))
    {
      if(81713 call _cond_test(81706 call < tmp[81697] 0))
      {
        (81710 call += tmp[81697] m[81689])
      }
    }
    (81724 return tmp[81697])
  }
  function chpl__diffMod[81734](arg minuend[81731] :
  integral[188](?), arg subtrahend[81737] :
  integral[188](?), arg modulus[81741] :
  integral[188](?)) : _unknown[43]
  {
    const m[81763] "const"(81762 call(81756 call .(81755 call abs modulus[81741]) c"safeCast")(81760 'typeof' minuend[81731]))
    unknown minMod[81772](81771 call chpl__mod minuend[81731] m[81763])
    unknown subMod[81780](81779 call chpl__mod subtrahend[81737] m[81763])
    (81801 return(81798 IfExpr (81785 call < minMod[81772] subMod[81780]) then
    { scopeless
      (81792 call - m[81763](81790 call - subMod[81780] minMod[81772]))
    } else
    { scopeless
      (81796 call - minMod[81772] subMod[81780])
    } ))
  }
  where {
    (81750 call ==(81747 'typeof' minuend[81731])(81749 'typeof' subtrahend[81737]))
  }
  { scopeless type
    (81745 'typeof' minuend[81731])
  }
  function chpl__diffMod[81813](arg minuend[81810] :
  integral[188](?), arg subtrahend[81816] :
  integral[188](?), arg modulus[81820] :
  integral[188](?)) : _unknown[43] "no return value for void"
  {
    (81841 call compilerError "chpl__diffMod -- Operand types must match.")
  }
  function chpl__add[81853](arg a[81850] :
  unknown t[81848], arg b[81856] :
  t[81848], arg resultType[81859]:_any[170](?)) : _unknown[43]
  {
    if(81887 call _cond_test(81865 call !(81864 call isIntegralType t[81848])))
    {
      (81885 call compilerError "Values must be of integral type.")
    }
    if(81921 call _cond_test(81913 call &&(81901 call &&(81895 call > a[81850] 0)(81899 call > b[81856] 0))(81911 call > b[81856](81909 call -(81907 call max t[81848]) a[81850]))))
    {
      (81919 return(81918 call max resultType[81859]))
    }
    if(81954 call _cond_test(81946 call &&(81934 call &&(81928 call < a[81850] 0)(81932 call < b[81856] 0))(81944 call < b[81856](81942 call -(81940 call min t[81848]) a[81850]))))
    {
      (81952 return(81951 call min resultType[81859]))
    }
    if(82039 call _cond_test(81962 call isUintType resultType[81859]))
    {
      if(82033 call _cond_test(82025 call ||(81992 call &&(81971 call &&(81965 call < a[81850] 0)(81969 call > b[81856] 0))(81990 call ||(81978 call == a[81850](81977 call min t[81848]))(81988 call >(81983 call abs a[81850])(81987 call abs b[81856]))))(82023 call &&(82002 call &&(81996 call > a[81850] 0)(82000 call < b[81856] 0))(82021 call ||(82009 call == b[81856](82008 call min t[81848]))(82019 call >(82014 call abs b[81856])(82018 call abs a[81850]))))))
      {
        (82031 return(82029 call _cast resultType[81859] 0))
      }
    }
    (82050 return(82048 call _cast resultType[81859](82045 call + a[81850] b[81856])))
  }
  function chpl__addRangeStrides[82058](arg start[82056]:_any[170](?), arg stride[82060]:_any[170](?), arg count[82062]:_any[170](?)) : _unknown[43]
  {
    function convert[82070](arg a[82068]:_any[170](?), arg b[82072]:_any[170](?)) param : _unknown[43]
    {
      (82112 return(82110 call ||(82090 call &&(82080 call ==(82075 'typeof' a[82068])(82079 call int(64)[13] 64))(82088 call ==(82083 'typeof' b[82072])(82087 call uint(64)[107] 64)))(82108 call &&(82098 call ==(82093 'typeof' a[82068])(82097 call uint(64)[107] 64))(82106 call ==(82101 'typeof' b[82072])(82105 call int(64)[13] 64)))))
    }
    function mul[82122](arg a[82120]:_any[170](?), arg b[82124]:_any[170](?)) : _unknown[43]
    {
      (82154 return(82151 IfExpr (82130 call convert a[82120] b[82124]) then
      { scopeless
        (82145 call *(82136 call _cast(82135 call int(64)[13] 64) a[82120])(82143 call _cast(82142 call int(64)[13] 64) b[82124]))
      } else
      { scopeless
        (82149 call * a[82120] b[82124])
      } ))
    }
    function add[82163](arg a[82161]:_any[170](?), arg b[82165]:_any[170](?)) : _unknown[43]
    {
      (82195 return(82192 IfExpr (82171 call convert a[82161] b[82165]) then
      { scopeless
        (82186 call +(82177 call _cast(82176 call int(64)[13] 64) a[82161])(82184 call _cast(82183 call int(64)[13] 64) b[82165]))
      } else
      { scopeless
        (82190 call + a[82161] b[82165])
      } ))
    }
    (82213 return(82211 call _cast(82210 'typeof' start[82056])(82208 call add start[82056](82207 call mul stride[82060] count[82062]))))
  }
  { scopeless type
    (82065 'typeof' start[82056])
  }
  function chpl__extendedEuclidHelper[82222](arg u[82220]:_any[170](?), arg v[82224]:_any[170](?)) : _unknown[43]
  {
    unknown zero[82229] 0(82227 'typeof' u[82220])
    unknown one[82236] 1(82234 'typeof' u[82220])
    unknown U[82245](82243 call _build_tuple one[82236] zero[82229] u[82220])
    unknown V[82254](82252 call _build_tuple zero[82229] one[82236] v[82224])
    {
      unknown tmp[82303] "temp"
      (82331 'move' tmp[82303](82324 call _cond_test(82326 call !=(82328 call V[82254] 3) 0)))
      WhileDo
      {
        {
          unknown oldU[82265] U[82245]
          unknown q[82279](82277 call /(82272 call U[82245] 3)(82276 call V[82254] 3))
          (82284 call = U[82245] V[82254])
          (82300 call = V[82254](82298 call - oldU[82265](82296 call * V[82254](82294 call _build_tuple q[82279] q[82279] q[82279]))))
        }
        label _continueLabel[82306]
        (82319 'move' tmp[82303](82312 call _cond_test(82314 call !=(82316 call V[82254] 3) 0)))
        tmp[82303]
      }
      label _breakLabel[82307]
    }
    (82345 return(82343 call _build_tuple(82337 call U[82245] 3)(82341 call U[82245] 1)))
  }
  function chpl__extendedEuclid[82358](arg u[82355] :
  (82354 call int(64)[13] 32), arg v[82364] :
  (82363 call int(64)[13] 32)) : _unknown[43] "inline"
  {
    (82372 return(82371 call chpl__extendedEuclidHelper u[82355] v[82364]))
  }
  function chpl__extendedEuclid[82386](arg u[82383] :
  (82382 call int(64)[13] 64), arg v[82392] :
  (82391 call int(64)[13] 64)) : _unknown[43] "inline"
  {
    (82400 return(82399 call chpl__extendedEuclidHelper u[82383] v[82392]))
  }
  function chpl__rangeIdxTypeError[82409](arg idxType[82407]:_any[170](?)) : _unknown[43] "private" "no return value for void"
  {
    (82449 call compilerError "ranges don't support '"(82431 call _cast string[24] idxType[82407]) "' as their idxType")
  }
  function chpl__rangeStrideType[82458](arg idxType[82456]:_any[170](?)) type : _unknown[43] "private"
  {
    if(82495 call _cond_test(82463 call isIntegralType idxType[82456]))
    {
      (82468 return(82467 call chpl__signedType idxType[82456]))
    }
    {
      if(82491 call _cond_test(82479 call ||(82474 call isEnumType idxType[82456])(82478 call isBoolType idxType[82456])))
      {
        (82482 return int(64)[13])
      }
      {
        (82488 call chpl__rangeIdxTypeError idxType[82456])
      }
    }
  }
  function chpl__rangeUnsignedType[82507](arg idxType[82505]:_any[170](?)) type : _unknown[43] "private"
  {
    if(82544 call _cond_test(82512 call isIntegralType idxType[82505]))
    {
      (82517 return(82516 call chpl__unsignedType idxType[82505]))
    }
    {
      if(82540 call _cond_test(82528 call ||(82523 call isEnumType idxType[82505])(82527 call isBoolType idxType[82505])))
      {
        (82531 return uint(64)[107])
      }
      {
        (82537 call chpl__rangeIdxTypeError idxType[82505])
      }
    }
  }
  function chpl__idxTypeToIntIdxType[82556](arg idxType[82554]:_any[170](?)) type : _unknown[43] "no doc"
  {
    if(82616 call _cond_test(82561 call isBoolType idxType[82554]))
    {
      (82563 return int(64)[13])
    }
    {
      if(82612 call _cond_test(82569 call isEnumType idxType[82554]))
      {
        if(82599 call _cond_test(82575 call <(82571 call . idxType[82554] c"size") 2))
        {
          (82597 call compilerError "ranges are not currently supported for enums with fewer than two values")
        }
        (82606 return int(64)[13])
      }
      {
        (82609 return idxType[82554])
      }
    }
  }
  function range[66183](?).chpl_intToIdx[82629](arg _mt[82634]:_MT[227], arg this[82631]:range[66183](?) :
  range[66183](?), arg i[82627]:_any[170](?)) : _unknown[43] "inline" "method" "no doc"
  {
    (82644 return(82643 call chpl__intToIdx(82638 call . this[82631] c"idxType") i[82627]))
  }
  function chpl__intToIdx[82655](arg idxType[82652] :
  integral[188](?), arg i[82658] :
  integral[188](?)) : _unknown[43] "inline"
  {
    if(82675 call _cond_test(82664 call ==(82662 'typeof' i[82658]) idxType[82652]))
    {
      (82667 return i[82658])
    }
    {
      (82673 return(82671 call _cast idxType[82652] i[82658]))
    }
  }
  function chpl__intToIdx[82690](arg idxType[82687] :
  integral[188](?), param arg i[82693] :
  integral[188](?)) : _unknown[43] "inline"
  {
    if(82710 call _cond_test(82699 call ==(82697 'typeof' i[82693]) idxType[82687]))
    {
      (82702 return i[82693])
    }
    {
      (82708 return(82706 call _cast idxType[82687] i[82693]))
    }
  }
  function chpl__intToIdx[82725](arg idxType[82722] :
  enumerated[179](?), arg i[82728] :
  integral[188](?)) : _unknown[43] "inline"
  {
    (82736 return(82735 call chpl__orderToEnum i[82728] idxType[82722]))
  }
  function chpl__intToIdx[82745](arg idxType[82743]:_any[170](?), arg i[82748] :
  integral[188](?)) : _unknown[43] "inline"
  {
    (82759 return(82757 call _cast bool[10] i[82748]))
  }
  where {
    (82754 call isBoolType idxType[82743])
  }
  function chpl__intToIdx[82769](arg idxType[82767]:_any[170](?), param arg i[82772] :
  integral[188](?)) param : _unknown[43] "inline"
  {
    (82783 return(82781 call _cast bool[10] i[82772]))
  }
  where {
    (82778 call isBoolType idxType[82767])
  }
  function chpl__intToIdx[82793](arg idxType[82791]:_any[170](?), arg i[82796] :
  nothing[7]) : _unknown[43] "inline"
  {
    (82800 return none[49])
  }
  function chpl__idxToInt[82811](arg i[82808] :
  integral[188](?)) : _unknown[43] "inline"
  {
    (82814 return i[82808])
  }
  function chpl__idxToInt[82825](param arg i[82822] :
  integral[188](?)) param : _unknown[43] "inline"
  {
    (82828 return i[82822])
  }
  function chpl__idxToInt[82839](arg i[82836] :
  enumerated[179](?)) : _unknown[43] "inline"
  {
    (82845 return(82844 call chpl__enumToOrder i[82836]))
  }
  function chpl__idxToInt[82856](arg i[82853] :
  bool[10]) : _unknown[43] "inline"
  {
    (82862 return(82860 call _cast int(64)[13] i[82853]))
  }
  function chpl__idxToInt[82873](param arg i[82870] :
  bool[10]) param : _unknown[43] "inline"
  {
    (82879 return(82877 call _cast int(64)[13] i[82870]))
  }
  (329335 'used modules list'(66061 'use' ChapelBase[302])(66063 'use' SysBasic[209963])(66064 'use' HaltWrappers[197622])(66068 'use' Math[202696]))
}