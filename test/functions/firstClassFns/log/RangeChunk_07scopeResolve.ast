AST dump for RangeChunk after pass scopeResolve.
Module use list: ChapelStandard 

{
  type RemElems[250327] def Thru[250321]:RemElems[250327] def Pack[250323]:RemElems[250327] def Mod[250325]:RemElems[250327]
  function chunks[250352](arg r[250349] :
  (250348 call range[66183](?) unknown RT[250342] bounded[66079] unknown S[250346]), arg numChunks[250355] :
  integral[188](?), arg remPol[250360] :
  RemElems[250327] =
  Thru[250321]) : _unknown[43] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[250422] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[250423] "expr temp" "temp"
      (250432 'move' _iterator[250423](250430 call _getIterator(250380 call chunksOrder r[250349] numChunks[250355] remPol[250360])))
      Defer
      {
        {
          (250463 call _freeIterator _iterator[250423])
        }
      }
      { scopeless type
        (250438 'move' _indexOfInterest[250422](250435 call iteratorIndex _iterator[250423]))
      }
      ForLoop
      {
        (250443 call _check_tuple_var_decl _indexOfInterest[250422] 2)
        unknown startOrder[250449] "index var" "insert auto destroy"
        (250451 'move' startOrder[250449](250447 call _indexOfInterest[250422] 1))
        unknown endOrder[250456] "index var" "insert auto destroy"
        (250458 'move' endOrder[250456](250454 call _indexOfInterest[250422] 2))
        {
          const start[250388] "const"(250387 call(250382 call . r[250349] c"orderToIndex") startOrder[250449])
          const end[250399] "const"(250398 call(250393 call . r[250349] c"orderToIndex") endOrder[250456])
          (250420 yield(250417 IfExpr  S[250346] then
          { scopeless
            (250411 call chpl_by(250405 call chpl_build_bounded_range start[250388] end[250399])(250408 call . r[250349] c"stride"))
          } else
          { scopeless
            (250415 call chpl_build_bounded_range start[250388] end[250399])
          } ))
        }
        label _continueLabel[250427]
        _indexOfInterest[250422]
        _iterator[250423]
      }
      label _breakLabel[250428]
    }
  }
  { scopeless type
    (250369 call range[66183](?) RT[250342] bounded[66079] S[250346])
  }
  function chunk[250487](arg r[250484] :
  (250483 call range[66183](?) unknown RT[250477] bounded[66079] unknown S[250481]), arg numChunks[250490] :
  integral[188](?), arg idx[250494] :
  integral[188](?), arg remPol[250499] :
  RemElems[250327] =
  Thru[250321]) : _unknown[43]
  {
    const tmp[250521] "const" "no copy" "temp"(250520 call chunkOrder r[250484] numChunks[250490] idx[250494] remPol[250499])
    (250528 call _check_tuple_var_decl tmp[250521] 2)
    const startOrder[250509] "const"(250522 call tmp[250521] 1)
    const endOrder[250511] "const"(250525 call tmp[250521] 2)
    const start[250541] "const"(250540 call(250535 call . r[250484] c"orderToIndex") startOrder[250509])
    const end[250551] "const"(250550 call(250545 call . r[250484] c"orderToIndex") endOrder[250511])
    (250572 return(250569 IfExpr  S[250481] then
    { scopeless
      (250563 call chpl_by(250557 call chpl_build_bounded_range start[250541] end[250551])(250560 call . r[250484] c"stride"))
    } else
    { scopeless
      (250567 call chpl_build_bounded_range start[250541] end[250551])
    } ))
  }
  { scopeless type
    (250508 call range[66183](?) RT[250477] bounded[66079] S[250481])
  }
  function chunksOrder[250589](arg r[250586] :
  (250585 call range[66183](?) unknown RT[250580] bounded[66079] ?[249]), arg numChunks[250592] :
  integral[188](?), arg remPol[250597] :
  RemElems[250327] =
  Thru[250321]) : _unknown[43] "iterator fn" "no return value for void"
  {
    if(250620 call _cond_test(250616 call ||(250610 call ==(250606 call . r[250586] c"length") 0)(250614 call <= numChunks[250592] 0)))
    {
      (250618 return _void[47])
    }
    const nElems[250630] "const"(250627 call . r[250586] c"length")
    unknown nChunks[250641](250639 call _cast RT[250580](250637 call min numChunks[250592] nElems[250630]))
    unknown chunkSize[250644] RT[250580]
    unknown rem[250648](250652 'typeof' chunkSize[250644])
    {
      unknown tmp[250719] "expr temp" "maybe param" "maybe type" "temp"
      (250721 'move' tmp[250719] remPol[250597])
      if(250726 call _cond_test(250723 call == tmp[250719] Pack[250323]))
      {
        (250662 call = chunkSize[250644](250660 call / nElems[250630] nChunks[250641]))
        if(250688 call _cond_test(250671 call !=(250668 call * chunkSize[250644] nChunks[250641]) nElems[250630]))
        {
          (250675 call += chunkSize[250644] 1)
          (250685 call = nChunks[250641](250684 call divceil nElems[250630] chunkSize[250644]))
        }
      }
      {
        if(250732 call _cond_test(250729 call == tmp[250719] Mod[250325]))
        {
          (250701 call = chunkSize[250644](250699 call / nElems[250630] nChunks[250641]))
          (250713 call = rem[250648](250711 call - nElems[250630](250709 call * chunkSize[250644] nChunks[250641])))
        }
      }
    }
    {
      unknown _indexOfInterest[250853] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[250854] "expr temp" "temp"
      (250863 'move' _iterator[250854](250861 call _getIterator(250870 call chpl_direct_counted_range_iter 0 nChunks[250641])))
      Defer
      {
        {
          (250886 call _freeIterator _iterator[250854])
        }
      }
      { scopeless type
        (250875 'move' _indexOfInterest[250853](250872 call iteratorIndex _iterator[250854]))
      }
      ForLoop
      {
        unknown i[250879] "index var" "insert auto destroy"
        (250881 'move' i[250879] _indexOfInterest[250853])
        {
          unknown chunk[250748](250746 call * 2 RT[250580])
          {
            unknown tmp[250825] "expr temp" "maybe param" "maybe type" "temp"
            (250827 'move' tmp[250825] remPol[250597])
            if(250832 call _cond_test(250829 call == tmp[250825] Thru[250321]))
            {
              (250763 call = chunk[250748](250762 call chunkOrderThru nElems[250630] nChunks[250641] i[250879]))
            }
            {
              if(250838 call _cond_test(250835 call == tmp[250825] Pack[250323]))
              {
                (250778 call = chunk[250748](250777 call chunkOrderPack chunkSize[250644] nElems[250630] i[250879]))
              }
              {
                if(250845 call _cond_test(250842 call == tmp[250825] Mod[250325]))
                {
                  (250795 call = chunk[250748](250794 call chunkOrderMod chunkSize[250644] rem[250648] nElems[250630] nChunks[250641] i[250879]))
                }
                {
                  (250819 call halt "RangeChunk: unknown RemElems in chunksOrder")
                }
              }
            }
          }
          (250851 yield chunk[250748])
        }
        label _continueLabel[250858]
        _indexOfInterest[250853]
        _iterator[250854]
      }
      label _breakLabel[250859]
    }
  }
  { scopeless type
    (250603 call * 2 RT[250580])
  }
  function chunkOrder[250908](arg r[250905] :
  (250904 call range[66183](?) unknown RT[250899] bounded[66079] ?[249]), arg numChunks[250911] :
  integral[188](?), arg idx[250915] :
  integral[188](?), arg remPol[250920] :
  RemElems[250327] =
  Thru[250321]) : _unknown[43]
  {
    if(250966 call _cond_test(250951 call ||(250945 call ||(250939 call ||(250933 call ==(250929 call . r[250905] c"length") 0)(250937 call <= numChunks[250911] 0))(250943 call < idx[250915] 0))(250949 call >= idx[250915] numChunks[250911])))
    {
      (250964 return(250962 call _build_tuple(250955 call _cast RT[250899] 1)(250959 call _cast RT[250899] 0)))
    }
    const nElems[250976] "const"(250973 call . r[250905] c"length")
    const nChunks[250987] "const"(250985 call _cast RT[250899](250983 call min numChunks[250911] nElems[250976]))
    const i[250994] "const"(250992 call _cast RT[250899] idx[250915])
    {
      unknown tmp[251105] "expr temp" "maybe param" "maybe type" "temp"
      (251107 'move' tmp[251105] remPol[250920])
      if(251112 call _cond_test(251109 call == tmp[251105] Thru[250321]))
      {
        (251007 return(251006 call chunkOrderThru nElems[250976] nChunks[250987] i[250994]))
      }
      {
        if(251118 call _cond_test(251115 call == tmp[251105] Pack[250323]))
        {
          unknown chunkSize[251018](251016 call / nElems[250976] nChunks[250987])
          if(251034 call _cond_test(251027 call !=(251024 call * chunkSize[251018] nChunks[250987]) nElems[250976]))
          {
            (251031 call += chunkSize[251018] 1)
          }
          (251045 return(251044 call chunkOrderPack chunkSize[251018] nElems[250976] i[250994]))
        }
        {
          if(251125 call _cond_test(251122 call == tmp[251105] Mod[250325]))
          {
            const chunkSize[251055] "const"(251053 call / nElems[250976] nChunks[250987])
            const rem[251066] "const"(251064 call - nElems[250976](251062 call * chunkSize[251055] nChunks[250987]))
            (251077 return(251076 call chunkOrderMod chunkSize[251055] rem[251066] nElems[250976] nChunks[250987] i[250994]))
          }
          {
            (251099 call halt "RangeChunk: unknown RemElems in chunkOrder")
          }
        }
      }
    }
  }
  { scopeless type
    (250926 call * 2 RT[250899])
  }
  function chunkOrderThru[251140](arg nElems[251137] :
  unknown I[251135], arg nChunks[251143] :
  I[251135], arg i[251147] :
  I[251135]) : _unknown[43] "no doc" "private"
  {
    const m[251159] "const"(251157 call * nElems[251137] i[251147])
    const start[251179] "const"(251176 IfExpr (251165 call == i[251147] 0) then
    { scopeless
      (251169 call _cast I[251135] 0)
    } else
    { scopeless
      (251175 call divceil m[251159] nChunks[251143])
    } )
    const end[251207] "const"(251204 IfExpr (251187 call == i[251147](251185 call - nChunks[251143] 1)) then
    { scopeless
      (251191 call - nElems[251137] 1)
    } else
    { scopeless
      (251202 call -(251200 call divceil(251196 call + m[251159] nElems[251137]) nChunks[251143]) 1)
    } )
    (251215 return(251213 call _build_tuple start[251179] end[251207]))
  }
  { scopeless type
    (251153 call _build_tuple I[251135] I[251135])
  }
  function chunkOrderPack[251227](arg chunkSize[251224] :
  unknown I[251222], arg nElems[251230] :
  I[251222], arg i[251234] :
  I[251222]) : _unknown[43] "no doc" "private"
  {
    const start[251246] "const"(251244 call * chunkSize[251224] i[251234])
    if(251267 call _cond_test(251252 call >= start[251246] nElems[251230]))
    {
      (251265 return(251263 call _build_tuple(251256 call _cast I[251222] 1)(251260 call _cast I[251222] 0)))
    }
    unknown end[251279](251277 call -(251274 call + start[251246] chunkSize[251224]) 1)
    if(251294 call _cond_test(251284 call >= end[251279] nElems[251230]))
    {
      (251291 call = end[251279](251289 call - nElems[251230] 1))
    }
    (251304 return(251302 call _build_tuple start[251246] end[251279]))
  }
  { scopeless type
    (251240 call _build_tuple I[251222] I[251222])
  }
  function chunkOrderMod[251316](arg chunkSize[251313] :
  unknown I[251311], arg rem[251319] :
  I[251311], arg nElems[251323] :
  I[251311], arg nChunks[251327] :
  I[251311], arg i[251331] :
  I[251311]) : _unknown[43] "no doc" "private"
  {
    unknown start[251339] I[251311]
    unknown end[251343](251347 'typeof' start[251339])
    if(251399 call _cond_test(251351 call < i[251331] rem[251319]))
    {
      (251361 call = start[251339](251359 call * i[251331](251357 call + chunkSize[251313] 1)))
      (251370 call = end[251343](251368 call + start[251339] chunkSize[251313]))
    }
    {
      (251384 call = start[251339](251382 call - nElems[251323](251380 call *(251377 call - nChunks[251327] i[251331]) chunkSize[251313])))
      (251396 call = end[251343](251394 call -(251391 call + start[251339] chunkSize[251313]) 1))
    }
    (251408 return(251406 call _build_tuple start[251339] end[251343]))
  }
  { scopeless type
    (251337 call _build_tuple I[251311] I[251311])
  }
  (329541 'used modules list'(328328 'use' ChapelStandard[19734])(250333 'use' RemElems[250327])(250337 'use' BoundedRangeType[66087]))
}