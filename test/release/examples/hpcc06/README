===============================
Chapel 2006 HPC Challenge Codes
===============================

This directory contains Chapel versions of the HPC Challenge
benchmarks (http://icl.cs.utk.edu/hpcc/) and a Makefile to help build
them.  These codes are based on our entries for the 2006 HPC Challenge
Award Competition for class 2 ("most productivity").  For a detailed
explanation of these benchmarks, please refer to hpcc06.pdf in the
doc/ directory.

The primary performance bottleneck for these benchmarks comes from the
insertion of sequence temporaries by the Chapel compiler to capture
intermediate values for promoted operators and reductions.  This
results in a much larger memory footprint than the benchmarks are
intended to use and will bog down most systems due to swapping.  To
select smaller problem sizes and avoid this overhead, override the
default values of the m and n configuration variables on the
command-line to specify smaller problem sizes (for example: "stream
--m=100000").  These sequence temporaries are not required by Chapel
semantics, but were inserted to move our compiler implementation
forward more rapidly.  We plan to remove these sequence temporaries in
the near future.  To see an example of the impact of these sequences,
compare the difference in reported performance between stream.chpl and
stream-nopromote.chpl.  The second version has its Triad statement
rewritten to avoid promotion and runs much faster in practice.

Apart from this primary bottleneck, there are several other smaller
performance issues, most of which can be resolved through traditional
optimizations that we simply haven't prioritized in our implementation
effort yet.

The codes in this directory have been improved from the versions in
the paper.  Some of these changes resolve workarounds in our original
implementations that were called out in the report using "Compiler
Status Notes."  Other changes reflect evolution in the Chapel language
or standard libraries.  Some changes reflect an improved understanding
of the benchmarks.

The changes that fix compiler status notes from the paper are:

  * the compiler can now infer the return type of an iterator, so the
    explicit return types in the iterators of ra-randstream.chpl have
    been removed to match the style of the rest of the code.

  * the compiler now supports casts to complex types other than the
    default "complex", so the casts in the FFT codes were changed to
    refer to the named type alias ":elemType" rather than ":complex".

  * the compiler now supports param functions and numBytes was
    converted into a param function, so the explicit cast in the 
    printProblemSize() routine in probSize.chpl was removed.

  * the compiler now supports inter-module parameters and types better
    than it did, allowing randType in ra-randstream.chpl to be defined
    in terms of randWidth rather than the literal "64".

  * the compiler now supports iterators within classes, so we moved
    the subBlocks iterator into the domain's implementation class
    rather than having it as a standalone iterator taking a domain
    as an argument.

Other changes to date are:

  * the memRatio argument to computeProblemSize in probSize.chpl was
    changed into a configuration constant, as alluded to in the
    report.

  * the physicalMemory() interface was updated to return an int(64) by
    default rather than an int, requiring a cast in computing the
    numIndices value to keep it an int as in the original
    implementation.

  * the physicalMemory() interface was changed from a top-level
    function taking a locale argument into a method on the locale
    type, so the calls to physicalMemory() were updated to reflect
    this change.

  * the default value of the sequentialVerify configuration constant
    in the RA benchmark was changed from "false" to a comparison
    between the number of locales and the log of the problem size (m).
    The reason for this is that the parallel verification step is an
    O(m*log2(m)) algorithm (with a large constant factor) whereas the
    sequential algorithm is O(m).  While the parallel version makes
    sense to use for large machine scales, the sequential version is
    far superior for smaller scales like our current 1-locale
    implementation.  This code doesn't reflect the crossover point
    accurately, but at least makes small numLocales cases much less
    ridiculous.

  * fixed a bug in cftmd2() in fft-mta.chpl in which a wk2 value was
    declared to be const, but then modified which the compiler wasn't
    catching.

  * removed the Temp array in the bitReverseShuffle() routine of
    fft.chpl and fft-mta.chpl to reduce memory requirements.

  * changed the RAStream iterator to take a range/domain as its
    argument rather than two integers.  This makes good use of
    Chapel's range concept and requires the need to break the block
    parameter apart at the callsite.

  * changed the module "use" statements to use comma-separated lists
    of modules rather than a separate use statement per module.
