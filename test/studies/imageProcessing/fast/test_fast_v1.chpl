
/*****
      test_fast_v1.chpl -
      Test bench to verify indices generated by the circumference iterator
      are correct.

      Call:
        test_fast_v1

      c 2015-2018 Primordial Machine Vision Systems
*****/

use fast_v1;



/**** BIST ****/

/***
    test_circumference:  Self-checking test bench for the circumference
                         iterator.
    returns:   pass/fail flag
***/
proc test_circumference() : bool {
  var cnt : int;                        /* test case counter */
  var passed = true;                    /* overall result for bench */

  writeln("\nStarting test bench for circumference");

  writeln("  checking radius 3");
  cnt = 0;
  for (x, y) in new circumference(3, 0, 0, true) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {  exp = ( 3,  0); }   when 1 {  exp = ( 3,  1); }
      when 2 {  exp = ( 2,  2); }   when 3 {  exp = ( 1,  3); }
      when 4 {  exp = ( 0,  3); }   when 5 {  exp = (-1,  3); }
      when 6 {  exp = (-2,  2); }   when 7 {  exp = (-3,  1); }
      when 8 {  exp = (-3,  0); }   when 9 {  exp = (-3, -1); }
      when 10 { exp = (-2, -2); }   when 11 { exp = (-1, -3); }
      when 12 { exp = ( 0, -3); }   when 13 { exp = ( 1, -3); }
      when 14 { exp = ( 2, -2); }   when 15 { exp = ( 3, -1); }
      when 16 { exp = ( 3,  0); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (17 != cnt) {
    writeln("  test only generated ", cnt, " points, not 17");
    passed = false;
  }

  writeln("  checking radius 4");
  cnt = 0;
  for (x, y) in new circumference(4, 0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  4,  0); }   when 1 {   exp = (  4,  1); }
      when 2 {   exp = (  3,  2); }   when 3 {   exp = (  2,  3); }
      when 4 {   exp = (  1,  4); }   when 5 {   exp = (  0,  4); }
      when 6 {   exp = ( -1,  4); }   when 7 {   exp = ( -2,  3); }
      when 8 {   exp = ( -3,  2); }   when 9 {   exp = ( -4,  1); }
      when 10 {  exp = ( -4,  0); }   when 11 {  exp = ( -4, -1); }
      when 12 {  exp = ( -3, -2); }   when 13 {  exp = ( -2, -3); }
      when 14 {  exp = ( -1, -4); }   when 15 {  exp = (  0, -4); }
      when 16 {  exp = (  1, -4); }   when 17 {  exp = (  2, -3); }
      when 18 {  exp = (  3, -2); }   when 19 {  exp = (  4, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (20 != cnt) {
    writeln("  test only generated ", cnt, " points, not 20");
    passed = false;
  }

  writeln("  checking radius 5");
  cnt = 0;
  for (x, y) in new circumference(5, 0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  5,  0); }   when 1 {   exp = (  5,  1); }
      when 2 {   exp = (  5,  2); }   when 3 {   exp = (  4,  3); }
      when 4 {   exp = (  3,  4); }   when 5 {   exp = (  2,  5); }
      when 6 {   exp = (  1,  5); }   when 7 {   exp = (  0,  5); }
      when 8 {   exp = ( -1,  5); }   when 9 {   exp = ( -2,  5); }
      when 10 {  exp = ( -3,  4); }   when 11 {  exp = ( -4,  3); }
      when 12 {  exp = ( -5,  2); }   when 13 {  exp = ( -5,  1); }
      when 14 {  exp = ( -5,  0); }   when 15 {  exp = ( -5, -1); }
      when 16 {  exp = ( -5, -2); }   when 17 {  exp = ( -4, -3); }
      when 18 {  exp = ( -3, -4); }   when 19 {  exp = ( -2, -5); }
      when 20 {  exp = ( -1, -5); }   when 21 {  exp = (  0, -5); }
      when 22 {  exp = (  1, -5); }   when 23 {  exp = (  2, -5); }
      when 24 {  exp = (  3, -4); }   when 25 {  exp = (  4, -3); }
      when 26 {  exp = (  5, -2); }   when 27 {  exp = (  5, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (28 != cnt) {
    writeln("  test only generated ", cnt, " points, not 28");
    passed = false;
  }

  writeln("  checking radius 6");
  cnt = 0;
  var circle = new unmanaged circumference(6);
  for (x, y) in circle(0, 0, true) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  6,  0); }   when 1 {   exp = (  6,  1); }
      when 2 {   exp = (  6,  2); }   when 3 {   exp = (  5,  3); }
      when 4 {   exp = (  4,  4); }   when 5 {   exp = (  3,  5); }
      when 6 {   exp = (  2,  6); }   when 7 {   exp = (  1,  6); }
      when 8 {   exp = (  0,  6); }   when 9 {   exp = ( -1,  6); }
      when 10 {  exp = ( -2,  6); }   when 11 {  exp = ( -3,  5); }
      when 12 {  exp = ( -4,  4); }   when 13 {  exp = ( -5,  3); }
      when 14 {  exp = ( -6,  2); }   when 15 {  exp = ( -6,  1); }
      when 16 {  exp = ( -6,  0); }   when 17 {  exp = ( -6, -1); }
      when 18 {  exp = ( -6, -2); }   when 19 {  exp = ( -5, -3); }
      when 20 {  exp = ( -4, -4); }   when 21 {  exp = ( -3, -5); }
      when 22 {  exp = ( -2, -6); }   when 23 {  exp = ( -1, -6); }
      when 24 {  exp = (  0, -6); }   when 25 {  exp = (  1, -6); }
      when 26 {  exp = (  2, -6); }   when 27 {  exp = (  3, -5); }
      when 28 {  exp = (  4, -4); }   when 29 {  exp = (  5, -3); }
      when 30 {  exp = (  6, -2); }   when 31 {  exp = (  6, -1); }
      when 32 {  exp = (  6,  0); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (33 != cnt) {
    writeln("  test only generated ", cnt, " points, not 33");
    passed = false;
  }

  writeln("  checking radius 7");
  cnt = 0;
  circle.set_radius(7);
  for (x, y) in circle(0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  7,  0); }   when 1 {   exp = (  7,  1); }
      when 2 {   exp = (  7,  2); }   when 3 {   exp = (  6,  3); }
      when 4 {   exp = (  6,  4); }   when 5 {   exp = (  5,  5); }
      when 6 {   exp = (  4,  6); }   when 7 {   exp = (  3,  6); }
      when 8 {   exp = (  2,  7); }   when 9 {   exp = (  1,  7); }
      when 10 {  exp = (  0,  7); }   when 11 {  exp = ( -1,  7); }
      when 12 {  exp = ( -2,  7); }   when 13 {  exp = ( -3,  6); }
      when 14 {  exp = ( -4,  6); }   when 15 {  exp = ( -5,  5); }
      when 16 {  exp = ( -6,  4); }   when 17 {  exp = ( -6,  3); }
      when 18 {  exp = ( -7,  2); }   when 19 {  exp = ( -7,  1); }
      when 20 {  exp = ( -7,  0); }   when 21 {  exp = ( -7, -1); }
      when 22 {  exp = ( -7, -2); }   when 23 {  exp = ( -6, -3); }
      when 24 {  exp = ( -6, -4); }   when 25 {  exp = ( -5, -5); }
      when 26 {  exp = ( -4, -6); }   when 27 {  exp = ( -3, -6); }
      when 28 {  exp = ( -2, -7); }   when 29 {  exp = ( -1, -7); }
      when 30 {  exp = (  0, -7); }   when 31 {  exp = (  1, -7); }
      when 32 {  exp = (  2, -7); }   when 33 {  exp = (  3, -6); }
      when 34 {  exp = (  4, -6); }   when 35 {  exp = (  5, -5); }
      when 36 {  exp = (  6, -4); }   when 37 {  exp = (  6, -3); }
      when 38 {  exp = (  7, -2); }   when 39 {  exp = (  7, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (40 != cnt) {
    writeln("  test only generated ", cnt, " points, not 40");
    passed = false;
  }

  writeln("  checking radius 8");
  cnt = 0;
  circle.set_radius(8);
  for (x, y) in circle(0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {  exp = (  8,  0); }   when 1 {  exp = (  8,  1); }
      when 2 {  exp = (  8,  2); }   when 3 {  exp = (  7,  3); }
      when 4 {  exp = (  7,  4); }   when 5 {  exp = (  6,  5); }
      when 6 {  exp = (  5,  6); }   when 7 {  exp = (  4,  7); }
      when 8 {  exp = (  3,  7); }   when 9 {  exp = (  2,  8); }
      when 10 { exp = (  1,  8); }   when 11 { exp = (  0,  8); }
      when 12 { exp = ( -1,  8); }   when 13 { exp = ( -2,  8); }
      when 14 { exp = ( -3,  7); }   when 15 { exp = ( -4,  7); }
      when 16 { exp = ( -5,  6); }   when 17 { exp = ( -6,  5); }
      when 18 { exp = ( -7,  4); }   when 19 { exp = ( -7,  3); }
      when 20 { exp = ( -8,  2); }   when 21 { exp = ( -8,  1); }
      when 22 { exp = ( -8,  0); }   when 23 { exp = ( -8, -1); }
      when 24 { exp = ( -8, -2); }   when 25 { exp = ( -7, -3); }
      when 26 { exp = ( -7, -4); }   when 27 { exp = ( -6, -5); }
      when 28 { exp = ( -5, -6); }   when 29 { exp = ( -4, -7); }
      when 30 { exp = ( -3, -7); }   when 31 { exp = ( -2, -8); }
      when 32 { exp = ( -1, -8); }   when 33 { exp = (  0, -8); }
      when 34 { exp = (  1, -8); }   when 35 { exp = (  2, -8); }
      when 36 { exp = (  3, -7); }   when 37 { exp = (  4, -7); }
      when 38 { exp = (  5, -6); }   when 39 { exp = (  6, -5); }
      when 40 { exp = (  7, -4); }   when 41 { exp = (  7, -3); }
      when 42 { exp = (  8, -2); }   when 43 { exp = (  8, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (44 != cnt) {
    writeln("  test only generated ", cnt, " points, not 44");
    passed = false;
  }

  writeln("  checking radius 9");
  cnt = 0;
  circle.set_radius(9);
  for (x, y) in circle(0, 0, true) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {  exp = (  9,  0); }   when 1 {  exp = (  9,  1); }
      when 2 {  exp = (  9,  2); }   when 3 {  exp = (  8,  3); }
      when 4 {  exp = (  8,  4); }   when 5 {  exp = (  7,  5); }
      when 6 {  exp = (  7,  6); }   when 7 {  exp = (  6,  7); }
      when 8 {  exp = (  5,  7); }   when 9 {  exp = (  4,  8); }
      when 10 { exp = (  3,  8); }   when 11 { exp = (  2,  9); }
      when 12 { exp = (  1,  9); }   when 13 { exp = (  0,  9); }
      when 14 { exp = ( -1,  9); }   when 15 { exp = ( -2,  9); }
      when 16 { exp = ( -3,  8); }   when 17 { exp = ( -4,  8); }
      when 18 { exp = ( -5,  7); }   when 19 { exp = ( -6,  7); }
      when 20 { exp = ( -7,  6); }   when 21 { exp = ( -7,  5); }
      when 22 { exp = ( -8,  4); }   when 23 { exp = ( -8,  3); }
      when 24 { exp = ( -9,  2); }   when 25 { exp = ( -9,  1); }
      when 26 { exp = ( -9,  0); }   when 27 { exp = ( -9, -1); }
      when 28 { exp = ( -9, -2); }   when 29 { exp = ( -8, -3); }
      when 30 { exp = ( -8, -4); }   when 31 { exp = ( -7, -5); }
      when 32 { exp = ( -7, -6); }   when 33 { exp = ( -6, -7); }
      when 34 { exp = ( -5, -7); }   when 35 { exp = ( -4, -8); }
      when 36 { exp = ( -3, -8); }   when 37 { exp = ( -2, -9); }
      when 38 { exp = ( -1, -9); }   when 39 { exp = (  0, -9); }
      when 40 { exp = (  1, -9); }   when 41 { exp = (  2, -9); }
      when 42 { exp = (  3, -8); }   when 43 { exp = (  4, -8); }
      when 44 { exp = (  5, -7); }   when 45 { exp = (  6, -7); }
      when 46 { exp = (  7, -6); }   when 47 { exp = (  7, -5); }
      when 48 { exp = (  8, -4); }   when 49 { exp = (  8, -3); }
      when 50 { exp = (  9, -2); }   when 51 { exp = (  9, -1); }
      when 52 { exp = (  9,  0); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (53 != cnt) {
    writeln("  test only generated ", cnt, " points, not 53");
    passed = false;
  }

  if (!passed) then writeln("  some test failed");
  else writeln("  all tests passed");

  delete circle;

  return passed;
}

/***
    test_is_corner:  Self-checking test bench for the is_corner procedure.
    returns:   pass/fail flag
***/
proc test_is_corner() : bool {
  var passed = true;                    /* overall result for bench */
  var img : unmanaged clrimage?;        /* dummy data */
  var circle = new unmanaged circumference(3);    /* iterator about circle */

  writeln("\nStarting test bench for is_corner");

  if (9 != minlen) {
    writeln("  assumes minlen is 9, not ", minlen,
            " - please correct on command line");
    return false;
  }
  if (13 != maxlen) {
    writeln("  assumes maxlen is 13, not ", maxlen,
            " - please correct on command line");
    return false;
  }

  img = new unmanaged clrimage(20, 20, clrspace.LAB);
  img!.c1(10,10) = 20.0;

  /* Pixel counts for r==3 range from 0 t/m 15. */

  /* Test 1 - segment good length at minlen. */
  set_segment(img, 10, 10, circle, 0, 2, thrdir.SAME);
  set_segment(img, 10, 10, circle, 3, 11, thrdir.MORE);
  set_segment(img, 10, 10, circle, 12, 15, thrdir.LESS);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 1 expected corner, got false");
    passed = false;
  }

  /* Test 2 - segment good length at maxlen. */
  set_segment(img, 10, 10, circle, 0, 1, thrdir.SAME);
  set_segment(img, 10, 10, circle, 2, 14, thrdir.MORE);
  set_segment(img, 10, 10, circle, 15, 15, thrdir.LESS);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 2 expected corner, got false");
    passed = false;
  }

  /* Test 3 - segment length too short at minlen-1. */
  set_segment(img, 10, 10, circle, 0, 3, thrdir.LESS);
  set_segment(img, 10, 10, circle, 4, 4, thrdir.MORE);
  set_segment(img, 10, 10, circle, 5, 12, thrdir.LESS);
  set_segment(img, 10, 10, circle, 13, 15, thrdir.SAME);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 2 expected not a corner, got true");
    passed = false;
  }

  /* Test 4 - segment length too long at maxlen+1. */
  set_segment(img, 10, 10, circle, 0, 0, thrdir.LESS);
  set_segment(img, 10, 10, circle, 1, 14, thrdir.MORE);
  set_segment(img, 10, 10, circle, 15, 15, thrdir.LESS);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 4 expected not a corner, got true");
    passed = false;
  }

  /* Test 5 - segment good length at minlen, wraps around 0. */
  set_segment(img, 10, 10, circle, 0, 6, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 10, thrdir.LESS);
  set_segment(img, 10, 10, circle, 11, 12, thrdir.SAME);
  set_segment(img, 10, 10, circle, 13, 13, thrdir.LESS);
  set_segment(img, 10, 10, circle, 14, 15, thrdir.MORE);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 5 expected corner, got false");
    passed = false;
  }

  /* Test 6 - segment good length at maxlen, wraps around 0. */
  set_segment(img, 10, 10, circle, 0, 6, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 9, thrdir.LESS);
  set_segment(img, 10, 10, circle, 10, 15, thrdir.MORE);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 6 expected corner, got false");
    passed = false;
  }

  /* Test 7 - segment length too short at minlen-1, wraps around 0 */
  set_segment(img, 10, 10, circle, 0, 3, thrdir.LESS);
  set_segment(img, 10, 10, circle, 4, 4, thrdir.MORE);
  set_segment(img, 10, 10, circle, 5, 11, thrdir.SAME);
  set_segment(img, 10, 10, circle, 12, 15, thrdir.LESS);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 7 expected not a corner, got true");
    passed = false;
  }

  /* Test 8 - segment length too long at maxlen+1, wraps around 0 */
  set_segment(img, 10, 10, circle, 0, 10, thrdir.MORE);
  set_segment(img, 10, 10, circle, 11, 12, thrdir.SAME);
  set_segment(img, 10, 10, circle, 13, 15, thrdir.MORE);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 8 expected not a corner, got true");
    passed = false;
  }

  /* Test 9 - segment length good at minlen, starting at 0. */
  set_segment(img, 10, 10, circle, 0, 8, thrdir.LESS);
  set_segment(img, 10, 10, circle, 9, 9, thrdir.MORE);
  set_segment(img, 10, 10, circle, 10, 14, thrdir.SAME);
  set_segment(img, 10, 10, circle, 15, 15, thrdir.MORE);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 9 expected corner, got false");
    passed = false;
  }

  /* Test 10 - segment length good at maxlen, ending at 15. */
  set_segment(img, 10, 10, circle, 0, 2, thrdir.SAME);
  set_segment(img, 10, 10, circle, 3, 15, thrdir.LESS);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 10 expected corner, got false");
    passed = false;
  }

  /* Test 11 - segment length good at minlen, starting at 15 and wrapping. */
  set_segment(img, 10, 10, circle, 0, 7, thrdir.MORE);
  set_segment(img, 10, 10, circle, 8, 14, thrdir.LESS);
  set_segment(img, 10, 10, circle, 15, 15, thrdir.MORE);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 11 expected corner, got false");
    passed = false;
  }

  /* Test 12 - segmeng length good at maxlen, wrapping and ending at 0. */
  set_segment(img, 10, 10, circle, 0, 0, thrdir.MORE);
  set_segment(img, 10, 10, circle, 1, 3, thrdir.LESS);
  set_segment(img, 10, 10, circle, 4, 15, thrdir.MORE);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 12 expected corner, got false");
    passed = false;
  }

  /* Test 13 - segment length too short at minlen-1, starting at 0. */
  set_segment(img, 10, 10, circle, 0, 7, thrdir.MORE);
  set_segment(img, 10, 10, circle, 8, 15, thrdir.LESS);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 13 expected not a corner, got true");
    passed = false;
  }

  /* Test 14 - segment length too long at maxlen+1, ending at 15. */
  set_segment(img, 10, 10, circle, 0, 1, thrdir.LESS);
  set_segment(img, 10, 10, circle, 2, 15, thrdir.MORE);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 14 expected not a corner, got true");
    passed = false;
  }

  /* Test 15 - segment length too short at minlen-1, starting at 15 w/ wrap. */
  set_segment(img, 10, 10, circle, 0, 6, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 14, thrdir.LESS);
  set_segment(img, 10, 10, circle, 15, 15, thrdir.MORE);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 15 expected not a corner, got true");
    passed = false;
  }

  /* Test 16 - segment length too short at minlen-1, ending at 0 w/ wrap. */
  set_segment(img, 10, 10, circle, 0, 0, thrdir.LESS);
  set_segment(img, 10, 10, circle, 1, 8, thrdir.MORE);
  set_segment(img, 10, 10, circle, 9, 15, thrdir.LESS);
  if (is_corner(img, 10, 10, circle)) {
    writeln("  test 16 expected not a corner, got true");
    passed = false;
  }

  /* Test 17 - segment length good at maxlen, starting at 1 */
  set_segment(img, 10, 10, circle, 0, 0, thrdir.SAME);
  set_segment(img, 10, 10, circle, 1, 11, thrdir.LESS);
  set_segment(img, 10, 10, circle, 12, 15, thrdir.SAME);
  if (!is_corner(img, 10, 10, circle)) {
    writeln("  test 17 expected corner, got false");
    passed = false;
  }

  /*
  set_segment(img, 10, 10, circle, , , thrdir.);
  set_segment(img, 10, 10, circle, , , thrdir.);
  set_segment(img, 10, 10, circle, , , thrdir.);
  set_segment(img, 10, 10, circle, , , thrdir.);
  */

  if (!passed) then writeln("  some test failed");
  else writeln("  all tests passed");

  delete img;
  delete circle;

  return passed;
}

/***
    set_segment:  Assign pixel values in the image along the circumference
                  between teh start and end.  The pixel is set so that the
                  direction condition holds.
    args:         img - greyscale image, plane c1 modified
                  xc, yc - center point of circle to mark
                  circle - iterator about circumference (radius already set)
                  st, end - index of first, last pixel along circle, incl.
                  dir - condition that perimeter pixel must meet
    modifies:  img
***/
proc set_segment(img : unmanaged clrimage?, xc : int, yc : int, circle : circumference,
                 st : int, end : int, dir : thrdir) {
  var cnt = 0;                          /* position along circumference */

  for (x, y) in circle(xc, yc) {
    if ((st <= cnt) && (cnt <= end)) {
      select (dir) {
      when thrdir.SAME { img!.c1(x, y) = img!.c1(xc, yc) + thr - 1.0; }
      when thrdir.MORE { img!.c1(x, y) = img!.c1(xc, yc) + thr + 1.0; }
      when thrdir.LESS { img!.c1(x, y) = img!.c1(xc, yc) - thr - 1.0; }
      otherwise writeln("unknown threshold direction ", dir);
      }
    }
    cnt += 1;
  }
}


/**** Top Level ****/

proc main() {
  var passed = true;                    /* overall pass/fail flag */

  if (!test_circumference()) then passed = false;
  if (!test_is_corner()) then passed = false;

  writeln("\nTest Bench Summary");
  if (passed) then writeln("  all tests passed\n");
  else writeln("  some test FAILED");

  return 0;
}
