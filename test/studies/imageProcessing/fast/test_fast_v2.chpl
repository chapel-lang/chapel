
/*****
      test_fast_v2.chpl -
      Test bench to verify indices generated by the circumference iterator
      are correct.

      Call:
        test_fast_v2

      c 2015-2018 Primordial Machine Vision Systems
*****/

use fast_v2;



/**** BIST ****/

/***
    test_circumference:  Self-checking test bench for the circumference
                         iterator.
    returns:   pass/fail flag
***/
proc test_circumference() : bool {
  var cnt : int;                        /* test case counter */
  var passed = true;                    /* overall result for bench */

  writeln("\nStarting test bench for circumference");

  writeln("  checking radius 3");
  cnt = 0;
  for (x, y) in new circumference(3, 0, 0, true) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {  exp = ( 3,  0); }   when 1 {  exp = ( 3,  1); }
      when 2 {  exp = ( 2,  2); }   when 3 {  exp = ( 1,  3); }
      when 4 {  exp = ( 0,  3); }   when 5 {  exp = (-1,  3); }
      when 6 {  exp = (-2,  2); }   when 7 {  exp = (-3,  1); }
      when 8 {  exp = (-3,  0); }   when 9 {  exp = (-3, -1); }
      when 10 { exp = (-2, -2); }   when 11 { exp = (-1, -3); }
      when 12 { exp = ( 0, -3); }   when 13 { exp = ( 1, -3); }
      when 14 { exp = ( 2, -2); }   when 15 { exp = ( 3, -1); }
      when 16 { exp = ( 3,  0); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (17 != cnt) {
    writeln("  test only generated ", cnt, " points, not 17");
    passed = false;
  }

  writeln("  checking radius 4");
  cnt = 0;
  for (x, y) in new circumference(4, 0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  4,  0); }   when 1 {   exp = (  4,  1); }
      when 2 {   exp = (  3,  2); }   when 3 {   exp = (  2,  3); }
      when 4 {   exp = (  1,  4); }   when 5 {   exp = (  0,  4); }
      when 6 {   exp = ( -1,  4); }   when 7 {   exp = ( -2,  3); }
      when 8 {   exp = ( -3,  2); }   when 9 {   exp = ( -4,  1); }
      when 10 {  exp = ( -4,  0); }   when 11 {  exp = ( -4, -1); }
      when 12 {  exp = ( -3, -2); }   when 13 {  exp = ( -2, -3); }
      when 14 {  exp = ( -1, -4); }   when 15 {  exp = (  0, -4); }
      when 16 {  exp = (  1, -4); }   when 17 {  exp = (  2, -3); }
      when 18 {  exp = (  3, -2); }   when 19 {  exp = (  4, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (20 != cnt) {
    writeln("  test only generated ", cnt, " points, not 20");
    passed = false;
  }

  writeln("  checking radius 5");
  cnt = 0;
  for (x, y) in new circumference(5, 0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  5,  0); }   when 1 {   exp = (  5,  1); }
      when 2 {   exp = (  5,  2); }   when 3 {   exp = (  4,  3); }
      when 4 {   exp = (  3,  4); }   when 5 {   exp = (  2,  5); }
      when 6 {   exp = (  1,  5); }   when 7 {   exp = (  0,  5); }
      when 8 {   exp = ( -1,  5); }   when 9 {   exp = ( -2,  5); }
      when 10 {  exp = ( -3,  4); }   when 11 {  exp = ( -4,  3); }
      when 12 {  exp = ( -5,  2); }   when 13 {  exp = ( -5,  1); }
      when 14 {  exp = ( -5,  0); }   when 15 {  exp = ( -5, -1); }
      when 16 {  exp = ( -5, -2); }   when 17 {  exp = ( -4, -3); }
      when 18 {  exp = ( -3, -4); }   when 19 {  exp = ( -2, -5); }
      when 20 {  exp = ( -1, -5); }   when 21 {  exp = (  0, -5); }
      when 22 {  exp = (  1, -5); }   when 23 {  exp = (  2, -5); }
      when 24 {  exp = (  3, -4); }   when 25 {  exp = (  4, -3); }
      when 26 {  exp = (  5, -2); }   when 27 {  exp = (  5, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (28 != cnt) {
    writeln("  test only generated ", cnt, " points, not 28");
    passed = false;
  }

  writeln("  checking radius 6");
  cnt = 0;
  var circle = new unmanaged circumference(6);
  for (x, y) in circle(0, 0, true) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  6,  0); }   when 1 {   exp = (  6,  1); }
      when 2 {   exp = (  6,  2); }   when 3 {   exp = (  5,  3); }
      when 4 {   exp = (  4,  4); }   when 5 {   exp = (  3,  5); }
      when 6 {   exp = (  2,  6); }   when 7 {   exp = (  1,  6); }
      when 8 {   exp = (  0,  6); }   when 9 {   exp = ( -1,  6); }
      when 10 {  exp = ( -2,  6); }   when 11 {  exp = ( -3,  5); }
      when 12 {  exp = ( -4,  4); }   when 13 {  exp = ( -5,  3); }
      when 14 {  exp = ( -6,  2); }   when 15 {  exp = ( -6,  1); }
      when 16 {  exp = ( -6,  0); }   when 17 {  exp = ( -6, -1); }
      when 18 {  exp = ( -6, -2); }   when 19 {  exp = ( -5, -3); }
      when 20 {  exp = ( -4, -4); }   when 21 {  exp = ( -3, -5); }
      when 22 {  exp = ( -2, -6); }   when 23 {  exp = ( -1, -6); }
      when 24 {  exp = (  0, -6); }   when 25 {  exp = (  1, -6); }
      when 26 {  exp = (  2, -6); }   when 27 {  exp = (  3, -5); }
      when 28 {  exp = (  4, -4); }   when 29 {  exp = (  5, -3); }
      when 30 {  exp = (  6, -2); }   when 31 {  exp = (  6, -1); }
      when 32 {  exp = (  6,  0); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (33 != cnt) {
    writeln("  test only generated ", cnt, " points, not 33");
    passed = false;
  }

  writeln("  checking radius 7");
  cnt = 0;
  circle.set_radius(7);
  for (x, y) in circle(0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {   exp = (  7,  0); }   when 1 {   exp = (  7,  1); }
      when 2 {   exp = (  7,  2); }   when 3 {   exp = (  6,  3); }
      when 4 {   exp = (  6,  4); }   when 5 {   exp = (  5,  5); }
      when 6 {   exp = (  4,  6); }   when 7 {   exp = (  3,  6); }
      when 8 {   exp = (  2,  7); }   when 9 {   exp = (  1,  7); }
      when 10 {  exp = (  0,  7); }   when 11 {  exp = ( -1,  7); }
      when 12 {  exp = ( -2,  7); }   when 13 {  exp = ( -3,  6); }
      when 14 {  exp = ( -4,  6); }   when 15 {  exp = ( -5,  5); }
      when 16 {  exp = ( -6,  4); }   when 17 {  exp = ( -6,  3); }
      when 18 {  exp = ( -7,  2); }   when 19 {  exp = ( -7,  1); }
      when 20 {  exp = ( -7,  0); }   when 21 {  exp = ( -7, -1); }
      when 22 {  exp = ( -7, -2); }   when 23 {  exp = ( -6, -3); }
      when 24 {  exp = ( -6, -4); }   when 25 {  exp = ( -5, -5); }
      when 26 {  exp = ( -4, -6); }   when 27 {  exp = ( -3, -6); }
      when 28 {  exp = ( -2, -7); }   when 29 {  exp = ( -1, -7); }
      when 30 {  exp = (  0, -7); }   when 31 {  exp = (  1, -7); }
      when 32 {  exp = (  2, -7); }   when 33 {  exp = (  3, -6); }
      when 34 {  exp = (  4, -6); }   when 35 {  exp = (  5, -5); }
      when 36 {  exp = (  6, -4); }   when 37 {  exp = (  6, -3); }
      when 38 {  exp = (  7, -2); }   when 39 {  exp = (  7, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (40 != cnt) {
    writeln("  test only generated ", cnt, " points, not 40");
    passed = false;
  }

  writeln("  checking radius 8");
  cnt = 0;
  circle.set_radius(8);
  for (x, y) in circle(0, 0, false) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {  exp = (  8,  0); }   when 1 {  exp = (  8,  1); }
      when 2 {  exp = (  8,  2); }   when 3 {  exp = (  7,  3); }
      when 4 {  exp = (  7,  4); }   when 5 {  exp = (  6,  5); }
      when 6 {  exp = (  5,  6); }   when 7 {  exp = (  4,  7); }
      when 8 {  exp = (  3,  7); }   when 9 {  exp = (  2,  8); }
      when 10 { exp = (  1,  8); }   when 11 { exp = (  0,  8); }
      when 12 { exp = ( -1,  8); }   when 13 { exp = ( -2,  8); }
      when 14 { exp = ( -3,  7); }   when 15 { exp = ( -4,  7); }
      when 16 { exp = ( -5,  6); }   when 17 { exp = ( -6,  5); }
      when 18 { exp = ( -7,  4); }   when 19 { exp = ( -7,  3); }
      when 20 { exp = ( -8,  2); }   when 21 { exp = ( -8,  1); }
      when 22 { exp = ( -8,  0); }   when 23 { exp = ( -8, -1); }
      when 24 { exp = ( -8, -2); }   when 25 { exp = ( -7, -3); }
      when 26 { exp = ( -7, -4); }   when 27 { exp = ( -6, -5); }
      when 28 { exp = ( -5, -6); }   when 29 { exp = ( -4, -7); }
      when 30 { exp = ( -3, -7); }   when 31 { exp = ( -2, -8); }
      when 32 { exp = ( -1, -8); }   when 33 { exp = (  0, -8); }
      when 34 { exp = (  1, -8); }   when 35 { exp = (  2, -8); }
      when 36 { exp = (  3, -7); }   when 37 { exp = (  4, -7); }
      when 38 { exp = (  5, -6); }   when 39 { exp = (  6, -5); }
      when 40 { exp = (  7, -4); }   when 41 { exp = (  7, -3); }
      when 42 { exp = (  8, -2); }   when 43 { exp = (  8, -1); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (44 != cnt) {
    writeln("  test only generated ", cnt, " points, not 44");
    passed = false;
  }

  writeln("  checking radius 9");
  cnt = 0;
  circle.set_radius(9);
  for (x, y) in circle(0, 0, true) {
    var exp : 2 * int;                  /* expected result */
    select cnt {
      when 0 {  exp = (  9,  0); }   when 1 {  exp = (  9,  1); }
      when 2 {  exp = (  9,  2); }   when 3 {  exp = (  8,  3); }
      when 4 {  exp = (  8,  4); }   when 5 {  exp = (  7,  5); }
      when 6 {  exp = (  7,  6); }   when 7 {  exp = (  6,  7); }
      when 8 {  exp = (  5,  7); }   when 9 {  exp = (  4,  8); }
      when 10 { exp = (  3,  8); }   when 11 { exp = (  2,  9); }
      when 12 { exp = (  1,  9); }   when 13 { exp = (  0,  9); }
      when 14 { exp = ( -1,  9); }   when 15 { exp = ( -2,  9); }
      when 16 { exp = ( -3,  8); }   when 17 { exp = ( -4,  8); }
      when 18 { exp = ( -5,  7); }   when 19 { exp = ( -6,  7); }
      when 20 { exp = ( -7,  6); }   when 21 { exp = ( -7,  5); }
      when 22 { exp = ( -8,  4); }   when 23 { exp = ( -8,  3); }
      when 24 { exp = ( -9,  2); }   when 25 { exp = ( -9,  1); }
      when 26 { exp = ( -9,  0); }   when 27 { exp = ( -9, -1); }
      when 28 { exp = ( -9, -2); }   when 29 { exp = ( -8, -3); }
      when 30 { exp = ( -8, -4); }   when 31 { exp = ( -7, -5); }
      when 32 { exp = ( -7, -6); }   when 33 { exp = ( -6, -7); }
      when 34 { exp = ( -5, -7); }   when 35 { exp = ( -4, -8); }
      when 36 { exp = ( -3, -8); }   when 37 { exp = ( -2, -9); }
      when 38 { exp = ( -1, -9); }   when 39 { exp = (  0, -9); }
      when 40 { exp = (  1, -9); }   when 41 { exp = (  2, -9); }
      when 42 { exp = (  3, -8); }   when 43 { exp = (  4, -8); }
      when 44 { exp = (  5, -7); }   when 45 { exp = (  6, -7); }
      when 46 { exp = (  7, -6); }   when 47 { exp = (  7, -5); }
      when 48 { exp = (  8, -4); }   when 49 { exp = (  8, -3); }
      when 50 { exp = (  9, -2); }   when 51 { exp = (  9, -1); }
      when 52 { exp = (  9,  0); }
      }
    if ((x, y) != exp) {
      writeln("  point ", cnt,"  expected ", exp, " got (", x, ",", y, ")");
      passed = false;
    }
    cnt += 1;
  }
  if (53 != cnt) {
    writeln("  test only generated ", cnt, " points, not 53");
    passed = false;
  }

  if (!passed) then writeln("  some test failed");
  else writeln("  all tests passed");

  delete circle;

  return passed;
}

/***
    test_is_corner:  Self-checking test bench for the is_corner procedure.
    returns:   pass/fail flag
***/
proc test_is_corner() : bool {
  var passed                            /* overall result for bench */
    = true;
  var img : unmanaged clrimage?;        /* dummy data */
  var circle                            /* iterator about circle */
    = new unmanaged circumference(3);
  var spec : fastspec;                  /* FAST parameters */

  writeln("\nStarting test bench for is_corner");

  spec.radius = 3;
  spec.minlen = 9;
  spec.maxlen = 13;
  spec.thr = 10.0;

  img = new unmanaged clrimage(20, 20, clrspace.LAB);
  img!.c1(10,10) = 20.0;

  /* Pixel counts for r==3 range from 0 t/m 15. */

  /* Test 1 - segment good length at minlen. */
  set_segment(img, 10, 10, circle, 0, 2, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 3, 11, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 12, 15, spec, thrdir.LESS);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 1 expected corner, got false");
    passed = false;
  }

  /* Test 2 - segment good length at maxlen. */
  set_segment(img, 10, 10, circle, 0, 1, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 2, 14, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.LESS);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 2 expected corner, got false");
    passed = false;
  }

  /* Test 3 - segment length too short at minlen-1. */
  set_segment(img, 10, 10, circle, 0, 3, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 4, 4, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 5, 12, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 13, 15, spec, thrdir.SAME);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 2 expected not a corner, got true");
    passed = false;
  }

  /* Test 4 - segment length too long at maxlen+1. */
  set_segment(img, 10, 10, circle, 0, 0, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 1, 14, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.LESS);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 4 expected not a corner, got true");
    passed = false;
  }

  /* Test 5 - segment good length at minlen, wraps around 0. */
  set_segment(img, 10, 10, circle, 0, 6, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 10, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 11, 12, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 13, 13, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 14, 15, spec, thrdir.MORE);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 5 expected corner, got false");
    passed = false;
  }

  /* Test 6 - segment good length at maxlen, wraps around 0. */
  set_segment(img, 10, 10, circle, 0, 6, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 9, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 10, 15, spec, thrdir.MORE);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 6 expected corner, got false");
    passed = false;
  }

  /* Test 7 - segment length too short at minlen-1, wraps around 0 */
  set_segment(img, 10, 10, circle, 0, 3, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 4, 4, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 5, 11, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 12, 15, spec, thrdir.LESS);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 7 expected not a corner, got true");
    passed = false;
  }

  /* Test 8 - segment length too long at maxlen+1, wraps around 0 */
  set_segment(img, 10, 10, circle, 0, 10, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 11, 12, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 13, 15, spec, thrdir.MORE);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 8 expected not a corner, got true");
    passed = false;
  }

  /* Test 9 - segment length good at minlen, starting at 0. */
  set_segment(img, 10, 10, circle, 0, 8, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 9, 9, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 10, 14, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.MORE);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 9 expected corner, got false");
    passed = false;
  }

  /* Test 10 - segment length good at maxlen, ending at 15. */
  set_segment(img, 10, 10, circle, 0, 2, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 3, 15, spec, thrdir.LESS);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 10 expected corner, got false");
    passed = false;
  }

  /* Test 11 - segment length good at minlen, starting at 15 and wrapping. */
  set_segment(img, 10, 10, circle, 0, 7, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 8, 14, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.MORE);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 11 expected corner, got false");
    passed = false;
  }

  /* Test 12 - segmeng length good at maxlen, wrapping and ending at 0. */
  set_segment(img, 10, 10, circle, 0, 0, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 1, 3, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 4, 15, spec, thrdir.MORE);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 12 expected corner, got false");
    passed = false;
  }

  /* Test 13 - segment length too short at minlen-1, starting at 0. */
  set_segment(img, 10, 10, circle, 0, 7, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 8, 15, spec, thrdir.LESS);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 13 expected not a corner, got true");
    passed = false;
  }

  /* Test 14 - segment length too long at maxlen+1, ending at 15. */
  set_segment(img, 10, 10, circle, 0, 1, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 2, 15, spec, thrdir.MORE);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 14 expected not a corner, got true");
    passed = false;
  }

  /* Test 15 - segment length too short at minlen-1, starting at 15 w/ wrap. */
  set_segment(img, 10, 10, circle, 0, 6, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 14, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.MORE);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 15 expected not a corner, got true");
    passed = false;
  }

  /* Test 16 - segment length too short at minlen-1, ending at 0 w/ wrap. */
  set_segment(img, 10, 10, circle, 0, 0, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 1, 8, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 9, 15, spec, thrdir.LESS);
  if (is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 16 expected not a corner, got true");
    passed = false;
  }

  /* Test 17 - segment length good at maxlen, starting at 1 */
  set_segment(img, 10, 10, circle, 0, 0, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 1, 11, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 12, 15, spec, thrdir.SAME);
  if (!is_corner(img, 10, 10, spec, circle)) {
    writeln("  test 17 expected corner, got false");
    passed = false;
  }

  /*
  set_segment(img, 10, 10, circle, , , spec, thrdir.);
  set_segment(img, 10, 10, circle, , , spec, thrdir.);
  set_segment(img, 10, 10, circle, , , spec, thrdir.);
  set_segment(img, 10, 10, circle, , , spec, thrdir.);
  */

  if (!passed) then writeln("  some test failed");
  else writeln("  all tests passed");

  delete img;
  delete circle;

  return passed;
}

/***
    test_is_corner_with_details:  Self-checking test bench for the
                                  is_corner_with_details procedure.
    returns:   pass/fail flag
***/
proc test_is_corner_with_details() : bool {
  var passed                            /* overall result for bench */
    = true;
  var img : unmanaged clrimage?;        /* dummy data */
  var circle                            /* iterator about circle */
    = new unmanaged circumference(3);
  var spec : fastspec;                  /* FAST parameters */
  var details : corner;                 /* specifics about corner */

  writeln("\nStarting test bench for is_corner_with_details");

  spec.radius = 3;
  spec.minlen = 9;
  spec.maxlen = 13;
  spec.thr = 10.0;

  img = new unmanaged clrimage(20, 20, clrspace.LAB);
  img!.c1(10,10) = 20.0;

  /* Pixel counts for r==3 range from 0 t/m 15. */

  /* Test 1 - segment good length at minlen. */
  set_segment(img, 10, 10, circle, 0, 2, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 3, 11, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 12, 15, spec, thrdir.LESS);
  if (!is_corner_with_details(img, 10, 10, spec, circle, details)) {
    writeln("  test 1 expected corner, got false");
    passed = false;
  } else if (!verify_details(details, no=1, xc=10, yc=10, len=9, st=(11, 13),
                             dpix=(spec.thr + 1 + 11))) {
    passed = false;
  }

  /* Test 2 - segment good length at minlen. */
  set_segment(img, 10, 10, circle, 0, 1, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 2, 14, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.MORE);
  if (!is_corner_with_details(img, 10, 10, spec, circle, details)) {
    writeln("  test 2 expected corner, got false");
    passed = false;
  } else if (!verify_details(details, no=2, xc=10, yc=10, len=13, st=(12, 12),
                             dpix=(spec.thr + 1 + 14))) {
    passed = false;
  }

  /* Test 3 - segment good length at minlen, wraps around 0. */
  set_segment(img, 10, 10, circle, 0, 6, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 7, 10, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 11, 12, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 13, 13, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 14, 15, spec, thrdir.MORE);
  if (!is_corner_with_details(img, 10, 10, spec, circle, details)) {
    writeln("  test 3 expected corner, got false");
    passed = false;
  } else if (!verify_details(details, no=3, xc=10, yc=10, len=9, st=(12, 8),
                             dpix=(spec.thr + 1 + 15))) {
    passed = false;
  }

  /* Test 4 - segment good length at minlen, starting at 0. */
  set_segment(img, 10, 10, circle, 0, 8, spec, thrdir.LESS);
  set_segment(img, 10, 10, circle, 9, 9, spec, thrdir.MORE);
  set_segment(img, 10, 10, circle, 10, 14, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 15, 15, spec, thrdir.MORE);
  if (!is_corner_with_details(img, 10, 10, spec, circle, details)) {
    writeln("  test 4 expected corner, got false");
    passed = false;
  } else if (!verify_details(details, no=4, xc=10, yc=10, len=9, st=(13, 10),
                             dpix=(spec.thr + 1 + 8))) {
    passed = false;
  }

  /* Test 5 - segment good length at maxlen, ending at 15. */
  set_segment(img, 10, 10, circle, 0, 2, spec, thrdir.SAME);
  set_segment(img, 10, 10, circle, 3, 15, spec, thrdir.LESS);
  if (!is_corner_with_details(img, 10, 10, spec, circle, details)) {
    writeln("  test 5 expected corner, got false");
    passed = false;
  } else if (!verify_details(details, no=5, xc=10, yc=10, len=13, st=(11, 13),
                             dpix=(spec.thr + 1 + 15))) {
    passed = false;
  }

  if (!passed) then writeln("  some test failed");
  else writeln("  all tests passed");

  delete img;
  delete circle;

  return passed;
}

/***
    verify_details:  Test the corner details against the expected values passed
                     as arguments.
    args:            details - corner info
                     no - test number (for fail messages)
                     xc, yc - expected corner position
                     len - expected len of differing run
                     st - (x, y) coords of start of differing run
                     dpix - largest diff in run to center pixel
    returns:   true if details match expected, false if any differ
***/
proc verify_details(details : corner, no : int, xc : int, yc : int, len : int,
                    st : 2*int, dpix : real) : bool {
  var passed = true;                    /* pass/fail flag */

  if (details.xc != xc) {
    writeln("  test ", no, " expected xc ", xc, ", got ", details.xc);
    passed = false;
  }
  if (details.yc != yc) {
    writeln("  test ", no, " expected yc ", yc, ", got ", details.yc);
    passed = false;
  }
  if (details.len != len) {
    writeln("  test ", no, " expected length ", len, ", got ", details.len);
    passed = false;
  }
  if (details.st != st) {
    writeln("  test ", no, " expected start at ", st, ", got ", details.st);
    passed = false;
  }
  if (details.dpix != dpix) {
    writef("  test %i expected dpix of %5.1dr, got %5.1dr\n",
           no, dpix, details.dpix);
    passed = false;
  }

  return passed;
}


/***
    set_segment:  Assign pixel values in the image along the circumference
                  between teh start and end.  The pixel is set so that the
                  direction condition holds.
    args:         img - greyscale image, plane c1 modified
                  xc, yc - center point of circle to mark
                  circle - iterator about circumference (radius already set)
                  st, end - index of first, last pixel along circle, incl.
                  spec - parameters that will be used for analysis
                  dir - condition that perimeter pixel must meet
    modifies:  img
***/
proc set_segment(img : unmanaged clrimage?, xc : int, yc : int, circle : circumference,
                 st : int, end : int, spec : fastspec, dir : thrdir) {
  var cnt = 0;                          /* position along circumference */

  for (x, y) in circle(xc, yc) {
    if ((st <= cnt) && (cnt <= end)) {
      var offset                        /* MORE/LESS, varies around ring */
        = spec.thr + 1.0 + cnt;
      select (dir) {
      when thrdir.SAME { img!.c1(x, y) = img!.c1(xc, yc) + spec.thr - 1.0; }
      when thrdir.MORE { img!.c1(x, y) = img!.c1(xc, yc) + offset; }
      when thrdir.LESS { img!.c1(x, y) = img!.c1(xc, yc) - offset; }
      otherwise writeln("unknown threshold direction ", dir);
      }
    }
    cnt += 1;
  }
}


/**** Top Level ****/

proc main() {
  var passed = true;                    /* overall pass/fail flag */

  if (!test_circumference()) then passed = false;
  if (!test_is_corner()) then passed = false;
  if (!test_is_corner_with_details()) then passed = false;

  writeln("\nTest Bench Summary");
  if (passed) then writeln("  all tests passed\n");
  else writeln("  some test FAILED");

  return 0;
}
